<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="React vue nodejs js typescript">
<meta property="og:type" content="website">
<meta property="og:title" content="FangCao">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="FangCao">
<meta property="og:description" content="React vue nodejs js typescript">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="FangCao">
<meta name="twitter:description" content="React vue nodejs js typescript">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/">





  <title>FangCao</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?f6bca865fcf2ff03fc0a96417de90b09";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">FangCao</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/14/yuque/Hexo 优化设置/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FangCao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FangCao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/14/yuque/Hexo 优化设置/" itemprop="url">Hexo 优化设置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-14T16:28:48+08:00">
                2019-06-14
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/06/14/yuque/Hexo 优化设置/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/06/14/yuque/Hexo 优化设置/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a name="UywVi"></a></p>
<h3 id="hexo官网"><a href="#hexo官网" class="headerlink" title="hexo官网"></a><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo官网</a></h3><p><a name="n6eqs"></a></p>
<h3 id="修改博客标题简介语言等"><a href="#修改博客标题简介语言等" class="headerlink" title="修改博客标题简介语言等"></a>修改博客标题简介语言等</h3><p><a href="https://github.com/iissnan/hexo-theme-next/wiki/%E5%88%9B%E5%BB%BA%E5%88%86%E7%B1%BB%E9%A1%B5%E9%9D%A2" target="_blank" rel="noopener">创建页面</a><br><br><br>编辑 _config.yml</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Xxb</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">Linux,crypto,mining</span></span><br><span class="line"><span class="attr">description:</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">Linux,crypto,mining</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">xxb.me</span></span><br><span class="line"><span class="attr">language:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">zh-TW</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">en</span></span><br></pre></td></tr></table></figure>

<p><a href></a><br><a name="Jf2d6"></a></p>
<h3 id="修改网站-URL-和链接格式"><a href="#修改网站-URL-和链接格式" class="headerlink" title="修改网站 URL 和链接格式"></a><a href="https://www.xxb.me/Hexo/yuque-hexo02/#%E4%BF%AE%E6%94%B9%E7%BD%91%E7%AB%99-URL-%E5%92%8C%E9%93%BE%E6%8E%A5%E6%A0%BC%E5%BC%8F" target="_blank" rel="noopener"></a>修改网站 URL 和链接格式</h3><p>编辑 _config.yml</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span><br><span class="line"><span class="attr">url:</span> <span class="attr">http://www.xxb.me</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:category/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br></pre></td></tr></table></figure>

<p><a name="RqKOi"></a></p>
<h3 id="创建分类页"><a href="#创建分类页" class="headerlink" title="创建分类页"></a><a href="https://www.xxb.me/Hexo/yuque-hexo02/#%E5%88%9B%E5%BB%BA%E5%88%86%E7%B1%BB%E9%A1%B5" target="_blank" rel="noopener"></a>创建分类页</h3><p>运行命令新建page页</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>

<p><a name="AwMpt"></a></p>
<h3 id="编辑页面"><a href="#编辑页面" class="headerlink" title="编辑页面"></a>编辑页面</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2018-04-25 22:34:08</span><br><span class="line">type: "categories"</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2018-04-25 22:34:08</span><br><span class="line">type: "tags"</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p><a name="MUlWU"></a></p>
<h3 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">title: hexo 添加标签和分类</span><br><span class="line">date: 2018-04-27 23:00:34</span><br><span class="line">categories:</span><br><span class="line"><span class="bullet">- </span>hexo</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">- </span>linux</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">layout: photo</span><br><span class="line">title: My Gallery</span><br><span class="line">date: 2019-06-19 15:54:13</span><br><span class="line"><span class="section"># tags: [photo, 照片]</span></span><br><span class="line">categories:</span><br><span class="line"><span class="bullet">    - </span>hexo</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">    - </span>linux</span><br><span class="line"><span class="bullet">    - </span>React</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">title: post title with whitespace</span><br><span class="line">date: 2019-06-19 15:39:18</span><br><span class="line">tags: [photo, 照片]</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p><a name="Jx1Zn"></a></p>
<h3 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h3><p>其中<code>:</code> 以前的是正式的名称，以后的是访问的路径</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Category &amp; Tag</span></span><br><span class="line"><span class="attr">default_category:</span> <span class="string">uncategorized</span></span><br><span class="line"><span class="attr">category_map:</span> <span class="attr">hexo:hexo</span></span><br><span class="line"><span class="attr">    ubuntu:</span><span class="string">ubuntu</span></span><br><span class="line">    <span class="string">computer</span> <span class="attr">vision:computer-vision</span></span><br><span class="line"><span class="attr">tag_map:</span> <span class="attr">linux:linux</span></span><br><span class="line"><span class="attr">    ubuntu:</span><span class="string">ubuntu</span></span><br><span class="line"><span class="attr">    vim:</span><span class="string">vim</span></span><br><span class="line"><span class="attr">    tmux:</span><span class="string">tmux</span></span><br><span class="line"><span class="attr">    hexo:</span><span class="string">hexo</span></span><br><span class="line"><span class="attr">    yolo:</span><span class="string">yolo</span></span><br><span class="line"><span class="attr">    opencv:</span><span class="string">opencv</span></span><br><span class="line">    <span class="string">computer</span> <span class="attr">vision:computer-vision</span></span><br></pre></td></tr></table></figure>

<p><a name="EAqVQ"></a></p>
<h3 id="部署生效"><a href="#部署生效" class="headerlink" title="部署生效"></a>部署生效</h3><p>一定要记得先clean在生成</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>

<p>运行后提示</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO  Created: ~/Documents/code/blog/<span class="built_in">source</span>/categories/index.md</span><br></pre></td></tr></table></figure>

<p>找到 index.md 这个文件，为其添加 type 属性</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2019</span><span class="bullet">-01</span><span class="bullet">-30</span> <span class="number">17</span><span class="string">:37:12</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">"categories"</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<p>修改主题 _config.yml 文件的menu段落，反注释掉tags那一行</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">  home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line"><span class="attr">  about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">user</span></span><br><span class="line"><span class="attr">  tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">  categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line"><span class="attr">  archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || heartbeat</span></span><br></pre></td></tr></table></figure>

<p><a name="OZ2T0"></a></p>
<h3 id="创建标签页"><a href="#创建标签页" class="headerlink" title="创建标签页"></a>创建标签页</h3><p>方法和创建分类页一样，只是把 categories 改为 tags<br><a name="vLnLU"></a></p>
<h3 id="创建about页"><a href="#创建about页" class="headerlink" title="创建about页"></a><a href="https://www.xxb.me/Hexo/yuque-hexo02/#%E5%88%9B%E5%BB%BAabout%E9%A1%B5" target="_blank" rel="noopener"></a>创建about页</h3><p>参考创建标签页<br><a name="X5U86"></a></p>
<h3 id="添加诗词插件"><a href="#添加诗词插件" class="headerlink" title="添加诗词插件"></a><a href="https://www.xxb.me/Hexo/yuque-hexo02/#%E6%B7%BB%E5%8A%A0%E8%AF%97%E8%AF%8D%E6%8F%92%E4%BB%B6" target="_blank" rel="noopener"></a>添加诗词插件</h3><p>今日诗词 API 根据不同地点、时间、节日、季节、天气、景观、城市、事件进行智能推荐，每次刷新都不同。<br>官网： <a href="https://www.jinrishici.com/" target="_blank" rel="noopener">https://www.jinrishici.com/</a><br>调用文档： <a href="https://www.jinrishici.com/doc/" target="_blank" rel="noopener">https://www.jinrishici.com/doc/</a><br>在想放置诗词的地方添加以下代码：（我放在_partials/header/brand.swig）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"jinrishici-sentence"</span> <span class="attr">class</span>=<span class="string">"shici"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://sdk.jinrishici.com/v2/browser/jinrishici.js"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>自定义样式，修改主题样式文件source/css/_custom/custom.styl</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.shici</span> &#123;<span class="attribute">font-size</span>: <span class="number">15px</span>;<span class="attribute">text-align</span>: center;<span class="attribute">font-weight</span>: <span class="number">300</span>;<span class="attribute">color</span>: <span class="number">#444</span>;<span class="attribute">font-style</span>: italic;&#125;</span><br></pre></td></tr></table></figure>

<p>在线演示： <a href="http://www.xxb.me/" target="_blank" rel="noopener">www.xxb.me</a><br><br><br>主题：<a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">https://github.com/ppoffice/hexo-theme-icarus</a><br><a name="3oTZQ"></a></p>
<h3 id="未完待续-…"><a href="#未完待续-…" class="headerlink" title="未完待续 …"></a><a href="https://www.xxb.me/Hexo/yuque-hexo02/#%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD-%E2%80%A6" target="_blank" rel="noopener"></a>未完待续 …</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/14/yuque/UI组件库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FangCao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FangCao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/14/yuque/UI组件库/" itemprop="url">UI组件库</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-14T16:00:09+08:00">
                2019-06-14
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/06/14/yuque/UI组件库/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/06/14/yuque/UI组件库/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><a href="https://www.layui.com/" target="_blank" rel="noopener">经典模块化前端框架</a></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/263301/1560499299823-82726d34-90ba-4d91-ace1-019aa195b307.png#align=left&display=inline&height=777&name=image.png&originHeight=1554&originWidth=2862&size=2167747&status=done&width=1431" alt="image.png"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/14/yuque/教程一/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FangCao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FangCao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/14/yuque/教程一/" itemprop="url">教程一</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-14T15:47:10+08:00">
                2019-06-14
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/06/14/yuque/教程一/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/06/14/yuque/教程一/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a name="d9c0bc4a"></a></p>
<h2 id="手摸手教程"><a href="#手摸手教程" class="headerlink" title="手摸手教程"></a>手摸手教程</h2><p><a href="https://panjiachen.github.io/awesome-bookmarks/blog/webpack/webpack4-a.html" target="_blank" rel="noopener">手摸手，带你用合理的姿势使用 webpack4（上）</a><br><a href="https://panjiachen.github.io/awesome-bookmarks/blog/webpack/webpack4-b.html" target="_blank" rel="noopener">手摸手，带你用合理的姿势使用 webpack4（下）</a><br><a name="url-loader-vs-file-loader"></a></p>
<h2 id="url-loader-vs-file-loader"><a href="#url-loader-vs-file-loader" class="headerlink" title="url-loader vs file-loader"></a>url-loader vs file-loader</h2><blockquote>
<p>2018-08-13</p>
</blockquote>
<p>很多人搞不清楚这两个 loader 是干嘛的？<br>其实 <code>url-loader</code> 就是对 <code>file-loader</code> 的一个拓展。照你设置的文件大小 limit, 将其内联为 base64 或者单独作为文件引入。</p>
<blockquote>
<p>将图片文件转换为 base64 编码并载入浏览器能够减少 http 请求数，但是增大了 js 或 html 文件的体积，如果图片在项目中的重用度较高，那么每处引用都会生成 base64 编码，造成了代码的冗余。所以是否需要内联自己需要权衡一下。</p>
</blockquote>
<ul>
<li>file-loader： 可以指定要复制和放置资源文件的位置，以及如何使用版本哈希命名以获得更好的缓存。此外，这意味着 你可以就近管理图片文件，可以使用相对路径而不用担心部署时 URL 的问题。使用正确的配置，webpack 将会在打包输出中自动重写文件路径为正确的 URL。<br></li>
<li>url-loader： 允许你有条件地将文件转换为内联的 base-64 URL (当文件小于给定的阈值)，这会减少小文件的 HTTP 请求数。如果文件大于该阈值，会自动的交给 file-loader 处理。<br></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/14/yuque/vue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FangCao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FangCao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/14/yuque/vue/" itemprop="url">vue</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-14T15:44:42+08:00">
                2019-06-14
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/06/14/yuque/vue/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/06/14/yuque/vue/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##Router Link<br><code>router-link</code>基本每一个人都会用，但有的时候我们需要在点击的时候做一些额外的操作，比如点击的时候先弹出一个确认框，问用户是否需跳转。但发现怎么也禁止不了它的默认时间。<br>查阅文档之后发现它有一个 <code>event</code>参数，默认是<code>click</code>。我们只要将它设空，之后自己来处理跳转的逻辑就可以了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to=<span class="string">"&#123; name: 'my-favorites' &#125;"</span></span><br><span class="line">             :event=<span class="string">"''"</span></span><br><span class="line">             @click.native.prevent=<span class="string">"routeOrLogin(&#123; name: 'my-favorites' &#125;)"</span>&gt;</span><br><span class="line">  Favorites&lt;<span class="regexp">/router-link&gt;</span></span><br></pre></td></tr></table></figure>

<p><a name="dynamic-components"></a></p>
<h2 id="Dynamic-Components"><a href="#Dynamic-Components" class="headerlink" title="Dynamic Components"></a>Dynamic Components</h2><p>vue 一个就是 它可以写愉快的写 template 一个类 html 的模板，大多数情况下都非常好用。但在一些复杂场景下，它就显得不太灵活了。 这里举一个例子来说：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;a v-<span class="keyword">if</span>=<span class="string">"isExternalLink"</span> :href=<span class="string">"xxx"</span>&gt;</span><br><span class="line">  &lt;componentA /&gt;</span><br><span class="line">  &lt;componentA /&gt;</span><br><span class="line">  &lt;componentC /&gt;</span><br><span class="line">&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">&lt;router-link v-else :to="xxx"&gt;</span></span><br><span class="line"><span class="regexp">  &lt;componentA /</span>&gt;</span><br><span class="line">  &lt;componentA /&gt;</span><br><span class="line">  &lt;componentC /&gt;</span><br><span class="line">&lt;<span class="regexp">/router-link&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里只是一个最简单一个例子，实际场景中，中间重复的内容可能更多，两者唯一的区别只是外链的时候使用<code>a</code>标签，内部链接使用<code>router-link</code>。但却要写一大串的 <code>if..else</code>很不爽。<br>这里提供一个简单的方法解决这个问题。就是使用动态组件，我们将<code>a</code>标签和<code>router-link</code>分装成一个动态组件，根据传入的 url 是否是外部链接，动态的选择使用什么标签来渲染。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Link.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;component v-bind=<span class="string">"linkProps(to)"</span>&gt;</span><br><span class="line">    &lt;slot&gt;<span class="xml"><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line">  &lt;<span class="regexp">/component&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      to: &#123;</span><br><span class="line">        type: <span class="built_in">String</span>,</span><br><span class="line">        required: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      linkProps (url) &#123;</span><br><span class="line">        <span class="keyword">if</span> (url.match(<span class="regexp">/^(http(s)?|ftp):\/\//</span>)) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">            is: <span class="string">'a'</span>,</span><br><span class="line">            href: url,</span><br><span class="line">            target: <span class="string">'_blank'</span>,</span><br><span class="line">            rel: <span class="string">'noopener'</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          is: <span class="string">'router-link'</span>,</span><br><span class="line">          to: url</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样我们将代码的复杂度都封装在了<code>Link.vue</code>之中，我们在原来文件中只需这样使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;link :to=<span class="string">"xxx"</span>&gt;</span><br><span class="line">  &lt;componentA /&gt;</span><br><span class="line">  &lt;componentA /&gt;</span><br><span class="line">  &lt;componentC /&gt;</span><br><span class="line">&lt;<span class="regexp">/link&gt;</span></span><br></pre></td></tr></table></figure>

<p>是不是一下子简单了许多，代码的可阅读性也直线上升了。<br><a name="fragment"></a></p>
<h2 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h2><p>react 很早就有了 Fragment 但 vue 迟迟还没有支持。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/14/yuque/产品/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FangCao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FangCao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/14/yuque/产品/" itemprop="url">产品</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-14T15:39:18+08:00">
                2019-06-14
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/06/14/yuque/产品/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/06/14/yuque/产品/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a name="c0f64c94"></a></p>
<h2 id="如何理解-DAU-和-MAU-这两个数据？"><a href="#如何理解-DAU-和-MAU-这两个数据？" class="headerlink" title="如何理解 DAU 和 MAU 这两个数据？"></a>如何理解 DAU 和 MAU 这两个数据？</h2><ul>
<li><p>DAU (Daily Active Users) 日活 单日活跃用户数，反应产品短期用户活跃度</p>
</li>
<li><p>MAU (Monthly Active Users) 月活 单月活跃用户量，反应产品长期用户活跃度<br><a name="09051279"></a></p>
<h3 id="DAU-的分析价值所在"><a href="#DAU-的分析价值所在" class="headerlink" title="DAU 的分析价值所在"></a>DAU 的分析价值所在</h3><p>核心用户规模：DAU 指标直接反应了核心用户规模。可以结合其他指标一同分析。 生命周期分析的价值：产品不同阶段，DAU 的数据表现不一样。DAU 趋势下滑，那么很可能是老用户流失，产品开始走下坡路。是否要投入运营预算，是否要产品重新战略部署等。 产品黏性：DAU 指标结合留存指标来分析产品的用户粘性。 渠道价值分析：DAU 可以间接判断各大渠道对产品的贡献价值。在产品初期投放各大渠道之后，DAU 数据会逐步减少，后期可以有选择的保留用户基数大的渠道运营。 用户流失分析：运营活动结束之后，DAU 数据有大幅减少，则要进行用户流失分析。<br><a name="f8c26d76"></a></p>
<h3 id="DAU-的多维度分析"><a href="#DAU-的多维度分析" class="headerlink" title="DAU 的多维度分析"></a>DAU 的多维度分析</h3></li>
<li><p>趋势：通过判断 DAU 指标在某一时间段的变化来预测未来的数据表现，一般用趋势图表示。例如，未来一个月的收益表现，可以参考三个月的 DAU，去年同期的数据表现，可以综合评估分析。</p>
</li>
<li><p>同比：是将本周期内的数据与历史相同时间点的数据进行比对。例如，今年 N 月与去年 N 月相比。</p>
</li>
<li><p>环比：是将本期数据与前期数据进行对比，体现了数据连续性变化的趋势。例如，今年九月同八月、七月的数据进行比对。</p>
</li>
<li><p>定基比：数据进行比对才有意义。该分析需要以某个时期为基数，其他各期数据都可以与之对比。基准线是产品发展的里程碑水平，可以反映产品的发展运营情况如何<br><a name="9e5c0f99"></a></p>
<h3 id="异常定位"><a href="#异常定位" class="headerlink" title="异常定位"></a>异常定位</h3><p>一般表现为：数据异常时间点的不同（如节假日，高考等），产品体验，近期是否发版，近期的运营活动，渠道投放，广告推广，产品相关的新闻事件，以及市场竞品的影响（如有新竞品进入市场，竞品最近搞运营活动）等。<br><a name="ed02f067"></a></p>
<h3 id="比值"><a href="#比值" class="headerlink" title="比值"></a>比值</h3><p>DAU/MAU 代表的是，每天登录的玩家占月活跃的百分比。形象点就是说，你这些活跃玩家，是每天都在登录，还是隔了几天登录。假设，每天都在登录，粘性就高。你隔个四五天登录，粘性就低。一般这个值会在 0.03 到 1 之间。 如果低于 10%，很可能已经处于衰退期；高于 20%的留存还不错。<br><a name="1da66c33"></a></p>
<h2 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h2><p><a name="53347f5a"></a></p>
<h3 id="席克定律"><a href="#席克定律" class="headerlink" title="席克定律"></a>席克定律</h3><p>它描述了根据已知选项做某项决定所花的时间——随着选项数量的增加，投入的时间也会呈对数增加。简单来讲，越少越快。 当用户出现恐慌或困惑时，唯一的选择反而给人一种「山有小口，仿佛若有光」的感觉。 所以，如果「反应时间」很重要，那选项数量一定要控制在最少。这样也可以加快用户抉择的速度。<br>解决方案:</p>
</li>
</ul>
<ol>
<li>分步选择, 均分总复杂度到每一个步骤</li>
<li>限制选项数量, 保留基本的选项</li>
<li>控制单个元素的复杂度, 使页面简单好理解</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/14/yuque/前端性能监控/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FangCao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FangCao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/14/yuque/前端性能监控/" itemprop="url">前端性能监控</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-14T15:32:03+08:00">
                2019-06-14
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/06/14/yuque/前端性能监控/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/06/14/yuque/前端性能监控/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://juejin.im/book/5b936540f265da0a9624b04b" target="_blank" rel="noopener">前端性能优化原理与实践</a><br>前端性能监控分为两种方式，一种叫做合成监控（Synthetic Monitoring，SYN），另一种是真实用户监控（Real User Monitoring，RUM）。</p>
<p><a name="362d9d5d"></a></p>
<h3 id="合成监控"><a href="#合成监控" class="headerlink" title="合成监控"></a>合成监控</h3><p><br>什么叫合成监控？就是在一个模拟场景里，去提交一个需要做性能审计的页面，通过一系列的工具、规则去运行你的页面，提取一些性能指标，得出一个审计报告。<br><br><br>常见的工具有 Google 的 Lighthouse，webpagetest，pagespeed 等。<br><br><br>当然其实业界对于 Lighthouse 也是评价有褒有贬，因为 Google 借助这个看似中立的性能评审工具也是在推行它的一些技术的方案。 比如你的页面如果没有支持 PWA 评分就不会很高。<br></p>
<ul>
<li>合成监控的优缺点<table>
<thead>
<tr>
<th align="center">优点</th>
<th align="center">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">实现简单</td>
<td align="center">无法还原全部真实场景</td>
</tr>
<tr>
<td align="center">能采集到丰富的数据，如硬件指标或瀑布图</td>
<td align="center">登录等场景需要额外解决</td>
</tr>
<tr>
<td align="center">不影响真实用户的访问性能</td>
<td align="center">单次数据不够稳定</td>
</tr>
<tr>
<td align="center">可以提供页面加载幻灯片等可视化分析途径</td>
<td align="center">数据量较小，无法发挥更大价值</td>
</tr>
</tbody></table>
</li>
</ul>
<p><a name="7c6d60a6"></a></p>
<h3 id="真实用户监控"><a href="#真实用户监控" class="headerlink" title="真实用户监控"></a>真实用户监控</h3><p>所谓真实用户监控，就是用户在我们的页面访问之后就会产生各种各样的性能指标，之后会将这些性能指标上传的我们的日志服务器上，进行数据的提起清洗加工，最后在我们的监控平台上进行展示和分析的一个过程。</p>
<ul>
<li>真实用户监控的优缺点<table>
<thead>
<tr>
<th align="center">优点</th>
<th align="center">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">无需配置模拟条件，完全还原真实场景</td>
<td align="center">一定程度影响真实用户的访问性能及流量消耗</td>
</tr>
<tr>
<td align="center">不存在登录等需要额外解决的场景</td>
<td align="center">无法采集硬件相关指标</td>
</tr>
<tr>
<td align="center">数据样本足够庞大，可以减少统计误差</td>
<td align="center">受传输限制无法采集完整的资源加载瀑布图</td>
</tr>
<tr>
<td align="center">新年数据可与其它数据关联，产生更大价值</td>
<td align="center">无法可视化展示加载过程</td>
</tr>
</tbody></table>
</li>
</ul>
<p><a name="f5deaa17"></a></p>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><table>
<thead>
<tr>
<th align="center">对比项</th>
<th align="center">合成监控</th>
<th align="center">真实用户监控</th>
</tr>
</thead>
<tbody><tr>
<td align="center">实现难度及成本</td>
<td align="center">较低</td>
<td align="center">较高</td>
</tr>
<tr>
<td align="center">采集数据丰富度</td>
<td align="center">丰富</td>
<td align="center">基础</td>
</tr>
<tr>
<td align="center">数据样本量</td>
<td align="center">较小</td>
<td align="center">大(视业务体量)</td>
</tr>
<tr>
<td align="center">适合场景</td>
<td align="center">团队自由业务，对性能做定性分析，或配合 CI 做小数据量的监控分析</td>
<td align="center">作为中台产品支持前台业务，对性能做定量分析，结合业务数据进行深度挖掘</td>
</tr>
</tbody></table>
<p><a name="729de1d0"></a></p>
<h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>在真实用户性能数据采集时，要关注四个方面的东西：</p>
<ul>
<li>使用标准的 API<br></li>
<li>定义合适的指标<br></li>
<li>采集正确的数据<br></li>
<li>上报关联的维度<br><br><a name="890a4d28"></a><h4 id="使用标准的-API"><a href="#使用标准的-API" class="headerlink" title="使用标准的 API"></a>使用标准的 API</h4>之前大家都使用一个叫 <code>performance.timing</code>，来做性能监控。但这个 API 已经“废弃”了。为什么会被废弃？因为 W3C 给我们提供了更全面、更强大的一个性能分析矩阵，比单一的 performance.timing 更加强大，能帮助我们从各个方面分析前端页面性能。<br><br><br>采集性能数据时先抹平 Navigation Timing spec 差异，优先使用 PerformanceTimeline API(在复杂场景，亦可考虑优先使用 PerformanceObserver)。<br></li>
</ul>
<p><a name="91e9acdc"></a></p>
<h4 id="定义合适的指标"><a href="#定义合适的指标" class="headerlink" title="定义合适的指标"></a>定义合适的指标</h4><p>First Meaningful Paint，首次有效渲染时长，这个指标最早是由 Google 提出的，它的一个核心的想法是渲染并不一定代表着用户看到了主要内容，Load 也不一定代表用户看到主要内容，那用户什么时候能够看到主要内容呢？我们假设当一个网页的 DOM 结构发生剧烈的变化的时候，就是这个网页主要内容出现的时候，那么在这样的一个时间点上，就是用户看到主要内容的一个时间点。<br>它的优点是相对校准的估算出内容渲染时间，贴近用户感知。但缺点是无原生 API 支持，算法推导时 DOM 节点不含权重。<br><a name="a6a45716"></a></p>
<h4 id="怎样采集正确的数据？"><a href="#怎样采集正确的数据？" class="headerlink" title="怎样采集正确的数据？"></a>怎样采集正确的数据？</h4><p>上报页⾯加载开始时间，以及后续各时间点相对增量，在数据端进行阶段清洗和异常处理。<br><a name="ddd71982"></a></p>
<h4 id="上报关联的维度"><a href="#上报关联的维度" class="headerlink" title="上报关联的维度"></a>上报关联的维度</h4><p>我们都知道在做前端的数据采集的时候，维度数据是非常重要的，除了我们刚才定义的各种度量，怎样采集到合适的相关维度，也能够极大地帮助我们分析页面性能的效果。<br>在分析页面性能的时候，有很多相对专业的维度是会被大家忽略掉的，比如说当前页面是否可见，这个页面加载方式是怎么样的，它是直接打开，还是刷新打开，还是前进后退打开等等。就是通过后面的数据分析，我们会发现，不同的页面操作，页面打开方式都会对我们页面加载的性能会有影响，以及一些更复杂的，比如说是否启用 HTTP2、Service Worker 等等，这些数据我们都应该尽可能采集到，从而能够更好的去分析我们的页面性能。<br><a name="e5729e94"></a></p>
<h3 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h3><p>本文为<a href="https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==∣=2247490527&idx=1&sn=cc2549683b3ff69c042483d78ced766a&chksm=f951ae9cce26278a263ecf2937b5c4957c9b37f35b7efe4c1a8c6ab69c74ebcb43c54e62abda&token=1927326837⟨=zh_CN#rd" target="_blank" rel="noopener">蚂蚁金服如何把前端性能监控做到极致?</a> 的阅读笔记。<br>拓展阅读 <a href="https://zhuanlan.zhihu.com/p/33825610" target="_blank" rel="noopener">我理解的前端性能 &amp; 优化</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/14/yuque/uni-app/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FangCao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FangCao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/14/yuque/uni-app/" itemprop="url">uni-app</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-14T14:55:40+08:00">
                2019-06-14
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/06/14/yuque/uni-app/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/06/14/yuque/uni-app/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://uniapp.dcloud.io/" target="_blank" rel="noopener">官网</a><br><a href="https://github.com/dcloudio/uni-app" target="_blank" rel="noopener">git源码地址</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/14/yuque/Javascript/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FangCao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FangCao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/14/yuque/Javascript/" itemprop="url">Javascript</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-14T10:25:59+08:00">
                2019-06-14
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/06/14/yuque/Javascript/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/06/14/yuque/Javascript/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a name="RGsMd"></a></p>
<h2 id="querySelectorAll-getElementsBy-区别？"><a href="#querySelectorAll-getElementsBy-区别？" class="headerlink" title="querySelectorAll getElementsBy 区别？"></a>querySelectorAll getElementsBy 区别？</h2><blockquote>
<p><a name="bd16e43f"></a></p>
</blockquote>
<h4 id="浏览器兼容"><a href="#浏览器兼容" class="headerlink" title="浏览器兼容"></a>浏览器兼容</h4><p>querySelectorAll 已被 IE 8+、FF 3.5+、Safari 3.1+、Chrome 和 Opera 10+ 良好支持 。getElementsBy 系列，以最迟添加到规范中的 getElementsByClassName 为例，IE 9+、FF 3 +、Safari 3.1+、Chrome 和 Opera 9+ 都已经支持该方法了。</p>
<blockquote>
<p><a name="f82513a1"></a></p>
</blockquote>
<h4 id="接收参数"><a href="#接收参数" class="headerlink" title="接收参数"></a>接收参数</h4><p>querySelectorAll 方法接收的参数是一个 CSS 选择符。而 getElementsBy 系列接收的参数只能是单一的 className、tagName 和 name。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c1 = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.b1 .c'</span>)</span><br><span class="line"><span class="keyword">var</span> c2 = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'c'</span>)</span><br><span class="line"><span class="keyword">var</span> c3 = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'b2'</span>)[<span class="number">0</span>].getElementsByClassName(<span class="string">'c'</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a name="ddc6e94b"></a></p>
</blockquote>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>大部分人都知道，querySelectorAll 返回的是一个 Static Node List，而 getElementsBy 系列的返回的是一个 Live Node List。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="comment">// Demo 1</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelectorAll(<span class="string">'ul'</span>)[<span class="number">0</span>],</span></span><br><span class="line"><span class="javascript">    lis = ul.querySelectorAll(<span class="string">"li"</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span> ; i++)&#123;</span></span><br><span class="line"><span class="javascript">    ul.appendChild(<span class="built_in">document</span>.createElement(<span class="string">"li"</span>));</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(lis) <span class="comment">//5</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// Demo 2</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'ul'</span>)[<span class="number">0</span>],</span></span><br><span class="line"><span class="javascript">    lis = ul.getElementsByTagName(<span class="string">"li"</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span> ; i++)&#123;</span></span><br><span class="line"><span class="javascript">    ul.appendChild(<span class="built_in">document</span>.createElement(<span class="string">"li"</span>));</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(lis) <span class="comment">//5+2</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Demo 1 中的 lis 是一个静态的 Node List，是一个 li 集合的快照，对文档的任何操作都不会对其产生影响。<br>Demo 2 中的 lis 是一个动态的 Node List， 每一次调用 lis 都会重新对文档进行查询，导致无限循环的问题。<br>但为什么要这样设计呢？ 其实，在 W3C 规范中对 querySelectorAll 方法有明确规定<br></p>
<blockquote>
<p>The NodeList object returned by the querySelectorAll() method must be static ([DOM], section 8).</p>
</blockquote>
<p>那什么是 NodeList 呢？</p>
<blockquote>
<p>The NodeList interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented. NodeList objects in the DOM are live.</p>
</blockquote>
<p>所以，NodeList 本质上是一个动态的 Node 集合，只是规范中对 querySelectorAll 有明确要求，规定其必须返回一个静态的 NodeList 对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">'a'</span>).toString() <span class="comment">// return "[object NodeList]"</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'a'</span>).toString() <span class="comment">// return "[object HTMLCollection]"</span></span><br></pre></td></tr></table></figure>

<p>这里又多了一个 HTMLCollection 对象出来，那 HTMLCollection 又是什么？</p>
<p>实际上，HTMLCollection 和 NodeList 十分相似，都是一个动态的元素集合，每次访问都需要重新对文档进行查询。两者的本质上差别在于，HTMLCollection 是属于 Document Object Model HTML 规范，而 NodeList 属于 Document Object Model Core 规范。这样说有点难理解，看看下面的例子会比较好理解</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'ul'</span>)[<span class="number">0</span>],</span><br><span class="line">  lis1 = ul.childNodes,</span><br><span class="line">  lis2 = ul.children</span><br><span class="line"><span class="built_in">console</span>.log(lis1.toString(), lis1.length) <span class="comment">// "[object NodeList]" 11</span></span><br><span class="line"><span class="built_in">console</span>.log(lis2.toString(), lis2.length) <span class="comment">// "[object HTMLCollection]" 4</span></span><br></pre></td></tr></table></figure>

<p>NodeList 对象会包含文档中的所有节点，如 Element、Text 和 Comment 等。HTMLCollection 对象只会包含文档中的 Element 节点。另外，HTMLCollection 对象比 NodeList 对象 多提供了一个 namedItem 方法。所以在现代浏览器中，querySelectorAll 的返回值是一个静态的 NodeList 对象，而 getElementsBy 系列的返回值实际上是一个 HTMLCollection 对象 。</p>
<p><a href="https://www.zhihu.com/question/24702250" target="_blank" rel="noopener">参照文章</a><br><a name="I4tMa"></a></p>
<h2 id="NodeList-和-HTMLCollection-之间的关系？"><a href="#NodeList-和-HTMLCollection-之间的关系？" class="headerlink" title="NodeList 和 HTMLCollection 之间的关系？"></a>NodeList 和 HTMLCollection 之间的关系？</h2><p><br>历史上的 DOM 集合接口。主要不同在于 <code>HTMLCollection</code>是元素集合而 NodeList 是节点集合（即可以包含元素，也可以包含文本节点）。所以 <code>node.childNodes</code> 返回 <code>NodeList</code>，而 <code>node.children</code> 和 <code>node.getElementsByXXX</code> 返回 <code>HTMLCollection</code> 。<br>唯一要注意的是 <code>querySelectorAll</code> 返回的虽然是 <code>NodeList</code> ，但是实际上是元素集合，并且是静态的（其他接口返回的 <code>HTMLCollection</code> 和 <code>NodeList</code> 都是 live 的）。<br>Both interfaces are collections of DOM nodes. They differ in the methods they provide and in the type of nodes they can contain. While a NodeList can contain any node type, an HTMLCollection is supposed to only contain Element nodes. An HTMLCollection provides the same methods as a NodeList and additionally a method called namedItem.<br>Collections are always used when access has to be provided to multiple nodes, e.g. most selector methods (such as getElementsByTagName) return multiple nodes or getting a reference to all children (element.childNodes).<br></p>
<p><a name="Rx8bI"></a></p>
<h2 id="“1”-“2”-“3”-map-parseInt-坑"><a href="#“1”-“2”-“3”-map-parseInt-坑" class="headerlink" title="[“1”, “2”, “3”].map(parseInt) 坑"></a>[“1”, “2”, “3”].map(parseInt) 坑</h2><p>第一反应都觉得结果会是 <code>[1,2,3]</code><br>但实际结果却是 <code>[1, NaN, NaN]</code><br>这是为什么呢？主要是 <code>map</code> 这个方法在调用 <code>callback</code>函数时，会给它传递三个参数:</p>
<ul>
<li>当前正在遍历的元素</li>
<li>元素索引</li>
<li>原数组本身</li>
</ul>
<p>也是就是说如上代码其实等同于</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>].map(<span class="function">(<span class="params">i, index, array</span>) =&gt;</span> <span class="built_in">parseInt</span>(i, index, array))</span><br></pre></td></tr></table></figure>

<p>这样就直观的解释了上面的答案是怎么产生得了。因为 <code>parseInt</code> 会接受两个参数：参数和进制数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际代码运算等于如下</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1'</span>, <span class="number">0</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'2'</span>, <span class="number">1</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'3'</span>, <span class="number">2</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<p>所以为了避免这个坑，平时写 <code>map</code> 还是不要偷懒了，完整的写法才更直观并且更容易维护。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>].map(<span class="function"><span class="params">str</span> =&gt;</span> <span class="built_in">parseInt</span>(str))</span><br></pre></td></tr></table></figure>

<p><a name="Qu4B3"></a></p>
<p>##<br><a name="RXhM8"></a></p>
<h2 id="省略参数引发的-bug"><a href="#省略参数引发的-bug" class="headerlink" title="省略参数引发的 bug"></a>省略参数引发的 bug</h2><p>省略参数是 es6 之后提供的一个很好用也非常常用的功能。但还是有一些细节值得注意，不然一不小心就会出现 bug。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">num = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test() <span class="comment">// (num is set to 1)</span></span><br><span class="line">test(<span class="literal">undefined</span>) <span class="comment">// (num is set to 1 too)</span></span><br><span class="line"></span><br><span class="line">test(<span class="string">''</span>) <span class="comment">// (num is set to '')</span></span><br><span class="line">test(<span class="literal">null</span>) <span class="comment">// (num is set to null)</span></span><br><span class="line">test(<span class="literal">false</span>) <span class="comment">// (num is set to false)</span></span><br></pre></td></tr></table></figure>

<p>如上面 demo 所示，只有参数没传或者是 <code>undefined</code> 是才会生效，其它情况默认参数并不会起作用。<br>所以有的时候你传入了<code>&#39;&#39;</code>空字符串是不行的，还需要自己手动判断一下。<br>str = str || defalutString</p>
<p>另外，一个容易忽略的地方是，参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">99</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">p = x + <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">100</span></span><br><span class="line">foo() <span class="comment">// 101</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，参数 p 的默认值是 x + 1。这时，每次调用函数 foo，都会重新计算 x + 1，而不是默认 p 等于 100。</p>
<p><a name="vPi0o"></a></p>
<h2 id="多余逗号引发的错误"><a href="#多余逗号引发的错误" class="headerlink" title="多余逗号引发的错误"></a>多余逗号引发的错误</h2><p>刚入前端的时候看错误日志，<code>ie</code> 的错误日志特别多，一直没找到原因，后来发现是 JSON 最后一组键值后多逗号。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有浏览器都正常</span></span><br><span class="line"><span class="keyword">var</span> json_normal = &#123;</span><br><span class="line">  id: <span class="number">1</span>,</span><br><span class="line">  name: <span class="string">"John"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ie 报错，其它游览器正常</span></span><br><span class="line"><span class="keyword">var</span> json_error = &#123;</span><br><span class="line">  id: <span class="number">1</span>,</span><br><span class="line">  name: <span class="string">"John"</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>好在现在有了 <code>eslint</code> 或者 <code>preitter</code>这种工具，这种错误很少会再发生了。</p>
<p><a name="Awisc"></a></p>
<h2 id="js-中的逗号"><a href="#js-中的逗号" class="headerlink" title="js 中的逗号"></a>js 中的逗号</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (((a = <span class="number">1</span>), a++, a)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很多人一下子可能会一脸懵逼。<br>但看一下 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/if...else" target="_blank" rel="noopener">MDN 文档</a> 就很清楚了<br></p>
<blockquote>
<p>逗号操作符 对它的每个操作数求值（从左到右），并返回最后一个操作数的值。</p>
</blockquote>
<p>举个例子<br><code>var a=(1+1,2+2,3+3);</code> 结果就是 6。 <code>3+3</code><br><br><br>但在函数中，比如比 <code>Math.max(x,y,z)</code>。这里的逗号就是分隔函数参数。<br>还有声明变量时，<code>var a=1,b=2,c=3</code>。这里的逗号也是起分隔的作用。<br>再举一个例子大家应该就理解了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="number">2</span> * <span class="number">5</span>, <span class="number">2</span> * <span class="number">4</span>)</span><br><span class="line"><span class="comment">//输出10而不是8  函数接收第一个参数,也说明逗号级别比较低</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span> * <span class="number">5</span>, <span class="number">2</span> * <span class="number">4</span>) <span class="comment">// 10,8</span></span><br><span class="line"></span><br><span class="line">alert((<span class="number">2</span> * <span class="number">5</span>, <span class="number">2</span> * <span class="number">4</span>))</span><br><span class="line"><span class="comment">// 输出8 ()是返回了,相当于隐藏了return 所以返回最右边操作数的值</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">2</span> * <span class="number">5</span>, <span class="number">2</span> * <span class="number">4</span>));<span class="comment">//8</span></span><br></pre></td></tr></table></figure>

<p><br>其实最常见的运用场景就是平时经常的<code>for</code>循坏</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, j = <span class="number">9</span>; i &lt;= <span class="number">9</span>; i++, j--) &#123;<span class="built_in">console</span>.log(i,j)&#125;</span><br></pre></td></tr></table></figure>

<p><a name="gFEmn"></a></p>
<h2 id="document-documentElement-与-document-body-区别"><a href="#document-documentElement-与-document-body-区别" class="headerlink" title="document.documentElement 与 document.body 区别"></a>document.documentElement 与 document.body 区别</h2><p><br>在前端开发中，我们经常需要获取网页中滚动条滚过的长度，获取该值的方式一般通过<code>scrollTop</code>属性，如：<code>document.body.scrollTop</code>，或者<code>document.documentElement.scrollTop</code>，这两者都是经常用来获取文档滚动条滚过长度值的方式，他们又有什么区别呢？</p>
<p>之前一直没注意，只到有一天发现了一个 bug:document.body.scrollTop 拿到的值一直是 0。<br><br><br>在这个之前我们先来了解一下 是干嘛的？为什么每个页面都需要加上这段声明。</p>
<blockquote>
<p>doctype 声明不属于 HTML 标签，它是一条指令，告诉浏览器编写页面所用的标记的版本。 这个声明的目的是防止浏览器在渲染文档时，切换到我们称为“<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Quirks_Mode_and_Standards_Mode" target="_blank" rel="noopener">怪异模式(兼容模式)</a>”的渲染模式。<code>&lt;!DOCTYPE html&gt;</code> 能确保浏览器按照最佳的相关规范进行渲染，而不是使用一个不符合规范的渲染模式。</p>
</blockquote>
<p><code>document.documentElement</code> 与 <code>document.body</code></p>
<ul>
<li>document 代表的是整个文档(对于一个网页来说包括整个网页结构)</li>
<li>document.documentElement 是整个文档节点树的根节点，在网页中即 html 标签</li>
<li>document.body 是整个文档 DOM 节点树里的 body 节点，网页中即为 body 标签元素</li>
</ul>
<p>但在标准模式下<code>document.body.scrollTop</code>是无效的。</p>
<blockquote>
<p>从 Chrome 61 开始，标准模式中 document.scrollingElement 已被修正为 document.documentElement。换句话说，这个版本开始标准模式中 document.body.scrollTop 始终都等于 0。</p>
</blockquote>
<p>所以这里建议使用兼容写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> scrollTop = <span class="built_in">Math</span>.max(</span><br><span class="line">  <span class="built_in">window</span>.pageYOffset,</span><br><span class="line">  <span class="built_in">document</span>.documentElement.scrollTop,</span><br><span class="line">  <span class="built_in">document</span>.body.scrollTop</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBodyScrollTop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> el =</span><br><span class="line">    <span class="built_in">document</span>.documentElement || <span class="built_in">document</span>.scrollingElement || <span class="built_in">document</span>.body</span><br><span class="line">  <span class="keyword">return</span> el.scrollTop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>每当这时候我就有一些怀念<code>jQuery</code>了</strong>。
<a name="sort"></a></p>
<h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">782</span>, <span class="number">7</span>, <span class="number">29</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">34</span>]</span><br><span class="line">array.sort()</span><br><span class="line"><span class="comment">// =&gt; [0, 1, 2, 2, 29, 3, 3, 34, 7, 7, 782, 8]</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，<code>sort</code>是按照<code>Unicode code points</code>排序的，换而言之，先回比较首个字符的 code point，若相同的情况下依次位数比下去。</p>
<p>所以很多时候我们需要自定义 sort 的规则。最常见的操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">782</span>, <span class="number">7</span>, <span class="number">29</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">34</span>]</span><br><span class="line">array.sort(<span class="function">(<span class="params">pre, next</span>) =&gt;</span> pre - next)</span><br><span class="line"><span class="comment">// =&gt; [0, 1, 2, 2, 3, 3, 7, 7, 8, 29, 34, 782]</span></span><br></pre></td></tr></table></figure>

<p>其实它的规则很简单，你想让 next 和 pre 换位子就返回一个&gt;0的值，其它情况位置不变，即返回&lt;=0的值。<br><a name="codepointat-vs-charcodeat"></a></p>
<h2 id="codePointAt-vs-charCodeAt"><a href="#codePointAt-vs-charCodeAt" class="headerlink" title="codePointAt vs charCodeAt"></a>codePointAt vs charCodeAt</h2><p>JavaScript 允许采用<code>\uxxxx</code>形式表示一个字符，其中<code>xxxx</code>表示字符的 Unicode 码点。<br>但是，这种表示法只限于码点在\u0000~\uFFFF 之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'\uD842\uDFB7'</span></span><br><span class="line"><span class="comment">// "𠮷"</span></span><br></pre></td></tr></table></figure>

<p>JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为 2 个字节。对于那些需要 4 个字节储存的字符（Unicode 码点大于 0xFFFF 的字符），JavaScript 会认为它们是两个字符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'𠮷'</span></span><br><span class="line"></span><br><span class="line">s.length <span class="comment">// 2</span></span><br><span class="line">s.charAt(<span class="number">0</span>) <span class="comment">// ''</span></span><br><span class="line">s.charAt(<span class="number">1</span>) <span class="comment">// ''</span></span><br><span class="line">s.charCodeAt(<span class="number">0</span>) <span class="comment">// 55362</span></span><br><span class="line">s.charCodeAt(<span class="number">1</span>) <span class="comment">// 57271</span></span><br></pre></td></tr></table></figure>

<p>所以 ES6 提供了 codePointAt 方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'𠮷'</span>.codePointAt() <span class="comment">//134071</span></span><br></pre></td></tr></table></figure>

<p>总之，codePointAt 方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与 charCodeAt 方法相同。</p>
<p><a name="rTZKa"></a></p>
<h2 id="switch-作用域"><a href="#switch-作用域" class="headerlink" title="switch 作用域"></a>switch 作用域</h2><p>其实我们经常会忽略一个点，switch case 是共用一个作用域的。<br>比如如下代码就会抛出重复定义的错误：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (x) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">let</span> foo</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">let</span> foo <span class="comment">// 重复定义引起TypeError</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Identifier 'foo' has already been declared</span></span><br></pre></td></tr></table></figure>

<p>解决方案也很简单，我们给每一个 case 加上一个 bracket 就可以了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (x) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">    <span class="keyword">let</span> foo</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">    <span class="keyword">let</span> foo <span class="comment">// 重复定义引起TypeError</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="LciUL"></a></p>
<h2 id="div-如何监听-keydown-事件"><a href="#div-如何监听-keydown-事件" class="headerlink" title="div 如何监听 keydown 事件"></a>div 如何监听 keydown 事件</h2><p>之前有一个人问我，为什么他监听了一个 div 的 keydown 事件，为什么没有用？ 我看了一下代码发现的确没有写错？但为什么就不触发呢？<br>后来查阅了一下文档</p>
<blockquote>
<p>Focused element processing the key event, root element if no suitable input element focused</p>
</blockquote>
<p>发现只有能被 focus 的元素才能出发键盘事件，所以 div 也就不能触发 keydown 事件了。<br>那怎么才能让 div 支持呢？<br>答案是 <code>tabindex</code> <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/tabindex" target="_blank" rel="noopener">mdn</a>。它表示元素是可聚焦的，并且可以通过键盘导航来访问到该元素。<br>这样一来我们就能愉快的使用<code>keydown</code>事件了.<br><a name="lqKfa"></a></p>
<h2 id="try-catch-的-finally-坑"><a href="#try-catch-的-finally-坑" class="headerlink" title="try catch 的 finally 坑"></a>try catch 的 finally 坑</h2><p>try…catch 的 finally 可能很多人都没有使用过，它其实和 promise 中的 finally 很类似。 见<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/try...catch" target="_blank" rel="noopener">MDN</a>。<br>它无论是否有异常它都会执行。 常见的操作就是 将关闭弹窗或者 loading</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ok'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'ok'</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'error'</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'finally'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'finally'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line"><span class="comment">// ok finally "finally"</span></span><br></pre></td></tr></table></figure>

<p>我们发现最终输出了<code>finally</code>。因为这个语句只会有一个 return，finally 中的 return 覆盖了之前的定义。而且 return 会被放在最后执行。<a href="https://stackoverflow.com/questions/3837994/why-does-a-return-in-finally-override-try" target="_blank" rel="noopener">详情见</a>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res=<span class="string">''</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    res=<span class="string">'ok'</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    res=<span class="string">'error'</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn() <span class="comment">//"ok"</span></span><br></pre></td></tr></table></figure>

<p>不过最好还是和 promise 中的 finally 一样，在里面做一些没有副作用的事情。免得发生一些 bug。<br><a name="8eG9o"></a></p>
<h2 id="atob-方法解码中文字符"><a href="#atob-方法解码中文字符" class="headerlink" title="atob 方法解码中文字符"></a>atob 方法解码中文字符</h2><p>由于一些网络通讯协议的限制,你必须使用 window.btoa() 方法对原数据进行编码后，才能进行发送。接收方使用相当于 window.atob() 的方法对接受到的 base64 数据进行解码,得到原数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.btoa(<span class="string">'foo'</span>)</span><br><span class="line"><span class="comment">// "Zm9v"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.atob(<span class="string">'Zm9v'</span>)</span><br><span class="line"><span class="comment">// "foo"</span></span><br></pre></td></tr></table></figure>

<p>atob 这个方法名称乍一看，很奇怪，不知道这个单词什么意思。我们可以理解为 A to B，也就是从 A 到 B。<br>atob 表示 Base64 字符 to 普通字符，也就是 Base64 解码。<br>当你在 Chrome console 中执行 <code>window.btoa(&#39;中文&#39;)</code>会发下会报错。</p>
<blockquote>
<p><code>Uncaught DOMException: Failed to execute &#39;btoa&#39; on &#39;Window&#39;: The string to be encoded contains characters outside of the Latin1 range.</code></p>
</blockquote>
<p>这时候我们可以借助 <code>encodeURIComponent</code> 和 <code>decodeURIComponent</code> 转义非中文字符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.btoa(<span class="built_in">encodeURIComponent</span>(<span class="string">'中文'</span>))</span><br><span class="line"><span class="comment">// ('JUU0JUI4JUFEJUU2JTk2JTg3')</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">decodeURIComponent</span>(<span class="built_in">window</span>.atob(<span class="string">'JUU0JUI4JUFEJUU2JTk2JTg3'</span>))</span><br><span class="line"><span class="comment">// "中文"</span></span><br></pre></td></tr></table></figure>

<p><a name="97hNP"></a></p>
<h2 id="Safari-下-Date-的坑"><a href="#Safari-下-Date-的坑" class="headerlink" title="Safari 下 Date 的坑"></a>Safari 下 Date 的坑</h2><p>在 使用 Date 相关 api 的时候要牢记一个坑，就是 Safari 对一些时间格式是不支持的。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Date</span>.parse(<span class="string">'2018-10-16 12:00:00'</span>)</span><br><span class="line"><span class="comment">// 1539662400000 -- 在Chrome 下</span></span><br><span class="line"><span class="comment">// NaN -- 在Safari下</span></span><br></pre></td></tr></table></figure>

<p>问题就出在 Safari 对于这个格式 YYYY-MM-DD HH:MM:SS 无法解析，Safari 要求 Date.parse()或 Date()转换日期的字符串需要满足 RFC2822 或 ISO 8601 定义的格式。不过我们可以将其转化为 YYYY/MM/DD HH:MM:SS</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Date</span>.parse(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2018-10-16 12:00:00'</span>.replace(<span class="regexp">/-/g</span>, <span class="string">'/'</span>)))</span><br></pre></td></tr></table></figure>

<p>相关<a href="https://stackoverflow.com/questions/4310953/invalid-date-in-safari" target="_blank" rel="noopener">stackoverflow</a><br></p>
<p><a name="fd465dc3"></a></p>
<h2 id="new-Date-在-safari-的坑"><a href="#new-Date-在-safari-的坑" class="headerlink" title="new Date 在 safari 的坑"></a>new Date 在 safari 的坑</h2><p><code>new Date(&#39;2019-06-04 00:00:00&#39;)</code>在除了 Safari 的浏览器都能正常运行。 问题就出在 Safari 对于这个格式 <code>YYYY-MM-DD HH:MM:SS</code> 无法解析，所以我们需要做的是将其转化为 <code>YYYY/MM/DD HH:MM:SS</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2019-06-04 00:00:00'</span>.replace(<span class="regexp">/-/g</span>, <span class="string">'/'</span>))</span><br></pre></td></tr></table></figure>

<p><a name="Tsg1B"></a></p>
<h2 id="e-target-与-e-currentTarget-的区别"><a href="#e-target-与-e-currentTarget-的区别" class="headerlink" title="e.target 与 e.currentTarget 的区别"></a>e.target 与 e.currentTarget 的区别</h2><p>有一次在面试的时候问了事件委托的题目，面试人说了一个 currentTarget，突然发现<code>target</code>和<code>currentTarget</code>的区别我好像有些忘记了，太多相似的 api 和属性了。</p>
<p>首先我们来看一下 MDN 上对它们的解释</p>
<ul>
<li>target：一个触发事件的对象的引用， 当事件处理程序在事件的冒泡或捕获阶段被调用时。</li>
<li>currentTarget： 当事件遍历 DOM 时，标识事件的当前目标。它总是引用事件处理程序附加到的元素，而不是 event.target，event.target 标识事件发生的元素。</li>
</ul>
<p>可能还是很抽象 ，这里提供一个在线<a href="https://jsbin.com/xekebepaqi/edit?html,js,console,output" target="_blank" rel="noopener">demo</a>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS Bin<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>hello 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>hello 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>hello 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>hello 4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> ul = <span class="built_in">document</span>.querySelectorAll(<span class="string">'ul'</span>)[<span class="number">0</span>]</span></span><br><span class="line"><span class="javascript">ul.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> oLi1 = e.target</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> oLi2 = e.currentTarget</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(oLi1.tagName); <span class="comment">//  被点击的li</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(oLi2.tagName); <span class="comment">// ul</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(oLi1 === oLi2); <span class="comment">// false</span></span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>也就是说，currentTarget 始终是监听事件者，而 target 是事件的真正发出者。<br><a name="CFzhD"></a></p>
<h2 id="函数变量必填校验"><a href="#函数变量必填校验" class="headerlink" title="函数变量必填校验"></a>函数变量必填校验</h2><p>这里分享一个平时写 ES6 的时候一个小技巧。如何简单的校验并强制在使用这个函数时必须传参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isRequired = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Missing parameter'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function">(<span class="params">something = isRequired(</span>)) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(something)</span><br><span class="line">  <span class="keyword">return</span> something</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">123</span>)</span><br><span class="line">foo() <span class="comment">// Error:Missing parameter</span></span><br></pre></td></tr></table></figure>

<p><a name="3pXxV"></a></p>
<h2 id="前端错误处理"><a href="#前端错误处理" class="headerlink" title="前端错误处理"></a>前端错误处理</h2><p>错误处理对于任何前端来说都是必不可少的。任何人写代码都避免不了会有 bug，而且很多 bug 也不是测试用例能完全覆盖的，如果我们没有一个完整的错误处理和错误收集的系统，我们都无法知道我们有 bug，不仅如此，很多 bug 也不一定是前端的问题，比如某个接口返回的数据格式不对了或者少字段了，亦或是在某个特定的浏览器型号上才有的问题等等。而且有了错误处理和收集，我们也才能更好的通过错误栈来还原这个问题。<br></p>
<p><a name="MQRyh"></a></p>
<h3 id="有哪些错误需要处理"><a href="#有哪些错误需要处理" class="headerlink" title="有哪些错误需要处理"></a>有哪些错误需要处理</h3><ul>
<li>JS 语法错误、代码异常</li>
<li>请求错误</li>
<li>静态资源加载异常</li>
<li>Promise 异常</li>
<li>页面崩溃和卡顿<br><a name="try-catch"></a><h3 id="Try-Catch"><a href="#Try-Catch" class="headerlink" title="Try Catch"></a>Try Catch</h3>try-catch 只能捕获到同步的运行时错误，对语法和异步错误却无能为力，捕获不到。 1.同步运行时错误：</li>
</ul>
<ol>
<li>同步错误</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">'foo'</span></span><br><span class="line">  <span class="built_in">console</span>.log(nam)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'捕获到异常：'</span>, e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>捕获到异常： ‘ReferenceError: nam is not defined at <anonymous>:3:15’</anonymous></p>
</blockquote>
<ol start="2">
<li>语法错误</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">'foo</span></span><br><span class="line"><span class="string">  console.log(nam)</span></span><br><span class="line"><span class="string">&#125; catch (e) &#123;</span></span><br><span class="line"><span class="string">  console.log('</span>捕获到异常：<span class="string">', e)</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Uncaught SyntaxError: Unexpected identifier</p>
</blockquote>
<ol start="3">
<li>异步错误</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="literal">undefined</span>.map(<span class="function"><span class="params">v</span> =&gt;</span> v)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'捕获到异常：'</span>, e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>每次的数都不一样，运行一次就加1<br>Uncaught TypeError: Cannot read property ‘map’ of undefined</p>
</blockquote>
<p><a name="window-onerror"></a></p>
<h3 id="window-onerror"><a href="#window-onerror" class="headerlink" title="window.onerror"></a>window.onerror</h3><p>当 JS 运行时错误发生时，window 会触发一个 ErrorEvent 接口的 error 事件，并执行 window.onerror()。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;String&#125;  message    错误信息</span></span><br><span class="line"><span class="comment"> * @param &#123;String&#125;  source    出错文件</span></span><br><span class="line"><span class="comment"> * @param &#123;Number&#125;  lineno    行号</span></span><br><span class="line"><span class="comment"> * @param &#123;Number&#125;  colno    列号</span></span><br><span class="line"><span class="comment"> * @param &#123;Object&#125;  error  Error对象（对象）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">message, source, lineno, colno, error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'捕获到异常：'</span>, &#123; message, source, lineno, colno, error &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不同域名下的 js 报错不能被 全局的 window.onerror 监听到，我们需要给相关的 js 文件上加上 Access-Control-Allow-Origin:*的 response header，并且引用相关的 js 文件时加上 crossorigin 属性。相关<a href="https://www.jianshu.com/p/315ffe6797b8" target="_blank" rel="noopener">文章</a></p>
<p>在实际的使用过程中，onerror 主要是来捕获预料之外的错误，而 try-catch 则是用来在可预见情况下监控特定的错误，两者结合使用更加高效。</p>
<p><a name="window-addeventlistener"></a></p>
<h3 id="window-addEventListener"><a href="#window-addEventListener" class="headerlink" title="window.addEventListener"></a>window.addEventListener</h3><p>当一项资源（如图片或脚本）加载失败，加载资源的元素会触发一个 Event 接口的 error 事件，并执行该元素上的 onerror() 处理函数。这些 error 事件不会向上冒泡到 window ，不过（至少在 Firefox 中）能被单一的 window.addEventListener 捕获。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">"./foo.png"</span>&gt;</span><br><span class="line">&lt;scritp&gt;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'error'</span>, (error) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'捕获到异常：'</span>, error);</span><br><span class="line">&#125;, <span class="literal">true</span>)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p><a name="promise-catch"></a></p>
<h3 id="Promise-Catch"><a href="#Promise-Catch" class="headerlink" title="Promise Catch"></a>Promise Catch</h3><p>没有写 catch 的 Promise 中抛出的错误无法被 onerror 或 try-catch 捕获到，所以我们务必要在 Promise 中不要忘记写 catch 处理抛出的异常。<br>或者可以全局增加一个对 unhandledrejection 的监听，用来全局监听 Uncaught Promise Error。使用方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'unhandledrejection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当然你如果使用如 axios 这种库的话，错误处理完全可以放在它的请求实例里面做。更加的灵活。</p>
<p><a name="vue-errorhandler"></a></p>
<h3 id="VUE-errorHandler"><a href="#VUE-errorHandler" class="headerlink" title="VUE errorHandler"></a>VUE errorHandler</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.config.errorHandler = <span class="function">(<span class="params">err, vm, info</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'通过vue errorHandler捕获的错误'</span>)</span><br><span class="line">  <span class="built_in">console</span>.error(err)</span><br><span class="line">  <span class="built_in">console</span>.error(vm)</span><br><span class="line">  <span class="built_in">console</span>.error(info)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="1hVlk"></a></p>
<h3 id="React-异常捕获"><a href="#React-异常捕获" class="headerlink" title="React 异常捕获"></a>React 异常捕获</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">componentDidCatch(error, info) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error, info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="UkWSW"></a></p>
<h3 id="崩溃和卡顿"><a href="#崩溃和卡顿" class="headerlink" title="崩溃和卡顿"></a>崩溃和卡顿</h3><p><a href="https://zhuanlan.zhihu.com/p/40273861" target="_blank" rel="noopener">相关文章</a> <a href="https://juejin.im/post/5cf72029f265da1b5f264334" target="_blank" rel="noopener">实践总结】优雅的处理 vue 项目异常</a></p>
<p><a name="4LEXG"></a></p>
<h2 id="insertBefore-坑"><a href="#insertBefore-坑" class="headerlink" title="insertBefore 坑"></a>insertBefore 坑</h2><p><br>Node.insertBefore()很多人都用过， 它在参考节点之前插入一个节点作为一个指定父节点的子节点。</p>
<blockquote>
<p>var insertedNode = parentNode.insertBefore(newNode, referenceNode);</p>
</blockquote>
<p>但看文档还有一句补充说明：</p>
<blockquote>
<p>如果 referenceElement 为 null 则 newElement 将被插入到子节点的末尾。如果 newElement 已经在 DOM 树中，newElement 首先会从 DOM 树中移除。</p>
</blockquote>
<p>这就很坑了，如下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"parentElement"</span>&gt;</span><br><span class="line">  &lt;span id=<span class="string">"bar"</span>&gt;bar&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">  &lt;span id='foo'&gt;foo&lt;/</span>span&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">var foo = document.getElementById("foo")</span></span><br><span class="line"><span class="regexp">var bar = document.getElementById("bar")</span></span><br><span class="line"><span class="regexp">var parentDiv = document.getElementById("parentElement")</span></span><br><span class="line"><span class="regexp">parentDiv.insertBefore(foo, bar)</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>

<p>原本以为结果是 <code>foo</code> <code>bar</code> <code>foo</code>，但实际结果是<code>foo</code> <code>bar</code>。<br>因为根据文档，当你 insertBefore 的是一个已存在的值时，会移动它而不是拷贝它重新插入。贼坑！！！<br>如果使用 ES6 的话可以使用 <code>before</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="built_in">document</span>.getElementById(<span class="string">'foo'</span>)</span><br><span class="line"><span class="keyword">var</span> bar = <span class="built_in">document</span>.getElementById(<span class="string">'bar'</span>)</span><br><span class="line">bar.before(foo)</span><br></pre></td></tr></table></figure>

<p><a name="d41d8cd9"></a></p>
<p>##<br><a name="O5Plg"></a></p>
<h2 id="为什么前端监控要用-GIF-打点"><a href="#为什么前端监控要用-GIF-打点" class="headerlink" title="为什么前端监控要用 GIF 打点"></a>为什么前端监控要用 GIF 打点</h2><p>目前主流的前端监控数据上报都是采用 GIF 的上报方式，(百度统计/友盟/谷歌统计）都是这样实现的。但为什么一定要使用 GIF 呢？不能发 post 请求或者通过 script 标签的形式么？<br>当然你也可以使用一些黑科技的方式上报，用纯 css 来实现。但这种方案并没有什么特别的好处。<br></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.track-xx</span><span class="selector-pseudo">:active</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="built_in">url</span>(track.php?xxxx=foo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="d41d8cd9-1"></a></p>
<p>###<br><a name="5caCe"></a></p>
<h3 id="主要原因"><a href="#主要原因" class="headerlink" title="主要原因"></a>主要原因</h3><ul>
<li>没有跨域问题<br></li>
<li>不会阻塞页面加载，影响用户体验<br></li>
<li>在所有图片中体积最小，相较 BMP/PNG，可以节约 41%/35%的网络资源<br></li>
</ul>
<p>详情见 <a href="https://mp.weixin.qq.com/s/v6R2w26qZkEilXY0mPUBCw" target="_blank" rel="noopener">为什么前端监控要用 GIF 打点</a><br><a name="a653042e"></a></p>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>但建议不要按如下方法使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Image().src = <span class="string">'https://foo.com/bar.gif?t=xxxx&amp;b=1'</span></span><br></pre></td></tr></table></figure>

<p>这段代码的问题是这个 new Image()是一个没有引用的临时变量，随时可能被浏览器的垃圾回收机制回收。如果这个图片的 HTTP 请求尚未建立，那么在被回收时这个请求就会被取消，导致打点并没有真正发出。如果打点所在的页面比较复杂，浏览器垃圾回收机制可能会被频繁触发，那么这种方式打点的丢失率可能会高达 10%以上。</p>
<p>解决方法很简单，将这个图片赋值给一个全局变量即可，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> img = <span class="keyword">new</span> Image()</span><br><span class="line"><span class="keyword">const</span> key = +<span class="keyword">new</span> <span class="built_in">Date</span>() <span class="comment">//加一个时间戳，防止图片被浏览器缓存了，不再发送请求  "+"转换时间戳</span></span><br><span class="line"><span class="built_in">window</span>[t] = img</span><br><span class="line">img.onload = img.onerror = img.onabort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// img标签加载完成、错误或终止时，解除事件绑定，销毁相关对象</span></span><br><span class="line">  img.onload = img.onerror = img.onabort = <span class="literal">null</span></span><br><span class="line">  <span class="built_in">window</span>[key] = <span class="literal">null</span></span><br><span class="line">  img = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line">img.src = <span class="string">`<span class="subst">$&#123;url&#125;</span>?t=key`</span></span><br></pre></td></tr></table></figure>

<p><a name="d41d8cd9-2"></a></p>
<p>###<br><a name="VkXKl"></a></p>
<h3 id="其它方案"><a href="#其它方案" class="headerlink" title="其它方案"></a>其它方案</h3><p>Beacon API</p>
<ul>
<li>在空闲的时候异步发送统计，不影响页面诸如 JS、CSS Animation 等执行</li>
<li>即使页面在 unload 状态下，也会异步发送统计，不影响页面过渡/跳转到下跳页</li>
<li>能够被客户端优化发送，尤其在 Mobile 环境下，可以将 Beacon 请求合并到其他请求上，一同处理</li>
</ul>
<p><a name="object-create-null-vs"></a></p>
<h2 id="Object-create-null-vs"><a href="#Object-create-null-vs" class="headerlink" title="Object.create(null) vs {}"></a>Object.create(null) vs {}</h2><p>查看 vue 的源码 或者一些开源项目的源码，发现不少地方都是使用 <code>Object.create(null)</code>来创建一个空对象的。<br>当使用语句 const obj = {}; 创建对象时，它其实并不是一个真的<code>空对象</code>，它从 Object.prototype 上继承了一些方法：</p>
<ul>
<li>hasOwnProperty</li>
<li>isPrototypeOf</li>
<li>propertyIsEnumerable</li>
<li>toString/toLocaleString</li>
<li>valueOf</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/263301/1560496421757-4fdbc517-a05f-420c-81b4-52b37d79d591.png#align=left&display=inline&height=301&name=image.png&originHeight=315&originWidth=419&size=41364&status=done&width=400" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/263301/1560496470556-3b7706ae-8953-40a0-bfeb-39fb28de3e1e.png#align=left&display=inline&height=159&name=image.png&originHeight=130&originWidth=328&size=9324&status=done&width=400" alt="image.png"></p>
<p>如果使用 <code>Object.create(null)</code> 创建的对象，在没有继承任何东西。</p>
<p><strong>所以说是不是 <code>Object.create(null)</code> 是更好的创建一个空对象的方案呢？</strong><br>这就要看从 Object 上继承的那些方法我们是不是有用到了。</p>
<p><a name="hasownproperty"></a></p>
<h3 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty"></a>hasOwnProperty</h3><p>判断一个对象属性中是否具有指定的属性，返回 <code>true</code> or <code>false</code>。</p>
<p><a name="2LMgx"></a></p>
<h3 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf"></a>valueOf</h3><p>valueOf 很少直接使用。在隐式转换类型时，JavaScript 引擎会调用 valueOf 方法，强制把对象转换成原始值<br></p>
<p><a name="8b378531"></a></p>
<h3 id="toString、isPrototypeOf-和-propertyIsEnumerable"><a href="#toString、isPrototypeOf-和-propertyIsEnumerable" class="headerlink" title="toString、isPrototypeOf 和 propertyIsEnumerable"></a>toString、isPrototypeOf 和 propertyIsEnumerable</h3><p>这几个方法直接使用的情况较少，但自己的代码中不用并不表示别人写的代码不会调用。比如，有些框架可能会调用 toString 方法来判断结果是否为 [object Object]。<br></p>
<p><a name="54bbba80"></a></p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>因此，我们可以得出结论：当创建的对象只在当前执行环境中使用并且不会用到任何从 Object.prototype 上继承来的方法，也不会将该对象作为其他对象的原型的时候，那么可以使用 Object.create(null)。比如，构造一个字典对象的时候。<br>不过相对而言 <code>const obj={}</code>在浏览器中的执行速度是会比<code>Object.create(null)</code>快的，具体可点击链接<a href="https://jsperf.com/object-create-null-vs-literal/2" target="_blank" rel="noopener">test</a>。不过你一般代码中这些性能差距完全是可以忽略不计的。</p>
<p><a name="async-await-with-foreach"></a></p>
<h2 id="async-await-with-forEach"><a href="#async-await-with-forEach" class="headerlink" title="async/await with forEach()"></a>async/await with forEach()</h2><p>之前在工作中遇到了一个需求，实现一个简单的请求队列，大概意思就是这个页面有一个 list，我需要按 list 顺序依次发请求，多数据做一些操作，每次等前一个请求成功之后，再执行下一个，全部执行完毕之后，显示已完成。<br>这不就是用 <code>async/await</code>就可以实现了。于是写了如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> waitFor = <span class="function"><span class="params">ms</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> setTimeout(r, ms));</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach(<span class="keyword">async</span> num =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> waitFor(<span class="number">1000</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(num)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Done'</span>)</span><br></pre></td></tr></table></figure>

<p>What？为什么<code>await</code>没有生效，直接就输出了<code>1,2,3</code>？谷歌搜索了一下，发现原来是<code>forEach</code>的锅。 我们简单来看一下 <code>forEach</code>的实现原理：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.forEach = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// this represents our array</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; <span class="keyword">this</span>.length; index++) &#123;</span><br><span class="line">    <span class="comment">// We call the callback for each entry</span></span><br><span class="line">    callback(<span class="keyword">this</span>[index], index, <span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到它只是 for 循环的一个简单封装，而且在内部它只是简单做了一个回调，根本就不会<code>wait</code>。其实一些其它的数组方式比如<code>map</code>、<code>reduce</code>等等也是不支持的，因为 Array 的迭代方法就支持不支持参数函数返回 promise 的异步用法，有兴趣的可以自行了解。<br>那我们直接用 <code>for</code>循环不就好了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].length; index++) &#123;</span><br><span class="line">    <span class="keyword">await</span> waitFor(<span class="number">1000</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(index)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'done'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者 <code>for-of</code>更为简单</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) &#123;</span><br><span class="line">    <span class="keyword">await</span> waitFor(<span class="number">1000</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'done'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="09ccd519"></a></p>
<h2 id="获取元素宽度"><a href="#获取元素宽度" class="headerlink" title="获取元素宽度"></a>获取元素宽度</h2><p>说真的，我觉得前端麻烦的地方就是 API 太多了，我只是想获取一个元素的宽度居然有<code>getBoundingClientRect().width</code></p>
<p><a name="7de30023"></a></p>
<h2 id="我使用-Async-Await-而不使用-Promises-的六个理由"><a href="#我使用-Async-Await-而不使用-Promises-的六个理由" class="headerlink" title="我使用 Async/Await 而不使用 Promises 的六个理由"></a>我使用 Async/Await 而不使用 Promises 的六个理由</h2><p>本文主要来自于 <a href="https://hackernoon.com/6-reasons-why-javascripts-async-await-blows-promises-away-tutorial-c7ec10518dd9" target="_blank" rel="noopener">6 Reasons Why JavaScript’s Async/Await Blows Promises Away</a>，在 medium 上，需要翻墙阅读。<br>之前我很长一段时间内都是使用 promise 的，但遇到一些复杂业务的时候，发现还是写起来会很不爽，代码阅读性也有所欠缺。<br></p>
<ol>
<li>简洁</li>
</ol>
<p>对比 Promise，我们不需要书写.then，不需要新建一个匿名函数处理响应，也不需要再把数据赋值给一个我们其实并不需要的变量</p>
<ol start="2">
<li>a</li>
</ol>
<p>但 Async/Await 也不是没有缺点的，很多人经常会错用它。比如我一个组件创建的的时候会异步向服务器发送三个请求，<code>a</code>、<code>b、c</code>。 很多人会这么写</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> resultA = <span class="keyword">await</span> fetch(<span class="string">'A'</span>)</span><br><span class="line">  <span class="keyword">const</span> resultB = <span class="keyword">await</span> fetch(<span class="string">'B'</span>)</span><br><span class="line">  <span class="keyword">const</span> resultC = <span class="keyword">await</span> fetch(<span class="string">'C'</span>)</span><br><span class="line">  render(resultA, resultB, resultC)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然上面的这段写法相对于 promise 简洁了不少，但效率来说是不合格的。因为这个请求是异步的，毫无联系的，所有没必要顺序请求，他们三个明显可以异步并发的去请求。要想实现真正的异步，还是需要依赖 Promise.all 封装一层：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(</span><br><span class="line">    fetch(<span class="string">'a.json'</span>),</span><br><span class="line">    fetch(<span class="string">'b.json'</span>),</span><br><span class="line">    fetch(<span class="string">'c.json'</span>)</span><br><span class="line">  )</span><br><span class="line">  render(...result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>未完待续…</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/14/yuque/Virtual DOM 性能好？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FangCao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FangCao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/14/yuque/Virtual DOM 性能好？/" itemprop="url">Virtual DOM 性能好？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-14T09:37:26+08:00">
                2019-06-14
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/06/14/yuque/Virtual DOM 性能好？/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/06/14/yuque/Virtual DOM 性能好？/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>每次面试，面试人一谈到 react 就必然会谈到 Virtual DOM，一谈到 Virtual DOM 就会说它比原生操作 DOM 性能哪里哪里好。<br><br><br>但任何一个 v-dom 框架都不会说自己的性能快过 DOM 操作。就拿 react 为例子，它的目标是：“每次数据变化都以最小的代价来更新真实 DOM”。引入 v-dom，在内存中比较虚拟节点，然后找出不同，之后执行更新。<br><br><br>就能更改页面上一个元素的内容，直接操作 DOM 的反应速度绝对会比你 diff 一次之后再更新来的快。但这时你可能会觉得当程序到达一定的复杂度之后，v-dom 性能上的优势才能体现出来。但是，无论你代价再少也好，v-dom 都是有消耗的，光从你要生成整个页面的 v-dom 就会比单单生成原生 dom 要多消耗一大截内存，更别说其中的复杂递归，比对，然后再变换。但是！它依然是纯 js 层面的计算，比起后面的 DOM 操作来说，依然便宜了太多。<br><br><br>所以 v-dom 真正的价值是什么？<br><br><br>框架给你的保证是，你在不需要手动优化的情况下，我依然可以给你提供过得去的性能。<br><br><br>我认为是带来了跨屏能力，以及代码的可维护性， 同时为函数式的 UI 编程方式打开了大门。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/14/yuque/垃圾回收/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FangCao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FangCao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/14/yuque/垃圾回收/" itemprop="url">垃圾回收</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-14T09:31:27+08:00">
                2019-06-14
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/06/14/yuque/垃圾回收/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/06/14/yuque/垃圾回收/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>作为编写程序的人，是可以做出“这个对象已经不再需要了”这样的判断，但计算机是做不到的。因此，如果程序（通过某个变量等等）可能会直接或间接地引用一个对象，那么这个对象就被视为“存活”；与之相反，已经引用不到的对象被视为“死亡”。将这些“死亡”对象找出来，然后作为垃圾进行回收，这就是 GC 的本质。</p>
<p><a name="PUsOw"></a></p>
<h2 id="三大基础-GC-算法"><a href="#三大基础-GC-算法" class="headerlink" title="三大基础 GC 算法"></a>三大基础 GC 算法</h2><p><a name="mOyWK"></a></p>
<h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p><img src="https://cdn.nlark.com/yuque/0/2019/png/263301/1560475934807-5e3e53e8-bafd-451a-9015-f5bd8b2ce39f.png#align=left&display=inline&height=334&name=image.png&originHeight=375&originWidth=337&size=61909&status=done&width=300" alt="image.png"></p>
<p>它的基本原理是，在每个对象中保存该对象的引用计数，当引用发生增减时对计数进行更新。引用计数的增减，一般发生在变量赋值、对象内容更新、函数结束（局部变量不再被引用）等时间点。当一个对象的引用计数变为 0 时，则说明它将来不会再被引用，因此可以释放相应的内存空间。</p>
<p>引用计数最大的缺点，就是无法释放循环引用的对象。</p>
<p><a name="wNHUq"></a></p>
<h4 id="标记清除法-标记压缩法"><a href="#标记清除法-标记压缩法" class="headerlink" title="标记清除法/标记压缩法"></a>标记清除法/标记压缩法</h4><p><img src="https://cdn.nlark.com/yuque/0/2019/png/263301/1560475996798-af83cf98-7ea3-4c4e-a986-6141b4f58511.png#align=left&display=inline&height=590&originHeight=590&originWidth=339&size=0&status=done&width=339" alt><br>这个算法假定设置一个叫做根（root）的对象（在 Javascript 里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象<br>从 2012 年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对 JavaScript 垃圾回收算法的改进都是基于标记-清除算法的改进，并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义。<br>标记清除算法有一个缺点，就是在分配了大量对象，并且其中只有一小部分存活的情况下，所消耗的时间会大大超过必要的值，这是因为在清除阶段还需要对大量死亡对象进行扫描。<br></p>
<p><a name="dlS73"></a></p>
<h4 id="复制收集算法"><a href="#复制收集算法" class="headerlink" title="复制收集算法"></a>复制收集算法</h4><p>在这种算法中，会将从根开始被引用的对象复制到另外的空间中，然后，再将复制的对象所能够引用的对象用递归的方式不断复制下去。<br>但是，和标记相比，将对象复制一份所需要的开销则比较大，因此在“存活”对象比例较高的情况下，反而会比较不利。这种算法的另一个好处是它具有局部性（Lo-cality）。在复制收集过程中，会按照对象被引用的顺序将对象复制到新空间中。于是，关系较近的对象被放在距离较近的内存空间中的可能性会提高，这被称为局部性。局部性高的情况下，内存缓存会更容易有效运作，程序的运行性能也能够得到提高。<br></p>
<p><a name="qEqzS"></a></p>
<h2 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h2><p>V8 引擎将保存对象的 堆 (heap) 进行了分代:</p>
<ul>
<li>对象最初会被分在 新生区(New Space) (1~8M)，新生区的内存分配只需要保有一个指向内存区的指针，不断根据内存大小进行递增，当指针达到新生区的末尾，会有一次垃圾回收清理(小周期)，清理掉新生区中不再活跃的死对象。<br></li>
<li>对于超过 2 个小周期的对象，则需要将其移动至 老生区(Old Space)。老生区在 标记-清除 或 标记-紧缩 的过程(大周期) 中进行回收。<br></li>
</ul>
<p>大周期进行的并不频繁。一次大周期通常是在移动足够多的对象至老生区后才会发生<br>参考：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/263301/1560476090513-e3b7d117-31dc-4896-9303-c26e1e919b1b.png#align=left&display=inline&height=561&name=image.png&originHeight=611&originWidth=327&size=106055&status=done&width=300" alt="image.png"><br></p>
<ul>
<li><a href="https://juejin.im/post/5cf4d12ee51d45775746b8ea" target="_blank" rel="noopener">JavaScript 垃圾回收机制</a></li>
<li><a href="https://segmentfault.com/a/1190000004665100" target="_blank" rel="noopener">GC 的三大基础算法</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">FangCao</p>
              <p class="site-description motion-element" itemprop="description">天空不留下鸟的痕迹，但我已飞过；流星是美丽的不为永恒，只为瞬间</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">66</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://macshuo.com/" title="MacTalk" target="_blank">MacTalk</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://example.com/" title="Title" target="_blank">Title</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2012 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">FangCao</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  







  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://wangfangcao7618@gmail.com.disqus.com/count.js" async></script>
    

    

  




	





  














  





  

  

  

  
  

  

  

  

</body>
</html>
