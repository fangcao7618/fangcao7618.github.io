<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo主题配置优化]]></title>
    <url>%2F2019%2F06%2F20%2Fyuque%2FHexo%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1.基本信息配置 基本信息包括：博客标题.作者.描述.语言等等。 打开 站点配置文件 ，找到Site模块 title: 标题subtitle: 副标题description: 描述author: 作者language: 语言（简体中文是zh-Hans）timezone: 网站时区（Hexo 默认使用您电脑的时区，不用写） 关于 站点配置文件 中的其他配置可参考站点配置 2.菜单设置 菜单包括：首页、归档、分类、标签、关于等等 我们刚开始默认的菜单只有首页和归档两个，不能够满足我们的要求，所以需要添加菜单，打开 主题配置文件 找到Menu Settings menu: home: / || home //首页 archives: /archives/ || archive //归档 categories: /categories/ || th //分类 tags: /tags/ || tags //标签 about: /about/ || user //关于 #schedule: /schedule/ || calendar //日程表 #sitemap: /sitemap.xml || sitemap //站点地图 #commonweal: /404/ || heartbeat //公益404 看看你需要哪个菜单就把哪个取消注释打开就行了；关于后面的格式，以archives: /archives/ || archive为例：|| 之前的/archives/表示标题“归档”，关于标题的格式可以去themes/next/languages/zh-Hans.yml中参考或修改||之后的archive表示图标，可以去Font Awesome中查看或修改，Next主题所有的图标都来自Font Awesome。 3.Next主题样式设置我们百里挑一选择了Next主题，不过Next主题还有4种风格供我们选择，打开 主题配置文件 找到Scheme Settings Schemesscheme: Musescheme: Mistscheme: Piscesscheme: Gemini 4种风格大同小异，本人用的是Gemini风格，你们可以选择自己喜欢的风格。 4.侧栏设置 侧栏设置包括：侧栏位置.侧栏显示与否.文章间距.返回顶部按钮等等 打开 主题配置文件 找到sidebar字段 sidebar: Sidebar Position - 侧栏位置（只对Pisces | Gemini两种风格有效） position: left //靠左放置 #position: right //靠右放置 Sidebar Display - 侧栏显示时机（只对Muse | Mist两种风格有效） #display: post //默认行为，在文章页面（拥有目录列表）时显示 display: always //在所有页面中都显示 #display: hide //在所有页面中都隐藏（可以手动展开） #display: remove //完全移除 offset: 12 //文章间距（只对Pisces | Gemini两种风格有效） b2t: false //返回顶部按钮（只对Pisces | Gemini两种风格有效） scrollpercent: true //返回顶部按钮的百分比 5.头像设置打开 主题配置文件 找到Sidebar Avatar字段 Sidebar Avatar avatar: /images/header.jpg 这是头像的路径，只需把你的头像命名为header.jpg（随便命名）放入themes/next/source/images中，将avatar的路径名改成你的头像名就OK啦！ 6.评论系统 推荐指数 优点 缺点 Valine 4 每天30000条评论，10GB的储存 作者评论无标识 来必力/livere 4 多种账号登录 评论无法导出 畅言 3 美观 必须备案域名 gitment 3 简洁 只能登陆github评论 Disqus 1 需要翻*墙 来必力2.1. 登陆 来必力 获取你的 LiveRe UID。2.2. 填写LiveRe UID到主题配置文件_config.yml 7.添加标签页 添加一个标签页面，里面包含您网站中的所有标签。参考链接 一个创建³³名为tags页面 hexo new page “tags” 编辑标签页，设置页面类型为tags。 title: All tags date: 2014-12-22 12:39:04 type: “tags” 添加tags到主题配置文件_config.yml里： menu: home: / archives: /archives tags: /tags 详细解释： 8.添加分类页 添加一个分类页面，里面包含您网站中的所有分类。 一个创建³³名为categories页面 hexo new page “categories” 编辑分类页，设置页面类型为categories。 title: All categories date: 2014-12-22 12:39:04 type: “categories” 添加 categories到主题配置文件_config.yml里： menu: home: / archives: /archives categories: /categories 详细解释： 参考截图: 9.添加萌萌哒宠物具体参考官方文档：点击跳转 1.安装模块: npm install –save hexo-helper-live2d 2.配置请向Hexo的 _config.yml 文件或主题的 _config.yml 文件中添加配置.示例: 12345678910111213141516live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: use: live2d-widget-model-wanko display: position: right width: 150 height: 300 mobile: show: true 详解: 1234567891011121314151617live2d: enable: true # enable: false scriptFrom: local # 默认 pluginRootPath: live2dw/ # 插件在站点上的根目录(相对路径) pluginJsPath: lib/ # 脚本文件相对与插件根目录路径 pluginModelPath: assets/ # 模型文件相对与插件根目录路径 # scriptFrom: jsdelivr # jsdelivr CDN # scriptFrom: unpkg # unpkg CDN # scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url tagMode: false # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中 debug: false # 调试, 是否在控制台输出日志 model: use: live2d-widget-model-wanko # npm-module package name # use: wanko # 博客根目录/live2d_models/ 下的目录名 # use: ./wives/wanko # 相对于博客根目录的路径 # use: https://cdn.jsdelivr.net/npm/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # 你的自定义 url 3.模型有许多方法来使用不同的模型: a. live2d_models子目录名称 在您博客根目录下创建一个 live2d_models 文件夹. 在此文件夹内新建名为 shizuku （模型名字）的子文件夹. 在这里应当有一个 .model.json 文件 (例如 shizuku.model.json) 将子文件夹的名称输入 _config.yml 的 model.use 中. b. 相对于博客根目录的自定义路径您可直接输入相对于博客根目录的自定义路径到 model.use 中.示例: ./wives/wanko c. npm 模块名（走这步就可以了）现有模型：https://github.com/xiazeyu/live2d-widget-models对应的模型图片：https://huaji8.top/post/live2d-plugin-2.0/模型地址npm install --save live2d-widget-model-xxx 来安装然后你就可以通过向 model.use 键入包名 (live2d-widget-model-wanko) 来使用了. 10.首页阅读全文Hexo 的 Next 主题默认是首页显示你每篇文章的全文内容，但这会使你的首页篇幅过于冗长，针对这个问题我们可以这么做：用编辑器打开themes/next 目录下的_config.yml文件找到代码： auto_excerpt: enable: false length: 150 将enable的 false改成true，length可以设定文章预览的文本长度。 11.修改背景图片在 themes/*/source/css/_custom/custom.styl 中添加如下代码： // 添加背景图 bg.jpg为图片名称body{ background:url(/images/bg.jpg); background-size:cover; background-repeat:no-repeat; background-attachment:fixed; background-position:center;} 12.实现点击出现桃心效果 在/themes/*/source/js/src下新建文件click.js，接着把以下粘贴到click.js文件中。代码如下： 1!function(e,t,a)&#123;function n()&#123;c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:"+d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+","+d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999");requestAnimationFrame(r)&#125;function o()&#123;var t="function"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement("div");a.className="heart",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement("style");a.type="text/css";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName("head")[0].appendChild(a)&#125;function s()&#123;return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 在\themes\*\layout\_layout.swig文件末尾添加： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/click.js"&gt;&lt;/script&gt; 13.主页文章添加边框阴影效果打开 themes/*/source/css/_custom/custom.styl ,向里面加代码: 12345678// 主页文章添加阴影效果.post &#123; margin-top: 0px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125; 14.显示当前浏览进度修改themes/*/_config.yml，把 false 改为 true： 12345# Back to top in sidebarb2t: true# Scroll percent label in b2t buttonscrollpercent: true 15.博客文章置顶安装插件 12$ npm uninstall hexo-generator-index --save$ npm install hexo-generator-index-pin-top --save 然后在需要置顶的文章的Front-matter中加上top即可：top值越大表示优先级越高 12345---title: 2018date: 2018-10-25 16:10:03top: 10--- 设置置顶标志打开：/themes/*/layout/_macro/post.swig插入以下代码即可： 12345&#123;% if post.top %&#125; &lt;i class="fa fa-thumb-tack"&gt;&lt;/i&gt; &lt;font color=000000&gt;置顶&lt;/font&gt; &lt;span class="post-meta-divider"&gt; &lt;/span&gt;&#123;% endif %&#125; 16.生成博文插入图片参考：Nuub用Typora编写Markdown的可以修改成这样就直接复制图片过去了 17.取消文章目录自动编号修改主题配置文件那里的number为false 18.修改文章底部标签的图标修改主题模板/themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将 # 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 19.静态资源压缩在站点目录下： 12$ npm install gulp -gnpm install gulp 安装gulp插件： 12345npm install gulp-minify-css --savenpm install gulp-uglify --savenpm install gulp-htmlmin --savenpm install gulp-htmlclean --savenpm install gulp-imagemin --save 在 Hexo 站点下新建 gulpfile.js文件，文件内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445var gulp = require('gulp');var minifycss = require('gulp-minify-css');var uglify = require('gulp-uglify');var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');var imagemin = require('gulp-imagemin');// 压缩css文件gulp.task('minify-css', function() &#123; return gulp.src('./public/**/*.css') .pipe(minifycss()) .pipe(gulp.dest('./public'));&#125;);// 压缩html文件gulp.task('minify-html', function() &#123; return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest('./public'))&#125;);// 压缩js文件gulp.task('minify-js', function() &#123; return gulp.src(['./public/**/.js','!./public/js/**/*min.js']) .pipe(uglify()) .pipe(gulp.dest('./public'));&#125;);// 压缩 public/demo 目录内图片gulp.task('minify-images', function() &#123; gulp.src('./public/demo/**/*.*') .pipe(imagemin(&#123; optimizationLevel: 5, //类型：Number 默认：3 取值范围：0-7（优化等级） progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片 interlaced: false, //类型：Boolean 默认：false 隔行扫描gif进行渲染 multipass: false, //类型：Boolean 默认：false 多次优化svg直到完全优化 &#125;)) .pipe(gulp.dest('./public/uploads'));&#125;);// 默认任务gulp.task('default', [ 'minify-html','minify-css','minify-js','minify-images']); 只需要每次在执行 generate 命令后执行 gulp 就可以实现对静态资源的压缩，压缩完成后执行 deploy 命令同步到服务器： 123456hexo ggulphexo dhexo clean &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo d 20.去掉图片边框NexT主题默认会有图片边框，不太好看，我们可以把边框去掉。打开 themes\Next\source\css\_custom\custom.styl，添加如下CSS代码： 12345678/* 去掉图片边框 */.posts-expand .post-body img &#123; border: none; padding: 0px;&#125;.post-gallery .post-gallery-img img &#123; padding: 3px;&#125; 21.添加 关于页面hexo new page “about” 新建一个 关于我 页面。主题的 _config.yml 文件中的 menu 中进行匹配 123456menu: home: / //主页 categories: /categories //分类 archives: /archives //归档 tags: /tags //标签 about: /about //关于 （添加此行即可） 同理于标签页和分类页 22.添加字数统计.阅读时长 统计插件 配置NexT 主题默认已经集成了文章【字数统计】.【阅读时长】统计功能，如果我们需要使用，只需要在主题配置文件 _config.yml 中打开 wordcount 统计功能即可。如下所示： 12345678# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true # 单篇 字数统计 min2read: true # 单篇 阅读时长 totalcount: false # 网站 字数统计 separated_meta: true 修改完成主题配置文件后，启动服务预览： hexo server 访问 http://localhost:4000/ 链接，如果出现字数统计和阅读时长失效的情况，一般是因为没有安装 hexo-wordcount 插件，查看 Hexo 插件： hexo –debug 安装如果没有安装 hexo-wordcount插件，先安装该插件： npm i –save hexo-wordcount Node 版本 7.6.0 之前,请安装 2.x 版本 (Node.js v7.6.0 and previous) ，安装命令如下： npm install hexo-wordcount@2 –save 安装完成后，重新执行启动服务预览就可以了。 显示文字打开post.swig文件，路径如下：/themes/next/layout/_macro/post.swig修改【字数统计】，找到如下代码： 12345678910111213&lt;span title="&#123;&#123; __('post.wordcount') &#125;&#125;"&gt; &#123;&#123; wordcount(post.content) &#125;&#125;&lt;/span&gt;添加 “字” 到 &#123;&#123; wordcount(post.content) &#125;&#125; 后面，修改后为：&lt;span title="&#123;&#123; __('post.wordcount') &#125;&#125;"&gt; &#123;&#123; wordcount(post.content) &#125;&#125; 字&lt;/span&gt;同理，我们修改【阅读时长】，修改后如下：&lt;span title="&#123;&#123; __('post.min2read') &#125;&#125;"&gt; &#123;&#123; min2read(post.content) &#125;&#125; 分钟&lt;/span&gt; 效果预览图： 23.添加社交在主题配置文件找到social，添加需要的就可以，具体如下图可以自定义图标，默认的图标都是从图标库自动匹配的，||后面的就是在图标库的图标名 24.添加站内搜索1、安装 hexo-generator-searchdb 插件 npm install hexo-generator-searchdb –save 2、打开 站点配置文件 找到Extensions在下面添加 搜索 search: path: search.xml field: post format: html limit: 10000 3、打开 主题配置文件 找到Local search，将enable设置为true 25.设置文字居中这一行需要居中设置方法： 这一行需要居中 注意：简书中此方法无效 26.点击爆炸效果实现方法跟那个红心是差不多的，首先在themes/next/source/js/src里面建一个叫fireworks.js的文件，代码如下： 1"use strict";function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color="#F00",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:"linear",duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(".fireworks");if(canvasEl)&#123;var ctx=canvasEl.getContext("2d"),numberOfParticules=30,pointerX=0,pointerY=0,tap="mousedown",colors=["#FF1461","#18FF92","#5A87FF","#FBF38C"],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+"px",canvasEl.style.height=window.innerHeight+"px",canvasEl.getContext("2d").scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;"sidebar"!==e.target.id&amp;&amp;"toggle-sidebar"!==e.target.id&amp;&amp;"A"!==e.target.nodeName&amp;&amp;"IMG"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener("resize",setCanvasSize,!1)&#125;"use strict";function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color="#F00",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:"linear",duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(".fireworks");if(canvasEl)&#123;var ctx=canvasEl.getContext("2d"),numberOfParticules=30,pointerX=0,pointerY=0,tap="mousedown",colors=["#FF1461","#18FF92","#5A87FF","#FBF38C"],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+"px",canvasEl.style.height=window.innerHeight+"px",canvasEl.getContext("2d").scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;"sidebar"!==e.target.id&amp;&amp;"toggle-sidebar"!==e.target.id&amp;&amp;"A"!==e.target.nodeName&amp;&amp;"IMG"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener("resize",setCanvasSize,!1)&#125;; 打开themes/next/layout/_layout.swig,在&lt;/body&gt;上面写下如下代码： 12345&#123;% if theme.fireworks %&#125; &lt;canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" &gt;&lt;/canvas&gt; &lt;script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/js/src/fireworks.js"&gt;&lt;/script&gt;&#123;% endif %&#125; 打开主题配置文件，在里面最后写下： 12# Fireworksfireworks: true 完😀 27.设置文章加密访问这里使用第三方插件Hexo-Blog-Encrypt 1)首先，你需要在站点 _config.yml 中启用该插件1234# Security##encrypt: enable: true 2)给文章添加密码：1234567891011121314---title: hello worlddate: 2016-03-30 21:18:02tags: - fdsfadsfa - fdsafsdafpassword: Mikeabstract: Welcome to my blog, enter password to read.message: Welcome to my blog, enter password to read.---Eg：password: abstract: 此处遭到了封印message: 请输入正确的密码 password: 是该博客加密使用的密码 abstract: 是该博客的摘要，会显示在博客的列表页 message: 这个是博客查看时，密码输入框上面的描述性文字 对 TOC 进行加密如果你有一篇文章使用了 TOC，你需要修改模板的部分代码。这里用 landscape 作为例子： 你可以在 hexo/themes/landscape/layout/_partial/article.ejs 找到 article.ejs。 然后找到 &lt;% post.content %&gt; 这段代码，通常在30行左右。 使用如下的代码来替代它: 1234567891011&lt;% if(post.toc == true)&#123; %&gt; &lt;div id="toc-div" class="toc-article" &lt;% if (post.encrypt == true) &#123; %&gt;style="display:none" &lt;% &#125; %&gt;&gt; &lt;strong class="toc-title"&gt;Index&lt;/strong&gt; &lt;% if (post.encrypt == true) &#123; %&gt; &lt;%- toc(post.origin, &#123;list_number: true&#125;) %&gt; &lt;% &#125; else &#123; %&gt; &lt;%- toc(post.content, &#123;list_number: true&#125;) %&gt; &lt;% &#125; %&gt; &lt;/div&gt;&lt;% &#125; %&gt;&lt;%- post.content %&gt; 28 设置首页缩略图有两种方法，自行选择。 这个需要使用&lt;!-- more --&gt;进行截断，&lt;!-- more --&gt;上面的内容就是显示在主页的摘要，把图片放在&lt;!-- more --&gt;上面就可以了。如果是文字也会进行分割。 在编写md文章的时候在头部添加photos:，如下所示： 1234567891011---title: categories: tags:copyright: truecomments: falsedescription: date: 2017-11-09 14:33:32top:photos: - "https://i.loli.net/2019/01/19/5c42f345b6b2f.jpg" 参考资料:遇见西门JuLi距离Next官方文档Hexo瞎折腾系列NIkkkki睡不醒二次元模型https://l2dwidget.js.org/dev.htmlhexo-helper-live2dlive2d-widget.js 优秀的设计博客：https://clovertuan.github.io/resume/ 优秀的星球博客：https://tzvetkov75.github.io/demo_blog/public/2017/02/05/hello-world/转自：https://selfishluck.top/2018/12/21/Hexo%E4%B8%BB%E9%A2%98%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE/]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F20%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Eg：password:abstract: 此处遭到了封印message: 请输入正确的密码 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[语雀写作自动同步部署Hexo]]></title>
    <url>%2F2019%2F06%2F20%2Fyuque%2F%E8%AF%AD%E9%9B%80%E5%86%99%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%90%8C%E6%AD%A5%E9%83%A8%E7%BD%B2Hexo%2F</url>
    <content type="text"><![CDATA[语雀和Hexo之前都有单独使用过，都很舒服，今天偶然看到一篇大佬的文章，居然可以把这两个结合起来使用，这岂不是美滋滋，爽歪歪，所以说心动不如行动，搞起来~在实施的过程中，由于自己太菜，有好多坑，搞了好长时间才搞好，不容易，写这样一个文章记录一下 一、所需环境 1.操作系统最好Linux，若在Windows中就装一下虚拟机 2.所需环境软件 Git Node.Js Hexo Ruby二、实现步骤利用Hexo+Github+Triavs-ci来实现在语雀上面写着之后自动部署到Hexo上面去，这么做只能用舒服来形容，嘻嘻！1.介绍1）Hexo要怎么来部署就不要我在这多说什么了，我的博客有这样的教程，附上我的博客地址。2）Github作为一个程序猿必备，略过，没有的，嗯哼，可以不用看了。3）Triavs-ci开源持续集成构建项目，它与jenkins有点像，可以直接用你的Github账号登录，同步你的仓库，很是方便，页面也比较简洁好看。4）yuque-hexo一个Hexo的插件，看名字就知道用来干什么的了，所以你猜的没有错，他就是用来同步语雀到Hexo的插件，这是开源插件，附上开源库地址。感谢大佬的插件。使用起来也很简单就只需要安装好在package.json配置一下就好了。还在配置一下命令，不然编译生成的时候不会同步语雀的文章，也在package.json文件中配置具体可以参考我的package.json文件2.操作流程1）配置Hexo这里简单说一下要注意的地方，具体教程网上有很多。 增加hexo-deployer-git依赖，防止部署时报错。 copynpm install –save hexo-deployer-git 增加hexo-util到dev依赖，防止travis的npm版本&lt;3,出现的Error: Cannot find module &#39;hexo-util&#39;错误。 copynpm install –save-dev hexo-util 2）配置Github 在Github上面建两个库（也不一定要两个，也可以利用两个代码分支来进行，我这里用两个仓库做栗子） 一个仓库拥来存放Hexo编译前的代码库。另一个用来存放编译后用来开启Pages的仓库。在本地创建好的Hexo可以提交到源码的仓库了。可以也把Pages的也配置好。 3）配置Travis CI 第一步我们需要有一个 Travis-CI 的账号，直接进入Travis-CI官网，用自己的Github账号授权登录即可。 然后可以看到当前账号的所有代码仓库，接下来将博客项目的状态设置为启用。 第二步创建一个部署在 Travis CI 上面的 SSH key 利用这个 SSH key 可以让 Travis CI 向我们自己的项目提交代码(也就是将博客部署到Page)。这如果你在之前部署Hexo的时候已经创建过了，就可以直接用那个公钥来添加到Github里面去，添加好之后大概就是图片上的样子。 这里提一下，有的时候你的本地向GitHub提交提交不上去，但之前还是可以的，这时候可以检查GitHub的SSH密钥这里，可能是因为安全问题，官方给你暂时冻结了这个密钥，冻结的情况下这里的Delete旁边就会多一个激活按钮，点一下就好了。 第三步加密私钥 加密密钥的时候一定要在Linux操作系统下进行，不然travis-ci之后进行解密的时候会报错，目前官方就是这样的一个BUG，暂时无解。Windows的同学可以在Linux虚拟机中把你的Hexo源码仓库clone进行下面的操作。 这里还需要Ruby来支撑，所以还需安装Ruby，有几种方式，个人推荐还是老老实实编译安装最好 下载ruby 下载最新版的 Ruby 压缩文件。请点击这里下载。也可以使用wget命令 1- 下载 Ruby 之后，解压到新创建的目录下： 12$ tar -xvzf ruby-2.2.3.tgz $ cd ruby-2.2.3 1- 现在，配置并编译源代码，如下所示： 123$ ./configure$ make$ sudo make install 装后，通过在命令行中输入以下命令来确保一切工作正常： 123$ruby -vruby 2.2.3…… 如果一切工作正常，将会输出所安装的 Ruby 解释器的版本，如上所示。如果您安装了其他版本，则会显示其他不同的版本。 安装travis（如果在国内的网络环境下建议安装之前先换源) $ gem install travis 那么之前把公钥文件配置好了，然后现在就要配置私钥文件，在 hexo 项目下面建立一个 .travis 的文件夹来放置需要配置的文件和travis的配置文件travis.yml。Windows和Linux下无法创建和创建报错可以用命令mkdir ./.travis进行创建文件夹，用命令touch ./.travis.yml来创建travis的配置文件。切换到.travis文件夹下 1![image.png](https://cdn.nlark.com/yuque/0/2019/png/240833/1552316024043-dfd7b632-8a75-4634-ad76-4cb77158b415.png#align=left&amp;display=inline&amp;height=46&amp;name=image.png&amp;originHeight=57&amp;originWidth=721&amp;size=17007&amp;status=done&amp;width=577)&lt;br /&gt;用命令行工具登录： travis login –auto 这时候会让你输入你的Github账号（邮箱）和密码，也可以使用GitHub的Token来进行登录 travis login –github-token 具体的Token –auto 然后将私钥 id_rsa 复制到 .travis 文件夹，用命令行工具进行加密： $ travis encrypt-file id_rsa –add 这时候在之前创建好的.travis.yml文件里面就会被写入一些密钥的信息，大概如此：在你的Travis的项目设置中也会出现密钥 接下来就要配置 .travis.yml 首先我们要改一下生成的解密信息，因为这个里面的in和out的文件位置是相对于本地环境来生成的，如果在Travis上面跑的时候位置会发生变化这样运行的时候就会报错，改完之后大概这样子： 为了让 git 默认连接 SSH 还要创建一个 ssh_config 文件。在 .travis 文件夹下创建一个 ssh_config 文件，输入以下内容： Host github.com User git StrictHostKeyChecking no IdentityFile ~/.ssh/id_rsa IdentitiesOnly yes 这样，当向项目 push 代码的时候 travis CI 就会根据 .travis.yml 的内容去部署我们的项目了。具体可以参考我的.travis.yml文件这里要提一下，我们在向Hexo源码仓库Push的时候不要提交本地编译生成的node_modules文件夹，不然到时候在上面跑的时候会有权限问题，npm会根据package.json上面的信息自己下模块的，所以不用当选，具体的涉及到npm的运行原理这里不提了，想了解的可以自行百度哈。** 4）配置Serverless服务目前阿里云和腾讯云都有serverless服务，免费的额度完全够用了，下面介绍一下腾讯云如何配置 创建函数 serverless 函数配置 点击完成即可，之后在配置具体函数代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;?phpfunction main_handler($event, $context) &#123; // 解析语雀post的数据 $update_title = ''; if($event-&gt;body)&#123; $yuque_data= json_decode($event-&gt;body); $update_title .= $yuque_data-&gt;data-&gt;title; &#125; // default params $repos = ''; // 你的仓库id 或 slug $token = ''; // 你travis-cide的登录token $message = date("Y/m/d").':更新啦:'.$update_title; // 你这里是更新信息可自定义 $branch = 'master'; // 你GitHub分支 // post params $queryString = $event-&gt;queryString; $q_token = $queryString-&gt;token ? $queryString-&gt;token : $token; $q_repos = $queryString-&gt;repos ? $queryString-&gt;repos : $repos; $q_message = $queryString-&gt;message ? $queryString-&gt;message : $message; $q_branch = $queryString-&gt;branch ? $queryString-&gt;branch : 'master'; echo($q_token); echo('==='); echo ($q_repos); echo ('==='); echo ($q_message); echo ('==='); echo ($q_branch); echo ('==='); //request travis ci $res_info = triggerTravisCI($q_repos, $q_token, $q_message, $q_branch); $res_code = 0; $res_message = '未知'; if($res_info['http_code'])&#123; $res_code = $res_info['http_code']; switch($res_info['http_code'])&#123; case 200: case 202: $res_message = 'success'; break; default: $res_message = 'faild'; break; &#125; &#125; $res = array( 'status'=&gt;$res_code, 'message'=&gt;$res_message ); return $res;&#125;/** @description travis api , trigger a build* @param $repos string 仓库ID、slug* @param $token string 登录验证token* @param $message string 触发信息* @param $branch string 分支* @return $info array 回包信息*/function triggerTravisCI ($repos, $token, $message='yuque update', $branch='master') &#123; //初始化 $curl = curl_init(); //设置抓取的url curl_setopt($curl, CURLOPT_URL, 'https://api.travis-ci.org/repo/'.$repos.'/requests'); //设置获取的信息以文件流的形式返回，而不是直接输出。 curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1); //设置post方式提交 curl_setopt($curl, CURLOPT_CUSTOMREQUEST, "POST"); //设置post数据 $post_data = json_encode(array( "request"=&gt; array( "message"=&gt;$message, "branch"=&gt;$branch ) )); $header = array( 'Content-Type: application/json', 'Travis-API-Version: 3', 'Authorization:token '.$token, 'Content-Length:' . strlen($post_data) ); curl_setopt($curl, CURLOPT_HTTPHEADER, $header); curl_setopt($curl, CURLOPT_POSTFIELDS, $post_data); //执行命令 $data = curl_exec($curl); $info = curl_getinfo($curl); //关闭URL请求 curl_close($curl); return $info;&#125;?&gt; 这里有几个需要获取的参数： travis登录token，在travis-ci.org 中设置界面获取： 1- 仓库ID 或 扩展名 使用findder 或者 postman 发起一个请求： https://api.travis-ci.org/owner/github用户名/repos 配置触发方式 一般会得到这么个api：https://service-8x9gl1u7-1258196125.ap-shanghai.apigateway.myqcloud.com/release/yuque-hexo 5）配置语雀配置一个仓库（公开的仓库）的webhook:可以选择所有更新触发或者主动触发，主动触发的意思即发布需要勾选一个选项才会触发webhook。具体可参见语雀文档；将serverless生成的api填入,可以在链接后面带参数： 1234567token 登录tokenrepos 仓库idmessage 提交信息branch 分支示例：https://service-8x9gl1u7-1258196125.ap-shanghai.apigateway.myqcloud.com/release/yuque-hexo?repos=xxx&amp;token=xxx&amp;message=xxx&amp;branch=xxx 如果不在链接带参数则写在serverless函数内。 6）大功告成发布或者更新一篇文章后，我们前往travis-ci,可以看到已经触发了一次构建请求：构建完成后，咱们的博客上已经妥妥的展示出来拉~ 参考资料Nero的语雀转自：https://sunnybob.github.io/2019/01/11/%E8%AF%AD%E9%9B%80%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hexo+GithubPages%E5%8D%9A%E5%AE%A2/]]></content>
  </entry>
  <entry>
    <title><![CDATA[流量统计]]></title>
    <url>%2F2019%2F06%2F19%2Fyuque%2F%E6%B5%81%E9%87%8F%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[如果你关心自己博客的访问数据，那么集成流量统计工具自然必不可少。统计站点流量访问的平台主要推荐以下三个： Google Analysis:google.com/intl/zh-CN/a，功能强大不用多说，由于国内Google的服务用不了，所以推荐海外站点使用。 CNZZ：http://web.umeng.com/ ，中文网站统计分析平台，口碑不错，目前和友盟合并被阿里收购。 百度统计：http://tongji.baidu.com/ ，正在研究，不多做评价。 统计功能同样集成简单，我索性把三家统计都集成了，做分析对比。]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何评价「多说」即将关闭？有什么替代方案？]]></title>
    <url>%2F2019%2F06%2F19%2Fyuque%2F%E5%A6%82%E4%BD%95%E8%AF%84%E4%BB%B7%E3%80%8C%E5%A4%9A%E8%AF%B4%E3%80%8D%E5%8D%B3%E5%B0%86%E5%85%B3%E9%97%AD%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[第三方评论系统推荐这几天在网上搜集了不少第三方评论系统，做了简单测评。原文太长，所以贴个链接：第三方评论系统推荐 - 水八口记。文中提到的评论系统有： Disqus HyperComments 来必力 IntenseDebate 畅言 网易云跟帖（已停止服务） 友言 Remarkbox Vuukle Muut Vicomi Civil Comments Widget Pack Rating &amp; Comment System Facebook comments Livefyre（已停止服务） Google+ Comments（非官方） HashOver Isso Staticman Gitment Gitalk Blog Comments2 Valine hexo评论从多说迁移到disqus鉴于duoshuo系统2017年6月1号停止维护,我决定把评论系统切换到 Disqus，即使可能会丢失全部的评论数据，我还是决定和多说一刀两断。 添加disqus 评论系统可以用到的评论系统有挺多的，多说，disqus等，这里只mark下disqus，disqus 的添加跟主题有关，因为hexo自带disqus，所以添加起来非常简单，这里讲下默认的主题landscape 和 上面演示的主题next整个切换过程其实很简单，在 Disqus 注册，然后在 Settings/Admin 中新建站点，接下来就是一步一步跟着向导程序走下去。然后在主题的配置文件，主题的配置文件，主题的配置文件，重要的说三遍，在主题的配置文件_config.yml的disqus后面添加website shortname中使用的唯一的disqus识别名字，这里我使用的是zyy1217。 Step 1：进入disqus官网， 点击蓝色框中链接，给自己的网站添加disqus， Step 2：点击后，出现下图，输入网站名字。然后在第二个输入框填写自己的唯一disqus识别名称，这个名称会在后面用到，比如我这里填写的是我最常用的absea。然后点击Next按钮 Step 3：上面点击Next后就会出现下面页面，这里面会有disqus在不同博客系统上或者其他系统上对应的代码。因为hexo自带支持disqus，所以不需要这里面的代码，这个页面的内容会在其他除hexo之外的博客系统中用到，如果是hexo搭建博客disqus，可以跳过 Step 4：然后在主题的配置文件，主题的配置文件，主题的配置文件，重要的说三遍，在主题的配置文件_config.yml的disqus后面添加step 2中使用的唯一的disqus识别名字。这里我使用的是absea，还有一点一定要注意，不要再跟目录下的_config.yml对评论进行设置 | 12 | # Disqusdisqus_shortname: absea || :— | :— | Step 5：然后输入 hexo s或者hexo server 就会出现disqus的效果：关于disqus评论框的样式美化可以参考Disqus Appearance Tweak不仅如此，我们还可以区分国内与国外GIT，分别显示多说与DISQUS转自：http://zyy1217.com/2017/05/03/hexo%E8%AF%84%E8%AE%BA%E4%BB%8E%E5%A4%9A%E8%AF%B4%E8%BF%81%E7%A7%BB%E5%88%B0disqus/ Gitment Demo https://github.com/imsun/gitment Gitment：使用 GitHub Issues 搭建评论系统本以为自己都二十好几了，早就过了折腾博客系统的年龄，然而万万没想到多说倒闭了。 综合考虑了多家评论系统以后，我最终打算自己写一个。 Gitment 是作者实现的一款基于 GitHub Issues 的评论系统。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown / GFM 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。本博客评论系统已迁移至 Gitment。虽然 Gitment 只能使用 GitHub 账号进行评论，但考虑到博客受众，这是可以接受的。 项目地址 示例页面基础使用1. 注册 OAuth Application点击此处 来注册一个新的 OAuth Application。其他内容可以随意填写，但要确保填入正确的 callback URL（一般是评论页面对应的域名，如 https://imsun.net）。你会得到一个 client ID 和一个 client secret，这个将被用于之后的用户登录。2. 引入 Gitment将下面的代码添加到你的页面： | var gitment = new Gitment({id: '页面 ID', // 可选。默认为 location.hrefowner: '你的 GitHub ID',repo: '存储评论的 repo',oauth: {client_id: '你的 client ID',client_secret: '你的 client secret',},})gitment.render('container') || :— | 注意，上述代码引用的 Gitment 将会随着开发变动。如果你希望始终使用最新的界面与特性即可引入上述代码。如果你希望引用确定版本的 Gitment，则应该使用 npm 进行安装。 | $ npm install –save gitment || :— | 关于构造函数中的更多可用参数请查看 Gitment Options 3. 初始化评论页面发布后，你需要访问页面并使用你的 GitHub 账号登录（请确保你的账号是第二步所填 repo 的 owner），点击初始化按钮。之后其他用户即可在该页面发表评论。 自定义Gitment 很容易进行自定义，你可以写一份自定义的 CSS 或者使用一个新的主题。（主题可以改变 DOM 结构而自定义 CSS 不能）比如你可以通过自定义主题将评论框放在评论列表前面： | const myTheme = {render(state, instance) {const container = document.createElement(‘div’)container.lang = “en-US”container.className = ‘gitment-container gitment-root-container’container.appendChild(instance.renderHeader(state, instance))container.appendChild(instance.renderEditor(state, instance))container.appendChild(instance.renderComments(state, instance))container.appendChild(instance.renderFooter(state, instance))return container},}const gitment = new Gitment({// …theme: myTheme,})gitment.render(‘container’) || :— | 更多自定义内容请查看文档。 其他问题 语言问题考虑到 GitHub 本身使用英文，而本项目面向用户均为 GitHub 用户，所以作者没有提供中文支持的打算。实在有需求的可以通过自定义主题支持中文。 请勿滥用在开发这个项目时我就一直有一个疑虑：我这样做有没有滥用 GitHub？为此我仔细读了 GitHub Terms of Service中 API Terms 的部分，认为自己并没有违反协议。之后我向 GitHub 发邮件询问了这一问题。GitHub 给出的回复是： We’re pleased to see you making use of the tools and resources available on GitHub. 因此本项目的确没有违反 GitHub 使用协议。但我还是想提醒使用本项目的用户，请保持克制，切勿滥用。 样式版权在项目开源前作者曾实现了一个像素级抄袭 GitHub Issues 样式的界面，但在阅读 ToS 时发现违反了 Section F，并在和 GitHub 邮件沟通的过程中确认了这一行为是侵权的。因此便改成了现在的样式。请其他想要自定义样式的用户也留意版权问题。# Gitment写个 Web Server（一）需求 这段转自：https://imsun.net/posts/gitment-introduction/ GITALK 一个基于 Github Issue 和 Preact 开发的评论插件开始使用 GITHUB 第三方评论系统推荐2多说要下线了，国内博客圈哀鸿遍野。主流博主们还好，有原生评论系统可以用，只是社交分享的时候麻烦点。最近流行起来的静态博客的博主们就不太好了，除了一部分技术帝能够“自己动手，丰衣足食”，其他吃瓜博主要么积极地到处求攻略，要么懒得折腾干脆关了评论。Bitcron 不算静态博客，也有自己的评论系统，但处女座的我嫌评论的保存方式不太整洁，所以换博初始就打定了主意使用第三方评论。根据多年的经验和体验，我选择了算是全球最大的评论系统——Disqus。但是突然某一天我被残忍告知这货已经被中国局域网长城挡住了，当时内心是极度奔溃的。本来作为一个洋应用就没什么本地化可言，现在这种局面就更指望不上适应性的提升了，心里拔凉拔凉的。好在现在能建博客的大多也都有科学上网的实力，我也不似以前那么在意和网友的互动了。有当然好，没有也无所谓了。（悄悄说，博客是写给自己的，连评论系统都是给自己用的。有空翻翻以前的文章留个言，看看进步什么的，以前就一直在日记本上这么做。）虽然我不打算换掉 Disqus，但还是本着为人民服务的精神找了一些可以替代多说的第三方评论系统，不止静态博客，理论上来说也适用于所有独立博客系统。以下注释仅代表我个人的想法，详细信息请参照官方网站说明，根据个人需求进行选择安装使用。 Disqus1https://disqus.com 作为业界的龙头老大，相信大家都已经很熟悉了。根据 Datanyze 的统计，Disqus 在全球范围内拥有继 Facebook comments 之后排名第二的占有率，大约37%1。如果不是因为一些不可言说的原因，它的占有率可能还会更大。当然 Facebook comments 也是“受害者”之一，所以单就中国地区而言，Disqus 的占有率是最大的，超过半数2。以上这些数据都来源于国外的统计，如果算上国内的评论系统，我想多说应该是当之无愧的霸主了。数据来源 Datanyze / 制图 水八口Disqus 的好处不必多言，本身就是专业做评论系统的，功能齐全，支持 ssl，响应化设计，界面美观。我还特别喜欢它的一项多说没有的功能是，可以在文章 url 改变后迁徙评论到新文章下。比如前段时间我把间隔年日记从每日一篇改为每周一篇，统合之后便把每日一篇的评论都集中到新写的每周一篇里了。当然它也是有缺点的，我认为的最主要的缺点有两个。一是无法导出/导入自家评论。后台的导出设置只是为了备份，导出的文件没法重新导入。二是没法自定义样式。不过，最大的“缺点”应该算是国内无法使用了吧。身为资深博主，科学上网当然不在话下，但是并不能要求每个读者都有这项技能。所以这也成为了是否使用 Disqus 的最大障碍。前面说了那么多，如果用不了，都成了废话。2017年7月10日更新：我找到了两种可以科学使用 Disqus 的方法，但都不能登录 Disqus，只能使用访客留言通道。也就说你的评论并不会出现在你 Disqus 的 timeline 里。同时访客留言的网址也没法写入 Disqus 后台，但在代理状态下可以显示。综上所述，对于墙内的博主来说，代理就像 WP 的原生评论一样；而对于墙外的博主来说，原生的 Disqus 看不到访客网址，影响回访效率。即便如此，能够使用已经非常难得。 使用 Typlog 提供的 Disqus 代理服务，服务器费用 $10/年，操作简单3。无评论回复邮件提醒4。 使用 fooleap 的研究成果，免费，需要支持 PHP cURL 的虚拟主机和一颗不怕折腾的心。有评论回复邮件提醒5。 HyperComments1https://www.hypercomments.com 来自俄罗斯的评论系统，使用谷歌账号注册。免费用户支持一个网站和一个管理员，对于个人博客来说足够用了。个人用户$24/年，支持一个网站和三个管理员。14天免费试用。更多请参考官网价格页面。功能暂且不说，光看这清爽的界面，作为一只颜狗，我是服气的。HyperComments 颜值在线除了耀眼的颜值，它的功能和 Disqus 大同小异，有些高阶功能需要收费。另外身在俄罗斯的小伙伴可以以短信形式收到评论回复，听着就很高大上。最后说说大家最关心的问题，现阶段国内可以使用，但是，必须使用谷歌账号才能登陆留言，所以有点悬。谢谢小F的更正：免费版后台可以设置支持游客评论。 来必力1https://livere.com 来自韩国，使用邮箱注册。不得不承认颜值也很高，准确地说应该是萌。中国地区的本地化做得很不错，甚至可以用微信登陆留言，简直热泪盈眶。就这点来看，是多说最好的替代品。同时支持的登陆方式还有：新浪微博、QQ、百度、人人、豆瓣。顺带提一下在韩文和英文模式下的登陆方式：来必力、Kakao talk、Naver、Facebook、Twitter、Instagram、Line、GitHub、Tistory、Google+、Linkedin。来必力支持国内多家社交平台登陆国内可以使用。修改评论框样式是收费项目。修改评论只有一次机会。理论上来说注册一个来必力账号，绑定各个社交网站以后，之后用社交网站登陆留言也会同步到同一个账号里6。可以设置评论分享到社交网站。点击头像会像 Disqus 一样显示侧边栏，可以看以往评论。 IntenseDebate1https://www.intensedebate.com 是 WordPress 所在的 Automattic 旗下的产品。优点是支持游客评论。国内可以用，但听说加载略慢。曾经是 Disqus 强有力的对手。既然和 WordPress 同一东家，想必反垃圾邮件的功能应该做得不错。如果有 WordPress 账户就不需要额外注册，但很多用 WP 的都可以使用原生评论，这真是个奇妙的悖论。IntenseDebate 可以以游客身份留言（上图中未开启此项功能） 畅言1http://changyan.kuaizhan.com 搜狐旗下，大牌加持，安装需要备案号。界面还算清爽，不满意的话可以自定义样式。畅言可以自定义 CSS 网易云跟帖（已停止服务）1https://gentie.163.com 感谢小F的提醒：此产品将于2017年8月1日停止服务7。网易旗下，大牌加持，支持网易账号、新浪微博和 QQ 登陆。界面有点尴尬，因为会把地址写出来，比如北京市网友，有种当年各大门户网站下的留言既视感。对于小清新的个人博客来说可能是个不能接受的大坑。网易云跟帖有着网易一贯的“风味” 友言（已停止服务）1http://www.uyan.cc 感谢荏苒的提醒，友言官网已经打不开了，谷歌后得知2017年就不能使用了。可能是最像多说的评论系统。有评论统计、最新评论插件可以使用。JiaThis（加网）旗下产品。它家有加网的分享按钮（Share this），友荐的猜你喜欢（Related posts），加上友言的评论系统，博客三件套齐活儿了。支持 QQ、新浪微博、人人、开心网账号登陆。界面很像 Disqus。友言的家族成员还有加网和友荐 Remarkbox1https://www.remarkbox.com 一位外国友人的个人项目，主打就是“Disqus 的替代品”。因为从 WP 搬到静态博客，寻找第三方评论系统时不喜欢评论里有广告，所以就自己写了一个。好像还是 beta 版，还在增加功能。在测试评论里看到了代码高亮，果然是极客的世界。界面简洁。由于是个人项目，故对未来的发展持观望态度。Remarkbox 的未来会如何？ Vuukle1http://vuukle.com 来自印度。后台感觉跟 WordPress 比较像，还能看当前在线人数。我注册了一个账号试安装了一下没成功。（所以给我留下了不靠谱的感觉。也可能是我技术不够。）界面设计不错，支持 Google+ 和 Facebook 账号登陆，也可以以游客身份留言。Vuukle 支持游客评论 Muut1https://muut.com 免费计划竟然包含了无限流量、多语言、无广告和样式修改？！我想要欢呼！更惊喜的是评论可以用 Markdown，还能 ctrl+enter 发布。支持 Facebook、Twitter、Google+、Yahoo、Windows Live、Linkedin、GitHub、Reddit、Yandex、Disqus 账号登陆。注册可以用邮箱。Demo 页面有很多格式，NY Times 样式的侧边栏评论令人惊艳。私聊功能需要付费。输入评论时可以实时预览。Muut 令人惊艳 Vicomi1http://www.vicomi.com 免费用户支持一个域名。特点是可以选择心情表情。也因此界面有些凌乱。Vicomi 是评论界的表情帝 Civil Comments1https://www.getcivil.com/comments 邮箱注册，社交网站支持 Facebook 和 Twitter。界面友好干净，无功无过。Civil 旗下还有 Civil Live 和 Civil Reviews。专注 UGC (User Generated Content) 的样子。Civil Comments 使用手册（英文） Widget Pack Rating &amp; Comment System1https://widgetpack.com/comment-system 跟 Civil Comments 类似，除了评论系统，还有 Reviews、Rating 和 Google Reviews。免费用户支持一个域名和一位管理员。使用邮箱注册。留言可以使用以下社交网站登陆：Facebook、Twitter、Google+、Linkedin、Instagram、SoundCloud、Tumblr、ВКонтакте (VK)、OK、Мой Мир、Yahoo、LiveJournal、Яндекс。从这些网站中我看出来了，这也是一家来自俄罗斯的产品。评论框内嵌星级评分，据官方称，评分会显示在谷歌的搜索结果中。支持 ssl。Widget Pack Rating &amp; Comment System Facebook comments1https://developers.facebook.com/docs/plugins/comments 如果你的朋友都在使用 Facebook，这绝对是不二选择。就好比新浪微博出了个评论系统，亲戚朋友都能方便登陆留言，评论可以点赞，还能分享到微博让更多人看到，一气呵成。当年多说能够保持绝对地位的占有率，也是靠了支持国内各个社交平台登陆的力量。 Livefyre（已停止服务）被 Adobe 收购以后就不再是独立的评论系统了。它成为 Adobe Experience Manager 的一部分，简单说来就像是简书的评论部分一样8。因为在 Datanyze 的图表上看见它排名第四，也在谷歌后找到官方的安装网站，顺利取得代码，于是我原以为它还能使用。但在测试时看到了以下信息，于是我彻底死心了。竟然也是最近的事。 Notice: Livefyre Community Comments will become read-only starting March 9, 2017 and no longer available as of April 6, 2017. To export your comments, please visit, www.livefyre.com/installation/site/export/. For more information, please see https://docs.adobe.com/docs/en/aem/livefyre-announcements.html. 面对曾经的用户，Adobe 给出了两个备用选择：Disqus 和一个 WordPress 插件。这个插件可以在 Google+、Facebook comment、Disqus 和 WordPress 原生评论中切换，对于想兼顾国内外朋友的博主来说应该是个不错的选择。 Google+ Comments（非官方）高手在民间9。 HashOver1http://tildehash.com/?page=hashover 技术小白表示看不太懂，大家可以去官网围观一下。 Isso1https://posativ.org/isso 也是技术向的，我等小白就不妄加评论了。 Staticman1https://staticman.net 顾名思义，静态评论，逼格太高了。最适合托管在 GitHub Pages 上的 Jekyll 博客。对于没有 Git 经验的我，安装手册看起来太难了。 Gitment1https://github.com/imsun/gitment 感谢Fooleap的分享，官网给出的说明是： Gitment 是作者实现的一款基于 GitHub Issues 的评论系统。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown / GFM 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。 目测非常适合 GitHub 重度用户，并且博客受众也是 GitHub 用户的人。 Gitalk1https://gitalk.github.io 感谢Liu Joey的分享，官方 GitHub 页面上对此的介绍是： Gitalk 是一个基于 Github Issue 和 Preact 开发的评论插件。 Blog Comments21https://github.com/revir/nodebb-plugin-blog-comments2 从 NodeBB 官方博客的评论插件上修改而来，支持静态博客。 Valine1https://github.com/xCss/Valine 感谢林小沐的分享，官方中文教程声称这是「一款基于Leancloud的极简风评论系统」。另有进化版可供选择。 Self-host comments in Jekyll1https://flinhong.com/2017/03/25/self-host-comments-in-jekyll-using-firebase-database 感谢flinhong分享的造轮子方法，按照大神的原话是： 感兴趣的同学也来自己动手做一个，很适合静态博客。唯一的缺点就是用的 Google 的服务，需要那啥，大家懂的。 Commento1https://gitlab.com/commento/commento 感谢fc4soda的推荐： 支持 markdown 支持匿名、层级回复 支持锁定主题 免费 go写的不需要安装依赖，还有docker版 目前作者在考虑多国语言化 缺点：- 需要自己搭建服务- 目前手动审核评论似乎只能在主帖下面，无法在管理后台统一管理 后记这篇文章写了整整一天半，信息量之大是我最初没有想到的。因为找到的很多都是收费的，所以看过的评论系统可能有现在总结出来的两倍，工程量非常浩大，好在我坚持下来了。好久没有如此专注过一件事，写完的时候心里美滋滋的。在查找 Disqus 替代品的时候发现很多国外的评论系统也消失了不少，看来当初选择了 Disqus 真是押对了宝。对于第三方评论系统来说，盈利模式非常重要。免费的评论系统一般都在说 UGC，也就是用户产生内容。如果你的网站有很多读者，一起讨论可以创造出更多的价值。简单说起来就是大家一起赚钱，或者类似粉丝经济。所以我找到了很多只面对企业客户的评论系统就一点也不意外了，毕竟普通的个人身上很难产生赢利点。而幸存下来的免费评论系统，比如 Disqus，最终也没能逃脱在评论里插入广告的魔咒，因此得罪了不少用户，即使广告费有分成。另外很多社交网络都有自己的评论系统，反正都得注册，评论也不需要门槛。这对第三方评论系统的生存也是一个冲击。在搜集资料的过程中，我还发现了一个特别的现象，就是很多收费的评论系统都有免费的 WordPress 插件。所以好好珍惜手中的 WordPress 吧。最后，还是得安利一下我的“大房东”——Bitcron。论专注写作、简洁、本地化、先进技术，多年在博客圈打拼的我觉得它都是第一名。一站式解决所有问题，比当年惊艳我们的 FarBox 走得更远了。现在它不仅仅是一个博客，甚至可以变身成任何你想要的东西，这是它的野心，也给了我们信心。当然，评论框很美是有加分的。如果你有什么更好的推荐欢迎留言告诉我，我会补充在这篇文章里。 参考网站 再见，那些年我们一起用过的多说 - 荏苒.me Are there any free alternatives to Disqus? - Quora Disqus Alternatives - tips &amp; tricks - Hugo Discussion Alternative to Disqus Needed More Than Ever - support - Hugo Discussion Hashover-PHP开源评论系统 - Orro.ro Disqus Alternatives and Similar Software - AlternativeTo.net Improving Static Comments with Jekyll &amp; Staticman | Made Mistakes 如何评价“多说”即将关闭？有什么替代方案？ - 知乎]]></content>
  </entry>
  <entry>
    <title><![CDATA[doc命令]]></title>
    <url>%2F2019%2F06%2F19%2Fyuque%2Fdoc%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[mac 杀掉占用某个端口的进程两个小命令: lsof -i :端口 kill -9 进程ID]]></content>
  </entry>
  <entry>
    <title><![CDATA[go语言]]></title>
    <url>%2F2019%2F06%2F19%2Fyuque%2Fgo%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[Go 语言中文开源图书、资料或文档–Go的开源书籍 破解方法：https://www.cnblogs.com/pig66/p/10420947.html软件安装后的路径：/Applications/GoLand.app/Contents/bin破解包：jetbrains-agent.jar GoLand2019 激活码 此教程对最新2019版本GoLand有效！！！ 本教程对windows、mac、ubuntu全系统可用 此教程实时更新，请放心使用；如果有新版本出现猪哥都会第一时间尝试激活； goland官网下载地址：http://www.jetbrains.com/goland/download/ 汉化教程 激活出问题可扫描下方二维码，加入激活群寻求帮助！两种激活方式 永久激活：推荐优先使用，永久有效 有效期激活：如果你实在激活不了又着急使用，这是备选激活方案，简单快捷一、永久激活1.下载新版破解补丁点击链接 https://pan.baidu.com/s/16ALpz_BCXjsRkpS_PtD23A 下载补丁文件 jetbrains-agent.jar 并将它放置到 goland安装目录的\bin目录下（位置可随意，放这里是怕误操作删除了破解文件）。2.进入项目界面如果你之前已经使用有效期激活过可跳过此步骤，如果你是刚下载的GoLand，则需要点击激活窗口的“Evaluate for free”免费试用，然后再创建一个空项目，这样就可以进入到GoLand的工作页面3.修改配置文件进入到项目界面后，点击GoLand最上面的菜单栏中的 “Help” -&gt; “Edit Custom VM Options …”，如果提示是否要创建文件，请点”Yes”。在打开的vmoptions编辑窗口末行添加：-javaagent:你goland的安装目录\jetbrains-agent.jar请仔细检查补丁路径是否正确，如果错误则会出现GoLand打不开的情况，这时候可以删除用户配置目录下的goland文件夹:windwos：C:\Users\用户名&lt;br /&gt;macos：/Library/Preferences/ubuntu：/.修改完配置文件之后重启GoLand修改完配置文件之后重启GoLand修改完配置文件之后重启GoLand4.输入激活码重启GoLand之后，点击菜单栏中的 “Help” -&gt; “Register …”，这里有两种激活方式：一、选择最后一种License server激活方式，地址填入：http://jetbrains-license-server（应该会自动填上），或者点击按钮：”Discover Server”来自动填充地址，完成激活二、如果服务器激活方式无法激活，还可以选择Activation code方式激活，复制下面激活码即可1D00F1BDTGF-eyJsaWNlbnNlSWQiOiJEMDBGMUJEVEdGIiwibGljZW5zZWVOYW1lIjoiaHR0cHM6Ly96aGlsZS5pbyIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiJVbmxpbWl0ZWQgbGljZW5zZSB0aWxsIGVuZCBvZiB0aGUgY2VudHVyeS4iLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiV1MiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSRCIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJDIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJEQiIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJNIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiRE0iLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJBQyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRQTiIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkdPIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUFMiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlBDIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlNVIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In1dLCJoYXNoIjoiODkwNzA3MC8wIiwiZ3JhY2VQZXJpb2REYXlzIjowLCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-3OPFIX9/KSL76ctAKOwpBPCCAfUhUbucdNbtqMaTqRryvKEvrFqCKncE0eMHA2YkrcP2CtV9LKjlIXhJMqp0N821Qv1AhuIJrDMBubqiEtiqnGkcGV35DF0GzyUQaUdN6fTbZna05riHzR6yzgEzo9R3RIzCTDMQdB/0EojWM0nCBkPsLdncZeDv3+Y+VA8ZH3/BBvzwR1e0gWsT3mfT9tIvwxPuEhNrQFNOP1PZOjC8nX9h/J7ag5X3JQL1CQVi4TnEipdy0fxKbDPKTloM3Y/bA23uaW+Q/JQFBRKRR0q3FYJ1DQuSc7YmeJ7Q2IHq7u5QYz8jPZJtP6PKs6g/tQ==-MIIECDCCAfCgAwIBAgIJAI5/xwNtz47cMA0GCSqGSIb3DQEBCwUAMBgxFjAUBgNVBAMMDUpldFByb2ZpbGUgQ0EwIBcNMTgwODIzMDcwNDA3WhgPMjExODA3MzAwNzA0MDdaMBExDzANBgNVBAMMBnByb2QzeTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAOZ3WopNRg9J8k3apGYFEUGRlvkRsQnQSEz1yMKY4YWg9ElxmuF0mQRAaIj3WOl1eqTn1CXsn4vXV7GODJk9A/rCqEk960sPesWn/RVz7zo5+KazE3Y9yYtwskKxlnkFNp82Kha6dUGDSwG2lYh0Sria2ByOhgr6gmyXtC0PKqlIlTAPcBvz0MEnKTZkxfSqdiHo/meTlMRd9885vr4P52Fd9Ryxe3yVAKZSP9ZzPmRvCvgF1oGCgobZJ5d7FvTwkGt2t4pjy/RlU6FDcXNMHLk4pfJqr3lnEkAh2MbCGlGo1i6Rc6DtgISuJn2AUkrQKhI6F0U7o9e5qPEOjNkhznMCAwEAAaNaMFgwCQYDVR0TBAIwADALBgNVHQ8EBAMCBaAwHQYDVR0OBBYEFJDgSMx4XrLktYOG827wP7VULTnJMB8GA1UdIwQYMBaAFDAS51akWaJlzxC2x4yP3iAYbqtxMA0GCSqGSIb3DQEBCwUAA4ICAQBxRyfCpL7q2VurGfh9XqaC4GsGp6ut3l/rOEyc6DP148A69DRmZ7saqfZW87DcLkmcynPhyBOxdcGwtwKlR9E/+X923JeL6VPQCTY5WyJKib36vQCnoC4ELTnw1yc51v2j+MaZXjrlzBIcCUocWK14WS4iBycUwLuMszz6rJ8xluuYDKDeNcS/AjQf+yTUfDXjktHLgcE27sSEQUQ+7bpbKHkJ5xBvaupJEPX+ndj7V2eD+/sO03jgnsWVa2nky7yDXX/5KCqzL5kAA1n2t2dWSJXxpac8O2bPyRhk6dUSwzNr+IjCjHqUKIouB0nosi85Q5MaIE0pwOOSggnawpnjmL3qDnsS/n7NUcX/mF4eiNQ8cMJmKIgfS6rntKuQY2zSod+4+G0AFbiihVTnKsRf7CiJa/VniZdaGdbclT8KzRnNKJ1TrPO8rVPjg+SpvqTq75xynS08/OXCpoJ3aVeBWZJYJmheHhvJw2RiNW2P2GSIw+m6HIIsthUtvvHqdKpIaThFHAOKmw0LpPO7uGs/z/Q3un7+lqSlW7akUoSCHdiAJ4wWv+qFEgE4mq8bKtHoa9yy6FZBoORbbRTj8WkS+UvCLN5p7kZenmKYnWCzBf02O1ULpMsR5WvKCGCekSwWf3lAF9lYTL12JaFTw9iH1nSkyvcu7AoXlWI50hOhmA== 5.查看有效期当你激活完毕后，GoLand右下角会有个Registration小长条提示框，大致的内容为：You copy is Licensed to XXX意思就会告诉你：兄弟，你已经激活成功了，激活码的许可来源是：XXX。查看有效期的步骤为点击：Help-&gt;About这里可以看到你的GoLand的版本号、许可来源、有效期、以及一些环境服务器激活是没有期限的，即为永久有效激活码激活的有效期到2089年的 二、有效期激活如果使用有效期出现问题可先加激活群寻求帮助，还可以尝试使用有效期激活！ 1.修改hosts文件将0.0.0.0 account.jetbrains.com和0.0.0.0 www.jetbrains.com添加到hosts文件最后，注意hosts文件无后缀，如果遇到无法修改或权限问题，可以采用覆盖的方法去替换hosts文件修改后请检查hosts文件是否修改，激活码无法激活的原因99.99%是因为hosts没有修改正确Windows系统hosts文件路径为：c:\windows\system32\drivers\etcLinux系统hosts文件路径为：/etc 2.复制激活码打开PyCharm选择Activation code激活，然后复制下面的激活码点击激活。此激活码有效期为2020-03-11，大家可以关注微信公众号：裸睡的猪 或扫描下方二维码，在过期之前我会在公众号中推送新的激活码哦 156ZS5PQ1RF-eyJsaWNlbnNlSWQiOiI1NlpTNVBRMVJGIiwibGljZW5zZWVOYW1lIjoi5q2j54mI5o6I5p2DIC4iLCJhc3NpZ25lZU5hbWUiOiIiLCJhc3NpZ25lZUVtYWlsIjoiIiwibGljZW5zZVJlc3RyaWN0aW9uIjoiRm9yIGVkdWNhdGlvbmFsIHVzZSBvbmx5IiwiY2hlY2tDb25jdXJyZW50VXNlIjpmYWxzZSwicHJvZHVjdHMiOlt7ImNvZGUiOiJJSSIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9LHsiY29kZSI6IkFDIiwicGFpZFVwVG8iOiIyMDIwLTAzLTEwIn0seyJjb2RlIjoiRFBOIiwicGFpZFVwVG8iOiIyMDIwLTAzLTEwIn0seyJjb2RlIjoiUFMiLCJwYWlkVXBUbyI6IjIwMjAtMDMtMTAifSx7ImNvZGUiOiJHTyIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9LHsiY29kZSI6IkRNIiwicGFpZFVwVG8iOiIyMDIwLTAzLTEwIn0seyJjb2RlIjoiQ0wiLCJwYWlkVXBUbyI6IjIwMjAtMDMtMTAifSx7ImNvZGUiOiJSUzAiLCJwYWlkVXBUbyI6IjIwMjAtMDMtMTAifSx7ImNvZGUiOiJSQyIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9LHsiY29kZSI6IlJEIiwicGFpZFVwVG8iOiIyMDIwLTAzLTEwIn0seyJjb2RlIjoiUEMiLCJwYWlkVXBUbyI6IjIwMjAtMDMtMTAifSx7ImNvZGUiOiJSTSIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9LHsiY29kZSI6IldTIiwicGFpZFVwVG8iOiIyMDIwLTAzLTEwIn0seyJjb2RlIjoiREIiLCJwYWlkVXBUbyI6IjIwMjAtMDMtMTAifSx7ImNvZGUiOiJEQyIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9LHsiY29kZSI6IlJTVSIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9XSwiaGFzaCI6IjEyMjkxNDk4LzAiLCJncmFjZVBlcmlvZERheXMiOjAsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-SYSsDcgL1WJmHnsiGaHUWbaZLPIe2oI3QiIneDtaIbh/SZOqu63G7RGudSjf3ssPb1zxroMti/bK9II1ugHz/nTjw31Uah7D0HqeaCO7Zc0q9BeHysiWmBZ+8bABs5vr25GgIa5pO7CJhL7RitXQbWpAajrMBAeZ2En3wCgNwT6D6hNmiMlhXsWgwkw2OKnyHZ2dl8yEL+oV5SW14t7bdjYGKQrYjSd4+2zc4FnaX88yLnGNO9B3U6G+BuM37pxS5MjHrkHqMTK8W3I66mIj6IB6dYXD5nvKKO1OZREBAr6LV0BqRYSbuJKFhZ8nd6YDG20GvW6leimv0rHVBFmA0w==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQAF8uc+YJOHHwOFcPzmbjcxNDuGoOUIP+2h1R75Lecswb7ru2LWWSUMtXVKQzChLNPn/72W0k+oI056tgiwuG7M49LXp4zQVlQnFmWU1wwGvVhq5R63Rpjx1zjGUhcXgayu7+9zMUW596Lbomsg8qVve6euqsrFicYkIIuUu4zYPndJwfe0YkS5nY72SHnNdbPhEnN8wcB2Kz+OIG0lih3yz5EqFhld03bGp222ZQCIghCTVL6QBNadGsiN/lWLl4JdR3lJkZzlpFdiHijoVRdWeSWqM4y0t23c92HXKrgppoSV18XMxrWVdoSM3nuMHwxGhFyde05OdDtLpCv+jlWf5REAHHA201pAU6bJSZINyHDUTB+Beo28rRXSwSh3OUIvYwKNVeoBY+KwOJ7WnuTCUq1meE6GkKc4D/cXmgpOyW/1SmBz3XjVIi/zprZ0zf3qH5mkphtg6ksjKgKjmx1cXfZAAX6wcDBNaCL+Ortep1Dh8xDUbqbBVNBL4jbiL3i3xsfNiyJgaZ5sX7i8tmStEpLbPwvHcByuf59qJhV/bZOl8KqJBETCDJcY6O2aqhTUy+9x93ThKs1GKrRPePrWPluud7ttlgtRveit/pcBrnQcXOl1rHq7ByB8CFAxNotRUYL9IF5n3wJOgkPojMy6jetQA5Ogc8Sm7RG6vg1yow== 转自：https://www.cnblogs.com/pig66/p/10420947.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[程序员都在 GitHub 上开源过哪些高颜值的 Markdown 客户端]]></title>
    <url>%2F2019%2F06%2F19%2Fyuque%2F%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E5%9C%A8%20GitHub%20%E4%B8%8A%E5%BC%80%E6%BA%90%E8%BF%87%E5%93%AA%E4%BA%9B%E9%AB%98%E9%A2%9C%E5%80%BC%E7%9A%84%20Markdown%20%E5%AE%A2%E6%88%B7%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[2004 年，来自美国宾夕凡尼亚州的作家 John Gruber 发明了 Markdown，让人们可以通过更加易读易写的纯文本格式来进行写作，并可以很方便的转为 HTML 或 XHTML 等文档。Markdown 自推出之后受到了许多程序员的追捧，目前基本所有主流技术社区都支持使用 Markdown 来进行创作。在 GitHub 上，也诞生了许多优秀的 Markdown 客户端，我看了二十多个项目，简单筛选过滤后，最终挑选了这 5 个高颜值、用户体验佳的 Markdown 编辑器分享给你。 Pine 优雅清新的编辑器适用平台：macOS这是一款基于 Swift 4.2 编写的 Markdown 编辑器，拥有主题定制、LaTeX 编写、自动补全、自动保存、版本控制、Touch Bar 支持等功能。lukakerr/Pine暗黑模式的主题看着特别酷炫：通过其设置界面，你可以很方便的挑选自己喜欢的文本字体，界面主题：目前还有以下几项特性仍在开发中，感兴趣的同学可以保持关注： 支持编辑 CSS 文件来定制 Markdown 预览效果 优化侧边栏 文件夹监听同步 上下文菜单中加入更多操作Gridea 无缝对接静态博客的编辑器适用平台：macOS、Windows这个是最近刚在微博上推荐的一个项目，作者将其产品定位为一个静态的博客写作客户端，也即是说，你可以在客户端上面写作，然后顺便将文章发布到静态博客上。getgridea/gridea相对于其它普通的 Markdown 编辑器，它有着以下特色： 对接了 GitHub、Coding Pages 的托管服务 内置 Gitalk 和 DisqusJS 两个评论系统 支持使用 OneDrive、Dropbox 等工具进行文章同步 支持外链的封面图 从上面列举出来的几项特性可以看到，Gridea 相对于普通的 Markdown 编辑器更加强大，如果你希望写作编辑与文章同步能无缝进行，不妨试下这个编辑器。另外作者还表示，Linux 版本正在开发中，你可以保持持续关注。 Notable 无限标签编辑器适用平台：macOS、Windows、Linux这是一款基于 AGPL 协议开源的 Markdown 编辑器，由于其界面清新、代码开源而受到不少程序员喜爱。notable/notable主要有着以下几项基础功能： 无限标签嵌套 可导入印象笔记 文章分类 模糊搜索 语法高亮 多文章编辑 多文章搜索替换 支持主流桌面平台 之前我曾写过一篇完整文章介绍了该项目，在此便不多做赘述，感兴趣的同学可看下下面这篇文章。分享一款高颜值的、代码完全开源的 Markdown 编辑器 Mark Text 多模式形态编辑器适用平台：macOS、Windows、Linux这是一款基于 MIT 协议开源的 Markdown 编辑器，支持 WYSIWYG（所见即所得）的编辑方式，致力于给你提供一个专注的写作环境。marktext/marktext该编辑器还内置了插件功能，你可以为其添加 KaTeX 数学公式、emoji 表情等插件扩展。在你编写完成后，还可以很方便的将 Markdown 导出为 HTML 或 PDF 文件。支持的主题也非常丰富多样：最值得一提的是，该编辑器提供了源码模式、打字机模式、专注模式等 3 种写作模式。源代码模式：专注模式：你可以根据自己需求来选择合适的写作模式。 MacDown 资深老牌编辑器支持平台：macOS作为一款老牌的 Markdown 编辑器，相信很多人都听过 MacDown，该编辑器的灵感来源于另一款 Markdown 编辑器 - Mou。这款编辑器相对来说年代较为久远，但也比较稳定，如果你对稳定性的追求比较高，可以体验下这块编辑器。MacDownApp/macdown 我用哪款编辑器？除了 GitHub 上一些开源的 Markdown 编辑器之外，还有一些免费但不开源的编辑器，个人常用的一款是 Typora。现在你正在查看的这篇文章，就是在 Typora 上完成排版编辑的。我比较喜欢它的原因是因为他可以自定义主题样式，编辑所见即所得，用完即走，方便快捷。对代码开源没啥要求的同学也可以体验下。a markdown editor, markdown reader.你平时主要用哪款 Markdown 编辑器呢？欢迎在评论区留言与我们分享。推荐阅读：华山论剑，谈谈 GitHub 上那几个开源的前端编辑器完美融合 Git 的笔记软件，了解一下？如何知道你的个人隐私是否被泄露？转自：https://zhuanlan.zhihu.com/p/62776921]]></content>
  </entry>
  <entry>
    <title><![CDATA[那些让人用上就戒不掉的Chrome扩展]]></title>
    <url>%2F2019%2F06%2F19%2Fyuque%2F%E9%82%A3%E4%BA%9B%E8%AE%A9%E4%BA%BA%E7%94%A8%E4%B8%8A%E5%B0%B1%E6%88%92%E4%B8%8D%E6%8E%89%E7%9A%84Chrome%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[Chrome虽然已成为国内常用浏览器之一，但像父母、长辈、女朋友等这类小白用户还是不少。所以，今天我们就来盘点一下Chrome商店里那些让人用上就戒不掉的扩展，大部分都是新手小白也能够一秒上手的工具。虽然是入门级扩展，但用户基数都高达数十万甚至百万，它们的功能极其丰富，能大幅提升上网体验，往往会让小白用户初尝便上瘾，从此再也离不开…… 1. 入门新标签页——Infinity ProInfinity新标签页算是早被业内夸过无数次的国产插件了，分为基础版和Pro版，两个版本的下载量都很高。这是一款百万用户选择的新标签页，能够自由添加网站图标，还有丰富的云端高清壁纸，支持快速访问书签、天气、笔记、待办事项、扩展管理与历史记录等（据了解开发者已申请专利）。Infinity的壁纸是真的非常好看了，右键空白处就能直接下载下来。并且，Infinity Pro版在今年又新增了文件夹功能，一个新标签页能容纳更多的常用网站，并由此实现了分类功能。开发者处理反馈的速度也很快，两个版本这么多年都保持完全免费，非常良心了，是新手和老用户都喜爱并推崇的Chrome工具之一。 2. 广告屏蔽——Adblock、Adblock Plus屏蔽广告的插件无疑是受用面最广的，因为它对于所有使用者来说，用户体验的提升是最大的。毕竟在此之前，大家都饱受各个网站的侧边广告和弹出窗口的困扰，开启广告屏蔽后清静多了。Adblock和Adblock Plus在Chrome商店里都没有太大争议，二者选一就足够了。 3. 视频广告屏蔽——广告终结者如今各个视频网站的广告都越来越丧心病狂，动辄90秒的长度简直让人生无可恋。广告终结者不仅能清除网页上浮动广告，恶意弹窗等，还能屏蔽视频广告。因为是国产的扩展，所以在国内大部分视频平台上都能使用。 4. 鼠标悬停预览图片——Imagus将鼠标悬停在链接或缩略图上，就能够直接在当前页面弹出高清大图、HTML5 视频/音频等内容。对于微博、淘宝等用户来说，在浏览多图和图片版的长微博时，Imagus是非常方便的。 5.图片批量下载——Image Downloader快速识别当前网页上的所有图片，支持一键批量下载，并且能够根据像素、尺寸等筛选图片范围。 6.视频下载插件——Video Downloader professional视频下载是很多人的需求，而在大部分视频网站上，要做到这一点都必须经历一个繁琐的过程，比如下载客户端等等。Video Downloader professional则可以直接检测页面中的所有视频文件，并提供一键下载，对新手来说也非常友好。 7.浏览器清理大师——Clean Master一键清理浏览器缓存和垃圾、保护隐私，使浏览器更快更高效，支持按时间段清理：- 清理浏览器缓存，cookies，网站存储和其他垃圾。- 清理密码，使网站不会自动登录用户的个人帐户。- 清理浏览器历史记录，其他人永远不会知道用户的浏览过的网站。- 清理所有个人信息，用户的隐私将受到保护。 无法访问chrome应用商店的朋友，可在扩展迷网站下载安装。Download Chrome Extensions From Here!extfans.com 转自：https://zhuanlan.zhihu.com/p/47642312]]></content>
  </entry>
  <entry>
    <title><![CDATA[这 10 款堪称神器的插件，让你的 Chrome 成为最好用的浏览器]]></title>
    <url>%2F2019%2F06%2F19%2Fyuque%2F%E8%BF%99%2010%20%E6%AC%BE%E5%A0%AA%E7%A7%B0%E7%A5%9E%E5%99%A8%E7%9A%84%E6%8F%92%E4%BB%B6%EF%BC%8C%E8%AE%A9%E4%BD%A0%E7%9A%84%20Chrome%20%E6%88%90%E4%B8%BA%E6%9C%80%E5%A5%BD%E7%94%A8%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%2F</url>
    <content type="text"><![CDATA[距离我 上次 推荐 Chrome 扩展已经过去了近 4 个月时间，Chrome 应用商店里又涌现出了一大批颇有潜力的实力选手。本文我将介绍 10 款近期上架的 Chrome 新扩展，从标签页到网站内容抓取再到隐私保护，它们总有一款能满足你的口味。 QlearlyQlearly 是一款有些特殊的 Chrome 新标签页扩展，你可以用它一键保存当前打开的标签页，将自己的收藏夹、喜欢的网站、暂存备用的标签页等分组收纳，并在需要时快速开启。此外，你还可以与他人协作，并分享自己的标签页组，提高自己的工作效率。你可以在 Chrome 网上应用店 免费获取 Qlearly。 Spider工作中，你可能会有批量抓取网站内容的需求：淘宝上的商品介绍、网站上的新闻标题、表格中的行列数据……如果只是单纯的复制粘贴，之后还要费心整理，想要写个爬虫又考验编程水平。这时，不妨试试 Spider，它可以一键抓取网页上的结构化数据，并导出为 JSON 和 CSV 文件，轻松高效。你可以在 Chrome 网上应用店 免费获取 Spider。 Repl.itRepl.it 是一款允许你浏览器上编程的云端 IDE，支持编译并运行包括 C、Python、JavaScript、Ruby 等在内的超过 50 种语言，无需下载，即开即用。而其第三方 Chrome 扩展，则给任意网页中的代码片段增加了一键运行按钮，省去复制到本地编译的流程。你可以在 Chrome 网上应用店 免费获取 Repl.it。 Password Checkup不论你是自己发明了一套密码策略，还是用 1Password 等应用随机生成密码，都无法避免网站后台被拖库造成的安全隐患。为了最大限度地减少这一风险，Google 于近期推出了 Password Checkup 扩展，当检测到你正在使用的用户名和密码存在于 40 亿条泄露数据库内时，自动弹出提醒，保护个人隐私。你可以在 Chrome 网上应用店 免费获取 Password Checkup。 Web Activities时间线是 Windows 10 春季创意者更新带来的最重要变化之一，允许你在一处查看所有历史活动记录，如浏览器访问过的网页、使用过的文件等。而微软近期推出的 Web Activities 扩展将这一特性带到了 Chrome，并支持多设备同步浏览记录，体验近似原生。你可以在 Chrome 网上应用店 免费获取 Web Activities。 划词小窗搜索划词翻译扩展我们见得多了，例如我此前推荐过的 沙拉查词 和 达达划词翻译 都可以在选中单词后通过悬浮小窗查询释义。而划词小窗搜索的泛用性更广一些，可以调用 Google、百度或 Bing 通过小窗搜索选中的文本，无需离开当前页面。你可以在 Chrome 网上应用店 和 GitHub 免费获取划词小窗搜索。 Simplify Gmail为了完成 KPI，Google 大刀部把广受欢迎的 Inbox 砍掉了，如果你曾是 Inbox 忠实用户，可能会对陈旧的 Gmail 界面感到不适应。为了拯救你的收件箱，前 Inbox 设计师 Michael Leggett 开发了 Simplify Gmail 扩展，重新设计了按钮和元素的摆放位置，隐藏了侧边栏，让界面更加清爽干净。你可以在 Chrome 网上应用店 免费获取 Simplify Gmail。 Google Results Previewer使用 Google 搜索时，你可能需要同时浏览对比多个结果。这时，按首页排序一路点下去就未免过于低效。而 Google Results Previewer 就可以在当前页面小窗加载鼠标悬停的链接，并支持进一步交互，提高信息检索效率。需要注意的是，由于 Google Results Previewer 无法运行 JavaScript，部分网站可能会出现加载异常或失败等情况，仍待改进。你可以在 Chrome 网上应用店 免费获取 Google Results Previewer。 NoScriptNoScript 是 Firefox 上知名的隐私保护扩展，近期移植到了 Chrome 上，作用是禁止加载 JavaScript、Flash、Silverlight 等可能收集你个人信息的脚本，让你的浏览更加安全。不过，由于 JavaScript 已然成为了网页标配，禁用后会导致大多数网站无法正常访问，需要一段时间的白名单调教后才能正常使用。你可以在 Chrome 网上应用店 免费获取 NoScript。 简易扩展简易扩展的名字相当实诚，但功能性却毫不逊色。它可以帮助你快速切换用户代理、管理多个 Cookies、监听网络请求、改写静态和动态网址等，可谓前端开发者必备。你可以在 Chrome 网上应用店 免费获取简易扩展。关联阅读：读文章、剪藏网页、新标签页增强…… 这 10 个扩展让你的 Chrome 更好用转自：https://zhuanlan.zhihu.com/p/65606735]]></content>
  </entry>
  <entry>
    <title><![CDATA[推荐几个超好用的Chrome插件]]></title>
    <url>%2F2019%2F06%2F19%2Fyuque%2F%E6%8E%A8%E8%8D%90%E5%87%A0%E4%B8%AA%E8%B6%85%E5%A5%BD%E7%94%A8%E7%9A%84Chrome%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[远方 New Tab每天打开新页面都是一段不期而遇的旅行简单的说，每次打开一个新的标签页，都会有一张看了心情很好的风景图~ uBlock Origin比较好用的清除广告的插件，图标也很可爱记得要下origin版本哦另外一个同名的是商业公司版本，害怕会加什么蜜汁优化来看一下效果，对付广告贼多的csdn The Great Suspender 自动休眠你不用的标签页，节省内存再也不用怕浏览器后台偷偷挖矿了 ~ 其实是因为实习生配的mac只有4g内存，才发现了这个插件。不过chrome每个标签页一个进程，的确很很吃内存有道网页翻译可以根据英语水平来&gt; 动态调节翻译的程度哦比如可以这样：下面推荐点开发中常用的插件 json-viewer自动&gt; 格式化显示服务器返回的&gt; json串 比如豆瓣电影Top250返回的是这样的：格式化之后是这样的！ Set Character Encoding快速设置网页的编码写爬虫的时候猜不透编码？自己试一下吧，所见即所得 octotreeGitHub看代码利器！可以直接看到代码的目录结构 Vimium像vim一样操控chrome什么？你想不用鼠标浏览网页？ 满足你j k 上下滑动f 定位网页链接vim 党会感动死的吧就先推荐这么多大家有什么好用的插件也别藏着掖着分享出出来呀~]]></content>
  </entry>
  <entry>
    <title><![CDATA[11款插件让你的Chrome成为全世界最好用的浏览器！｜ Chrome插件推荐～]]></title>
    <url>%2F2019%2F06%2F19%2Fyuque%2F11%E6%AC%BE%E6%8F%92%E4%BB%B6%E8%AE%A9%E4%BD%A0%E7%9A%84Chrome%E6%88%90%E4%B8%BA%E5%85%A8%E4%B8%96%E7%95%8C%E6%9C%80%E5%A5%BD%E7%94%A8%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%81%EF%BD%9C%20Chrome%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90%EF%BD%9E%2F</url>
    <content type="text"><![CDATA[Chrome可以说是全世界最受欢迎的浏览器了，其快速、稳定的性能，简洁的设计以及多平台同步的功能都深受用户的推崇，然而很多人成为他的忠粉还是因为它强大的拓展性！在发现了这些功能实用又不太占地的小插件之后，简直要感叹：“原来这才是Chrome的正确打开方式啊！”用对了插件，工作效率真的是蹭蹭蹭往上飙啊！下面就为大家推荐这段时间我发现的比较优质的Chrome小插件，目前一共有11款，都可以在［Chrome网上应用店］下载，当然辣，只有科学上网才能访问哦～ 照顾以前没有使用过Chrome浏览器的朋友，先说一下［Chrome网上应用店］简单来说［Chrome网上应用店］可以让你通过使用应用、扩展程序和主题背景来自定义你的Chrome，打开Chrome点击“应用”即可进入：&gt; 在搜索框中输入关键字即可找到所需的应用或者拓展程序，也可以浏览经过分类和整理的合集发现新的内容：&gt; 此外，&gt; Chrome还支持多设备同步。登录到 Chrome 后，您可以从多台计算机访问自己的应用，而无需再在自己的所有计算机上记住软件密钥或重新安装软件。Chrome上有很多优质的应用，我也还在探索中，这一次先为大家推荐小插件，点赞多的话马上来更新应用篇哦～ 1、Infinity ／ Momentum ／ Google Art Project——定义你的新标签页自定义的第一步当然是选择自定义你的新标签页，这三款插件都是用来重新定义你的新标签页的。之所以推荐三款，是因为我觉得三款真的都很棒啊，我自己使用的是第一款“Infinity ”，比较符合我的使用习惯，将三款都介绍给大家，大家可以按自己的喜好来选择：没有使用插件之前，我们打开新的标签页（BTW，打开新标签页的快捷键是command＋T），显示的界面是这样的：这个界面是比较简洁，但是对于我们快速进入工作界面或某个网页其实不是很方便，这时候我们就需要小插件啦～ 1.1 Infinity在Chrome网上应用店中搜索Infinity ，然后将它添加到Chrome：成功添加之后，当你再打开新标签页，它就变成了这样，背景壁纸可以随意更换，点击右下角的小风车就可以了，你也可以上传自己喜欢的图片：还可以点击右上角的红色＋号按钮，添加更多你需要的网址到界面：喜欢 Infinity 是因为它比较接近我的使用习惯，点击图标就可以进入目标网页，还可以方便地查看历史记录、添加待办事项、获得天气情况等等。你还可以在添加更多常用网页到界面，Infinity 将一些比较主流的网站都收录在分类里面，方便你添加。此外，** Infinity 还有一个非常方便的功能，就是管理你的Chrome上的应用和插件！是的，用插件管理插件，因为Chrome上的插件五花八门，经常不注意就下了一大推，当然我们可以通过Chrome来管理，但比较不方便，使用 Infinity 的话，我们只需要点击界面上的“应用”图标，就可以轻松管理啦。Chrome上也有专门用来管理应用和插件的插件，但我觉得既然 Infinity 就能够实现的话，就不要再下其它的啦，过多的插件还是会影响浏览器的速度的。** 1.2 Momentum相比 Infinity ，Momentum的设计更加简洁，个人觉得背景图比 Infinity 的更好看一些，四个角分别有不同的功能，但缺点是不能直接进入目标页面，放张图大家自行感受一下： 1.3 Google Art Project除了以上两款比较常见的新标签页插件，还要向喜欢艺术的朋友推荐 Google Art Project，这是Google的一个文化艺术项目，希望探索世界各地的精彩故事和馆藏，将经典和精品展示给更多的人，附上这个计划的网址，没事上去看看艺术品也很赏心悦目：https://www.google.com/culturalinstitute/beta/同样还是在Chrome应用商店搜索 “Google Art Project” 然后添加，之后你的新标签页就会变成这样啦：背景每天都会更新，这样你就可以在浏览器标签页中欣赏 Google Cultural Institute 中的艺术计划精彩作品啦，点击还可以查看更多关于画作的信息。而右下角的按钮可以让你留言一些常用网址。 2、下载管理器——管理你的下载我们从网站上下载文件时，一般来说比较倾向于可以方便地看到下载进度和结果，Safari这一点上就比较好：不过在Chrome中，我们也可以通过安装插件来实现。搜索添加“下载管理器”，在插件栏就可以看到啦：3、Adblock Plus——无用广告拦截这款插件基本上是必备啦，评价比较高，用户非常多，我个人使用体验也还是很好的，安装之后基本上屏蔽了大部分垃圾广告，节约了时间也帮助你在浏览网页时集中注意力在目标内容上。 4、OneTab——管理你打开的网页我们平时在查阅资料或者工作的时候，常常不自觉就打开了一堆网站，当你想快速地点击到你的目标网站时，会发现十分不便，而且会把眼睛搞得很累，就像下图：OneTab 就是为解决这个问题诞生的，搜索添加它之后，点击插件栏中的 OneTab 图标，这些打开的网页就被全部集合到一起啦：OneTab 还有历史纪录，方便你浏览过去时间打开的网页，因此使用它除了管理你打开的网页之外，也比较不担心会丢失有用的网页。 5、右键搜——拓展你的右键非常喜欢的一款插件，添加之后，当我们点击右键就可以看到它啦。用它选中网页上的图片，就可以用 Google 或者 百度搜索这张图片，知道图片的更多信息以及跟它相近的其它图片。而当我们选中网页上的文字的时候，我们可以方便地利用 “右键搜”翻译文字，并且可以将生成二维码！从此用二维码来表个白简直是小意思了～ 6、Awesome screenshot——注释&amp;录屏主要功能有两个，一是录屏&gt; 二是捕获整个页面或任何部分，然后对捕获的图片进行注释，可以添加矩形，圆形，箭头，线条和文字，模糊敏感信息等。 作为一款小插件来说，我觉得它已经挺厉害了，有很多朋友说，Mac自带的录屏软件还有快捷键截图也已经很方便了，但我个人觉得插件的操作路径更短些，效率不就是这么一点点提高的吗？ 7、Imagus——悬停放大图片鼠标指针悬停在链接或缩略图上时直接在当前页面的弹出视图上显示这些图片、HTML5 视频/音频和内容专辑。喜欢淘宝、微博还有各类图片网站的朋友，这个插件绝对会极大提高你们的效率，将光标停放在图片上，图片就会自动放大啦～ 8、Video Downloader professional——自动识别下载资源我们在浏览网页的时候有时候需要把网页上的视频下载下来，而这常常需要借助第三放的下载软件，过程有时候十分复杂而且在电脑上装有些软件也很烦， Video Downloader professional的功能就是帮我们省去这一过程，它会自动检测网页中的所有的视频文件，提供一键下载，简直不要太方便！ 9、新媒体管家——帐号管理&amp;图文编辑顾名思义，新媒体管家的主要功能是管理你的新媒体帐号，目前支持以下平台：使用新媒体管家，可以让你同时管理几个平台的帐号，或一个平台上的多个帐号。添加帐号之后，就可以通过新媒体管家进入相应的帐号了。比如，对于微信公众平台来说，你可以添加多个帐号，并且同时登陆，一天之内只需要扫码登陆一次，便可以直接进入后台。除此之外，对于有写微信推文需要的人，新媒体管家的作用还体现在它可以帮助你完成推文的排版和编辑！以往我们在写推文的时候，可能需要借助135编辑器或者秀米，个人觉得135的板式比较多，秀米的排版比较好，所以有时候需要同时用两个平台才可以完成编辑，而中间可能会出现两个平台格式不通用的情况，非常麻烦。有了新媒体管家之后，通过它打开微信后台，选择新建素材，你会发现编辑页面变成了这样：也就是说，你可以直接在后台选择板式、调整边距、添加emoji；新增的小功能里面，还可以让你去别的地方采集样式，然后运用到你的推文里面；搜图功能帮你省去漫天找图、下载、上传的繁琐步骤。然而我最喜欢它的功能还是“热点中心”，通过它你可以快速地获取当天的热点！目前新媒体管家为用户呈现三个平台（微信热文、头条指数、知乎精选）的热门消息，包括了当日热词。你还可以通过它搜索公众号和文章，获取时间、阅读和点赞数等信息。此外，它还有一些非常实用的功能、比如营销日历，通过它你可以提前做好营销计划的选题和排期等等 10、印象笔记——网页标注和收藏必须推荐的一个插件，以前在Safari中就一直使用的一款小插件，可以快速保存、标注和分享网页上的一切内容，包括网页正文、图片、截屏和整个网页。相信很多人已经在用了，我个人的使用体验还是非常好的，有起是它在保存网页的时候，格式保留得很完整。 11、Google翻译Google翻译做得已经非常不错了，平时翻译文献的时候用Google 翻译基本上可以有7成的正确率，自己再稍作修改就行。Google 翻译的小插件主要是方便我们在浏览网页的时候，随手翻译不认识的字词句。使用的时候只需要选中需要翻译的部分，然后点击插件栏“Google翻译”的小图标就行。 先写到这，觉得有用的话点个赞哦～也欢迎大家留言来推荐你觉得好用的Chrome插件，有新的发现我也会及时更新到文章里面！ 更多精彩也欢迎大家关注微信公众平台 ［麦客范儿］！！！日常为你推荐：Mac／iPhone使用技巧、Mac／iPhone优质软件限免消息、趣味科技短视频～ 转自：https://zhuanlan.zhihu.com/p/27196557]]></content>
  </entry>
  <entry>
    <title><![CDATA[学算法，刷 LeetCode，GitHub 上这几个项目助你一臂之力]]></title>
    <url>%2F2019%2F06%2F19%2Fyuque%2F%E5%AD%A6%E7%AE%97%E6%B3%95%EF%BC%8C%E5%88%B7%20LeetCode%EF%BC%8CGitHub%20%E4%B8%8A%E8%BF%99%E5%87%A0%E4%B8%AA%E9%A1%B9%E7%9B%AE%E5%8A%A9%E4%BD%A0%E4%B8%80%E8%87%82%E4%B9%8B%E5%8A%9B%2F</url>
    <content type="text"><![CDATA[LeetCode 是一个汇集了诸多算法题库的编程网站，许多开发者在初学算法时，都会跑到 LeetCode 网站上面刷题，也有一些开发者为了过微软、Google、Facebook 等国际大企的面试，选择刷 LeetCode 来快速提升自己的编程能力与算法能力，以便顺利通过面试。于是，刷 LeetCode 的做法开始在技术圈传播开来，程序员彼此见面聊天时也会时不时问候几句，”你今天刷 LeetCode 了吗？”。在 GitHub 上，各种语言、不同版本的 LeetCode 题解项目也慢慢多了起来。。。今天，就让我们来简单盘点一下，GitHub 上那几个比较知名的 LeetCode 项目吧。希望对那些打算学习算法，或正在刷 LeetCode 的同学有所帮助。 C++ 题解库该仓库作为 LeetCode 题解库的鼻祖，由左耳朵耗子，也即是同学们常说的耗子叔于 2014 年创建，算是 GitHub 上创建最早的 LeetCode 题解库，同时也是现在 Star 数最高的一个。该项目主要实现了 C++ 的 LeetCode 题解，非常适合广大程序员查看。http://t.cn/R75PA91 Python &amp; Java项目作者 QiYuan Gong 是东南大学的博士生，现为英特尔公司的深度学习工程师，由于受到耗子叔 C++ 题解库的启发，在 GitHub 上创建了这个以 Python 与 Java 为主的题解库。现在身边不少搞算法的朋友，都以 Python 作为首选的编程语言，相信这个库你们一定会喜欢。http://t.cn/EabmDAN Swift 题解库项目作者故胤道长毕业于卡内基梅隆大学，先后就职于 Uber、Amazon 等公司，现在 Quora 担任 iOS 工程师，同时也是 GitHub 全美前 20 名的 Swift 开源作者之一。道长在 2016 年的时候创建了该库，并于微博进行推广后开始广为人知，后续不少开发者加入了项目维护，使得更新也较为频繁。该仓库按照数据结构与公司对 LeetCode 进行了分类，使其目录结构看起来更加清晰。目前收纳的有 Google、Facebook、Snapchat 等多家公司的 LeetCode 题解。http://t.cn/Rg87FJa Go 语言题解库最近国内某个知名企业的代码泄露，为 Go 语言的推广做出了不可磨灭的贡献，因此在这里，也为大家献上一个基于 Go 语言实现的题解库，希望你在阅读某个项目源码的时候，也别忘了多学点算法。http://t.cn/Exg9mPF LeetCode for VS Code 插件我们之前写过一篇文章《装上这几个 VSCode 插件后，上班划水摸鱼不是梦》，里面就推荐过这个 LeetCode 插件。该插件由微软的一名工程师开发，并于今年春节前正式上线，装上之后，就可以在 VSCode 上愉快的刷 LeetCode，在听音乐、看小说等沙雕插件横行的时代，该插件可谓是一股清流，建议当前有在刷 VSCode 的同学装一下。http://t.cn/Rk8r2ao GitHub 上其实还有其它一些 LeetCode 题解库，但由于项目作者许久未更新，给人感觉像是弃坑逃离，所以就不将其纳入到该统计列表中啦。有兴趣的同学可以自己到 GitHub 上翻一下。知乎用户胖君说过，现在刷 LeetCode 的，主要分两个流派，一个是「龟派」，一个是「兔派」。龟派在于把每个题目做得干干净净，滴水不漏，力求把所有解法都试一遍。兔派则是非常暴力的直接硬刷，追求以快制胜，直接上来就看答案，套模板，以解题、找工作作为首要目标，不带一丁点矜持。你是属于哪一派的呢？欢迎在评论区与我们留言分享推荐阅读：GitHub 上有哪些项目能帮你更好的学习编程？GitHub 上的这几个项目或许能帮你学好英语转自：https://zhuanlan.zhihu.com/p/63916811]]></content>
  </entry>
  <entry>
    <title><![CDATA[给大家推荐几个浏览器插件(不用外网也能使用google了)]]></title>
    <url>%2F2019%2F06%2F19%2Fyuque%2F%E7%BB%99%E5%A4%A7%E5%AE%B6%E6%8E%A8%E8%8D%90%E5%87%A0%E4%B8%AA%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6(%E4%B8%8D%E7%94%A8%E5%A4%96%E7%BD%91%E4%B9%9F%E8%83%BD%E4%BD%BF%E7%94%A8google%E4%BA%86)%2F</url>
    <content type="text"><![CDATA[虽然一直知道谷歌浏览器有很多插件，但并不知道还有一些这么好的插件，不知道是不是我太落后了，今天我就给大家介绍几款自己常用的插件。 如果你不知道谷歌浏览器的插件在哪里的话，只需要在谷歌浏览器右上角菜单下选择【更多工具】-【扩展程序】，然后点击【拓展程序】就可以看到Chrome网上应用商店了在那里就可以下载各种插件了。（不过没有外网的话是进不来这个应用商店的）。 1.谷歌浏览器必备神器：谷歌访问助手这估计是我最喜欢的一个插件吧，有了这个插件就算没有外网也可以使用谷歌搜索，登录谷歌帐号，使用谷歌翻译，进去谷歌商店等了。本来那些插件我们都是可以在谷歌插件商店下载的，但此时你不能上外网的话，无法在谷歌商店下载这个插件，我给大家找了一个按照这个插件的教程。谷歌访问助手安装教程：https://jingyan.baidu.com/article/d2b1d102a89a925c7f37d445.html（或者在我的公众号“苦逼的码农”后台直接回复”助手“获取对应的压缩包，里面包含安装方法）按照里面的教程就可以安装谷歌访问助手了，之后的插件就可以直接在谷歌商店那里下载了。不过需要注意的是，谷歌访问助手安装之后，并不可以访问推特等网站平台。 2.去广告插件：广告终结者广告终结者，各种花式广告瞬间完虐，这个神器可以清除几乎所有的网络广告，各种网络站上的广告轻松屏蔽，什么购物广告、浮动广告、视频广告、恶意弹窗、网络跟踪统统眼不见心为净。不过我使用的比较少，不过感觉装了后那些恶心的广告确实少了挺多，我想很多人都讨厌广告，因此介绍给大家。 3.OneTab：将无数Tab合并在一个页面这个插件是用来管理网页的，有时我们会在浏览器中打开了多个页面，会导致电脑变的很卡，这个插件可以帮你暂时把网页挂起，节省95%的内存，想要打开被合并的网页时可以随时恢复。使用之后： 4.必备翻译：Imtranslator网页翻译必备神器，有时阅读英文文档时，经常遇到不认识的单词，选中需要翻译的单词，这个插件可以很方便着帮你翻译出来，而且翻译之后会把对应的中文放在旁边，不怕等下又把单词忘记了，也可以翻译整个网页，不过需要注意的是，翻译是需要电脑可以上外网的，不过假如你按照我上面说的安装了谷歌访问助手，那就可以很方便着翻译了。 5.截图必备神器：FireShot有时想要对网页进行截图时，我是经常用微信带的截图功能的，这种很不方便，经常需要登录微信，而且如果想要截整个网页时也很不方便，这个插件可以帮我们很方便着进行截图，而且还可以存储为PDF等其他格式。 6.公众号必备编辑器：壹伴这个是编辑类插件，主要是针对微信公众号编辑页面的，可以一键排版，我最喜欢这个插件的主要原因是这个插件可以帮我很方便着找到各种封面图，不用自己调尺寸比例等。而且这个插件的一键排版也是挺方便的。 7.必须掌握的编辑语法：Markdown herMarkdown现在是越来越就行了，现在很多网站平台都提供支持Markdown语法来编辑各种文本，强烈建议大家学下用Markdown语法来写文章，不过就算该网站没有提供Markdown编辑器，我们也可以直接用插件Markdown here把我们所写的文本直接Markdown渲染一下，而且我们可以自定义配置自己喜欢的css样式，不想自定义的可以网上搜，一搜一大把，自己复制过来使用。上面这些插件就是我平时用的插件，感觉还不错，介绍给大家。日后有遇到更好的插件，再来继续介绍…哈哈….]]></content>
  </entry>
  <entry>
    <title><![CDATA[GitHub 上见过哪些奇葩的 Chrome 插件]]></title>
    <url>%2F2019%2F06%2F19%2Fyuque%2FGitHub%20%E4%B8%8A%E8%A7%81%E8%BF%87%E5%93%AA%E4%BA%9B%E5%A5%87%E8%91%A9%E7%9A%84%20Chrome%20%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Google Chrome 作为程序员最常用的一款网页浏览器，凭借其强大的插件系统而广受赞赏，程序员作为上面一批最会折腾的用户，自然也不免俗的会在上面胡乱折腾出一些沙雕插件。而这其中，有不少插件代码还开源并托管到 GitHub 上。今天抽空跟大家分享下，我曾看过的那些比较沙雕的 Chrome 插件。 Flappy Octocat2013 年，一位来自越南的独立游戏开发者发布了一款鸟类飞行游戏，Flappy Bird。之后，在短短数月内，该游戏瞬间火爆各大社交网络，成为 2014 年最受欢迎的手游之一，当时我身边不少朋友的手机上都安装了这款游戏。一款爆品的诞生，往往也伴随着一些赝品的争相模仿。Flappy Octocat，这款以 GitHub 吉祥物章鱼猫为主角所打造的小游戏便是其中之一。该游戏由电子科技大学的一名学生所研发，通过在 Chrome 上安装这款游戏，你便可以在 GitHub 上的 commit 强愉快的玩耍章鱼猫小游戏。可以说是非常有创意了。https://github.com/chxj1992/flappy-octocat 微信秒变云笔记在上班的时候，如果不好意思打开微信，跟网友吹水聊天怎么办？没关系，装上这款插件，就可以把你电脑上的网页微信伪装成云笔记，让你神不知鬼不觉地上微信了。伪装到这地步，可以说真的很丧心病狂了。https://github.com/YGYOOO/WeChat-Shelter 一键将 Google 转为百度如果你会用 Google 进行科学上网，而其他人不会，那相信这个声音应该时常会在你耳边响起：“咦？你是怎么能上 Google 的？”时间久了，问得多了，答得烦了，难免耳朵长茧，嘴角生泡。这时，你只需要在你电脑上装上这款插件，扮成不懂科学上网的小白用户，便可以一劳永逸，远离尘世喧嚣了。希望这款插件能救你于水深火热之中。https://greasyfork.org/zh-CN/scripts/372883 以上，即是本次分享。不多，但有趣。今后分享也是如此，内容贵精不贵多。觉得好玩、有意思的，不妨点个赞，支持一下。推荐阅读：GitHub 项目推荐：俄罗斯小游戏、Markdown 幻灯片、头像生成器、Logo 制作工具、坦克大战]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何以光速查看一行代码的提交记录]]></title>
    <url>%2F2019%2F06%2F18%2Fyuque%2F%E5%A6%82%E4%BD%95%E4%BB%A5%E5%85%89%E9%80%9F%E6%9F%A5%E7%9C%8B%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E7%9A%84%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[❓这行代码谁写的 ？在多人协作的项目中进行开发，总是会遇到这些问题：- 这行代码谁写的？明显是个坑，上线肯定是个故障。- 这行代码谁写的？相当优雅，得学习下。- 这行代码谁写的？看不懂，得咨询下。- 这行代码谁写的？不是我呀，得查一下。好，问题来了，这行代码谁写的？ 怎么查是谁写的？ 💢命令行工具 git blame例如，查询 request.js 第 99 行代码是谁提交的，命令为： 12$ git blame -L 99,99 request.js-&gt; dadd208596 lib/core/app/extend/request.js (fengmk2 2016-07-17 12:48:09 +0800 99) * @member &#123;String&#125; Request#ip 即使把这个命令设置为快捷方式，一行一行的查询也是非常耗费精力的，那么有没有一眼可以看到的方式呢？那就是直接在 GitHub 上查。 😑使用 GitHub 查询直接打开 GitHub 查询 request.js 提交记录，就可以看到了。然而，代码敲的好好的，能不能不切换窗口呢？那就是使用各大 IDE 的插件实现了。 🔥使用 VS Code 查询VS Code 在我的电脑上存在有两个原因：- 写 TypeScript- 使用 Git Blame 插件主要说一下 Git Blame 插件，迄今为止用过的最方便的查询代码提交记录的工具，来张截图感受下：光标在哪行，状态栏就显示该行代码的提交者。如果你使用 VS Code 用户，恭喜你，已经完美解决了本篇文章的问题。如果你喜欢轻量级编辑器，喜欢秒开，喜欢像特斯拉 P100D 一样百公里加速 2.5 秒的感觉，那就接着往下看吧。 🌟使用 Sublime Text 查询好好好，你要的，都给你。安装 Git Blame 插件后，需要在光标所在行启动命令框，输入：”Git Blame”，效果如下：重点到了，身为 VIM 用户，我们的插件呢？ 🚀在 VIM 中使用 git-blame.vim 快速查询我是一只小小鸟，想要飞呀却飞也飞不高我遨游在 GitHub 中，寻找着 VIM 适合的查询插件，tpope/vim-fugitive 太重，没有个轻量的插件么？git-blame.vim 横空出世！先看效果：怎么做到的？只需要同时按 ,s 即可。当然也支持自定义快捷键了。对实现感兴趣，请戳 git-blame.vim 代码仓库 🔧安装最直接的方式： 12cd ~/.vim/bundlegit clone git@github.com:zivyangll/git-blame.vim.git 如果你跟你一样用的是 Vundle： 1Plugin &apos;zivyangll/git-blame.vim&apos; 👏使用在 .vimrc 中设置快捷键“逗号+s“： 1nnoremap &lt;Leader&gt;s :&lt;C-u&gt;call gitblame#echo()&lt;CR&gt; 若未设置 Leader，建议设置为逗号： 12let mapleader = &quot;,&quot; &quot; map leader键设置let g:mapleader = &quot;,&quot; 如果你是 VIM 新手，一键上手没有用过 VIM 没关系，可以参考我的 vim 配置：zivim，一键安装： 1$ curl -k https://raw.githubusercontent.com/zivyll/zivim/master/install.sh 配置文件及其适合新手阅读和学习，截两张图 🔚结束语如果你觉得这个插件对你有帮助，不要吝啬你的 star：zivyangll/git-blame.vim，哈哈😄，也可以在 vim.org 投出你宝贵的一票。使用中有任何问题请提 issue。 转自：https://zhuanlan.zhihu.com/p/37599990]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端规范文档]]></title>
    <url>%2F2019%2F06%2F17%2Fyuque%2F%E5%89%8D%E7%AB%AF%E8%A7%84%E8%8C%83%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[百度：ecomfe/spec · GitHub腾讯AlloyTeam：Code Guide by @AlloyTeamGitHub：Styleguide · GitHub]]></content>
  </entry>
  <entry>
    <title><![CDATA[markdown]]></title>
    <url>%2F2019%2F06%2F14%2Fyuque%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[markdown API 欢迎使用 Cmd Markdown 编辑阅读器 学习网站：https://www.zybuluo.com/mdeditor、[https://markdown-here.com/](https://markdown-here.com/) 安装chrome插件：chrome-extension://elifhakcjgalahccnjkneoccemfahfoa/common/options.html可以编辑markdown我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown： 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持）除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载： Windows/Mac/Linux 全平台客户端 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 新文稿 或者使用快捷键 Ctrl+Alt+N。 什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 1. 制作一份待办事宜 Todo 列表 支持以 PDF 格式导出文稿 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 新增 Todo 列表功能 修复 LaTex 公式渲染问题 新增 LaTex 公式编号功能 2. 书写一个质能守恒公式[1]$$E=mc^2$$ 3. 高亮一段代码[2]123456@requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world' 4. 高效绘制 流程图 5. 高效绘制 序列图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 6. 高效绘制 甘特图12345678910111213title 项目开发流程 section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5d section 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5d section 发布验收 发布: 2d 验收: 3d 7. 绘制表格 项目 价格 数量 计算机 $1600 5 手机 $12 12 管线 $1 234 8. 更详细语法说明 想要查看更详细的语法说明，可以参考我们准备的 [Cmd Markdown 简明语法手册][1]，进阶用户可以参考 [Cmd Markdown 高阶语法手册][2] 了解更多高级功能。 总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。 什么是 Cmd Markdown您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 编辑/发布/阅读 Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。 1. 实时同步预览我们将 Cmd Markdown 的主界面一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！ 2. 编辑工具栏也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 编辑区 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。 3. 编辑模式完全心无旁骛的方式编辑文字：点击 编辑工具栏 最右侧的拉伸按钮或者按下 Ctrl + M，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！ 4. 实时的云端文稿为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 编辑工具栏 的最右侧提示 已保存 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。 5. 离线模式在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。 6. 管理工具栏为了便于管理您的文稿，在 预览区 的顶部放置了如下所示的 管理工具栏：通过管理工具栏可以：发布：将当前的文稿生成固定链接，在网络上发布，分享新建：开始撰写一篇新的文稿删除：删除当前的文稿导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地列表：所有新增和过往的文稿都可以在这里查看、操作模式：切换 普通/Vim/Emacs 编辑模式 7. 阅读工具栏通过 预览区 右上角的 阅读工具栏，可以查看当前文稿的目录并增强阅读体验。工具栏上的五个图标依次为：目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落视图：互换左边编辑区和右边预览区的位置主题：内置了黑白两种模式的主题，试试 黑色主题，超炫！阅读：心无旁骛的阅读模式提供超一流的阅读体验全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境 8. 阅读模式在 阅读工具栏 点击 或者按下 Ctrl+Alt+M 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。 9. 标签、分类和搜索在编辑区任意行首位置输入以下格式的文字可以标签当前文档：标签： 未分类标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示： 10. 文稿发布和分享 在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 (Ctrl+Alt+P) 发布这份文档给好友吧！再一次感谢您花费时间阅读这份欢迎稿，点击 (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！作者 [@ghosert][3]2016 年 07月 07日 123// All the code you will ever needvar hw = "Hello World!"alert(hw); My math is so rusty that I barely remember the quadratic equation:$-b \pm \sqrt{b^2 - 4ac} \over 2a$ 支持 LaTeX 编辑显示支持，例如：$\sum_{i=1}^n a_i=0$， 访问 [MathJax][4] 参考更多使用方法。 ↩︎ 代码高亮功能支持包括 Java, Python, JavaScript 在内的，四十一种主流编程语言。[1]: https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown[2]: https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#cmd-markdown-高阶语法手册[3]: http://weibo.com/ghosert[4]: http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference| Name | Lunch order | Spicy | Owes || —– | ———– | —— | —: || Joan | saag paneer | medium | $11 || Sally | vindaloo | mild | $14 || Erin | lamb madras | HOT | $5 |There are multiple syntax highlighting themes to choose from. Here’s one of them: ↩︎]]></content>
  </entry>
  <entry>
    <title><![CDATA[mermaidjs]]></title>
    <url>%2F2019%2F06%2F14%2Fyuque%2Fmermaidjs%2F</url>
    <content type="text"><![CDATA[mermaidjs]]></content>
  </entry>
  <entry>
    <title><![CDATA[markExample]]></title>
    <url>%2F2019%2F06%2F14%2Fyuque%2FmarkExample%2F</url>
    <content type="text"><![CDATA[https://segmentfault.com/markdown markdown例子Basic writing and formatting syntax 文本 Headers This is an tagThis is an tagThis is an tagInline-style: 12var s = "JavaScript syntax highlighting";alert(s); 12s = "Python syntax highlighting"print s 12No language indicated, so no syntax highlighting. But let&apos;s throw in a &lt;b&gt;tag&lt;/b&gt;. 表情包来自余：https://www.webfx.com/tools/emoji-cheat-sheet/ https://github.com/ikatyang/emoji-cheat-sheet/edit/master/README.md https://help.github.com/en/articles/basic-writing-and-formatting-syntax#using-emoji 1@octocat :+1: This PR looks great - it&apos;s ready to merge! :shipit: | top | :bowtie: | :bowtie: | | :smile: | emoji-cheat-sheetThis cheat sheet is automatically generated from GitHub Emoji API and Emoji Cheat Sheet. Table of Contents People Nature Objects Places Symbols Uncategorized]]></content>
  </entry>
  <entry>
    <title><![CDATA[在 VPS 上部署 Hexo]]></title>
    <url>%2F2019%2F06%2F14%2Fyuque%2F%E5%9C%A8%20VPS%20%E4%B8%8A%E9%83%A8%E7%BD%B2%20Hexo%2F</url>
    <content type="text"><![CDATA[Hexo博客架构 简单地说，在本地用 markdown 写好文章，用 hexo 生成静态的 html 文件并 push 到远程服务器（vps），vps 再通过 git-hooks 同步网站目录。其实这两个是可以合成一个的，不过每次写文章都要 ssh 登录到 vps，体验可能没那么好。 流程大纲 本地 – 环境搭建，安装 Hexo,包括 hexo-cli, Nodejs, git; 本地 – 写文章； 远程 VPS – 环境搭建，包括 Nodejs, git, Nginx 配置和创建 git 用户;使用 git 自动化部署发布博客 使用 Git 自动化部署发布博客 本地 Hexo 安装和配置首先要安装 Nodejs 和 git , mac 系统可用 brew 安装，其它系统自行摸索 1brew install nodejs git 安装 hexo-cli 1npm install -g hexo-cli 找个地方放 Hexo 程序 123mkdir -p ~/Documents/codecd ~/Documents/codehexo init blog 然后安装两个插件，分别是 git 自动部署插件 hexo-deployer-git 和简单的本地web服务器 hexo-server 123cd ~/Documents/code/blognpm install hexo-deployer-git --savenpm install hero-server --save 至此本地环境算搭建好了，下面是写文章 本地 Hexo 发表文章使用命令新建文章 12cd ~/Documents/codehexo new "hello Hexo" 该命令会成一个对应的 .md 文件放置在 sources/_posts 文件夹 1sources/_posts/hello-hexo.md 接下来用你喜欢的编辑器编辑 hello-hexo.md 文件，记得要用 markdown 语法。 写好以后， 使用 hexo g 命令将 .md 文件渲染成静态文件 1hexo g 然后启动本地 web 服务器 hexo-server 1hexo server 该命令可简写为 hexo s, 现在可以用浏览器打开 http://localhost:4000 访问博客了。 （注：以上本地环境搭建完成可以放在远程服务器 vps 上，当然写文章也得在 vps 上写，传统的做法是像架构图那样分离开。）_ 远程 VPS 环境搭建同样要安装 Nodejs 和 git，根据自己的系统自行摸索，此步略过Nginx 配置，我用宝塔 linux 面板一键安装，不用手动配置，如果要手动改，参考配置如下（抄来的，仅供参考）： 1234567891011121314151617181920212223242526272829server&#123; listen 80; #listen [::]:80; server_name www.xxb.me xxb.me; index index.html index.htm index.php default.html default.htm default.php; #这里要改成网站的根目录 root /path/to/www; include other.conf; #error_page 404 /404.html; location ~ .*\.(ico|gif|jpg|jpeg|png|bmp|swf)$ &#123; access_log off; expires 1d; &#125; location ~ .*\.(js|css|txt|xml)?$ &#123; access_log off; expires 12h; &#125; location / &#123; try_files $uri $uri/ =404; &#125; access_log /home/wwwlogs/blog.log access;&#125; 未完待续]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo 优化设置]]></title>
    <url>%2F2019%2F06%2F14%2Fyuque%2FHexo%20%E4%BC%98%E5%8C%96%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[hexo官网 修改博客标题简介语言等创建页面编辑 _config.yml 12345678910# Sitetitle: Xxbsubtitle: Linux,crypto,miningdescription:keywords: Linux,crypto,miningauthor: xxb.melanguage: - zh-CN - zh-TW - en 修改网站 URL 和链接格式编辑 _config.yml 123456# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://www.xxb.meroot: /permalink: :category/:title/permalink_defaults: 创建分类页运行命令新建page页 1hexo new page categories 编辑页面123456789101112---title: 分类date: 2018-04-25 22:34:08type: "categories"------title: 标签date: 2018-04-25 22:34:08type: "tags"--- 实际使用1234567891011121314151617181920212223242526title: hexo 添加标签和分类date: 2018-04-27 23:00:34categories:- hexotags:- linux---layout: phototitle: My Gallerydate: 2019-06-19 15:54:13# tags: [photo, 照片]categories: - hexotags: - linux - React------title: post title with whitespacedate: 2019-06-19 15:39:18tags: [photo, 照片]--- 配置别名其中: 以前的是正式的名称，以后的是访问的路径 12345678910111213# Category &amp; Tagdefault_category: uncategorizedcategory_map: hexo:hexo ubuntu:ubuntu computer vision:computer-visiontag_map: linux:linux ubuntu:ubuntu vim:vim tmux:tmux hexo:hexo yolo:yolo opencv:opencv computer vision:computer-vision 部署生效一定要记得先clean在生成 123$ hexo clean$ hexo g$ hexo d 运行后提示 1INFO Created: ~/Documents/code/blog/source/categories/index.md 找到 index.md 这个文件，为其添加 type 属性 12345---title: tagsdate: 2019-01-30 17:37:12type: "categories"--- 修改主题 _config.yml 文件的menu段落，反注释掉tags那一行 123456789menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 创建标签页方法和创建分类页一样，只是把 categories 改为 tags 创建about页参考创建标签页 添加诗词插件今日诗词 API 根据不同地点、时间、节日、季节、天气、景观、城市、事件进行智能推荐，每次刷新都不同。官网： https://www.jinrishici.com/调用文档： https://www.jinrishici.com/doc/在想放置诗词的地方添加以下代码：（我放在_partials/header/brand.swig） 12&lt;div id="jinrishici-sentence" class="shici"&gt;&lt;/div&gt;&lt;script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"&gt;&lt;/script&gt; 自定义样式，修改主题样式文件source/css/_custom/custom.styl 1.shici &#123;font-size: 15px;text-align: center;font-weight: 300;color: #444;font-style: italic;&#125; 在线演示： www.xxb.me主题：https://github.com/ppoffice/hexo-theme-icarus 未完待续 …]]></content>
  </entry>
  <entry>
    <title><![CDATA[UI组件库]]></title>
    <url>%2F2019%2F06%2F14%2Fyuque%2FUI%E7%BB%84%E4%BB%B6%E5%BA%93%2F</url>
    <content type="text"><![CDATA[经典模块化前端框架]]></content>
  </entry>
  <entry>
    <title><![CDATA[教程一]]></title>
    <url>%2F2019%2F06%2F14%2Fyuque%2F%E6%95%99%E7%A8%8B%E4%B8%80%2F</url>
    <content type="text"><![CDATA[手摸手教程手摸手，带你用合理的姿势使用 webpack4（上）手摸手，带你用合理的姿势使用 webpack4（下） url-loader vs file-loader 2018-08-13 很多人搞不清楚这两个 loader 是干嘛的？其实 url-loader 就是对 file-loader 的一个拓展。照你设置的文件大小 limit, 将其内联为 base64 或者单独作为文件引入。 将图片文件转换为 base64 编码并载入浏览器能够减少 http 请求数，但是增大了 js 或 html 文件的体积，如果图片在项目中的重用度较高，那么每处引用都会生成 base64 编码，造成了代码的冗余。所以是否需要内联自己需要权衡一下。 file-loader： 可以指定要复制和放置资源文件的位置，以及如何使用版本哈希命名以获得更好的缓存。此外，这意味着 你可以就近管理图片文件，可以使用相对路径而不用担心部署时 URL 的问题。使用正确的配置，webpack 将会在打包输出中自动重写文件路径为正确的 URL。 url-loader： 允许你有条件地将文件转换为内联的 base-64 URL (当文件小于给定的阈值)，这会减少小文件的 HTTP 请求数。如果文件大于该阈值，会自动的交给 file-loader 处理。]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue]]></title>
    <url>%2F2019%2F06%2F14%2Fyuque%2Fvue%2F</url>
    <content type="text"><![CDATA[##Router Linkrouter-link基本每一个人都会用，但有的时候我们需要在点击的时候做一些额外的操作，比如点击的时候先弹出一个确认框，问用户是否需跳转。但发现怎么也禁止不了它的默认时间。查阅文档之后发现它有一个 event参数，默认是click。我们只要将它设空，之后自己来处理跳转的逻辑就可以了。 1234&lt;router-link :to="&#123; name: 'my-favorites' &#125;" :event="''" @click.native.prevent="routeOrLogin(&#123; name: 'my-favorites' &#125;)"&gt; Favorites&lt;/router-link&gt; Dynamic Componentsvue 一个就是 它可以写愉快的写 template 一个类 html 的模板，大多数情况下都非常好用。但在一些复杂场景下，它就显得不太灵活了。 这里举一个例子来说： 12345678910&lt;a v-if="isExternalLink" :href="xxx"&gt; &lt;componentA /&gt; &lt;componentA /&gt; &lt;componentC /&gt;&lt;/a&gt;&lt;router-link v-else :to="xxx"&gt; &lt;componentA /&gt; &lt;componentA /&gt; &lt;componentC /&gt;&lt;/router-link&gt; 这里只是一个最简单一个例子，实际场景中，中间重复的内容可能更多，两者唯一的区别只是外链的时候使用a标签，内部链接使用router-link。但却要写一大串的 if..else很不爽。这里提供一个简单的方法解决这个问题。就是使用动态组件，我们将a标签和router-link分装成一个动态组件，根据传入的 url 是否是外部链接，动态的选择使用什么标签来渲染。 1234567891011121314151617181920212223242526272829303132&lt;!-- Link.vue --&gt;&lt;template&gt; &lt;component v-bind="linkProps(to)"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/component&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: &#123; to: &#123; type: String, required: true &#125; &#125;, methods: &#123; linkProps (url) &#123; if (url.match(/^(http(s)?|ftp):\/\//)) &#123; return &#123; is: 'a', href: url, target: '_blank', rel: 'noopener' &#125; &#125; return &#123; is: 'router-link', to: url &#125; &#125; &#125; &#125;&lt;/script&gt; 这样我们将代码的复杂度都封装在了Link.vue之中，我们在原来文件中只需这样使用： 12345&lt;link :to="xxx"&gt; &lt;componentA /&gt; &lt;componentA /&gt; &lt;componentC /&gt;&lt;/link&gt; 是不是一下子简单了许多，代码的可阅读性也直线上升了。 Fragmentreact 很早就有了 Fragment 但 vue 迟迟还没有支持。]]></content>
  </entry>
  <entry>
    <title><![CDATA[产品]]></title>
    <url>%2F2019%2F06%2F14%2Fyuque%2F%E4%BA%A7%E5%93%81%2F</url>
    <content type="text"><![CDATA[如何理解 DAU 和 MAU 这两个数据？ DAU (Daily Active Users) 日活 单日活跃用户数，反应产品短期用户活跃度 MAU (Monthly Active Users) 月活 单月活跃用户量，反应产品长期用户活跃度 DAU 的分析价值所在核心用户规模：DAU 指标直接反应了核心用户规模。可以结合其他指标一同分析。 生命周期分析的价值：产品不同阶段，DAU 的数据表现不一样。DAU 趋势下滑，那么很可能是老用户流失，产品开始走下坡路。是否要投入运营预算，是否要产品重新战略部署等。 产品黏性：DAU 指标结合留存指标来分析产品的用户粘性。 渠道价值分析：DAU 可以间接判断各大渠道对产品的贡献价值。在产品初期投放各大渠道之后，DAU 数据会逐步减少，后期可以有选择的保留用户基数大的渠道运营。 用户流失分析：运营活动结束之后，DAU 数据有大幅减少，则要进行用户流失分析。 DAU 的多维度分析 趋势：通过判断 DAU 指标在某一时间段的变化来预测未来的数据表现，一般用趋势图表示。例如，未来一个月的收益表现，可以参考三个月的 DAU，去年同期的数据表现，可以综合评估分析。 同比：是将本周期内的数据与历史相同时间点的数据进行比对。例如，今年 N 月与去年 N 月相比。 环比：是将本期数据与前期数据进行对比，体现了数据连续性变化的趋势。例如，今年九月同八月、七月的数据进行比对。 定基比：数据进行比对才有意义。该分析需要以某个时期为基数，其他各期数据都可以与之对比。基准线是产品发展的里程碑水平，可以反映产品的发展运营情况如何 异常定位一般表现为：数据异常时间点的不同（如节假日，高考等），产品体验，近期是否发版，近期的运营活动，渠道投放，广告推广，产品相关的新闻事件，以及市场竞品的影响（如有新竞品进入市场，竞品最近搞运营活动）等。 比值DAU/MAU 代表的是，每天登录的玩家占月活跃的百分比。形象点就是说，你这些活跃玩家，是每天都在登录，还是隔了几天登录。假设，每天都在登录，粘性就高。你隔个四五天登录，粘性就低。一般这个值会在 0.03 到 1 之间。 如果低于 10%，很可能已经处于衰退期；高于 20%的留存还不错。 交互 席克定律它描述了根据已知选项做某项决定所花的时间——随着选项数量的增加，投入的时间也会呈对数增加。简单来讲，越少越快。 当用户出现恐慌或困惑时，唯一的选择反而给人一种「山有小口，仿佛若有光」的感觉。 所以，如果「反应时间」很重要，那选项数量一定要控制在最少。这样也可以加快用户抉择的速度。解决方案: 分步选择, 均分总复杂度到每一个步骤 限制选项数量, 保留基本的选项 控制单个元素的复杂度, 使页面简单好理解]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端性能监控]]></title>
    <url>%2F2019%2F06%2F14%2Fyuque%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[前端性能优化原理与实践前端性能监控分为两种方式，一种叫做合成监控（Synthetic Monitoring，SYN），另一种是真实用户监控（Real User Monitoring，RUM）。 合成监控什么叫合成监控？就是在一个模拟场景里，去提交一个需要做性能审计的页面，通过一系列的工具、规则去运行你的页面，提取一些性能指标，得出一个审计报告。常见的工具有 Google 的 Lighthouse，webpagetest，pagespeed 等。当然其实业界对于 Lighthouse 也是评价有褒有贬，因为 Google 借助这个看似中立的性能评审工具也是在推行它的一些技术的方案。 比如你的页面如果没有支持 PWA 评分就不会很高。 合成监控的优缺点 优点 缺点 实现简单 无法还原全部真实场景 能采集到丰富的数据，如硬件指标或瀑布图 登录等场景需要额外解决 不影响真实用户的访问性能 单次数据不够稳定 可以提供页面加载幻灯片等可视化分析途径 数据量较小，无法发挥更大价值 真实用户监控所谓真实用户监控，就是用户在我们的页面访问之后就会产生各种各样的性能指标，之后会将这些性能指标上传的我们的日志服务器上，进行数据的提起清洗加工，最后在我们的监控平台上进行展示和分析的一个过程。 真实用户监控的优缺点 优点 缺点 无需配置模拟条件，完全还原真实场景 一定程度影响真实用户的访问性能及流量消耗 不存在登录等需要额外解决的场景 无法采集硬件相关指标 数据样本足够庞大，可以减少统计误差 受传输限制无法采集完整的资源加载瀑布图 新年数据可与其它数据关联，产生更大价值 无法可视化展示加载过程 对比 对比项 合成监控 真实用户监控 实现难度及成本 较低 较高 采集数据丰富度 丰富 基础 数据样本量 较小 大(视业务体量) 适合场景 团队自由业务，对性能做定性分析，或配合 CI 做小数据量的监控分析 作为中台产品支持前台业务，对性能做定量分析，结合业务数据进行深度挖掘 方案在真实用户性能数据采集时，要关注四个方面的东西： 使用标准的 API 定义合适的指标 采集正确的数据 上报关联的维度使用标准的 API之前大家都使用一个叫 performance.timing，来做性能监控。但这个 API 已经“废弃”了。为什么会被废弃？因为 W3C 给我们提供了更全面、更强大的一个性能分析矩阵，比单一的 performance.timing 更加强大，能帮助我们从各个方面分析前端页面性能。采集性能数据时先抹平 Navigation Timing spec 差异，优先使用 PerformanceTimeline API(在复杂场景，亦可考虑优先使用 PerformanceObserver)。 定义合适的指标First Meaningful Paint，首次有效渲染时长，这个指标最早是由 Google 提出的，它的一个核心的想法是渲染并不一定代表着用户看到了主要内容，Load 也不一定代表用户看到主要内容，那用户什么时候能够看到主要内容呢？我们假设当一个网页的 DOM 结构发生剧烈的变化的时候，就是这个网页主要内容出现的时候，那么在这样的一个时间点上，就是用户看到主要内容的一个时间点。它的优点是相对校准的估算出内容渲染时间，贴近用户感知。但缺点是无原生 API 支持，算法推导时 DOM 节点不含权重。 怎样采集正确的数据？上报页⾯加载开始时间，以及后续各时间点相对增量，在数据端进行阶段清洗和异常处理。 上报关联的维度我们都知道在做前端的数据采集的时候，维度数据是非常重要的，除了我们刚才定义的各种度量，怎样采集到合适的相关维度，也能够极大地帮助我们分析页面性能的效果。在分析页面性能的时候，有很多相对专业的维度是会被大家忽略掉的，比如说当前页面是否可见，这个页面加载方式是怎么样的，它是直接打开，还是刷新打开，还是前进后退打开等等。就是通过后面的数据分析，我们会发现，不同的页面操作，页面打开方式都会对我们页面加载的性能会有影响，以及一些更复杂的，比如说是否启用 HTTP2、Service Worker 等等，这些数据我们都应该尽可能采集到，从而能够更好的去分析我们的页面性能。 原文本文为蚂蚁金服如何把前端性能监控做到极致? 的阅读笔记。拓展阅读 我理解的前端性能 &amp; 优化]]></content>
  </entry>
  <entry>
    <title><![CDATA[uni-app]]></title>
    <url>%2F2019%2F06%2F14%2Fyuque%2Funi-app%2F</url>
    <content type="text"><![CDATA[官网git源码地址]]></content>
  </entry>
  <entry>
    <title><![CDATA[Javascript]]></title>
    <url>%2F2019%2F06%2F14%2Fyuque%2FJavascript%2F</url>
    <content type="text"><![CDATA[querySelectorAll getElementsBy 区别？ 浏览器兼容querySelectorAll 已被 IE 8+、FF 3.5+、Safari 3.1+、Chrome 和 Opera 10+ 良好支持 。getElementsBy 系列，以最迟添加到规范中的 getElementsByClassName 为例，IE 9+、FF 3 +、Safari 3.1+、Chrome 和 Opera 9+ 都已经支持该方法了。 接收参数querySelectorAll 方法接收的参数是一个 CSS 选择符。而 getElementsBy 系列接收的参数只能是单一的 className、tagName 和 name。 123var c1 = document.querySelectorAll('.b1 .c')var c2 = document.getElementsByClassName('c')var c3 = document.getElementsByClassName('b2')[0].getElementsByClassName('c') 返回值大部分人都知道，querySelectorAll 返回的是一个 Static Node List，而 getElementsBy 系列的返回的是一个 Live Node List。 1234567891011121314151617181920212223&lt;ul&gt; &lt;li&gt;&lt;/ul&gt; &lt;li&gt;&lt;/ul&gt; &lt;li&gt;&lt;/ul&gt; &lt;li&gt;&lt;/ul&gt; &lt;li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;script&gt;// Demo 1var ul = document.querySelectorAll('ul')[0], lis = ul.querySelectorAll("li");for(var i = 0; i &lt; 5 ; i++)&#123; ul.appendChild(document.createElement("li"));&#125;console.log(lis) //5// Demo 2var ul = document.getElementsByTagName('ul')[0], lis = ul.getElementsByTagName("li");for(var i = 0; i &lt; 5 ; i++)&#123; ul.appendChild(document.createElement("li"));&#125;console.log(lis) //5+2&lt;/script&gt; Demo 1 中的 lis 是一个静态的 Node List，是一个 li 集合的快照，对文档的任何操作都不会对其产生影响。Demo 2 中的 lis 是一个动态的 Node List， 每一次调用 lis 都会重新对文档进行查询，导致无限循环的问题。但为什么要这样设计呢？ 其实，在 W3C 规范中对 querySelectorAll 方法有明确规定 The NodeList object returned by the querySelectorAll() method must be static ([DOM], section 8). 那什么是 NodeList 呢？ The NodeList interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented. NodeList objects in the DOM are live. 所以，NodeList 本质上是一个动态的 Node 集合，只是规范中对 querySelectorAll 有明确要求，规定其必须返回一个静态的 NodeList 对象。 12document.querySelectorAll('a').toString() // return "[object NodeList]"document.getElementsByTagName('a').toString() // return "[object HTMLCollection]" 这里又多了一个 HTMLCollection 对象出来，那 HTMLCollection 又是什么？ 实际上，HTMLCollection 和 NodeList 十分相似，都是一个动态的元素集合，每次访问都需要重新对文档进行查询。两者的本质上差别在于，HTMLCollection 是属于 Document Object Model HTML 规范，而 NodeList 属于 Document Object Model Core 规范。这样说有点难理解，看看下面的例子会比较好理解 12345var ul = document.getElementsByTagName('ul')[0], lis1 = ul.childNodes, lis2 = ul.childrenconsole.log(lis1.toString(), lis1.length) // "[object NodeList]" 11console.log(lis2.toString(), lis2.length) // "[object HTMLCollection]" 4 NodeList 对象会包含文档中的所有节点，如 Element、Text 和 Comment 等。HTMLCollection 对象只会包含文档中的 Element 节点。另外，HTMLCollection 对象比 NodeList 对象 多提供了一个 namedItem 方法。所以在现代浏览器中，querySelectorAll 的返回值是一个静态的 NodeList 对象，而 getElementsBy 系列的返回值实际上是一个 HTMLCollection 对象 。 参照文章 NodeList 和 HTMLCollection 之间的关系？历史上的 DOM 集合接口。主要不同在于 HTMLCollection是元素集合而 NodeList 是节点集合（即可以包含元素，也可以包含文本节点）。所以 node.childNodes 返回 NodeList，而 node.children 和 node.getElementsByXXX 返回 HTMLCollection 。唯一要注意的是 querySelectorAll 返回的虽然是 NodeList ，但是实际上是元素集合，并且是静态的（其他接口返回的 HTMLCollection 和 NodeList 都是 live 的）。Both interfaces are collections of DOM nodes. They differ in the methods they provide and in the type of nodes they can contain. While a NodeList can contain any node type, an HTMLCollection is supposed to only contain Element nodes. An HTMLCollection provides the same methods as a NodeList and additionally a method called namedItem.Collections are always used when access has to be provided to multiple nodes, e.g. most selector methods (such as getElementsByTagName) return multiple nodes or getting a reference to all children (element.childNodes). [“1”, “2”, “3”].map(parseInt) 坑第一反应都觉得结果会是 [1,2,3]但实际结果却是 [1, NaN, NaN]这是为什么呢？主要是 map 这个方法在调用 callback函数时，会给它传递三个参数: 当前正在遍历的元素 元素索引 原数组本身 也是就是说如上代码其实等同于 1['1', '2', '3'].map((i, index, array) =&gt; parseInt(i, index, array)) 这样就直观的解释了上面的答案是怎么产生得了。因为 parseInt 会接受两个参数：参数和进制数。 1234// 实际代码运算等于如下parseInt('1', 0) // 1parseInt('2', 1) // NaNparseInt('3', 2) // NaN 所以为了避免这个坑，平时写 map 还是不要偷懒了，完整的写法才更直观并且更容易维护。 1['1', '2', '3'].map(str =&gt; parseInt(str)) ## 省略参数引发的 bug省略参数是 es6 之后提供的一个很好用也非常常用的功能。但还是有一些细节值得注意，不然一不小心就会出现 bug。 12345678910function test(num = 1) &#123; console.log(num)&#125;test() // (num is set to 1)test(undefined) // (num is set to 1 too)test('') // (num is set to '')test(null) // (num is set to null)test(false) // (num is set to false) 如上面 demo 所示，只有参数没传或者是 undefined 是才会生效，其它情况默认参数并不会起作用。所以有的时候你传入了&#39;&#39;空字符串是不行的，还需要自己手动判断一下。str = str || defalutString 另外，一个容易忽略的地方是，参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。 123456789let x = 99function foo(p = x + 1) &#123; console.log(p)&#125;foo() // 100x = 100foo() // 101 上面代码中，参数 p 的默认值是 x + 1。这时，每次调用函数 foo，都会重新计算 x + 1，而不是默认 p 等于 100。 多余逗号引发的错误刚入前端的时候看错误日志，ie 的错误日志特别多，一直没找到原因，后来发现是 JSON 最后一组键值后多逗号。 1234567891011// 所有浏览器都正常var json_normal = &#123; id: 1, name: "John"&#125;;// ie 报错，其它游览器正常var json_error = &#123; id: 1, name: "John",&#125;; 好在现在有了 eslint 或者 preitter这种工具，这种错误很少会再发生了。 js 中的逗号123if (((a = 1), a++, a)) &#123; console.log(a)&#125; 很多人一下子可能会一脸懵逼。但看一下 MDN 文档 就很清楚了 逗号操作符 对它的每个操作数求值（从左到右），并返回最后一个操作数的值。 举个例子var a=(1+1,2+2,3+3); 结果就是 6。 3+3但在函数中，比如比 Math.max(x,y,z)。这里的逗号就是分隔函数参数。还有声明变量时，var a=1,b=2,c=3。这里的逗号也是起分隔的作用。再举一个例子大家应该就理解了 1234567alert(2 * 5, 2 * 4)//输出10而不是8 函数接收第一个参数,也说明逗号级别比较低console.log(2 * 5, 2 * 4) // 10,8alert((2 * 5, 2 * 4))// 输出8 ()是返回了,相当于隐藏了return 所以返回最右边操作数的值console.log((2 * 5, 2 * 4));//8 其实最常见的运用场景就是平时经常的for循坏 1for (var i = 0, j = 9; i &lt;= 9; i++, j--) &#123;console.log(i,j)&#125; document.documentElement 与 document.body 区别在前端开发中，我们经常需要获取网页中滚动条滚过的长度，获取该值的方式一般通过scrollTop属性，如：document.body.scrollTop，或者document.documentElement.scrollTop，这两者都是经常用来获取文档滚动条滚过长度值的方式，他们又有什么区别呢？ 之前一直没注意，只到有一天发现了一个 bug:document.body.scrollTop 拿到的值一直是 0。在这个之前我们先来了解一下 是干嘛的？为什么每个页面都需要加上这段声明。 doctype 声明不属于 HTML 标签，它是一条指令，告诉浏览器编写页面所用的标记的版本。 这个声明的目的是防止浏览器在渲染文档时，切换到我们称为“怪异模式(兼容模式)”的渲染模式。&lt;!DOCTYPE html&gt; 能确保浏览器按照最佳的相关规范进行渲染，而不是使用一个不符合规范的渲染模式。 document.documentElement 与 document.body document 代表的是整个文档(对于一个网页来说包括整个网页结构) document.documentElement 是整个文档节点树的根节点，在网页中即 html 标签 document.body 是整个文档 DOM 节点树里的 body 节点，网页中即为 body 标签元素 但在标准模式下document.body.scrollTop是无效的。 从 Chrome 61 开始，标准模式中 document.scrollingElement 已被修正为 document.documentElement。换句话说，这个版本开始标准模式中 document.body.scrollTop 始终都等于 0。 所以这里建议使用兼容写法： 12345const scrollTop = Math.max( window.pageYOffset, document.documentElement.scrollTop, document.body.scrollTop) 或者 12345function getBodyScrollTop() &#123; const el = document.documentElement || document.scrollingElement || document.body return el.scrollTop&#125; 每当这时候我就有一些怀念jQuery了。 sort123var array = [3, 7, 2, 8, 2, 782, 7, 29, 1, 3, 0, 34]array.sort()// =&gt; [0, 1, 2, 2, 29, 3, 3, 34, 7, 7, 782, 8] 默认情况下，sort是按照Unicode code points排序的，换而言之，先回比较首个字符的 code point，若相同的情况下依次位数比下去。 所以很多时候我们需要自定义 sort 的规则。最常见的操作： 123const array = [3, 7, 2, 8, 2, 782, 7, 29, 1, 3, 0, 34]array.sort((pre, next) =&gt; pre - next)// =&gt; [0, 1, 2, 2, 3, 3, 7, 7, 8, 29, 34, 782] 其实它的规则很简单，你想让 next 和 pre 换位子就返回一个&gt;0的值，其它情况位置不变，即返回&lt;=0的值。 codePointAt vs charCodeAtJavaScript 允许采用\uxxxx形式表示一个字符，其中xxxx表示字符的 Unicode 码点。但是，这种表示法只限于码点在\u0000~\uFFFF 之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。 12'\uD842\uDFB7'// "𠮷" JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为 2 个字节。对于那些需要 4 个字节储存的字符（Unicode 码点大于 0xFFFF 的字符），JavaScript 会认为它们是两个字符。 1234567var s = '𠮷's.length // 2s.charAt(0) // ''s.charAt(1) // ''s.charCodeAt(0) // 55362s.charCodeAt(1) // 57271 所以 ES6 提供了 codePointAt 方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。 1'𠮷'.codePointAt() //134071 总之，codePointAt 方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与 charCodeAt 方法相同。 switch 作用域其实我们经常会忽略一个点，switch case 是共用一个作用域的。比如如下代码就会抛出重复定义的错误： 12345678910switch (x) &#123; case 0: let foo break case 1: let foo // 重复定义引起TypeError break&#125;// Uncaught SyntaxError: Identifier 'foo' has already been declared 解决方案也很简单，我们给每一个 case 加上一个 bracket 就可以了： 1234567891011switch (x) &#123; case 0: &#123; let foo break &#125; case 1: &#123; let foo // 重复定义引起TypeError break &#125;&#125; div 如何监听 keydown 事件之前有一个人问我，为什么他监听了一个 div 的 keydown 事件，为什么没有用？ 我看了一下代码发现的确没有写错？但为什么就不触发呢？后来查阅了一下文档 Focused element processing the key event, root element if no suitable input element focused 发现只有能被 focus 的元素才能出发键盘事件，所以 div 也就不能触发 keydown 事件了。那怎么才能让 div 支持呢？答案是 tabindex mdn。它表示元素是可聚焦的，并且可以通过键盘导航来访问到该元素。这样一来我们就能愉快的使用keydown事件了. try catch 的 finally 坑try…catch 的 finally 可能很多人都没有使用过，它其实和 promise 中的 finally 很类似。 见MDN。它无论是否有异常它都会执行。 常见的操作就是 将关闭弹窗或者 loading 1234567891011121314var fn = function() &#123; try &#123; console.log('ok') return 'ok' &#125; catch &#123; console.log('error') return 'error' &#125; finally &#123; console.log('finally') return 'finally' &#125;&#125;fn()// ok finally "finally" 我们发现最终输出了finally。因为这个语句只会有一个 return，finally 中的 return 覆盖了之前的定义。而且 return 会被放在最后执行。详情见。 1234567891011var fn = function() &#123; var res='' try &#123; res='ok' &#125; catch &#123; res='error' &#125; finally &#123; return res &#125;&#125;fn() //"ok" 不过最好还是和 promise 中的 finally 一样，在里面做一些没有副作用的事情。免得发生一些 bug。 atob 方法解码中文字符由于一些网络通讯协议的限制,你必须使用 window.btoa() 方法对原数据进行编码后，才能进行发送。接收方使用相当于 window.atob() 的方法对接受到的 base64 数据进行解码,得到原数据。 12345window.btoa('foo')// "Zm9v"window.atob('Zm9v')// "foo" atob 这个方法名称乍一看，很奇怪，不知道这个单词什么意思。我们可以理解为 A to B，也就是从 A 到 B。atob 表示 Base64 字符 to 普通字符，也就是 Base64 解码。当你在 Chrome console 中执行 window.btoa(&#39;中文&#39;)会发下会报错。 Uncaught DOMException: Failed to execute &#39;btoa&#39; on &#39;Window&#39;: The string to be encoded contains characters outside of the Latin1 range. 这时候我们可以借助 encodeURIComponent 和 decodeURIComponent 转义非中文字符。 12345window.btoa(encodeURIComponent('中文'))// ('JUU0JUI4JUFEJUU2JTk2JTg3')decodeURIComponent(window.atob('JUU0JUI4JUFEJUU2JTk2JTg3'))// "中文" Safari 下 Date 的坑在 使用 Date 相关 api 的时候要牢记一个坑，就是 Safari 对一些时间格式是不支持的。比如： 123Date.parse('2018-10-16 12:00:00')// 1539662400000 -- 在Chrome 下// NaN -- 在Safari下 问题就出在 Safari 对于这个格式 YYYY-MM-DD HH:MM:SS 无法解析，Safari 要求 Date.parse()或 Date()转换日期的字符串需要满足 RFC2822 或 ISO 8601 定义的格式。不过我们可以将其转化为 YYYY/MM/DD HH:MM:SS 1Date.parse(new Date('2018-10-16 12:00:00'.replace(/-/g, '/'))) 相关stackoverflow new Date 在 safari 的坑new Date(&#39;2019-06-04 00:00:00&#39;)在除了 Safari 的浏览器都能正常运行。 问题就出在 Safari 对于这个格式 YYYY-MM-DD HH:MM:SS 无法解析，所以我们需要做的是将其转化为 YYYY/MM/DD HH:MM:SS 1+new Date('2019-06-04 00:00:00'.replace(/-/g, '/')) e.target 与 e.currentTarget 的区别有一次在面试的时候问了事件委托的题目，面试人说了一个 currentTarget，突然发现target和currentTarget的区别我好像有些忘记了，太多相似的 api 和属性了。 首先我们来看一下 MDN 上对它们的解释 target：一个触发事件的对象的引用， 当事件处理程序在事件的冒泡或捕获阶段被调用时。 currentTarget： 当事件遍历 DOM 时，标识事件的当前目标。它总是引用事件处理程序附加到的元素，而不是 event.target，event.target 标识事件发生的元素。 可能还是很抽象 ，这里提供一个在线demo。 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width"&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;li&gt;hello 1&lt;/li&gt; &lt;li&gt;hello 2&lt;/li&gt; &lt;li&gt;hello 3&lt;/li&gt; &lt;li&gt;hello 4&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;const ul = document.querySelectorAll('ul')[0]ul.addEventListener('click', function(e) &#123; let oLi1 = e.target let oLi2 = e.currentTarget console.log(oLi1.tagName); // 被点击的li console.log(oLi2.tagName); // ul console.log(oLi1 === oLi2); // false&#125;);&lt;/script&gt; 也就是说，currentTarget 始终是监听事件者，而 target 是事件的真正发出者。 函数变量必填校验这里分享一个平时写 ES6 的时候一个小技巧。如何简单的校验并强制在使用这个函数时必须传参数。 12345678910const isRequired = () =&gt; &#123; throw new Error('Missing parameter')&#125;const foo = (something = isRequired()) =&gt; &#123; console.log(something) return something&#125;foo(123)foo() // Error:Missing parameter 前端错误处理错误处理对于任何前端来说都是必不可少的。任何人写代码都避免不了会有 bug，而且很多 bug 也不是测试用例能完全覆盖的，如果我们没有一个完整的错误处理和错误收集的系统，我们都无法知道我们有 bug，不仅如此，很多 bug 也不一定是前端的问题，比如某个接口返回的数据格式不对了或者少字段了，亦或是在某个特定的浏览器型号上才有的问题等等。而且有了错误处理和收集，我们也才能更好的通过错误栈来还原这个问题。 有哪些错误需要处理 JS 语法错误、代码异常 请求错误 静态资源加载异常 Promise 异常 页面崩溃和卡顿Try Catchtry-catch 只能捕获到同步的运行时错误，对语法和异步错误却无能为力，捕获不到。 1.同步运行时错误： 同步错误 123456try &#123; let name = 'foo' console.log(nam)&#125; catch (e) &#123; console.log('捕获到异常：', e)&#125; 捕获到异常： ‘ReferenceError: nam is not defined at :3:15’ 语法错误 123456try &#123; let name = 'foo console.log(nam)&#125; catch (e) &#123; console.log('捕获到异常：', e)&#125; Uncaught SyntaxError: Unexpected identifier 异步错误 1234567try &#123; setTimeout(() =&gt; &#123; undefined.map(v =&gt; v) &#125;, 1000)&#125; catch (e) &#123; console.log('捕获到异常：', e)&#125; 每次的数都不一样，运行一次就加1Uncaught TypeError: Cannot read property ‘map’ of undefined window.onerror当 JS 运行时错误发生时，window 会触发一个 ErrorEvent 接口的 error 事件，并执行 window.onerror()。 12345678910/** * @param &#123;String&#125; message 错误信息 * @param &#123;String&#125; source 出错文件 * @param &#123;Number&#125; lineno 行号 * @param &#123;Number&#125; colno 列号 * @param &#123;Object&#125; error Error对象（对象） */window.onerror = function(message, source, lineno, colno, error) &#123; console.log('捕获到异常：', &#123; message, source, lineno, colno, error &#125;)&#125; 不同域名下的 js 报错不能被 全局的 window.onerror 监听到，我们需要给相关的 js 文件上加上 Access-Control-Allow-Origin:*的 response header，并且引用相关的 js 文件时加上 crossorigin 属性。相关文章 在实际的使用过程中，onerror 主要是来捕获预料之外的错误，而 try-catch 则是用来在可预见情况下监控特定的错误，两者结合使用更加高效。 window.addEventListener当一项资源（如图片或脚本）加载失败，加载资源的元素会触发一个 Event 接口的 error 事件，并执行该元素上的 onerror() 处理函数。这些 error 事件不会向上冒泡到 window ，不过（至少在 Firefox 中）能被单一的 window.addEventListener 捕获。 123456&lt;img src="./foo.png"&gt;&lt;scritp&gt;window.addEventListener('error', (error) =&gt; &#123; console.log('捕获到异常：', error);&#125;, true)&lt;/script&gt; Promise Catch没有写 catch 的 Promise 中抛出的错误无法被 onerror 或 try-catch 捕获到，所以我们务必要在 Promise 中不要忘记写 catch 处理抛出的异常。或者可以全局增加一个对 unhandledrejection 的监听，用来全局监听 Uncaught Promise Error。使用方式： 123window.addEventListener('unhandledrejection', function(e) &#123; console.log(e)&#125;) 当然你如果使用如 axios 这种库的话，错误处理完全可以放在它的请求实例里面做。更加的灵活。 VUE errorHandler123456Vue.config.errorHandler = (err, vm, info) =&gt; &#123; console.error('通过vue errorHandler捕获的错误') console.error(err) console.error(vm) console.error(info)&#125; React 异常捕获123componentDidCatch(error, info) &#123; console.log(error, info);&#125; 崩溃和卡顿相关文章 实践总结】优雅的处理 vue 项目异常 insertBefore 坑Node.insertBefore()很多人都用过， 它在参考节点之前插入一个节点作为一个指定父节点的子节点。 var insertedNode = parentNode.insertBefore(newNode, referenceNode); 但看文档还有一句补充说明： 如果 referenceElement 为 null 则 newElement 将被插入到子节点的末尾。如果 newElement 已经在 DOM 树中，newElement 首先会从 DOM 树中移除。 这就很坑了，如下面的例子： 12345678910&lt;div id="parentElement"&gt; &lt;span id="bar"&gt;bar&lt;/span&gt; &lt;span id='foo'&gt;foo&lt;/span&gt;&lt;/div&gt;&lt;script&gt;var foo = document.getElementById("foo")var bar = document.getElementById("bar")var parentDiv = document.getElementById("parentElement")parentDiv.insertBefore(foo, bar)&lt;/script&gt; 原本以为结果是 foo bar foo，但实际结果是foo bar。因为根据文档，当你 insertBefore 的是一个已存在的值时，会移动它而不是拷贝它重新插入。贼坑！！！如果使用 ES6 的话可以使用 before 123var foo = document.getElementById('foo')var bar = document.getElementById('bar')bar.before(foo) ## 为什么前端监控要用 GIF 打点目前主流的前端监控数据上报都是采用 GIF 的上报方式，(百度统计/友盟/谷歌统计）都是这样实现的。但为什么一定要使用 GIF 呢？不能发 post 请求或者通过 script 标签的形式么？当然你也可以使用一些黑科技的方式上报，用纯 css 来实现。但这种方案并没有什么特别的好处。 123.track-xx:active:after &#123; content: url(track.php?xxxx=foo);&#125; ### 主要原因 没有跨域问题 不会阻塞页面加载，影响用户体验 在所有图片中体积最小，相较 BMP/PNG，可以节约 41%/35%的网络资源 详情见 为什么前端监控要用 GIF 打点 使用方式但建议不要按如下方法使用 1new Image().src = 'https://foo.com/bar.gif?t=xxxx&amp;b=1' 这段代码的问题是这个 new Image()是一个没有引用的临时变量，随时可能被浏览器的垃圾回收机制回收。如果这个图片的 HTTP 请求尚未建立，那么在被回收时这个请求就会被取消，导致打点并没有真正发出。如果打点所在的页面比较复杂，浏览器垃圾回收机制可能会被频繁触发，那么这种方式打点的丢失率可能会高达 10%以上。 解决方法很简单，将这个图片赋值给一个全局变量即可，例如： 12345678910const img = new Image()const key = +new Date() //加一个时间戳，防止图片被浏览器缓存了，不再发送请求 "+"转换时间戳window[t] = imgimg.onload = img.onerror = img.onabort = function() &#123; // img标签加载完成、错误或终止时，解除事件绑定，销毁相关对象 img.onload = img.onerror = img.onabort = null window[key] = null img = null&#125;img.src = `$&#123;url&#125;?t=key` ### 其它方案Beacon API 在空闲的时候异步发送统计，不影响页面诸如 JS、CSS Animation 等执行 即使页面在 unload 状态下，也会异步发送统计，不影响页面过渡/跳转到下跳页 能够被客户端优化发送，尤其在 Mobile 环境下，可以将 Beacon 请求合并到其他请求上，一同处理 Object.create(null) vs {}查看 vue 的源码 或者一些开源项目的源码，发现不少地方都是使用 Object.create(null)来创建一个空对象的。当使用语句 const obj = {}; 创建对象时，它其实并不是一个真的空对象，它从 Object.prototype 上继承了一些方法： hasOwnProperty isPrototypeOf propertyIsEnumerable toString/toLocaleString valueOf 如果使用 Object.create(null) 创建的对象，在没有继承任何东西。 所以说是不是 Object.create(null) 是更好的创建一个空对象的方案呢？这就要看从 Object 上继承的那些方法我们是不是有用到了。 hasOwnProperty判断一个对象属性中是否具有指定的属性，返回 true or false。 valueOfvalueOf 很少直接使用。在隐式转换类型时，JavaScript 引擎会调用 valueOf 方法，强制把对象转换成原始值 toString、isPrototypeOf 和 propertyIsEnumerable这几个方法直接使用的情况较少，但自己的代码中不用并不表示别人写的代码不会调用。比如，有些框架可能会调用 toString 方法来判断结果是否为 [object Object]。 结论因此，我们可以得出结论：当创建的对象只在当前执行环境中使用并且不会用到任何从 Object.prototype 上继承来的方法，也不会将该对象作为其他对象的原型的时候，那么可以使用 Object.create(null)。比如，构造一个字典对象的时候。不过相对而言 const obj={}在浏览器中的执行速度是会比Object.create(null)快的，具体可点击链接test。不过你一般代码中这些性能差距完全是可以忽略不计的。 async/await with forEach()之前在工作中遇到了一个需求，实现一个简单的请求队列，大概意思就是这个页面有一个 list，我需要按 list 顺序依次发请求，多数据做一些操作，每次等前一个请求成功之后，再执行下一个，全部执行完毕之后，显示已完成。这不就是用 async/await就可以实现了。于是写了如下代码： 123456const waitFor = ms =&gt; new Promise(r =&gt; setTimeout(r, ms));[1, 2, 3].forEach(async num =&gt; &#123; await waitFor(1000) console.log(num)&#125;)console.log('Done') What？为什么await没有生效，直接就输出了1,2,3？谷歌搜索了一下，发现原来是forEach的锅。 我们简单来看一下 forEach的实现原理： 1234567Array.prototype.forEach = function(callback) &#123; // this represents our array for (let index = 0; index &lt; this.length; index++) &#123; // We call the callback for each entry callback(this[index], index, this) &#125;&#125; 我们可以看到它只是 for 循环的一个简单封装，而且在内部它只是简单做了一个回调，根本就不会wait。其实一些其它的数组方式比如map、reduce等等也是不支持的，因为 Array 的迭代方法就支持不支持参数函数返回 promise 的异步用法，有兴趣的可以自行了解。那我们直接用 for循环不就好了 1234567async function test() &#123; for (let index = 0; index &lt; [1, 2, 3].length; index++) &#123; await waitFor(1000) console.log(index) &#125; console.log('done')&#125; 或者 for-of更为简单 1234567async function test() &#123; for (let i of [1, 2, 3]) &#123; await waitFor(1000) console.log(i) &#125; console.log('done')&#125; 获取元素宽度说真的，我觉得前端麻烦的地方就是 API 太多了，我只是想获取一个元素的宽度居然有getBoundingClientRect().width 我使用 Async/Await 而不使用 Promises 的六个理由本文主要来自于 6 Reasons Why JavaScript’s Async/Await Blows Promises Away，在 medium 上，需要翻墙阅读。之前我很长一段时间内都是使用 promise 的，但遇到一些复杂业务的时候，发现还是写起来会很不爽，代码阅读性也有所欠缺。 简洁 对比 Promise，我们不需要书写.then，不需要新建一个匿名函数处理响应，也不需要再把数据赋值给一个我们其实并不需要的变量 a 但 Async/Await 也不是没有缺点的，很多人经常会错用它。比如我一个组件创建的的时候会异步向服务器发送三个请求，a、b、c。 很多人会这么写 123456async function mount() &#123; const resultA = await fetch('A') const resultB = await fetch('B') const resultC = await fetch('C') render(resultA, resultB, resultC)&#125; 虽然上面的这段写法相对于 promise 简洁了不少，但效率来说是不合格的。因为这个请求是异步的，毫无联系的，所有没必要顺序请求，他们三个明显可以异步并发的去请求。要想实现真正的异步，还是需要依赖 Promise.all 封装一层： 12345678async function mount() &#123; const result = await Promise.all( fetch('a.json'), fetch('b.json'), fetch('c.json') ) render(...result)&#125; 未完待续…]]></content>
  </entry>
  <entry>
    <title><![CDATA[Virtual DOM 性能好？]]></title>
    <url>%2F2019%2F06%2F14%2Fyuque%2FVirtual%20DOM%20%E6%80%A7%E8%83%BD%E5%A5%BD%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[每次面试，面试人一谈到 react 就必然会谈到 Virtual DOM，一谈到 Virtual DOM 就会说它比原生操作 DOM 性能哪里哪里好。但任何一个 v-dom 框架都不会说自己的性能快过 DOM 操作。就拿 react 为例子，它的目标是：“每次数据变化都以最小的代价来更新真实 DOM”。引入 v-dom，在内存中比较虚拟节点，然后找出不同，之后执行更新。就能更改页面上一个元素的内容，直接操作 DOM 的反应速度绝对会比你 diff 一次之后再更新来的快。但这时你可能会觉得当程序到达一定的复杂度之后，v-dom 性能上的优势才能体现出来。但是，无论你代价再少也好，v-dom 都是有消耗的，光从你要生成整个页面的 v-dom 就会比单单生成原生 dom 要多消耗一大截内存，更别说其中的复杂递归，比对，然后再变换。但是！它依然是纯 js 层面的计算，比起后面的 DOM 操作来说，依然便宜了太多。所以 v-dom 真正的价值是什么？框架给你的保证是，你在不需要手动优化的情况下，我依然可以给你提供过得去的性能。我认为是带来了跨屏能力，以及代码的可维护性， 同时为函数式的 UI 编程方式打开了大门。]]></content>
  </entry>
  <entry>
    <title><![CDATA[垃圾回收]]></title>
    <url>%2F2019%2F06%2F14%2Fyuque%2F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%2F</url>
    <content type="text"><![CDATA[作为编写程序的人，是可以做出“这个对象已经不再需要了”这样的判断，但计算机是做不到的。因此，如果程序（通过某个变量等等）可能会直接或间接地引用一个对象，那么这个对象就被视为“存活”；与之相反，已经引用不到的对象被视为“死亡”。将这些“死亡”对象找出来，然后作为垃圾进行回收，这就是 GC 的本质。 三大基础 GC 算法 引用计数法 它的基本原理是，在每个对象中保存该对象的引用计数，当引用发生增减时对计数进行更新。引用计数的增减，一般发生在变量赋值、对象内容更新、函数结束（局部变量不再被引用）等时间点。当一个对象的引用计数变为 0 时，则说明它将来不会再被引用，因此可以释放相应的内存空间。 引用计数最大的缺点，就是无法释放循环引用的对象。 标记清除法/标记压缩法这个算法假定设置一个叫做根（root）的对象（在 Javascript 里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象从 2012 年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对 JavaScript 垃圾回收算法的改进都是基于标记-清除算法的改进，并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义。标记清除算法有一个缺点，就是在分配了大量对象，并且其中只有一小部分存活的情况下，所消耗的时间会大大超过必要的值，这是因为在清除阶段还需要对大量死亡对象进行扫描。 复制收集算法在这种算法中，会将从根开始被引用的对象复制到另外的空间中，然后，再将复制的对象所能够引用的对象用递归的方式不断复制下去。但是，和标记相比，将对象复制一份所需要的开销则比较大，因此在“存活”对象比例较高的情况下，反而会比较不利。这种算法的另一个好处是它具有局部性（Lo-cality）。在复制收集过程中，会按照对象被引用的顺序将对象复制到新空间中。于是，关系较近的对象被放在距离较近的内存空间中的可能性会提高，这被称为局部性。局部性高的情况下，内存缓存会更容易有效运作，程序的运行性能也能够得到提高。 分代回收V8 引擎将保存对象的 堆 (heap) 进行了分代: 对象最初会被分在 新生区(New Space) (1~8M)，新生区的内存分配只需要保有一个指向内存区的指针，不断根据内存大小进行递增，当指针达到新生区的末尾，会有一次垃圾回收清理(小周期)，清理掉新生区中不再活跃的死对象。 对于超过 2 个小周期的对象，则需要将其移动至 老生区(Old Space)。老生区在 标记-清除 或 标记-紧缩 的过程(大周期) 中进行回收。 大周期进行的并不频繁。一次大周期通常是在移动足够多的对象至老生区后才会发生参考： JavaScript 垃圾回收机制 GC 的三大基础算法]]></content>
  </entry>
  <entry>
    <title><![CDATA[nodejs]]></title>
    <url>%2F2019%2F06%2F13%2Fyuque%2Fnodejs%2F</url>
    <content type="text"><![CDATA[npx npm 从 5.2 版开始，增加了 npx 命令。它有不少用处，但很多人其实又不知道它是个什么，该如何正确的使用它。Node 自带 npm 模块。所以你只要安装了 node，你就可以直接使用它了，不需要什么额外的操作。 一、方便调用 方便的调用了项目内部安装的模块。比如我项目内安装了测试工具 Mocha。 1npm install -D mocha 一般来说，调用 Mocha ，只能在项目脚本和 package.json 的 scripts 字段里面， 如果想在命令行下调用，必须像下面这样。 12# 项目的根目录下执行node-modules/.bin/mocha npx 就是想解决这个问题，让项目内部安装的模块用起来更方便，只要像下面这样调用就行了。 1npx mocha 它的原理也很简单：运行的时候会到node_modules/.bin路径和环境变量$PATH里面，检查命令是否存在。 二、避免全局安装 可以避免全局安装模块。 比如，你要用 react 的脚手架create-react-app它是需要全局安装的，但你其实也只有在初始化的时候需要用到它，大部分时间它是使用不到的。 但用了 npx 之后，就不需要全局安装它了。你可以使用 npx 直接运行它。 1npx create-react-app my-react-app 三、指定版本 可以指定你要运行模块的版本。 比如你本地环境是 node10 的，但你想用 node11 的环境执行一段脚本。(当然你也可以 nvm 本地管理多个 node 版本) 1npx -p node@11.9.0 node -v]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue面试题]]></title>
    <url>%2F2019%2F06%2F13%2Fyuque%2Fvue%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[很多人面试会问啥 vue 实现原理，但我觉得这略过分，有多少人会老老实实看过它的源码。但我觉得面者这也只是知道 vue 双向绑定的原理吧。 发布者-订阅者模式（backbone.js） 一般通过 sub, pub 的方式实现数据和视图的绑定监听，更新数据方式通常做法是 vm.set(‘property’, value)，这种方式现在毕竟太 low 了，我们更希望通过 vm.property = value 这种方式更新数据，同时自动更新视图，于是有了下面两种方式 脏值检查（angular.js） angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然 Google 不会这么 low，angular 只有在指定的事件触发时进入脏值检测，大致如下： DOM 事件，譬如用户输入文本，点击按钮等( ng-click ) XHR 响应事件 ( $http ) 浏览器 Location 变更事件 ( $location ) Timer 事件( $timeout , $interval ) 执行 $digest() 或 $apply() 数据劫持（vue.js） vue.js[2.0] 则是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 vue.js[3.0]采取了 proxy 的方式]]></content>
  </entry>
  <entry>
    <title><![CDATA[React面试题]]></title>
    <url>%2F2019%2F06%2F13%2Fyuque%2FReact%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[React面试题&amp;回答 React在使用 react 的过程中，我们绕不开渲染性能优化问题，因为默认情况下 react 组件的 shouldComponentUpdate 函数会一直返回 true，这回导致所有的组件都会进行耗时的虚拟 DOM 比较。在使用 redux 作为 react 的逻辑层框架时，我们可以使用经典的 PureComponent+ShallowCompare 的方式进行渲染性能优化https://foio.github.io/mobx-react/ MobX作为一个数据层框架，mobx 基于一个最简单的原则： 当应用状态更新时，所有依赖于这些应用状态的监听者（包括 UI、服务端数据同步函数等），都应该自动得到细粒度地更新。 在使用 mobx 作为 react 的 store 时，我们该如何进行渲染性能优化呢？ 通过分析源代码发现，在使用@observer 将 react 组件转换成一个监听者(Reactions)后，mobx 会为 react 组件提供一个精确的、细粒度的 shouldComponentUpdate 函数: 123456789shouldComponentUpdate: function(nextProps, nextState) &#123; ...... // update on any state changes (as is the default) if (this.state !== nextState) &#123; return true; &#125; // update if props are shallowly not equal return isObjectShallowModified(this.props, nextProps);&#125; 借助于 mobx 框架对 Observable 变量引用的跟踪和依赖收集，mobx 能够精确地得到 react 组件对 Observable 变量的依赖图谱，然后再用经典的 ShallowCompare 实现细粒度的 shouldComponentUpdate 函数，以达到 100%无浪费 render。这一切都是自动完成地，fantastic！使用 mobx 后，我们再也无需手动写 shouldComponentUpdate 函数了。 React Native 优势 跨平台 （只有 0.2% 的平台特定代码） 统一的设计语言，同时还能为不同平台提供不同设计 React 的 scale 很好。组件化，简单的生命周期,声明式 迭代速度快（主要是 hot reloading 很快） 大量基础设施的投入值得（网络、国际化、复杂动画、设备信息、用户信息等等都是通过一- 个桥把原生 api 暴露给 RN 的。） 同时他们在这里也指出：他们并不相信在一个已有 app 上集成 RN 是一件简单事儿，必须- 要大量且持续地投入基础设施才行（说好的「满意的地方」呢） 性能 （尽管大家都担心但是其实基本没有问题） 不过首次渲染比较慢，导致不适合用作启动屏、deeplink，也增加了可交互时间（TTI），另外掉帧不好 debug（说好的「满意的地方」呢） Redux（好用，虽然废话太多） 背后是原生，一些曾经不确定能不能做的功能（Shared element transitions、动画库 Lottie、网络层、核心基础设施）发现都能做 静态分析（eslint，prettier，一些性能检测） 动画 JS/React 的开源生态 Flexbox 有时候可以加上 Web 跨三端 劣势 论成熟度，稳定性，RN 比 不上 iOS 和 Android 原生。 由于 RN 的 Bug，有时我们必须维护自己的一个 RN 分支。 JS 缺少类型系统，Flow 太严格，TS 集成到已有项目也还有问题。 不好重构（JS 没有类型无法静态分析，重构引起的错误不能在编译时被捕捉到） JavaScriptCore 不一致性，更糟糕的是，现在都 8102 年了，RN （Android）带的还是不支持 ES 6 的 JSC RN 开源库质量参差不齐。比如在 iOS 上正常的库在 Android 上可能有意想不到的错误（因为为作者也许只熟悉 iOS 和 RN,并不熟悉 Android） 有时不得不白手起家，因为很多的基础框架中的库还没有 的 RN 封装。 崩溃监控库在 RN 上表现不是特别特定业。内没方案，只能自己搞。 Native Bridge 的由于 JS 的弱类型造成 Native 与 JS 通信 中类型的不匹配，容易造成错误。 启动时间，RN 框架初始化需要几秒，即使是在高端机器上。 新开页面的渲染时间，0.4 秒左右页面第一次渲染费时。 APP 大小。至少增加 12M。 直到目前都无法在 Android 上支持 64 位。 手势，iOS 和 Android 的手势 API 差距很大，不过喜闻 react-native-gesture-handler 发布了 1.0 版本。 长列表，虽然 RN 团队很努力了，但是由于 RN 的异步通信机制，长列表的流畅渲染，目前依然无解。 React Native 升级是个坑。 RN 中的 Accessibility 就是个大坑。 还有一些奇怪的 Bug，暂没有修复。 SavedInstanceState 在 Android 上跨进程的坑。 不是技术问题的问题 要用好 RN 你必须同时熟悉 iOS 和 Android ，当然还有 RN 本身，这就对我们工程师提出了更多挑战。 团队的管理，责任的划分。 RN 文档及相关资源不如 iOS 和 Android 的丰富。 面试题reactjs-interview-questions]]></content>
  </entry>
  <entry>
    <title><![CDATA[网络面试题]]></title>
    <url>%2F2019%2F06%2F13%2Fyuque%2F%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[WebSocket WebSocket 与 HTTP 什么关系呢？简单来说，WebSocket 是一种协议，是一种与 HTTP 同等的网络协议，两者都是应用层协议，都基于 TCP 协议。但是 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。 WebSocket 与 Socket网络应用中，两个应用程序同时需要向对方发送消息的能力（即全双工通信），所利用到的技术就是 socket，其能够提供端对端的通信。对于程序员而言，其需要在 A 端创建一个 socket 实例，并为这个实例提供其所要连接的 B 端的 IP 地址和端口号，而在 B 端创建另一个 socket 实例，并且绑定本地端口号来进行监听。当 A 和 B 建立连接后，双方就建立了一个端对端的 TCP 连接，从而可以进行双向通信。WebSocekt 是 HTML5 规范中的一部分，其借鉴了 socket 的思想，为 client 和 server 之间提供了类似的双向通信机制。同时，WebSocket 又是一种新的应用层协议，包含一套标准的 API；而 socket 并不是一个协议，而是一组接口，其主要方便大家直接使用更底层的协议（比如 TCP 或 UDP） 什么是 Socket.IOSocket.IO 是一个封装了 Websocket、基于 Node 的 JavaScript 框架，包含 client 的 JavaScript 和 server 的 Node。其屏蔽了所有底层细节，让顶层调用非常简单。另外，Socket.IO 还有一个非常重要的好处。其不仅支持 WebSocket，还支持许多种轮询机制以及其他实时通信方式，并封装了通用的接口。这些方式包含 Adobe Flash Socket、Ajax 长轮询、Ajax multipart streaming 、持久 Iframe、JSONP 轮询等。换句话说，当 Socket.IO 检测到当前环境不支持 WebSocket 时，能够自动地选择最佳的方式来实现网络的实时通信。 WebSocket VS SSE(Server-Sent Events)Server-sent Events 其实很多人都不知道这东西，但其实肯定用过的，webpack-hot-middleware就是运用该原理进行热更新的，当然webpack-dev-server使用的是 WebSocket。SSE 与 WebSocket 作用相似，都是建立浏览器与服务器之间的通信渠道，然后服务器向浏览器推送信息。总体来说，WebSocket 更强大和灵活。因为它是全双工通道，可以双向通信；SSE 是单向通道，只能服务器向浏览器发送，因为流信息本质上就是下载。如果浏览器向服务器发送信息，就变成了另一次 HTTP 请求。但是，SSE 也有自己的优点。 SSE 使用 HTTP 协议，现有的服务器软件都支持。WebSocket 是一个独立协议。 SSE 属于轻量级，使用简单；WebSocket 协议相对复杂。 SSE 默认支持断线重连，WebSocket 需要自己实现。 SSE 一般只用来传送文本，二进制数据需要编码后传送，WebSocket 默认支持传送二进制数据。 SSE 支持自定义发送的消息类型。 相关补充文章 Server-Sent Events-阮一峰 WebSockets vs. Server-Sent events/EventSourceWebSocket 推荐阅读文章WebSocket 是什么原理？TCP VS UDPTCP UDP 这两个东西已经是老生常谈了，基本每个面试都会问一下，还不了解的赶快去补习一下。但发现一个问题，大家都只是知道这两者的区别是什么，完全不知道他们各自的应用场景是什么？UDP 场景： 实时音视频是可以而且应该用 UDP 的，一方面因为它常常涉及到网络穿透，另外一方面它不需要重传。——我需要实时的看到你的图像跟声音，至于中间丢一帧什么的完全不重要。而为了重传往往会造成延迟与不同步，考虑一下，某一帧因为重传，导致 0.5 秒以后才到，那么整个音视频就延迟了 0.5 秒。考虑一下接收方看视频，如果使用 TCP 导致视频的中间延迟了 0.5 秒，只要我不按「快进」键，那么后续的视频全都会比发送方延迟 0.5 秒。这种延迟是累加的，随着持续丢帧，延迟会越来越大，达到数秒，甚至分钟级，这会严重影响实时音视频的用户体验。因此「实时音视频聊天」功能通常都会使用 UDP 实现。 网络真的非常非常可靠，以至于你完全不需要考虑 UDP 丢包问题的情况。典型的例子应该是专门为有线局域网设计的协议。 另外一个问题是 TCP 是纯粹的流式数据，所以制定传输协议的时候，接受方需要自行判定一个包的开始和结束，因为你完全可能接受到半个包或者两个包。——如果数据报的起止判定对你具体的程序会成为大问题，也可以考虑 UDP。 采用 UDP 有 3 个关键点： 网络带宽需求较小，而实时性要求高 大部分应用无需维持连接 需要低功耗]]></content>
  </entry>
  <entry>
    <title><![CDATA[常规面试题]]></title>
    <url>%2F2019%2F06%2F13%2Fyuque%2F%E5%B8%B8%E8%A7%84%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[事件委托应该是前端最经常问的一个问题。 但其实里面有非常非常多的知识点可以考察。 css last-of-type last-child 事件委托的好处 addEventListener 第三个参数 实现 index 类数组 =&gt; 数组 querySelectorAll 方法相比 getElementsBy 系列方法有什么区别 HTMLCollection NodeList 区别 https://www.zhihu.com/question/24702250 12345678const ul = window.document.getElementsByTagName('ul')[0]ul.addEventListener('click', e =&gt; &#123; const children = [...ul.getElementsByTagName('li')] //htmlCollection =&gt; array if (e.target &amp;&amp; e.target.nodeName.toLowerCase() === 'li') &#123; const index = children.indexOf(e.target) console.log(index) &#125;&#125;) 一道有意思的面试题 100*100 的 canvas 占多少内存？ 你有必要知道的几个 JavaScript 面试题 1. 使用 typeof bar === “object” 判断 bar 是不是一个对象有神马潜在的弊端？如何避免这种弊端？大部分情况下 typeof 是可信的，但 js 就是这样不靠谱，总是有一些边缘 case。 1234567typeof &#123;&#125; //'object'typeof [] //'object'typeof null //'object'typeof new String() //'object'typeof NaN //'number'const var reg = /pop/gtypeof reg //'object' 这时候你可以说使用 instanceof。但 instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型。 简而言之就是 123'' instanceof String //falsenew String() instanceof String //truenew String() instanceof Object //true 只有使用构造函数创建的基本类型可以正确显示。所以到底有没有靠谱的校验类型方法？答案是有的 详情见玉伯的分享 12345678910111213var toString = Object.prototype.toStringfunction isObject(obj) &#123; return toString.call(obj) === '[object Object]'&#125;function isString(obj) &#123; return toString.call(obj) === '[object String]'&#125;function isArray(obj) &#123; return toString.call(obj) === '[object Array]'&#125;function isFunction(obj) &#123; return toString.call(obj) === '[object Function]'&#125; 附加问题： 我们知道 typeof new String(“xxx”) 返回 “object”，请问 typeof String(“xxx”) 返回什么？为什么？ 返回”string”，因为直接调用 String 返回的是一个字符串，而 new String 返回的是一个 String 对象。2. 下面的代码会在 console 输出神马？为什么？12345;(function() &#123; var a = (b = 3)&#125;)()console.log(typeof a)console.log(b) 12console.log(typeof a) //undefinedconsole.log(b) //3 这题是以前比较常见的变量提升的问题 它实际执行步骤是这样子的 12b = 3var a = b 并且 b 变成一个全局变量，而 a 还是一个局部变量，所以你在外部 console 是会报错的。 3. 下面的代码会在 console 输出神马？为什么？12345678910111213var myObject = &#123; foo: 'bar', func: function() &#123; var self = this console.log('outer func: this.foo = ' + this.foo) console.log('outer func: self.foo = ' + self.foo) ;(function() &#123; console.log('inner func: this.foo = ' + this.foo) console.log('inner func: self.foo = ' + self.foo) &#125;)() &#125;&#125;myObject.func() 这题是最简单的作用域问题，没啥好讨论的了。 4. 将 JavaScript 代码包含在一个函数块中有神马意思呢？为什么要这么做？换句话说，为什么要用立即执行函数表达式（Immediately-Invoked Function Expression）。IIFE 有两个比较经典的使用场景，一是类似于在循环中定时输出数据项，二是类似于 JQuery/Node 的插件和模块开发。 12345for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(i) &#125;, 1000)&#125; 上面的输出并不是你以为的 0，1，2，3，4，但输出的全部是 5，这时 IIFE 就能有用了： 1234567for (var i = 0; i &lt; 5; i++) &#123; ;(function(i) &#123; setTimeout(function() &#123; console.log(i) &#125;, 1000) &#125;)(i)&#125; ES6 的话，可以用 let 12345for (let i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(i) &#125;, 1000)&#125; 而在 JQuery/Node 的插件和模块开发中，为避免变量污染，也是一个大大的 IIFE： 123;(function($) &#123; //代码&#125;)(jQuery) 5. 在严格模式(‘use strict’)下进行 JavaScript 开发有神马好处？ 消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的 Javascript 做好铺垫。6. 下面两个函数的返回值是一样的吗？为什么？1234567891011function foo1() &#123; return &#123; bar: 'hello' &#125;&#125;function foo2() &#123; return &#123; bar: 'hello' &#125;&#125; 对于 return 、break、continue 等语句，如果后面紧跟换行，解析器一定会自动在后面填充分号(😉，所以上面的第二个函数就直接被 return了。所以第二个函数是返回 undefined。 7. 神马是 NaN，它的类型是神马？怎么测试一个值是否等于 NaN?NaN 是 Not a Number 的缩写，JavaScript 的一种特殊数值，其类型是 Number，可以通过 isNaN(param) 来判断一个值是否是 NaN： 12345678910console.log(isNaN(NaN)) //trueconsole.log(isNaN(23)) //falseconsole.log(isNaN('23')) //false 因为执行的时候先回转化为数字 所以 '23'=&gt; 23console.log(isNaN('ds')) //trueconsole.log(isNaN('32131sdasd')) //true 先回 Number("123ABC") 结果是 NaNconsole.log(NaN === NaN) //falseconsole.log(NaN === undefined) //falseconsole.log(undefined === undefined) //falseconsole.log(typeof NaN) //numberconsole.log(Object.prototype.toString.call(NaN)) //[object Number] ES6 中，isNaN() 成为了 Number 的静态方法：Number.isNaN().它的 polyfill 实现起来也很简单–利用了 NaN 自身永不相等于自身这一特征 1234const isNaN = function(value) &#123; const n = Number(value) return n !== n&#125; 8. 解释一下下面代码的输出12console.log(0.1 + 0.2) //0.30000000000000004console.log(0.1 + 0.2 == 0.3) //false 另一道非常经典的面试题，js 精度问题 JavaScript 浮点数陷阱及解法JavaScript 存储任何数字都是遵循 IEEE-754 标准，使用 64 位固定长度来表示，也就是标准的 double 双精度浮点数。所以为什 0.1+0.2=0.30000000000000004？ 计算步骤为： 12345// 0.1 和 0.2 都转化成二进制后再进行运算0.00011001100110011001100110011001100110011001100110011010 +0.0011001100110011001100110011001100110011001100110011010 =0.0100110011001100110011001100110011001100110011001100111// 转成十进制正好是 0.30000000000000004 解决方案 你可以使用一些成熟的库如：big.js，bignumber.js。 或者对精度要求不高的情况下 直接 toFixed就可以了。不过注意它得到的值可能是不准确的。如：1.005.toFixed(2) 返回的是 1.00 而不是 1.01。原因： 1.005 实际对应的数字是 1.00499999999999989，在四舍五入时全部被舍去！ 9. 实现函数 isInteger(x) 来判断 x 是否是整数可以将 x 转换成 10 进制，判断和本身是不是相等即可： 123function isInteger(x) &#123; return parseInt(x, 10) === x&#125; 10. 在下面的代码中，数字 1-4 会以什么顺序输出？为什么会这样输出？12345678910;(function() &#123; console.log(1) setTimeout(function() &#123; console.log(2) &#125;, 1000) setTimeout(function() &#123; console.log(3) &#125;, 0) console.log(4)&#125;)() 最简单的运行提了，如果这都不会的话，真应该好好补习补习基础了。 11. 判断一个字符串是不是回文字符串12345678910function isPalindrome(str) &#123; str = str.replace(/\W/g, '').toLowerCase() return ( str == str .split('') .reverse() .join('') )&#125; 12. 写一个按照下面方式调用都能正常工作的 sum 方法12console.log(sum(2, 3)) // Outputs 5console.log(sum(2)(3)) // Outputs 5 13. 据下面的代码片段回答后面的问题12345678for (var i = 0; i &lt; 5; i++) &#123; var btn = document.createElement('button') btn.appendChild(document.createTextNode('Button ' + i)) btn.addEventListener('click', function() &#123; console.log(i) &#125;) document.body.appendChild(btn)&#125; 没啥难度，不说了 15. 下面的代码会输出什么？为什么？123456console.log(1 + '2' + '2')console.log(1 + +'2' + '2')console.log(1 + -'1' + '2')console.log(+'1' + '1' + '2')console.log('A' - 'B' + '2')console.log('A' - 'B' + 2) 这个主要考察的隐式转换，规则太多太复杂了，我也记不住，如果真有面试官问你这个的话，随缘吧。 16. 解释下列代码的输出1234console.log('0 || 1 = ' + (0 || 1))console.log('1 || 2 = ' + (1 || 2))console.log('0 &amp;&amp; 1 = ' + (0 &amp;&amp; 1))console.log('1 &amp;&amp; 2 = ' + (1 &amp;&amp; 2)) 运算符优先级的问题，这题同上，遇到就随缘吧，我反正搞不清也记不住。 17. 解释下面代码的输出12console.log(false == '0')console.log(false === '0') ==和===的区别，太基础略。 18.移动端问题 1. 你怎么提高一个长列表在手机端滑动的流畅度这里主要考察的是否知道 passive这个属性首先解释一下为什么会卡顿： 当你触摸滑动页面时，页面应该跟随手指一起滚动。而此时你绑定了一个 touchstart 事件，你的事件大概执行 200 毫秒。这时浏览器就犯迷糊了：如果你在事件绑定函数中调用了 preventDefault，那么页面就不应该滚动，如果你没有调用 preventDefault，页面就需要滚动。但是你到底调用了还是没有调用，浏览器不知道。只能先执行你的函数，等 200 毫秒后，绑定事件执行完了，浏览器才知道，“哦，原来你没有阻止默认行为，好的，我马上滚”。此时，页面开始滚。 题外话，这里也可以考察你对addEventListenerapi 的熟练度，很多人其实不知道addEventListener其实第三个参数除了可以传true or false，还可以传一个对象。 12345&#123; capture: Boolean, // 表示`listener`会在该类型的事件捕获阶段传播到该`EventTarget`时触发 once: Boolean, // 表示`listener`在添加之后最多只调用一次。如果是`true`，`listener`会在其被调用之后自动移除 passive: Boolean, // 表示`listener`永远不会调用`preventDefault()`。如果`listener`仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告&#125; 拓展：will-change 、pointer-events 19.用 setTimeout 实现 setIntervalrender props 和 HOC 的区别 purecomponent 柯里化 高阶函数 尾调用 vue 3.0 proxy Object.defineProperty 原因 线上版本回退 发布流程 开发生产环境区分 调试 dokder 持续集成 babel-polyfil babel-plugin-transform-runtime babel-preset-env htttp2 有哪些优势，对于前端来说会有什么影响？ 设计一个登录系统 es6 私有方法 WeakMap 顺序存储结构与链式存储结构的比较（也可以说的顺序表与链表的比较）HOC(高阶组件)和 Decorator(装饰器)的区别是什么？ 如何使用一个 Decorator 来修饰一个函数?https://github.com/sunyongjian/blog/issues/32iOS 下 input 无法自动聚焦的问题 手写实现以下事件委托函数 function delegate(parent, selector, handle) {}手写实现 inherit 函数 手写实现 throttle 函数请解释 XSS 与 CSRF 分别是什么，两者有什么联系？如何防御？ 手写代码实现一下 Array.prototype.trim 这个函数，并写个测试用例跑给我看下 面向切面编程和函数式编程听说过吗图灵完备理论知道吗？关于图灵的其他知识知道吗？ 如果一系列操作数据的规则（如指令集、编程语言、细胞自动机）可以用来模拟单带图灵机，那么它是图灵完备的。图灵机由以下几个部分组成： 一条无限长的纸带 TAPE。 一个读写头 HEAD。 一套控制规则 TABLE。 一个状态寄存器。 图片懒加载的两种实现形式 如何实现图片懒加载； 如何提高图片懒加载的效率； PWA 的原理； 如何写一个 PWA； getBoundingClientRect 方法的弊端； 前端性能优化有哪些； 静态资源加载和更新的策略； CDN 服务器的了解和使用；缓存静态资源的注意事项； history 路由和 hash 路由的区别, 在浏览器有什么影响； http 1.1 与 http 2 的区别； 遇到过什么 Webpack 上的坑； 什么是虚拟 DOM； 为什么虚拟 DOM 的操作比 DOM 更快； 谈一下你对 MVVM 的认识； 谈一下你对 Vue 的认识，以及 Vue 底层实现的机制； 写一个自定义事件系统，实现 on、off、emit API，要求可以同时触发多个事件，也可同时取消多个事件 使用 requestAnimationFrame 实现类似 setInterval 的计时器 实现一个类似百度的搜索框，就是一边输入内容，一边在一个下拉列表显示搜索结果，需要考虑哪些问题？ file-loader 和 url-loader 区别 淘宝 P6 前端要求，比较泛的能力描述，供参考： 掌握程序设计的一般性原则，能正确应用设计模式 提炼可复用组件，为类库贡献高质量代码；至少掌握一门后端语言，并有相关的开发使用经验 理解程序内部原理，能快速定位解决疑难杂症；通过开发、使用、推广效率工具让自己与团队的效率得到提高 有效跟进，能独立计划实施复杂项目，过程监控，有预案，保证结果 有效传达思想观念信息，把握别人的意图立场，快速与别人达成共识 积极的学习，并学以致用，甚至突破经验与常规思维方式，引入新的方法，流程等 精通各种前端技术（包括 HTML/CSS/JavaScript 等），熟悉 ES6 语法，具备跨终端（Mobile+PC）的前端开发能力，熟悉网络协议（HTTP/SSL），熟悉常见安全问题和对策； 熟悉前端工程化与模块化开发，并有实践经验（如 gulp/webpack、VueJS/React 等）； 熟悉 NodeJS，并有实践经验；熟悉一门非前端的语言（如 Java/C/C++ 等），加分； 有桌面客户端相关开发经验（如 Electron/VSCode Plugin 等），加分； 熟悉 TypeScript，并有较大项目实践经验，加分； 有独立的开源项目或者参与知名开源项目经验，加分； 百度阿里网易大疆等大小厂前端校招面筋 如何轻松拿到淘宝前端 offer]]></content>
  </entry>
  <entry>
    <title><![CDATA[面试题]]></title>
    <url>%2F2019%2F06%2F13%2Fyuque%2F%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[TIP你的简历是自己工作的答卷，项目经历是你给面试官出的考纲。所以，我的面试一定是与我的简历、工作经历相关的，一些面试题并不一定适用于任何人，但是你可以从中了解他们考察的点，以及侧重点。基础知识可以查漏补缺。 前端工程师手册30-seconds-of-interviewsfront-end-interview-handbook33-js-concepts33-js-concepts 中国国情版Git 飞行规则 看了这个常规的 git 应该没什么问题了node-interviewNode.js-Troubleshooting-Guide Node.js 应用线上/线下故障、压测问题和性能调优指南手册2018 大厂高级前端面试题汇总Daily-Interview-Question 每天一道前端大厂面试题https://github.com/forthealllight/blog/issues想成为一个好的前端工程师，光有强大的编程能力是远远不够的，还有很多软知识需要知道。学会与人沟通。前端是一个承上启下的工作，在实际业务之中你除了要面对代码之外还需要对接 UI、产品、后端和其它前端有时候经常也会和运营啊广告销售打交道。因此怎么与其他角色很好的沟通也是一个非常重要的能力，代码写的再好，但不满足需求也是白搭。需求明确再动手；发现问题尽快解决；意见分歧不要拒绝沟通；学会换位思考，不要总站在自己的角度想当然； 华尔街见闻面试题请先 fork 本项目，之后按照题目规则，完成功能之后，请不要依赖任何外部框架。 页面中有一个 ul列表，里面有 20 个 li，和若干个其它元素：div，需要实现一个功能，点击任何一个 li都会 alert hello world，点击其它元素没反应 在线demo 注意：请在在线 demo 的基础上进行修改， 在第一题的基础上进行修改，现在点击任何 li需要 alert 它的位置，即 它的 index，第一个 li alert(1)，第二个 alert(2)，以此类推 需要实现一个功能，每过 1s，往列表的末端添加新的5 个li元素，并且li的内容是它的位置，并且当页面的 li 个数超过 50 个时，停止添加。 请根据设计稿，写成相应的静态页面，并且有如下要求 根据 api 拉取列表数据 可以使用 Vue、React 或者任何框架还原页面 需要自适应 适配 PC 和 Mobile 最后一个 item 不需要下划线 点击任何一个 item alert 它的 title title 超过两个需要省略超出部分 对 Node.js 的看法 算法 OSI 七层协议？ http 和 https 有什么区别？ https 使用上有什么注意点？ https 和 http 性能有什么区别？ 常见的排序方法，你都熟悉那些？ 说下希尔排序的过程？ 希尔排序的时间复杂度和空间复杂度多少？（ 希尔排序的时间复杂度是：O（nlogn）～ O（n2），平均时间复杂度大致是 O(n√n)） 时间复杂度怎么推测的？ 数据结构你对那些比较熟悉？ 二叉树是什么啊？ 平衡二叉树（AVL）有什么特点？ 平衡二叉树（AVL）有什么好处？ 平衡二叉树（AVL）和红黑树的区别？ 平衡树的插入和删除的时间复杂度？ 怎么实现 短链？ 设计模式https://juejin.im/post/5c2e10a76fb9a049c0432697设计模式定义：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。通俗一点来讲就是在某种特定场合下对某个问题的一种解决方案。所有的设计模式的实现都遵循一条原则，‘找出程序变化的地方，并将变化封装起来’。 设计原则设计本身是为了提高代码可利用性，增加可维护性，符合以下的原则： 单一原则：永远不应该有多于一个原因来改变某个类。当我们做系统设计时，如果发现有一个类拥有了两种的职责，那就问自己一个问题：可以将这个类分成两个类吗？如果真的有必要，那就分吧。千万不要让一个类干的事情太多！ 开放封闭原则：软件实体，如：类、模块与函数，对于扩展应该是开放的，但对于修改应该是封闭的。当需求有改动，要修改代码了，此时您要做的是，尽量用继承或组合的方式来扩展类的功能，而不是直接修改类的代码。当然，如果能够确保对整体架构不会产生任何影响，那么也没必要搞得那么复杂了，直接改这个类吧。 最少知识原则（迪米特原则）：尽量减少对象之间的交互，从而减小类之间的耦合。简言之，一定要做到：低耦合，高内聚。 里氏转换原则：在使用基类的的地方可以任意使用其子类，能保证子类完美替换基类。 接口隔离原则：一个类与另一个类之间的依赖性，应该依赖于尽可能小的接口。不要对外暴露没有实际意义的接口 依赖倒转原则：引用一个对象，如果这个对象有底层对象，直接引用底层对象，比如可以直接用小桶打水，就没必要引用大桶向大桶灌水再用大桶。单例模式应用场景：全局唯一模态框，登录注册。 延伸：单例懒加载 定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。策略模式应用场景：计算不同绩效的工资，表单验证 将计算逻辑或者验证逻辑的算法单独封装。 定义：一系列的算法，将它们一个个封装起来，并且使它们可以相互替代。代理模式应用场景：图片懒加载(proxyImage),代理缓存，代理合并请求 定义：一个对象提供一个代用品或占位符，以便控制对它的访问。迭代器模式定义：提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。发布-订阅模式应用场景：DOM 事件系统(addEventListener)，网站登录系统 定义：又叫观察者模式，它定义了对象间的一种一对多的依赖关系。当一个对象的状态发生变化时，所有依赖它的对象都将受到通知。 延伸：订阅不同事件，订阅离线缓存命令模式组合模式模板模式延伸：好莱坞原则享元模式定义：核心是运用共享技术来有效的支持大量颗粒度的对象，常用于性能优化。 延伸：对象池职责链模式定义：避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，知道有一个对象处理它为止。 例子：手机商城-是否有 500 打折券-&gt;200 打折券 -&gt;有库存…，aop，上传组件适配 html5=&gt;flash=&gt;xxx中介者模式定义：作用是解除对象与对象之间的紧耦合关系，所有的相关对象都通过中介者对象来通信装饰者模式状态模式适配器模式定义：作用是解决两个软件实体间的接口不兼容问题。常规面试题 网络面试题 React面试题 VUE面试题]]></content>
  </entry>
  <entry>
    <title><![CDATA[文章收集]]></title>
    <url>%2F2019%2F06%2F13%2Fyuque%2F%E6%96%87%E7%AB%A0%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[说明主要是用来收集汇总平时看过得一些不错的文章，方便日后查找 Vue手摸手，带你用 vue 撸后台 系列一(基础篇)手摸手，带你用 vue 撸后台 系列二(登录权限篇)手摸手，带你用 vue 撸后台 系列三 (实战篇)手摸手，带你用 vue 撸后台 系列四(vueAdmin 一个极简的后台基础模板)手摸手，带你封装一个 vue component手摸手，带你优雅的使用 icon 前端Press Enter to Submit 背后的那些事Webnovel 国际化实践Things I Don’t Know as of 2018The TypeScript Tax: A Cost vs Benefit Analysis 主要讲 ts 收益，具有一定可读性TypeScript 解决了什么痛点？ 比较中肯的一个答案，做技术不要盲目跟风 GraphQLGraphQL 核心概念RPC vs REST vs GraphQLWhy use GraphQL, good and bad reasons 职业发展一个程序员的成长之路 张云龙大佬的文章，强推！！值得反复阅读。开发者如何在「技术+管理」的路上越走越宽？蔡志忠：努力是没有用的 视频计算机科学速成课 计算机科学基础的系列视频，很不错，浅显易懂，看完这四十节课能多计算机世界有一个大概的整体认知。 其它前端人工智能？TensorFlow.js 学会游戏通关谈谈 WebSocket https://zhuanlan.zhihu.com/p/37171897 小程序只需两步获取任何微信小程序源码 挺有意思的一篇文章 node基于 node.js 的脚手架工具开发经历 How to build a CLI with Node.js 网络什么是 RPC 框架？前端技术清单关于 JavaScript 单线程的一些事从零开始开发一款属于你的 Visual Studio Code 插件 AST平庸前端码农之蜕变 — AST]]></content>
  </entry>
  <entry>
    <title><![CDATA[网站]]></title>
    <url>%2F2019%2F06%2F13%2Fyuque%2F%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[常看的网站 awesome-f2e-libs sorrycc 整理的个人关注使用的前端库 overreacted react Dan 的个人博客，更新频率很高 DailyJS codeburst Github github 短域名服务 shields Github README 里面的装逼小图标 Emoji 方便平时写查找 emoji emoji.muan 同上 而且更全 git-awards github ranking 没事可以查着玩玩 http://githubrank.com/ github 按照 followers 排名 github-rank同上，githubrank 基本算挂了已经，只能用这个新的 star-history 展示一个项目 Stars 增长规矩曲线 probot 基于 github 做一个小机器人。可以做很多 workflow 的事情 开发 can i use 前端常用网站了 查看不同属性和方法的兼容性 Squoosh 谷歌出品在线免费图片压缩工具 神器 codesandbox-client - 在线 web 开发容器 astexplorer - 一个在线 ast 生成器 30 seconds of code 收集了许多有用的代码小片段 zeplin 前端和设计师神器，有标注、Style Guide、版本管理、简单的团队协作，重点是前端不用写 css 了，复制就可以了。 iconfont 阿里出的图标库，非常实用，支持 svg、font、png 多种格式，基本现在所有图标都在上面找。 cssicon 所有的 icon 都是纯 css 画的 缺点：icon 不够多 智图 腾讯出品 在线图片压缩 支持转成 webP 处理静态图片时候很好用 picdiet 另一个图片压缩网站 CSS triangle generator 帮你快速用 css 做出三角形 cssarrowplease 帮你做对话框三角的 clippy 在线帮你使用 css clip-path 做出各种形状的图形 Regular Expressions 在线正则网站 jex 正则可视化网站，配合上面的 Regular Expressions，写正则方便很多 jsfiddle 在线运行代码网站 很不错，可惜要翻墙 codepan 在线运行代码网站 不用翻墙，可以自己部署 fiddle.md 一个方便的在线共享 markdown 在线笔试题一般都用这个 jsdelivr cdn 服务 unpkg cdn 服务 coderpad 远程面试的神器，可以让面试者远程写代码 不过需要翻墙 icode 有赞团队出品的 coderpad 可以互补，它不需要翻墙 codeadvice 又一个让面试者远程写代码的网址 snipper 一个代码协同的网站。你新建一个代码片段，然后把网址分享给其他人，就可以看到他们的实时编辑。 codesandbox 一个可以在线编辑且提供在线 demo 的网站 支持 vue react angular 多种框架 神器 codrops 上面的交互都非常酷炫 bgremover 在线图片去底工具 photopea 一个网页端 Photoshop 很变态 bestofjs 查看一个项目增长经历，Star 数变化的网站，辅助你判断这个库的质量 stackblitz 一款在线 IDE,主要面向 Web 开发者,移植了很多 VS Code 的特性与功能 programmingfonts.org 一个专门介绍编程字体的网站 早报 一个个人开发者的前端开发的分享日报 emoji-search 帮你快速找到能表达你情感的 emoji gitmoji 通过 emoji 表达 git 的操作内容 starcharts 可以把你一个项目的 stars 增长轨迹当做 svg 放在 readme 中 mockapi 一个还不错的在线 mock 服务（可在线可视化编辑），可以满足大部分简单需求了 coder 在线版 VS Code browserstack 远程调整各种版本浏览器 兼容性问题 carbon 根据源码生成图片 主要作用是让你打代表片段分享的时候更好看一点 clipboard2markdown 将你所有复制进去的内容都转化为 markdown grammarly 英语写作检查工具 quickchart 通过 URL 生成图表的开源服务 hipdf 一站式在线 PDF 解决方案 whimsical 画路程图 Lorem Picsum 提供免费的占位图 sm.ms 免费图床 设计 uimovement 能从这个网站找到不少动画交互的灵感 awwwards是一个一个专门为设计精美的网站以及富有创意的网站颁奖的网站 dribbble 经常能在上面找到很多有创意好看的 gif 或者图片，基本上我所有的图都是上面招的 Bēhance dribbble 是设计师的微博，Bēhance 是设计师的博客 Logojoy 使用 ai 做 logo 的网站，做出来的 logo 质量还不错。 brandmark 另一个在线制作 logo 网站 instant 又一个 logo 制作网站 logo-maker 又一个 logo 制作网站 这个更简单点 就是选模板之后微调 coolors 帮你在线配色的网站 你能找到不少配色灵感 colorhunt 另一个配色网站 uigradients 渐变色网站 designcap 在线海报设计 Flat UI 色表 Flat UI 色表 0to255 颜色梯度 Ikonate 提供免费的图标 icons remixicon 又一个提供免费图标 icons feather 免费的 icons nord 北欧性冷淡风主题配色 Unsplash 提供免费的高清图片 colorkitty 从你的图片中提取配色 有趣 帮你百度一下 可以 点我测试一下- 国际版 同帮我百度一下-点我测试一下- wallhaven 壁纸网站- URL 地址播放 Emojis 动画 在地址栏里面播放 emoji Can’t Unsee 强烈建议前端、客户端、UI 开发的同学玩下，检查一下自己对设计稿的敏感度怎么样 ggtalk 平时一直在听的一个技术博客 awesome-comment 里面收集了很多有趣的代码注释 text-img 都将图片转化为 ascii 用来写注释 weird-fonts 将普通字母转化为 特殊 unicode snake 在地址栏里面玩贪吃蛇 交互 微交互 里面收集了市面上很多很好的微交互例子 值得学习 Little Big Details 同上，一个国外微交互汇集网站 cruip 登录页的各种页面设计，可以免费下载模板 Comixify 一个波兰团队做了非常好玩的工具，可以把视频自动转成漫画，上图是他们提供的 demo，效果很棒。 taiko-web 太鼓达人网页版 只能说很 6 Css css-tricks 一个学习 css 不错的网站 有很多有意思的 demo 教程 npx 教你怎么合理的使用 npx hacksplaining 网络安全学习网站 产品 产品大牛 什么有很多完整的产品原型可以借鉴 磨刀 快速出 ui 原型 实用typeform 一个国外的在线调查问卷网站 Talkpeerigon-talks 收集了不少有意思的 talks 算法leetcode 用 js 刷 leetcode]]></content>
  </entry>
  <entry>
    <title><![CDATA[推荐库]]></title>
    <url>%2F2019%2F06%2F13%2Fyuque%2F%E6%8E%A8%E8%8D%90%E5%BA%93%2F</url>
    <content type="text"><![CDATA[太常用的一些库，比如 lodash、axios、echarts、normalize.css等就不再下面推荐了。这里主要推荐一下自己平时常用，提高效率的，但大家可能又不知道的一些库。 前端常用 sweetalert2 一个自适应，且自定义性强的弹出框（零依赖） tippy.js 最著名的 tooltip/popover library text-mask 可以让 input 按照规则输入(如电话,email,日期,信用卡等)，特殊格式 input dinero.js 用来创建、计算和格式化货币价值的不可变的框架，支持国际化 lerna 大项目版本控制工具，项目中可以有多个 package.json 文件 img-2 一个提高图片加载性能和体验的库，懒加载使用 web worker 模糊预览 fingerprintjs 是一个快速的浏览器指纹库，通浏览环境的一系列配置生成 id ajv 一个 json schema 验证的库 dayjs 一个轻量级类 moment.js API 时间库 primjs 让页面支持代码高亮 ReLaXed 一个将 document html 转成 PDF 的工具 uppy 一个很好看的也很好用的 前端上传库 Filepond 一个小巧的文件上传库 tui-calendar 功能全面的日程安排日历控件，还支持拖拽 tui.editor markdown 所见即所得编辑器 tabler - 基于 Bootstrap 4 的 Dashboard UI Kit 和美观 高颜值 ui 模板 pulltorefresh.js - 下个下拉刷新插件 lulu - 腾讯阅文基于 jQuery，针对 PC 网站 IE8+（peak 主题）的前端 UI 框架 chancejs - 生成随机数据的库 spritejs - 360 奇舞团出的跨平台绘图对象模型 workbox - 让你的网站更方便的变成 pwa tui.image-editor - 一个功能齐全的在线图片编辑，基于 canvas nanoid - 前端轻量 unique string ID 生成库 rxdb - 一款开源的快速、灵活的客户端数据库，支持各种浏览器以及 NodeJS，Electron、React 等等，是 PouthDB 之上的一个封装库 percollate - 命令行工具 能将网页转换成 pdf rawact - 一个 babel 插件，把 react 组件转为原生 dom irondb - 是一个浏览器 key-value 储存的封装库，把 Cookies、IndexedDB、LocalStorage、SessionStorage 统一成一个接口。它的最大特色就是数据冗余机制，即使某种底层储存机制失效，它可以从其他机制恢复数据。 big.js 解决 js 浮点数问题。 主要就是 Big Number 或者小数点温柔 bignumber.js - 同上 stickybits - CSS 的 position: sticky 是一个很有用的设置，但是老的浏览器不支持。这个 JS 库是该功能的垫片库。 react-jsonschema-form - Mozilla service 开源了一个通过 JSON 直接生成表单的 React 组件 cleave.js - 用于在输入时格式化输入内容（信用卡格式、日期等） shiny - 在手机设备上模拟光的反射效果。 支持 DeviceMotion 事件 cloudquery - Turn any website to serverless API A-Programmers-Guide-to-English - 专为程序员编写的英语学习指南。 rrweb - 一个可以记录你页面中所有操作的库 nodeppt - markdown 写 ppt flexsearch - 能让你更加高效和快速的检索文本内容 public-apis - 汇集了市面上一些对外免费开放的 api，做一些自己练手 app 的时候很好用。 scroll-hint 用于提示用户页面可以左右滑动的一个提示库 fuse.js 轻量级前端模糊查询库 非常的好用 FileSaver.js 文件下载插件 很多时候下载会有兼容性问题，它能帮你解决这些问题 instant.page 一个判断用户行为 预测提前加载页面的库 screenfull.js 浏览器全屏插件 解决了不少兼容性问题 VuePress 本网站就是基于它实现的，简单方便的静态网站生成器 selection 可视化选择页面元素的库 scroll-out 滚动效果（滚动视差）的框架，框架大小不到 1KB,使用回调的方式将相关动画元素的属性进行实时分配 gpu.js 通过将 js 转为特定的 language，利用 GPU 来执行，大大提高了执行性能和速度 pressure 前端实现 3D Touch hammer 移动端手势库 AlloyFinger 腾讯出的手势库 lowdb LowDB 是一个本地 JSON 数据库，基于 Lodash 开发的 JSON-server 可以配合 LowDB 使用 快速搭建一个 REST API lunr.js 是个用于浏览器的轻量级 JavaScript 全文搜索引擎,对于一些小型的博客、开发者文档或 Wiki 网站来说,完全可以通过它实现站内离线搜索 he 一个前端 encoder/decoder 库 grade 一个可以根据你的 图片 调整底色的插件 pretty-bytes 将字节转换成可以读的字符串，比如 1337 个字节，会显示成 1.34 KB Css &amp;&amp; 动画 animate.css 最有名的动画效果库 magic.css css 动画效果库 类似 animate.css popmotion 一个函数式声明前端动画库 NES.css 任天堂主题风格 css 库 particles.js 前端实现颗粒粒子的动画效果库，比较炫酷，但相对的也比较吃性能 PaperCSS 手绘风格感觉 css 库 rough 基于 Canvas 的手绘风格图形库 wired-elements 基于 rough.js 分装 button input radio 等组件。它的底层是 Web components matter-js web 物理引擎 micron 通过在元素上绑定属性从而实现动画效果的库 direction-reveal 根据鼠标进入位置，展现从不同方向 展现 hover 效果 laxxx 滚动特效库 轻量级 压缩完 2kb cssfx 优雅的 CSS 动画效果，开箱即用 zdog 3D engine 引擎 Vue vue-multiselect select 组件 目前 vue 里面用过最好用的 Vue.Draggable DnD 拖拽组件 基于 Sortable.js 的 vue 版本 vue-sauce 一个可以展示 vue 源码的指令 vue-smooth-dnd Vue wrappers components for smooth-dnd vuegg 一个 vue 可视化拖拽界面生成器 vee-validate 基于 vue 的验证，能验证的内容比较全 vuesax 一个很漂亮的基于 vue 的 ui 框架 vue-analytics 基于 vue 的 谷歌统计封装 vue-virtual-scroller 基于 vue 的虚拟列表无限滚动 vue-content-placeholders 页面龙骨 skeleton 实践库 Jasonette 一个用 json 来构建 hybrid App 的框架 crate 一个 react 全栈练习(pc,mobile,rn,api) demo，适合入门拿来练手 react-in-patterns 一本开源教你如何写 react 的书 hocs react 相关 hoc 收集库 工具库 live-server 可以快速启一个本地 dev 服务 并且支持自动刷新的 http server serve - 快速起本地静态服务 picojs js 人脸识别库 es-checker 检查当前环境对 ES6 支持的情况。支持浏览器和 node.js merge-images 图片合成，利用canvas能将几张图片合成一张 fabric.js 基于 canvas 创建交互式的图片编辑界面非常适合用来做图片合成类工作。 phaser 这是一个为桌面和移动浏览器开发 HTML5 游戏的快速开源框架。 你可以为 iOS、 Android 和不同的本地应用程序创建游戏。 purifycss 移除没使用到的 css dropcss 同上 fast-cli 命令行测试下载上传速度 @pika/web 让你不需要在本地 webpack 中 import，直接在游览器里面运行 npm 包 pinyin 汉字拼音转换工具 JavaScript Obfuscator Tool js 代码混淆工具 tesseract 图像识别，它能识别图片中的文字，支持中文 gka 一款高效、高性能的帧动画生成工具。只需一行命令，快速图片优化、生成动画文件，支持效果预览。 recast 前端 ast 库 jscodeshift 将 js 内容解析成 AST 语法树，然后提供一些便利的操作接口，方便我们对各个节点进行更改 stats.js 前端性能监控 如 FPS、内存使用情况等 PapaParse 解析 csv excel Node consola 优雅的命令行 console vuepress 也使用了它 cheerio - 用类 jQuery 语法处理 HTML chokidar - node 监听文件变化的库 fs-extra - fs-extra 模块是系统 fs 模块的扩展，提供了更多便利的 API，并继承了 fs 模块的 API rimraf - 删除文件 globby - 用于模式匹配目录文件 glob - 文件查找 tiny-glob - 文件查找 node-semver - node 版本验证库 npm-run-all - 一个 CLI 工具可以并行或者串行执行 script live-server - 一个简单的 http server 带有 reload 功能 node-portfinder - 一个端口嗅探工具 update-notifier - Update notifications for your CLI app. cli 升级提醒工具 y18n - yargs 基于 i18n 的一个包 signale - Hackable console logger 一个 Node 的日志格式库，自带 16 个级别，可以定制颜色和 Emoji execa - A better child_process listr - Terminal task commander.js - 自动的解析命令和参数，合并多选项，处理短参，等等，功能强大，上手简单 Inquirer.js - A collection of common interactive command line user interfaces. 命令行询问库 enquirer - 命令行 prompt 询问库，写 cli 的时候很有用 Qoa 同上 ora - Elegant terminal spinner 命令行 loading chalk - 命令行着色美化库 hygen - 快速方便的创建代码 可以命令行创建预设的 template ndb - node 调试 got - http 请求库 如果你觉得 request 太多的话 这是一个不错的选择 dumper.js - 能让你的 node console 更加的规整，方便调试 node-in-debugging - node.js 调试指南 node-best-practices - node 最佳实践 fastscan - node 敏感词库 fx - 命令行优化 JSON 输出 dataloader - 解决 Graphql 中的 N+1 查询问题 progress-estimator - 命令行 progress bar 进度条模拟库 Node.js 最佳实践 grpc-web - 前端直连 gRPC 服务 node-fetch - node 环境下轻量级 fetch 请求库 ink 是一个 React 的命令行渲染器，命令行界面可以像写页面那么写了 strapi 开源的解决方案来创建、部署和管理自己的 API listr Terminal task list dotenv 通过.env 设置环境部变量 vue-cli 也依赖它 GraphQL prisma - 让前端也能快速的写出 Apollo GraphQL - 是基于 GraphQL 的全栈解决方案集合。从后端到前端提供了对应的 lib 使得开发使用 GraphQL 更加的方便 有趣 the-bread-code - 使用程序员的思维制作面包 ，比如制作中使用 A/B test, 来比较那种做法更好。 build-your-own-x - 教你用各种语言实现 Bot Database Neural Network javascript-algorithms - 教你用前端知识认识各种算法 not-paid - 如果你给人做网站，交过去以后对方没有付款，那么这个 JS 会把网站的透明度一天调低一点，直到看不见 nsfwjs - 前端图片鉴黄，基于 Tensorflow elevator.js 我很喜欢的一个库，让一个 back-to-top 的效果有了一种坐复古电梯的感觉 app-ideas 很多年轻人苦于缺少练手的项目，这个项目收集了不少点子，每个点子都有明确的目标和复杂资源。 WebGL-Fluid-Simulation 很酷的 WebGL 交互 工具 high-speed-downloader - 百度网盘不限速下载 支持 Windows 和 Mac hyper - 前端命令行 yapi - 是一个可本地部署的、打通前后端及 QA 的、可视化的接口管理平台 sway - 一个微软自己出的在线 ppt 很强大 bigjpg - 放大图片的神器 通过神经网络可以放大图片并能降噪 Ascii Art Generator - 在线生成 Ascii 图案 Winds - 开源 RSS JSUI - 一个用来控制管理前端项目的客户端 docz - 让你能快速写文档的一个库 hiper - 性能统计分析工具 verdaccio - 私有 npm git-guide - git 入门指南 git-tips - git 进阶 bit - 实现了项目之间的代码共享 可以自建私有 simpread - 简悦 ( SimpRead ) 让你瞬间进入沉浸式阅读的扩展 mkcert - 一键命令 让本地也支持 https termtosvg - 录制 命令操作转成 svg 基于 python gh-polls - 可以在 github issue 中添加投票 eruda - 移动端调试工具 vConsole - 也是一个移动端调试工具 腾讯出品 terminalizer - 命令行录制工具 基于 node badgen - 快速构建和 shields 一样的 svg badge 但速度更快 readability - 移除页面非正文部分 基于 jsdom WeChatPlugin-MacOS - 一款功能强大的 macOS 版微信小助手 puppeteer-recorder - 一个 chrome 插件 能够根据你的操作 自动生成 puppeteer 相关代码 mdx-deck - 用 markdown 编写演示文稿 code-surfer - 基于 mdx-deck 的一个插件 让你更好的在文稿中展示 code Progressive Tooling - 前端性能优化工具集合 https://github.com/artf/grapesjs - 可视化建站工具 不需要写代码就能写一个页面，前端再次再次要下岗了 image-charts - 该服务通过 URL 接受参数，然后生成图表，以图片形式返回 eagle.js - 一个用 vue 来制作 PPT 的库 Optimizely - A/B Test appadhoc - 一个国内的 A/B Test 服务 glorious-demo - 通过编写代码的方式构建一个命令行的演示例子 nginxconfig - 可视化配置 nginx 提供了多个基础模板 bundlephobia - 一个可以查看某个库的大小，并且分析它的依赖 jsperf - 一个提供在线 test case 的网站，主要用来比较性能。可以比较如： forEach vs for 的性能 perflink 与 jsperf 类似的一个比较 js 性能的网站 algorithm-visualizer - 算法代码可视化 An-English-Guide-for-Programmers - 专为程序员编写的英语学习指南 Webhint - 用于检查代码的可访问性、性能和安全的开源检查（Linting）工具 airtap - 测试浏览器兼容性，可覆盖 800 多种浏览器 jsonstore - 供免费，安全且基于 JSON 的云数据存储，自己玩的小项目神器 git-history - 可视化查看一个文件的历史变化 x-spreadsheet 一个基于 Canvas 的 JS 电子表格库 excel imgcook 阿里出品，一键通过设计稿生成代码 majestic jest 可视化 leon 你开源项目的 ai 个人助手 js-code-to-svg-flowchart 将代码逻辑用流程图的方式展现出来 Webpack webpackbar webpack 打包进度可视化 jarvis webpack dashboard webpack-chain 通过 chain 风格 api 的方式修改 webpack 配置 speed-measure-webpack-plugin 探测 webpack 各阶段的耗时 obsolete-webpack-plugin 基于 browserslist 做浏览器升级提示 mini-css-extract-plugin 提取 CSS 为单独文件 copy-webpack-plugin 复制额外的文件到输出目录 duplicate-package-checker-webpack-plugin 检查是否存在重复依赖 Mac get-plain-text - 能清除剪贴板里的格式 很实用 IINA - mac 平台感觉免费最好的播放器 强推 magnet - 分屏管理 Xnip - 方便好用的截图工具-支持截长图 Spectacle - 窗口管理工具 vanilla - 顶栏图标管理工具 Dozer - 一个开源的顶栏管理 腾讯电脑管家 - 反正我用下来好觉得蛮好用的 mos - 鼠标平滑滚动软件，很好用。免费开源 sequel pro - mysql 客户端 好用 Microsoft Remote Desktop Beta - Mac 远程登录 Windows 调试神器 pap.er - 专为 Mac 设计的壁纸应用 The Unarchive - Mac 目前感觉最好用的免费解压软件 Tickeys - 让你用 Mac 键盘也能打出机械键盘的感觉 Beaker Browser - P2P 开源浏览器 支持点对点发布文件，成为了文件传输工具，支持 DAT 对等协议 Gifski - 视频转 gif 工具 more - 更多优秀的 mac app 介绍 Motrix - 支持 HTTP、FTP、BT、磁力链、百度网盘的下载工具 Chrome 拓展 Tampermonkey 油猴 神器 扩展管理器 轻松管理扩展，就不用担心安装太多扩展了 visbug 它可以帮助你改变 css，移动元素等等一系类强大的功能,页面调试神器。当然有些时候还是 DevTools 更好用 refined-github 优化 github 默认功能和样式的 chrome 插件 ADB chrome 真机调试安卓神器 Adblock Plus 免费广告拦截程序 这个应该不用说了，装机必备 Axure RP Extension 看原型必备 JSON Formatter JSON 格式化 程序员必备 Lighthouse 谷歌出品，检查网页综合性能评分，分析不足 二维码(QR 码)生成器 手机扫码神器 Octotree github 上看代码必备神器 OctoLinker 能在 github 上看代码的时候 快速链接跳转到依赖的库 The Great Suspender chrome 太吃内存了，当页面开的很多时候会很卡，它就完美的解决了这个问题。它将几分钟没浏览过的页面都挂载了，当你想看是再重新加载 WEB 前端助手 支持 JSON 格式化、二维码生成与解码、代码压缩、Markdown 与 HTML 互转、网页滚动截屏、正则表达式、时间转换工具、JSON 比对工具等 掘金 目前我默认新开 tab 的默认页，可以刷刷新的文章或者项目，还不错。 沙拉查词 划词翻译插件 npmhub在 README 下方显示 npm 依赖信息 #VS Code Import Cost 查看你引入的依赖模块大小 Auto Close Tag 自动补全 html 标签，如输入&lt;a&gt;将自动补全&lt;/a&gt; Auto Rename Tag 自动重命名 html 标签，如修改&lt;a&gt;为&lt;b&gt;，将自动修改结尾标签&lt;/a&gt;为&lt;/b&gt; polacode 生产代码图片快照插件 vscode-leetcode - 一个能让你在 vscode 中刷 LeetCode 的插件 算一个划水神器吧 vscode-icons VS Code 必备吧，为文件添加炫图标 工程 lerna - monorepo 管理。 lerna-changelog - 为 lerna 项目自动生成 changelog。 eslint - JS 风格约束。 eslint-config-airbnb xo - 封装自 eslint。 prettier - 更主观的风格自动修改。 yeoman-generator - 脚手架工具。 serve - 本地静态服务器。 np - npm publish 辅助，自动 push、打 tag、升版本等。 lint-staged - eslint 提速，只 lint 提交的代码。 coveralls - 覆盖率。 husky - 添加 git hooks。 cross-env - 跨平台的环境变量声明。 projj - 本地 git 项目管理，支持 github 和 gitlab。 nvm - 管理 node 版本。 concurrently -在 npm scripts 里并行执行命令。 @zeit/ncc - 打包为 npm 包为一个文件。 npm-check - 检测依赖升级情况，我会和 yarn upgrade-interactive 配合着用，主要用来检测冗余依赖。 cpx - 复制，支持 glob，并且可以 watch。 onchange - 监听文件变动然后做一些事。 常看的网站]]></content>
  </entry>
  <entry>
    <title><![CDATA[素材网站收集]]></title>
    <url>%2F2019%2F06%2F13%2Fyuque%2F%E7%B4%A0%E6%9D%90%E7%BD%91%E7%AB%99%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[干货01—PPT素材全搜罗]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSS]]></title>
    <url>%2F2019%2F06%2F13%2Fyuque%2FCSS%2F</url>
    <content type="text"><![CDATA[占位图 Css&amp;&amp;动画 animate.css 最有名的动画效果库 magic.css css 动画效果库 类似 animate.css popmotion 一个函数式声明前端动画库 NES.css 任天堂主题风格 css 库 particles.js 前端实现颗粒粒子的动画效果库，比较炫酷，但相对的也比较吃性能 PaperCSS 手绘风格感觉 css 库 rough 基于 Canvas 的手绘风格图形库 wired-elements 基于 rough.js 分装 button input radio 等组件。它的底层是 Web components matter-js web 物理引擎 micron 通过在元素上绑定属性从而实现动画效果的库 direction-reveal 根据鼠标进入位置，展现从不同方向 展现 hover 效果 laxxx 滚动特效库 轻量级 压缩完 2kb cssfx 优雅的 CSS 动画效果，开箱即用 zdog 3D engine 引擎 ### KulerKuler是在线色彩工具的典范。有数千个出色的预置色彩模板可供选择，你也可以利用这款既先进又好用的工具来生成自己的模板。kuler from adobe - Color:https://color.adobe.com/zh/create PiknikPiknik是地球上最基本的色彩工具之一，绝对是我的至爱之一。只需轻轻移动鼠标去改变颜色，滚动一下改变亮度，然后点击复制数值到粘贴板上，大功告成矣。做网站的时候，我每天都用它来为颜色选用找感觉，包括它看起来会如何、如果覆盖整个屏幕效果会怎样、做幻灯片用哪个颜色好等等。 0to2550to255也是我的至爱之一，是寻找颜色变化的一款非常震撼的工具。这让它在设计网站的边界和悬浮（hover）效果时表现出色，但你同样可以用它来为PPT的排版或其他要素寻找重点色。]]></content>
  </entry>
  <entry>
    <title><![CDATA[ppt制作]]></title>
    <url>%2F2019%2F06%2F13%2Fyuque%2Fppt%E5%88%B6%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[PPT排版https://www.zhihu.com/question/29386330/answer/79692944 PPT像电影一样流畅？这5招带你入门MG动画 色彩灵感来源https://zhuanlan.zhihu.com/p/41077780在前面的 里提到过一个网站**http://pictogram2.com/提供各种人形素材，而这些素材均有矢量文件下载，因此可以随下随用在Behance.net上看到过大神Rutger Paulusse的每日C4D练习，立刻就被这种风格吸引了~虽然整体只采用一种搭配，却显得十分和谐自然。 精选15个PPT制作网站，收藏好，别丢了 pptfans.cn 不仅有海量的模板，还有各种级别的视频教程。很适合初学者来丰富自己的素材库。 *NO.1 officeplus *微软官方在线模板网站，模板比较丰富，内容花样多，可以来学习一波。 **叮当设计 **全网站总共1037的模板，全部免费下载。 **present **这是一个全球的网站，内容比较丰富，设计水平比较高端，缺点就是需要付费够买。一些对内容要求比较高的可以看一下。 *演界网 *yanj.cn 国内原创ppt模板网站，有大量的免费图表分享给大家使用。有一部分需要付费，免费的就可以满足我们的普通需求啦。 *逼格 *tretars.com 这是一个个人博客网站，逼格高，在发模板的同时还有一些ppt小技巧教程，图文结合，写的挺不错。 *优品 *ypppt.com 这个网站内容分类比较清晰，直接搜索自己所需要的模板内容就能找到。内容质量都挺高，免费。 *雷锋 *lfppt.com 有着海量的ppt，分类比较明确。需要哪个点哪个就完事。 *扑奔 *pooban.com 内容极其丰富，图表免费的居多，但是有些优质模板都需要200个积分才可以下载。 *无忧ppt *网站如其名字，搜集了很多的ppt模板，完全免费，内容质量也不错，就是网站广告有点多。 *ppt宝藏 *pptbz.com 内容比较丰富，但是质量参差不齐，有缺点，网站分类不太明确，不能够想要什么点什么，适合上网浏览，收集模板，免费。 **500丁 **内容都是优质的，质量也比较高，有一些简历模板，都是收费的，适合大佬使用。 **变色龙 **和500丁一样，质量也都挺高。内容更是不得了，不仅分类明确，而且全面。同样全部收费，适合大佬使用。 ppt之家 压轴的来啦，内容全面，质量高。文章、教程、图表、背景、素材、应有尽有。重点是免费下载，只需要关注一下人家的公众号就可以了。 http://yanshuo.io/演说 NO.2 slidemodel 国外的PPT模板网站，网站绝大部分的PPT都是图标或者图形类型的，而且还添加了地图类型的ppt模板，虽然这些都是需要付费订阅，但网站每周会提供150个免费的ppt模板，注册后均可下载。 NO.3 presentationmagazine 网站模板内容非常齐全，大部分的模板都可以免费使用，还免费提供一些制作 PPT 时所用到背景元素，如果你在PPT的制作过程中遇到什么困难，可以在网站的官方论坛上提出来， NO.4 slidehunter 4000个完全免费ppt模板网站，不管你做什么工作，都能在网站中找到相应的 PPT 模板，有趣的是网站还提供3D类型的 PPT，感兴趣的朋友可以去了解一下。 NO.5 AllPPT 网站设计简洁大方，种类也比较齐全，并且还有4；3的模板下载，如果你不会 PPT，他们还提供了 PPT 学习网站，以及免版权的图片使用网站，该网站每周会更新30个精美的ppt模板提供下载。 PPT审美训练营 ： https://www.zhihu.com/question/39233528/answer/390237175 PPT遥控器：http://ppt.baidu.com/ PPT 插件： iSlide iSlide 是一款基于 PowerPoint 的插件工具，即便您不懂设计，也能简单、高效地创建各类专业PPT演示文档。拥有近数十万 PPT 模板，而且还会持续更新。你可以快速检索、一键插入PPT 。另外，使用 iSlide 智能图表可以让数据变得直观易懂！目前 ，iSlide 已经全面支持微软 Office 以及金山 WPS。 口袋动画 口袋动画分为盒子版和专业版。盒子版是 PPT 小白专属工具；专业版是 PPT 进阶级变身，无论使用哪个版本，都能让你快速制作出媲美 AE 特效水准的 PPT 动画。同时它还拥有一键美化功能，覆盖片头、片尾、图表等多场景动画，还有各种组合、单一动画。仅需一键下载，既可替换元素，生成酷炫动画展示页。目前这款插件同时支持微软 Office 和金山 WPS 。 OneKeyTools OneKeyTools 简称 “OK插件” 或 “OK” ，是一款免费开源的 PPT 设计辅助插件。功能覆盖形状、图片、调色、表格、图表、音频、辅助等领域。目前支持微软 Office 2013 及以上版本。 PPT 美化大师 PPT 美化大师拥有海量在线模板素材。专业模板、精美图示、创意画册、实用形状等，细致分类，内容也会持续更新。最大的特点是支持一键全自动智能美化，让精美的 PPT变得简单起来。同时，它还支持将 PPT 一键生成不能复制、修改的只读格式。目前，PPT 美化大师都支持微软 Office 和金山 WPS 。 ispring suite 作为教师或者课程开发者，我们可能会有制作在线课程的需要，而这款名为 ispring suite 的 PPT 插件可以帮你把普通的 PPT 演示文档转换为适合在 Windows、Mac、iPad、iPhone、Android 等多种平台独立使用的在线课程。你可以将 PPT 生成为 H5 或者 Flash ，也可以集成为 exe 格式的软件或者 MP4 视频。目前这款插件并不支持 WPS ，适配微软的 Office 2007 及以上版本。 查看这里：https://topbook.cc/overview 1、Note &amp; Point Note &amp; Point2、Stock XCHNG stock.xchng - the leading free stock photography site3、Lauren Tucker Wheat Field In Newton-St-Loe4、色彩理论 Basic color schemes: Color Theory Introduction5、三个工具：KulerPiknikOto255 PPT动画基于软件工具开发3D素材网站：free3d.com画图神器：Paint 3D 寻找模型（Paint3D+Remix3D）：在较新的win10版本，系统里已经自带了Paint3D这项APP，通过可以直接进行建模。如果没有找到，可以至MS Store下载：画图 3D - Microsoft Store3D模型逆天新功能全剧透： https://zhuanlan.zhihu.com/p/30860481PPT-3D使用教程：这一招，带你的PPT突破天际！C4d入门：零基础自学C4D？不妨从这里开始Focusky动画：Focusky动画演示大师：https://zhuanlan.zhihu.com/p/37336987 动画背景网站：1.videos.pexels.com2.Free HD Stock Video &amp; HD Video Clips3.Mazwai 好的动画网站或APPPPT中最酷的效果—3D模型全解 一懒再懒—好用到爆的PPT插件来自：有哪些让你相见恨晚的 PPT 制作技术或知识？https://www.zhihu.com/question/30018273/answer/3657817581_._全能选手-iSlide（原Nordri tools）2.动画爱好者福音—PA口袋动画3.排版/图片神器-OneKeyTools js/css 怎么制作动画版PPT，基于js Slides Revealjs http://hakim.se 可给ppt增加模版组件 一般需求用 http://slides.com 的服务应该能满足大部分场景。但如果需要内嵌脚本之类的，可能就不太够用了。可以手写 HTML/Markdown 然后用 reveal.js 来展示。 用Markdown写一个极客范儿的PPThttps://www.jianshu.com/p/e063303317cb这个需要一定的程序基础才可以进入 前端大神都用什么做 PPT？ yanshuo.io]]></content>
  </entry>
  <entry>
    <title><![CDATA[vim]]></title>
    <url>%2F2019%2F06%2F13%2Fyuque%2Fvim%2F</url>
    <content type="text"><![CDATA[Vim 有什么奇技淫巧？ Vim实用插件推荐 笨方法学Vimscript面向那些想学会如何自定义Vim编辑器的用户。 Mac开发配置手册 安装macvimmac预装了vim，但官方的 vim 在 Mac 上只有一个很不完善的，长期没人维护的 Carbon 图形用户界面。macvim 主要是在此基础上添加了一个完整的 Cocoa 用户界面，其核心部分和 vim 同步。MacVim 采用了分离进程的方式，一个 MacVim 程序可以启动多个 vim 进程，每个显示在一个 MacVim 窗口中，这是官方的 vim 和其他平台下的 gvim 所不支持的。MacVim 还支持很多 Mac OS X 原生的界面特性，比如工具栏、滚动条、全屏显示、Mac 菜单快捷键的绑定等。 12345# 查看预装vim版本vim --version# 查看预装vim路径where vim 安装有两种方式来安装macvim: Github上下载macvim.dmg安装包进行安装 使用Homebrew安装 https://aaaaaashu.gitbooks.io/mac-dev-setup/content/Homebrew/index.html 这也是我们所采用的方式： 1brew install macvim 建立软链接(这步可以不走)无论使用哪种方式进行安装，可以在MacVim.app包文件中找到mvim和vim的可执行文件，要在shell中方便的执行这些命令，可以： 将可执行文件所在路径添加到环境变量$PATH中 将可执行文件复制到环境变量$PATH中的某一个路径下； 在$PATH中的某一个路径下创建该可执行文件的软/硬链接； 为可执行文件设置别名，并添加到配置文件中（/.zshrc）； 这里推荐在/usr/local/bin目录下为mvim软链接的方式。同时，mac预装vim版本过低，推荐使用MacVim.app包中的vim将其替代,如果想同时保留原来预装的/usr/bin/vim中的vim，可以通过创建别名来将其“覆盖”掉。 12345678910111213# 将可执行文件所在路径添加到环境变量`$PATH`中，单引号内的字符会原样输出echo 'export PATH=/usr/local/Cellar/macvim/8.0-133/MacVim.app/Contents/bin:$PATH' &gt;&gt; ~/.zshrc# 或将可执行文件mvim复制到/usr/local/bin/路径下cp /usr/local/Cellar/macvim/8.0-133/MacVim.app/Contents/bin/mvim /usr/local/bin/mvim# 或者在/usr/local/bin/路径中为mvim建立软链接ln -s /usr/local/Cellar/macvim/8.0-133/MacVim.app/Contents/bin/mvim /usr/local/bin/mvim# 为macvim中的vim创建别名，将其添加至~/.zshrc配置文件echo 'alias vim="/usr/local/Cellar/macvim/8.0-133/MacVim.app/Contents/MacOS/vim"' &gt;&gt; ~/.zshrc# 重新加载.zshrc以使修改生效 source ~/.zshrc 安装验证终端输入vim，终端vim显示如下:终端输入mvim，弹出GUIvim如下： 配置文件在vim启动过程中，首先将查找配置文件并执行其中的命令，而这些初始化文件一般有vimrc、gvimrc和exrc三种。通过:version命令可以查看vim的配置文件信息： 配置文件的位置vim的配置文件有全局和用户两种版本，分别存放于$VIM和$HOME目录中，用户配置文件默认是没有的，必要时由用户自己在$HOME目录下创建。可以使用:echo命令查看他们的路径，使用:e命令进入目录： 12345:echo $VIM/usr/local/Cellar/macvim/8.0-133/MacVim.app/Contents/Resources/vim:echo $HOME/Users/fangcao vimrc是vim最常用的配置文件 gvim是Gvim的配置文件 exrc仅用于向后兼容olvi/ex；除非你使用vi-compatible模式，否则不需要关注exrc配置文件 配置文件的加载顺序(这步也可以不用)可以通过:scriptname查看各脚本的加载顺序: 12345678910111213141: /usr/local/Cellar/macvim/8.0-133/MacVim.app/Contents/Resources/vim/vimrc 2: ~/.vimrc 3: /usr/local/Cellar/macvim/8.0-133/MacVim.app/Contents/Resources/vim/runtime/syntax/syntax.vim 4: /usr/local/Cellar/macvim/8.0-133/MacVim.app/Contents/Resources/vim/runtime/syntax/synload.vim 5: /usr/local/Cellar/macvim/8.0-133/MacVim.app/Contents/Resources/vim/runtime/syntax/syncolor.vim 6: /usr/local/Cellar/macvim/8.0-133/MacVim.app/Contents/Resources/vim/runtime/filetype.vim 7: /usr/local/Cellar/macvim/8.0-133/MacVim.app/Contents/Resources/vim/runtime/menu.vim 8: /usr/local/Cellar/macvim/8.0-133/MacVim.app/Contents/Resources/vim/runtime/autoload/paste.vim 9: /usr/local/Cellar/macvim/8.0-133/MacVim.app/Contents/Resources/vim/runtime/ftoff.vim 10: ~/.vim/bundle/Vundle.vim/autoload/vundle.vim ...... 85: /usr/local/Cellar/macvim/8.0-133/MacVim.app/Contents/Resources/vim/gvimrc 86: ~/.gvimrc ...... 可以看到：macvim在启动时会依次加载全局vimrc&gt;&gt;用户.vimrc&gt;&gt;全局gvimrc&gt;&gt;用户.gvimrc，而终端vim在启动既不加载gvimrc也不加载.gvimrc也就是说： 用户配置文件中的配置会覆盖全局配置文件的配置；因此，我们可以通过创建~/.vimrc来修改vim的默认配置。 对GUIvim，gvimrc会覆盖vimrc中的配置；因此，我们可以通过创建~/.vimrc使终端vim和GUIvim拥有不同的配置。此外，GUIvim支持更多扩展，有些功能在终端vim中无法使用。创建用户配置文件 1234# 切换至用户目录cd ~# 使用mvim创建并打开.vimrcmvim .vimrc 编辑配置文件1234可以使用以下命令，新建缓冲区来编辑配置文件：:edit $MYVIMRC也可以使用以下命令，新建标签页来编辑配置文件：:tabedit $MYVIMRC 当然也可以使用任何其他文本编辑器打开配置文件进行编辑。 应用配置文件修改配置文件后，需要重新启动Vim，或使用:source命令来应用新的设置： 1:source $MYVIMRC 我们可以在配置文件中增加以下命令，在保存后自动应用配置： 1autocmd bufwritepost .vimrc source $MYVIMRC 配置文件基本配置 显示中文帮助 下载vimdoc 将文件解压到~/.vim/doc，若路径不存在则自己创建 打开vim执行:helptags ~/.vim/doc 在~/.vimrc中进行配置： 12345set helplang=cn if version &gt;= 603 set helplang=cn set encoding=utf-8endif 没有完毕转自：https://www.jianshu.com/p/923aec861af3]]></content>
  </entry>
  <entry>
    <title><![CDATA[JsBridge]]></title>
    <url>%2F2019%2F06%2F12%2Fyuque%2FJsBridge%2F</url>
    <content type="text"><![CDATA[整个流程就是Native和Js两端各准备一个bridge，Native的bridge提供modules，js的bridge注册Native提供的modules。这就是bridge存在的意义–提供一个桥梁，让两边通信。 简单来说，只需要两步，第一简历桥连接，第二注册方法： 123456789101112131415161718192021222324252627function setupWebViewJavascriptBridge(callback) &#123; if (window.WebViewJavascriptBridge) &#123; return callback(WebViewJavascriptBridge); &#125; if (window.WVJBCallbacks) &#123; return window.WVJBCallbacks.push(callback); &#125; window.WVJBCallbacks = [callback]; var WVJBIframe = document.createElement('iframe'); WVJBIframe.style.display = 'none'; WVJBIframe.src = 'wvjbscheme://__BRIDGE_LOADED__'; document.documentElement.appendChild(WVJBIframe); setTimeout(function () &#123; document.documentElement.removeChild(WVJBIframe) &#125;, 100)&#125;function connectWebViewJavascriptBridge(callback) &#123; if (window.WebViewJavascriptBridge) &#123; callback(WebViewJavascriptBridge) &#125; else &#123; document.addEventListener( 'WebViewJavascriptBridgeReady' , function () &#123; callback(WebViewJavascriptBridge) &#125;, false); &#125;&#125; 兼容安卓ios 12345678910111213141516171819if (navigator.userAgent.match(/(iPhone|iPod|iPad);?/i)) &#123; //ios setupWebViewJavascriptBridge(function (bridge) &#123; bridge.callHandler(funcName, data,callback ); &#125;);&#125; else if (navigator.userAgent.match(/android/i)) &#123; connectWebViewJavascriptBridge(function(bridge) &#123; if(window.WebViewJavascriptBridge)&#123; window.WebViewJavascriptBridge.callHandler( funcName , data, callback ); &#125;else&#123; bridge.callHandler(funcName, data, callback); &#125; &#125;);&#125; else &#123;&#125; Android 初次加载是需要初始化 1bridge.init(function(message, responseCallback) &#123;responseCallback(data)&#125;); h5调用nativeiOS在setupWebViewJavascriptBridge里注册android在connectWebViewJavascriptBridge里注册 1bridge.callHandler(funcName, data, callback); native调用js 12bridge.registerHandler(funcName, function(responseData, responseCallback) &#123;&#125;); 概念1、H5，即是html5，超文本标记语言，用于描述网页内容结构的语言，网页编程中由它有负责描述页面数据和信息2、JS，即是JavaScript，广泛用于web应用开发中的脚本语言，负责响应用户的操作，为网页添加动态功能3、native APP，即传统的原生APP开发模式，Android基于Java语言，底层调用Google的 API；iOS基于Objective-C或者Swift语言，底层调用App官方提供的API4、Hybrid App，即原生和web的混合开发模式，由原生提供统一的API给js调用，实现跨平台的效果 交互方式 第一种为H5与native的基本通讯方式 说是基本通讯方式是因为由native自身的组件进行通讯的，这里需要区分为android和iOS，两端的组件实现有差异**基本通讯方式汇总 iOS通过官方提供的库文件JaveScriptCore来实现交互，可以脱离webview直接运行js android是通过addJavascriptInterface开放统一的api给js调用，实现交互，但具有安全性问题，版本4.2之前addJavascriptInterface接口引起安全漏洞，可被反编译获取Native注册的js对象，在页面通过反射Java的内置静态类，获取一些敏感的信息和破坏。 第二种H5与native交互方式为JSBridge原理 JSBridge是H5代码与native代码之间的一个通讯桥梁，是广为流行的交互理念。目前的统一实现流程是：H5触发url scheme–&gt;native捕获url scheme–&gt;原生分析并执行–&gt;原生调用H5，如下图：URL scheme，是一个URL最初始的位置，即://之前的那段字符，如_baidu.com_的scheme为http；根据我们上面对URL scheme的使用，我们可以理解，H5通过某种方式如iframe触发scheme，然后Native用某种方法捕获对应的url触发事件，根据定义好的协议，分析当前触发了哪种方法，然后根据定义来执行。比如短信，就是sms：，比如微信，就是weixin**所以JSBridge交互本质就是通过webview的代理拦截url scheme，然后注入相应的JS，从而实现交互，目前我们公司使用的是第三方开源库WebViewJavascriptBridge，下面我们来讲讲这个通讯桥梁。 实现流程 首先在H5代码注入js代码块 1234567891011121314151617181920212223242526272829303132333435function setupFH5JsBridge(callback) &#123; var ua = navigator.userAgent.toLowerCase(), isiOS = ua.match(/(iphone|ipod|ipad);?/i), isAndroid = ua.match("android"); if (isAndroid) &#123; if (window.FH5JsBridge) &#123; window.FH5JsBridge.initBridge(callback); &#125; else &#123; document.addEventListener( "FH5JsBridgeReady", function() &#123; window.FH5JsBridge.initBridge(callback); &#125;, false ); &#125; window.WebViewJavascriptBridge = window.FH5JsBridge; &#125; else if (isiOS) &#123; if (window.WebViewJavascriptBridge) &#123; return callback(WebViewJavascriptBridge); &#125; if (window.WVJBCallbacks) &#123; return window.WVJBCallbacks.push(callback); &#125; window.WVJBCallbacks = [callback]; var WVJBIframe = document.createElement("iframe"); WVJBIframe.style.display = "none"; WVJBIframe.src = "wvjbscheme://__BRIDGE_LOADED__"; document.documentElement.appendChild(WVJBIframe); setTimeout(function() &#123; document.documentElement.removeChild(WVJBIframe); &#125;, 0); &#125;&#125;setupFH5JsBridge(function(bridge) &#123;&#125;); or我们项目里是这样： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153function nativeApp() &#123; var App = &#123; callbacks: &#123;&#125; &#125;, slice = Array.prototype.slice; /** * 常量定义 */ var ua = navigator.userAgent.toUpperCase(); // 当前环境是否为Android平台 App.IS_ANDROID = ua.indexOf("ANDROID") != -1; // 当前环境是否为IOS平台 App.IS_IOS = ua.indexOf("IPHONE OS") != -1; // 当前环境是否为WP平台 App.IS_WP = ua.indexOf("WINDOWS") != -1 &amp;&amp; ua.indexOf("PHONE") != -1; App.IS_YZT = /One Account (IOS|Android)/gi.test(ua); App.callbacks.__leftAction__ = function() &#123; var haveLeftAction = typeof App.callbacks.leftAction === "function", args = slice.call(arguments); if (haveLeftAction) &#123; setTimeout(function() &#123; App.callbacks.leftAction.apply(App.callbacks, args); &#125;, 0); if (App.IS_ANDROID) &#123; App.call(["called"]); &#125; else if (App.IS_IOS) &#123; return true; &#125; &#125; &#125;; //=======================Native 相关================================ var callindex = 0, isFunc = function(name) &#123; return typeof name === "function"; &#125;, isObj = function(name) &#123; return typeof name === "object"; &#125;; /** * 调用一个Native方法 * @param &#123;String&#125; name 方法名称 */ App.call = function(name) &#123; // 获取传递给Native方法的参数 var args = slice.call(arguments, 1); var successCallback = "", errorCallback = "", item = null, returnArg; var methodName = name[name.length - 1]; if (App.IS_YZT) &#123; if (App.IS_ANDROID) &#123; if (window.HostApp) &#123; var newArguments = []; for (var i = 0; i &lt; args.length; i++) &#123; if (isFunc(args[i])) &#123; var callbackName = methodName + "Callback" + callindex; window[callbackName] = args[i]; newArguments.push(callbackName); callindex++; &#125; else if (isObj(args[i])) &#123; newArguments.push(JSON.stringify(args[i])); &#125; else &#123; newArguments.push(args[i]); &#125; &#125; // 之所以要重新调用，是因为Android 初始化HostApp可能晚于JS调用。 try &#123; HostApp[methodName].apply(window.HostApp, newArguments); &#125; catch (e) &#123; // TODO 这里应该走Mock functions var params = slice.call(arguments, 0); setTimeout(function() &#123; App["call"].apply(window.App, params); &#125;, 300); &#125; &#125; else &#123; var params = slice.call(arguments, 0); setTimeout(function() &#123; App["call"].apply(window.App, params); &#125;, 1000); &#125; &#125; else if (App.IS_IOS) &#123; var tempArgument = []; for (var i = 0; i &lt; args.length; i++) &#123; if (isFunc(args[i])) &#123; var callbackName = methodName + "Callback" + callindex; window[callbackName] = args[i]; tempArgument.push(callbackName); callindex++; &#125; else &#123; args[i] &amp;&amp; tempArgument.push(args[i]); &#125; &#125; callindex++; var iframe = document.createElement("iframe"); var _src = "callnative://" + methodName + "/" + (tempArgument &amp;&amp; tempArgument.length ? encodeURIComponent(JSON.stringify(tempArgument)) + "/" + callindex : ""); console.log(_src); iframe.src = _src; iframe.style.display = "none"; document.body.appendChild(iframe); iframe.parentNode.removeChild(iframe); iframe = null; &#125; else &#123; // WP 用户不支持。 Mock functions, 模拟H5 容器 console.warn("Tips: No available environment WP"); // Mock functions, 模拟H5 容器 for (var i = 0; i &lt; args.length; i++) &#123; if (isFunc(args[i])) &#123; args[i](&#123;&#125;); return; &#125; &#125; &#125; &#125; else &#123; console.warn("Tips: No available environment, NO YZT"); // Mock functions, 模拟H5 容器 for (var i = 0; i &lt; args.length; i++) &#123; if (isFunc(args[i])) &#123; args[i](&#123;&#125;); return; &#125; &#125; &#125; &#125;;&#125;window.AppAPI = nativeApp();AppAPI.call(["onGetShareData"], data);AppAPI.call( ["checkLoginStatus"], function(data) &#123; callback &amp;&amp; callback(SUCCESS, formatJSON(data)); &#125;, function(err) &#123; //do nothing callback &amp;&amp; callback(ERROR, err); &#125;, &#123;&#125;); JS端使用方式 native端需要进行注册对应的方法，H5才可以调用 Android注册方式如下: 1FH5JsBridge.registerHandler(bridgeWebView, handlerName, bridgeHandler); iOS端注册方式如下 12345678910111213/*** @param registerHandler 要注册的事件名称@param handel 回调block函数 当后台触发这个事件的时候会执行block里面的代码 ***/ [_bridgeregisterHandler:@"loginFunc" handler:^(id data, PAFFWVJBResponseCallbackresponseCallback) &#123; // data 后台传过来的参数,例如用户名、密码等 NSLog(@"testObjcCallback called:%@", data); //具体的登录事件的实现,这里的login代表实现登录功能的一个OC函数。 [self login]; // responseCallback 给后台的回复 responseCallback(res);&#125;]; H5调用方式如下 12FH5JsBridge.callHandler(methodName, 方法名options,对象 callback) 调用 Native API其中callback 统一接受一个参数json对象 H5常见的调用方法 打开native 页面，从H5页面跳转到某个原生页面 1void openAppPage(data,callback) --data 为&#123;pageName:''&#125; 获取会话token，H5登录区内的操作需获取原生的登录态 1void getSSOTicket(data,callback) 刷新会话，在一定的时间内刷新会话 1void refreshSession(data,callback) 打开原生App的安全键盘 1void openSafeKeyboard(data,callback) 打开分享，微信QQ等分享 1void share(data,callback) 设置临时存储数据，H5需要存储native的数据作为临时数据，退出APP后，临时数据清空 12void setData(data, callback)data 格式为&#123;key:"key", value: string &#125; 获取临时存储数据，获取临时存储的数据进行使用 12void getData(data, callback)data 格式为&#123;key:"key"&#125; 删除临时存储数据 12void removeData(data, callback)data格式为&#123;key:"key"&#125; **加载过程 加载和互相调用]]></content>
  </entry>
  <entry>
    <title><![CDATA[学习的UP主收集]]></title>
    <url>%2F2019%2F06%2F12%2Fyuque%2F%E5%AD%A6%E4%B9%A0%E7%9A%84UP%E4%B8%BB%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[关注这些牛人，你可以丰富多彩 3Blue1Brown 对不少理工科学生来说，数学都是噩梦一般的存在。从线代到离散，从高数到数分，每一科都要耗费大量的时间和精力，让人想怒摔课本。为了人类的未来发展，3Blue1Brown 决心用动画讲述数学专业知识，其视频涵盖了线性代数、微积分、拓扑学等领域，每门课都配有直观生动的动画演示，帮助观众加深对数学概念定理的理解。3Blue1Brown 原作者毕业于斯坦福大学数学系，并在 Khan Academy 担任过数学讲师，专业性有所保障。如果你上网方式比较科学，也可以关注其 YouTube 账号，第一时间掌握其动态。 李永乐老师官方 如果你还是高中生，不妨关注李永乐老师官方这个 B 站账号。他任职于人大附中，取得了北京大学双学士学位，在物理和数学两大学科领域都颇有造诣。除了高中数学讲座外，他还会结合时事热点，推出《流浪地球》科普、金庸武侠的科学解释等视频，幽默风趣，寓教于乐。 田浅浅 田浅浅是一位人大本科生，高考排名全省前百，她的学习经验对文科生来说大有裨益。在她的个人投稿中，你可以找到文综答题技巧、练字方法、高效笔记术、期末复习技巧等，凝聚了一枚学霸的心血。 蜡笔和小勋 蜡笔和小勋 是一对浙大毕业的情侣，他俩上传的视频，除了狂撒狗粮外，就是自己学习的经验之谈了，例如提高记忆效率、自律和自制力、对付拖延症等。如果你想提高自己的成绩排名，看他们的视频准没错。 潘子Jane 潘子Jane 是一位清华大学在读研究生，她的 B 站账号为我们分享了诸多生活技巧和个人感悟，如学生党如何月入过万、快速背单词方法、考研历程分享等，都是过来人的经验之谈。此外，你也可以借她的视频窥见清华学生的日常生活，激励自己进取前行。 FanfaniShare FanfaniShare 是一位在美国高校教英文的中国女孩，她 TESOL 硕士全 A 毕业，在国内教过雅思口语和新概念课程，水平与母语者不相上下。你可以借助她的投稿视频练习英式口语、雅思写作、单词记忆等，并纠正错误的发音习惯，面对歪果仁也不怯场。 小圆脸Paprika 读书破万卷，下笔如有神，这句诗人人皆知，却非人人都能做到。如果你正面临不知看何书、又如何看书的困境，小圆脸Paprika 就可以帮到你。她会为我们定期分享最近出版的好书、个人读书的感触等，伴你一路前行。 oeasy 如果你想涉足设计领域，关注oeasy可以避免走许多弯路。作为中国传媒大学的计算机教师，他可谓是这一领域的全才，出品了 Photoshop、Illustrator、Office、视频编辑、动画制作乃至编程入门等教程，内容翔实易懂，广受好评，带你从零开始，成为大神。 doyoudo doyoudo 同样是一位设计教程分享 UP 主，不过其更侧重于技术在具体生活场景中的应用，如用 C4D 制作猫爪杯模型、用 Photoshop 制作表情包、用 Audition 制作鬼畜音频等，选题十分有趣，小白也能轻松跟上节奏。 影视飓风 随着智能手机的普及和人们对生活追求的提高，Vlog 这一表现形式受到了越来越多人的欢迎。如果你想拍摄属于自己的 Vlog，又不知从何下手，影视飓风 或许能帮上忙。它的视频涵盖了 Vlog 制作的方方面面，从拍摄前期的准备工作到拍摄过程中的布光技巧，乃至后期剪辑等专业知识，深入浅出。 左手plus 拍照人人都会，手机一举，快门咔嚓，就大功告成了。但想拍出一张好照片，却并不那么简单，如果你内心深处有一个摄影梦，关注 左手plus 准没错。你可以从他的视频中学到鲜为人知的摄影技巧、摄影器材选购知识、照片后期处理流程等，再也不怕给妹子拍照后被踹了。 Free从容 如果你想学一门乐器，吉他可以说是性价比最高的选择之一：价格实惠、易于上手、在聚会上小露一手还能收获喝彩无数。如果你的公司年会在即，不妨关注 Free从容 的 B 站账号，突击学习吉他的弹奏方法，成为全公司最靓的仔。 少数派sspai 少数派sspai 是国际知名科技媒体我派本派（本句收费五毛）的 B 站官方账号，专注于提高你的数字生活效率。在目前投稿的视频中，你可以了解 Windows 美化技巧、捷径使用指南、隐私保护秘笈、新鲜科技产品评测等，推荐大家关注。]]></content>
  </entry>
  <entry>
    <title><![CDATA[名人博客收集]]></title>
    <url>%2F2019%2F06%2F12%2Fyuque%2F%E5%90%8D%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[看过的博客收集地址 语雀AlloyTeam 腾讯全端 AlloyTeam 团队 Blog学习的 UP 主收集京程一灯程墨 Morgan我的兜兜有糖PanjiaChen云龙 http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1530517140411/Codelife.pdf小Z博客 GMTC 2019 全球大前端技术大会]]></content>
  </entry>
  <entry>
    <title><![CDATA[GitHub Pages 建立个人网站详细教程]]></title>
    <url>%2F2019%2F06%2F12%2Fyuque%2FGitHub%20Pages%20%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[GitHub Pages是免费的静态站点，三个特点： 免费托管、 自带主题、 支持自制页面和Jekyll。 为什么使用github pages 搭建简单而且免费； 支持静态脚本； 可以绑定你的域名； DIY自由发挥，动手实践一些有意思的东西git,markdown,bootstrap,jekyll； 理想写博环境，git+github+markdown+jekyll； 创建github pages 安装git工具 http://windows.github.com/http://mac.github.com/ 2.两种pages模式 使用自己的用户名，每个用户名下面只能建立一个； 资源命名必须符合这样的规则username/http://username.github.com； 主干上内容被用来构建和发布页面 gh-pages分支用于构建和发布； 如果user/org pages使用了独立域名，那么托管在账户下的所有project pages将使用相同的域名进行重定向，除非project pages使用了自己的独立域名； 如果没有使用独立域名，project pages将通过子路径的形式提供服务http://username.github.com/projectname； 自定义404页面只能在独立域名下使用，否则会使用User Pages 404； 创建项目站点步骤： 123456$ git clone https://github.com/USERNAME/PROJECT.git PROJECT$ git checkout --orphan gh-pages$ git rm -rf .$ git add .$ git commit -a -m "First pages commit"$ git push origin gh-pages 可以通过User/Organization Pages建立主站，而通过Project Pages挂载二级应用页面。 创建步骤第一步：创建个人站点第二步：设置站点主题 常用命令123456789$ git clone git@github.com:username/username.github.com.git //本地如果无远程代码，先做这步，不然就忽略$ cd .ssh/username.github.com //定位到你blog的目录下$ git pull origin master //先同步远程文件，后面的参数会自动连接你远程的文件$ git status //查看本地自己修改了多少文件$ git add . //添加远程不存在的git文件$ git commit * -m "what I want told to someone"$ git push origin master //更新到远程服务器上 使用Jekyll搭建博客 1 什么是jekyllJekyll是一种简单的、适用于博客的、静态网站生成引擎。它使用一个模板目录作为网站布局的基础框架，支持Markdown、Textile等标记语言的解析，提供了模板、变量、插件等功能，最终生成一个完整的静态Web站点。说白了就是，只要安装Jekyll的规范和结构，不用写html，就可以生成网站。[jekyll介绍][jekyll on github][jekyllbootstrap]。Jekyll使用Liquid模板语言，表示文章标题， GitHub Pages是免费的静态站点，三个特点： 免费托管、 自带主题、 支持自制页面和Jekyll。 为什么使用github pages 搭建简单而且免费； 支持静态脚本； 可以绑定你的域名； DIY自由发挥，动手实践一些有意思的东西git,markdown,bootstrap,jekyll； 理想写博环境，git+github+markdown+jekyll； 创建github pages 安装git工具 http://windows.github.com/http://mac.github.com/ 2.两种pages模式 使用自己的用户名，每个用户名下面只能建立一个； 资源命名必须符合这样的规则username/http://username.github.com； 主干上内容被用来构建和发布页面 gh-pages分支用于构建和发布； 如果user/org pages使用了独立域名，那么托管在账户下的所有project pages将使用相同的域名进行重定向，除非project pages使用了自己的独立域名； 如果没有使用独立域名，project pages将通过子路径的形式提供服务http://username.github.com/projectname； 自定义404页面只能在独立域名下使用，否则会使用User Pages 404； 创建项目站点步骤： 123456$ git clone https://github.com/USERNAME/PROJECT.git PROJECT$ git checkout --orphan gh-pages$ git rm -rf .$ git add .$ git commit -a -m "First pages commit"$ git push origin gh-pages 可以通过User/Organization Pages建立主站，而通过Project Pages挂载二级应用页面。 创建步骤第一步：创建个人站点第二步：设置站点主题 常用命令123456789$ git clone git@github.com:username/username.github.com.git //本地如果无远程代码，先做这步，不然就忽略$ cd .ssh/username.github.com //定位到你blog的目录下$ git pull origin master //先同步远程文件，后面的参数会自动连接你远程的文件$ git status //查看本地自己修改了多少文件$ git add . //添加远程不存在的git文件$ git commit * -m "what I want told to someone"$ git push origin master //更新到远程服务器上 使用Jekyll搭建博客 1 什么是jekyllJekyll是一种简单的、适用于博客的、静态网站生成引擎。它使用一个模板目录作为网站布局的基础框架，支持Markdown、Textile等标记语言的解析，提供了模板、变量、插件等功能，最终生成一个完整的静态Web站点。说白了就是，只要安装Jekyll的规范和结构，不用写html，就可以生成网站。[jekyll介绍][jekyll on github][jekyllbootstrap]。Jekyll使用Liquid模板语言，{{page.title}}表示文章标题，{{content}}表示文章内容。我们可以用两种Liquid标记语言：输出标记（output markup）和标签标记 (tag markup)。输出标记会输出文本（如果被引用的变量存在），而标签标记不会。输出标记是用双花括号分隔，而标签标记是用花括号-百分号对分隔。[Liquid模板语言] [Liquid模板变量参考]。jekyll与github的关系：GitHub Pages一个由 GitHub 提供的用于托管项目主页或博客的服务，jekyll是后台所运行的引擎。 2 jekyll本地环境搭建1.下载最新的RubyInstaller并安装(我下载的是rubyinstaller-1.9.3-p194.exe)，设置环境变量，path中配置C:Ruby193bin目录，然后在命令行终端下输入gem update –system来升级gem；2.下载最新的DevKit，DevKit是windows平台下编译和使用本地C/C++扩展包的工具。它就是用来模拟Linux平台下的make,gcc,sh来进行编译。但是这个方法目前仅支持通过RubyInstaller安装的Ruby，并双击运行解压到C:DevKit。然后打开终端cmd，输入命令进行安装。3.完成上面的准备就可以安装Jekyll了,因为Jekyll是用Ruby编写的,最好的安装方式是通过RubyGems(gem): 1gem install Jekyll 并使用命令检验是否安装成功 1jekyll --version 4.安装Rdiscount，这个用来解析Markdown标记的包，使用如下命令： 1gem install rdiscount 5.运行本地工程：cd 到工程目录，启动服务： 1jekyll --server 3 jekyll目录结构 _posts：_posts中的数据文档，通过注入_layouts定义的模板，通过jekyll –server最终生成的静态页面在_sites目录。目录是用来存放你的文章的，一般以日期的形式书写标题。 _layouts：_layouts中的模板一般指向了_includes/themes中的模板。目录是用来存放模板的，在这里你可以定义页面中不同的头部和底部。 _includes： _includes/JB中有一些常用的工具，用于列表显示、评论等； _includes/themes中可参看主题的相关html文档。 _includes/themes中的主题一般包含default.html、post.html和page.html三个文档。default.html定义了网站的最上层框架（模板），post.html和page.html是其子框架（模板）。 生成好的html子页面通过default.html的{{ content }}变量调用，生成整个页面。assets渲染页面的CSS和JS文档在assets/themes中_config.yml站点生成需要用到_config.yml配置文件，站点的全局变量在_config.yml中定义，用site.访问；页面的变量在YAML Front Matter中定义，用page.访问，更多的模板变量可参考模板数据。index.html你的页面首页。Jekyll-Bootstrap创建博客 1.创建个人站点，即创建一个新资源，格式为http://username.github.com；2.安装Jekyll-Bootstrap： 1234$ git clone https://github.com/plusjade/jekyll-bootstrap.git USERNAME.github.com$ cd USERNAME.github.com$ git remote set-url origin git@github.com:USERNAME/USERNAME.github.com.git$ git push origin master 3.访问创建好的个人站点： http://username.github.com4.在本地测试查看效果： 1cd USERNAME.github.comjekyll --server 详细的教程看：http://jekyllcn.com/https://www.zhihu.com/question/30018945?sort=created 表示文章内容。我们可以用两种Liquid标记语言：输出标记（output markup）和标签标记 (tag markup)。输出标记会输出文本（如果被引用的变量存在），而标签标记不会。输出标记是用双花括号分隔，而标签标记是用花括号-百分号对分隔。[Liquid模板语言] [Liquid模板变量参考]。jekyll与github的关系：GitHub Pages一个由 GitHub 提供的用于托管项目主页或博客的服务，jekyll是后台所运行的引擎。 2 jekyll本地环境搭建1.下载最新的RubyInstaller并安装(我下载的是rubyinstaller-1.9.3-p194.exe)，设置环境变量，path中配置C:Ruby193bin目录，然后在命令行终端下输入gem update –system来升级gem；2.下载最新的DevKit，DevKit是windows平台下编译和使用本地C/C++扩展包的工具。它就是用来模拟Linux平台下的make,gcc,sh来进行编译。但是这个方法目前仅支持通过RubyInstaller安装的Ruby，并双击运行解压到C:DevKit。然后打开终端cmd，输入命令进行安装。3.完成上面的准备就可以安装Jekyll了,因为Jekyll是用Ruby编写的,最好的安装方式是通过RubyGems(gem): 1gem install Jekyll 并使用命令检验是否安装成功 1jekyll --version 4.安装Rdiscount，这个用来解析Markdown标记的包，使用如下命令： 1gem install rdiscount 5.运行本地工程：cd 到工程目录，启动服务： 1jekyll --server 3 jekyll目录结构 _posts：_posts中的数据文档，通过注入_layouts定义的模板，通过jekyll –server最终生成的静态页面在_sites目录。目录是用来存放你的文章的，一般以日期的形式书写标题。 _layouts：_layouts中的模板一般指向了_includes/themes中的模板。目录是用来存放模板的，在这里你可以定义页面中不同的头部和底部。 _includes： _includes/JB中有一些常用的工具，用于列表显示、评论等； _includes/themes中可参看主题的相关html文档。 _includes/themes中的主题一般包含default.html、post.html和page.html三个文档。default.html定义了网站的最上层框架（模板），post.html和page.html是其子框架（模板）。 生成好的html子页面通过default.html的 GitHub Pages是免费的静态站点，三个特点： 免费托管、 自带主题、 支持自制页面和Jekyll。 为什么使用github pages 搭建简单而且免费； 支持静态脚本； 可以绑定你的域名； DIY自由发挥，动手实践一些有意思的东西git,markdown,bootstrap,jekyll； 理想写博环境，git+github+markdown+jekyll； 创建github pages 安装git工具 http://windows.github.com/http://mac.github.com/ 2.两种pages模式 使用自己的用户名，每个用户名下面只能建立一个； 资源命名必须符合这样的规则username/http://username.github.com； 主干上内容被用来构建和发布页面 gh-pages分支用于构建和发布； 如果user/org pages使用了独立域名，那么托管在账户下的所有project pages将使用相同的域名进行重定向，除非project pages使用了自己的独立域名； 如果没有使用独立域名，project pages将通过子路径的形式提供服务http://username.github.com/projectname； 自定义404页面只能在独立域名下使用，否则会使用User Pages 404； 创建项目站点步骤： 123456$ git clone https://github.com/USERNAME/PROJECT.git PROJECT$ git checkout --orphan gh-pages$ git rm -rf .$ git add .$ git commit -a -m "First pages commit"$ git push origin gh-pages 可以通过User/Organization Pages建立主站，而通过Project Pages挂载二级应用页面。 创建步骤第一步：创建个人站点第二步：设置站点主题 常用命令123456789$ git clone git@github.com:username/username.github.com.git //本地如果无远程代码，先做这步，不然就忽略$ cd .ssh/username.github.com //定位到你blog的目录下$ git pull origin master //先同步远程文件，后面的参数会自动连接你远程的文件$ git status //查看本地自己修改了多少文件$ git add . //添加远程不存在的git文件$ git commit * -m "what I want told to someone"$ git push origin master //更新到远程服务器上 使用Jekyll搭建博客 1 什么是jekyllJekyll是一种简单的、适用于博客的、静态网站生成引擎。它使用一个模板目录作为网站布局的基础框架，支持Markdown、Textile等标记语言的解析，提供了模板、变量、插件等功能，最终生成一个完整的静态Web站点。说白了就是，只要安装Jekyll的规范和结构，不用写html，就可以生成网站。[jekyll介绍][jekyll on github][jekyllbootstrap]。Jekyll使用Liquid模板语言，{{page.title}}表示文章标题，{{content}}表示文章内容。我们可以用两种Liquid标记语言：输出标记（output markup）和标签标记 (tag markup)。输出标记会输出文本（如果被引用的变量存在），而标签标记不会。输出标记是用双花括号分隔，而标签标记是用花括号-百分号对分隔。[Liquid模板语言] [Liquid模板变量参考]。jekyll与github的关系：GitHub Pages一个由 GitHub 提供的用于托管项目主页或博客的服务，jekyll是后台所运行的引擎。 2 jekyll本地环境搭建1.下载最新的RubyInstaller并安装(我下载的是rubyinstaller-1.9.3-p194.exe)，设置环境变量，path中配置C:Ruby193bin目录，然后在命令行终端下输入gem update –system来升级gem；2.下载最新的DevKit，DevKit是windows平台下编译和使用本地C/C++扩展包的工具。它就是用来模拟Linux平台下的make,gcc,sh来进行编译。但是这个方法目前仅支持通过RubyInstaller安装的Ruby，并双击运行解压到C:DevKit。然后打开终端cmd，输入命令进行安装。3.完成上面的准备就可以安装Jekyll了,因为Jekyll是用Ruby编写的,最好的安装方式是通过RubyGems(gem): 1gem install Jekyll 并使用命令检验是否安装成功 1jekyll --version 4.安装Rdiscount，这个用来解析Markdown标记的包，使用如下命令： 1gem install rdiscount 5.运行本地工程：cd 到工程目录，启动服务： 1jekyll --server 3 jekyll目录结构 _posts：_posts中的数据文档，通过注入_layouts定义的模板，通过jekyll –server最终生成的静态页面在_sites目录。目录是用来存放你的文章的，一般以日期的形式书写标题。 _layouts：_layouts中的模板一般指向了_includes/themes中的模板。目录是用来存放模板的，在这里你可以定义页面中不同的头部和底部。 _includes： _includes/JB中有一些常用的工具，用于列表显示、评论等； _includes/themes中可参看主题的相关html文档。 _includes/themes中的主题一般包含default.html、post.html和page.html三个文档。default.html定义了网站的最上层框架（模板），post.html和page.html是其子框架（模板）。 生成好的html子页面通过default.html的{{ content }}变量调用，生成整个页面。assets渲染页面的CSS和JS文档在assets/themes中_config.yml站点生成需要用到_config.yml配置文件，站点的全局变量在_config.yml中定义，用site.访问；页面的变量在YAML Front Matter中定义，用page.访问，更多的模板变量可参考模板数据。index.html你的页面首页。Jekyll-Bootstrap创建博客 1.创建个人站点，即创建一个新资源，格式为http://username.github.com；2.安装Jekyll-Bootstrap： 1234$ git clone https://github.com/plusjade/jekyll-bootstrap.git USERNAME.github.com$ cd USERNAME.github.com$ git remote set-url origin git@github.com:USERNAME/USERNAME.github.com.git$ git push origin master 3.访问创建好的个人站点： http://username.github.com4.在本地测试查看效果： 1cd USERNAME.github.comjekyll --server 详细的教程看：http://jekyllcn.com/https://www.zhihu.com/question/30018945?sort=created 变量调用，生成整个页面。assets渲染页面的CSS和JS文档在assets/themes中_config.yml站点生成需要用到_config.yml配置文件，站点的全局变量在_config.yml中定义，用site.访问；页面的变量在YAML Front Matter中定义，用page.访问，更多的模板变量可参考模板数据。index.html你的页面首页。Jekyll-Bootstrap创建博客 1.创建个人站点，即创建一个新资源，格式为http://username.github.com；2.安装Jekyll-Bootstrap： 1234$ git clone https://github.com/plusjade/jekyll-bootstrap.git USERNAME.github.com$ cd USERNAME.github.com$ git remote set-url origin git@github.com:USERNAME/USERNAME.github.com.git$ git push origin master 3.访问创建好的个人站点： http://username.github.com4.在本地测试查看效果： 1cd USERNAME.github.comjekyll --server 详细的教程看：http://jekyllcn.com/https://www.zhihu.com/question/30018945?sort=created]]></content>
  </entry>
  <entry>
    <title><![CDATA[flutter]]></title>
    <url>%2F2019%2F06%2F12%2Fyuque%2Fflutter%2F</url>
    <content type="text"><![CDATA[API:https://flutterchina.club/web-analogs/知乎flutter:https://zhuanlan.zhihu.com/p/65033883]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何优雅地使用 macOS]]></title>
    <url>%2F2019%2F06%2F12%2Fyuque%2F%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8%20macOS%2F</url>
    <content type="text"><![CDATA[来自：https://www.zhihu.com/question/20873070 终端配置 (iTerm2 + zsh + oh-my-zsh + tmux) 和一些好用的小插件 oh-my-zsh theme: 自带主题已经很多了, 想折腾的, 可以自己定制一套主题 wting/autojump: 终端中一键直达目录, 命令行中切换目录是最常用的操作, 只要正常 cd 过目录, 下次只要记住目录名字, 就可以直接进去, 支持模糊匹配, 用过一次, 无法离开 zsh-users/zsh-autosuggestions: 终端历史操作记录自动补全 vim-mode: 喜欢 vim 键位的可以配合oh-my-zsh开启 vim mode, 当然终端中默认使用的是emacs jeffkaufman/icdiff: diff 的 升级美化版, 高亮文件差异对比工具 jakubroztocil/httpie: curl 的升级美化版,高亮效果和返回结果格式化效果 ack: 更强大的文件内容检索, grep 的升级版本 Taskwarrior: 这个是装逼的, 终端 todo list dbcli/mycli: 这个是装逼的, 终端操作数据库的时候, 自动提示 guarinogabriel/Mac-CLI: 这个是 mac 终端工具一个集合包, 暂时还没用过 生产力工具, 介绍几个常用的插件 有道翻译: 翻译结果回车可到剪贴板 音量控制: 直接输入音量大小, 控制音量 terminal finder: terminal 的目录在 finder 中打开, finder 当前目录在 terminal 中打开 source tree: 直接进入到指定 show desktop: 隐藏所有窗口, 显示桌面 jetBrains: 直接进入到 idea 指定项目的编辑窗口 Search tabs in Safari and Chrome: 搜索到 chrome 或者 safari 中 tab 等等 日常 网易邮箱大师 网易云音乐 chrome 微信 印象笔记 QQ iPic ，图床神器，搭配个人站上传图片使用 百度网盘 Microsoft 365 MacDown，Atom上有MD撰写的插件，不过感觉没这个好用 typora, 评论好多同学分享的另外一款MD的阅读编辑器，简单大方～ 网易有道词典 Xmind，思维导图 OmniGraffle，Visio替代品 番茄土豆，番茄工作法，让你知道其实你一天的工作效率其实低的可怜 OneDrive，微软云的桌面版，可以把仓库克隆到Finder里面实现本地无缝云同步 (*2018-10-08 更新*） Folx，BT下载工具，告别迅雷 iina，播放工具，开源软件，完全免费,作者还是校友，厉害厉害（相关：作者知乎) 1password，密码管理软件，多终端密码管理 CAJ云阅读，mac版的caj阅读器，妈妈再也不用担心我下载的论文读不了了～ (*2019-01-17 更新*） duet, 如果你同时拥有一个ipad的话，你一定会需要它。屏幕扩展，让你的ipad成为你的第二个屏幕～ Things3, to-do软件，个人强推，比上面提到的番茄要好的多哈哈哈，我现在已经把番茄卸载了～ 开发工具 Dash，离线api文档，搭配aflred食用体验更佳（后文有aflred） Postman，接口测试工具 iTerm2，替换原生终端 Oh My zsh，zsh扩展，留坑待补充 brew，mac的包管理工具，类似于apt-get一套，开发环境配置不用太简单 tmux，shell多窗口管理，终端断开延续，终端历史共享等（Oh My Tmux!，tmux配套插件，酌情选择使用） Xcode，特别说明，mac的一些系统扩展需要xcode支持，必须下载xcode才能使用 Docker，容器盒子 Atom，GitHub官方IDE，对git有很好的支持，感觉都不会使用sourceTree了 VS Code,另外一款IDE，微软旗下，速度性能很优秀，不输Atom，可以两个都下，同时品味，然后选择最喜欢的一款～ SourceTree，对，就是这个软件，Git的GUI管理软件 Navicat，数据库管理GUI 奇技淫巧（系统增强） Aflred，WorkFlow神器，谁用谁知道 TotalFinder，Finder增强，多标签页管理Finder Dr.Cleaner，内存监控，系统优化 Proxifier ，网络代理软件，支持对单一软件的强制代理 Bartender，菜单栏管理软件，给你一个简洁优雅的菜单栏 Moom，窗口大小管理，谁用谁知道 iStat Menus，菜单栏系统监控（内存，网速，磁盘，电池…..) PopClip，划词增强工具，包括但不限于（上百个官方扩展）：复制，粘贴，翻译，定制搜索（淘宝，知乎，google…） ProxyeeDown，底层 HTTP 高速下载器，支持百度云不限速下载 Disk Drill，数据恢复，磁盘数据安全 Mounty，NTFS格式U盘的完全读写 Qbserve，时间监控，记录你在电脑上花费的时间 Scroll Reveser，鼠标（触摸板）控制滚动翻转，让mac上鼠标滚轮方向不再反人类 cDock，Dock栏增强，几乎你能想到的它都有，不过目前版本1.13部分功能在macOS 10.14中失效了 AppCleaner，超级小，超级好用的app删除工具 Tips（效率提升） 关于双系统： 目前我接触到的最完美的解决办法是Parallels Desktop+bootcamp。 日常使用可以使用pd做虚拟机，需要更强性能和稳定性的时候使用bootcamp。PD真的很强大。。。 关于更加详细的双系统教程，戳这里官方解释（有时间我自己做一个教程～） 通过 Parallels Desktop 使用 Boot Camp 大写键和control键交换一下。contorl键绑定了很多的快捷键，交换了之后可以打开快捷键世界的大门。 屏幕触发角设置，提高鼠标党和单手党的工作效率。 2.如果你是程序员，最好学会使用Alfred，如果你只是普通的用户那也应该学会用Spotlight。Alfred有各种好用的workflow强烈推荐！具体请看：https://github.com/zenorocha/alfred-workflows喜欢这个workflow，不用再跑到terminal里面找pid了… 借助 Alfred 的 Workflows 功能可以做哪些好玩的事情？ 3.Dash + alfred 很好用，程序员必备 这是纯 Dash，加上了 alfred 以后就变成了下面这样： 觉得这几个软件可以提高我们使用的流畅度, 便捷度高,能用快捷键尽量不要用触摸板, 能用触摸板尽量不要用鼠标,来回移动右手, 真的好累!!!!]]></content>
  </entry>
  <entry>
    <title><![CDATA[Github+Hexo搭建个人网站]]></title>
    <url>%2F2019%2F06%2F12%2Fyuque%2FGithub%2BHexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2F2019%2F06%2F12%2Fyuque%2FGit%2F</url>
    <content type="text"><![CDATA[git查看命令地址不了解GitHub,可以看 https://github.com/xirong/my-git/blob/master/how-to-use-github.md 作为一名开发者，GitHub上面有很多东西值得关注学习，可是刚刚接触GitHub，怎样一步步学习使用GitHub？怎样更高效的利用GitHub？ 在这里搜集整理网络上面的资料，汇总成这么一篇repo 《GitHub使用指南》，供大家一起学习。 GitHub 入门使用教程-图文并茂 很简洁的说明如何使用，看图即可明白。 GitHub help Sometimes you just need a little help. 中文翻译版在此GitHub 帮助文档。 GitHub 之 fork 简介指南 帮你理解清楚什么是fork，fork 的工作流有哪些。 GitHub-cheat-sheet 关于使用 git 和 GitHub 的一些技巧汇总，中文版在此GitHub秘籍 The GitHub Blog GitHub 官方博客，关注最新动态。 How to Build a GitHub GitHub一名早期员工介绍GitHub的历史，5年108名员工无人离职。 阳志平：如何高效利用GitHub 介绍的挺全，以及一些用法，如怎样利用GitHub来学习、演讲找工作等。 GitHub 支持的 emoji表情 emoji-cheat-sheet ✌️ 👏 感觉不好找到需要的表情？试试Emoji Searcher GitHub guides 从Contributing to Open Source on GitHub、Hello World、Forking Projects、Be Social、Making Your Code Citable、Mastering Issues、Mastering Markdown、Mastering Wikis、Getting Started with GitHub Pages 等9个方面图文详细讲解每一步如何使用，以及能做哪些功能。 fork-me-on-GitHub 个人博客、技术博客等如果需要添加GitHub 的彩带，可以使用此方法。 蒋鑫-GotGitHub 《Git权威指南》的作者，对GitHub有很深的了解。（由于首页打开太慢，放到了本文目录中，下面的文章既是） GitHub Skills Using Git blame to trace changes in a file 如果你想看某一个文件中每一行是谁修改的，为什么修改？那么尽情的使用 blame 按钮，发现文件的历史。 GitHub 搜索技巧 Closing issues via commit messages - 通过提交信息关闭Issues Update your forked code from original repository - 如何更新自己 Fork 的代码 更多关于 GitHub 的内容请查看：GitHubHelp 查找需要的信息。原文地址：http://www.worldhello.net/gotgithub/index.html git - Retrieve the commit log for a specific line in a file? - Stack Overflow Git - git-blame Documentation Git Book 中文版 - 查找问题的利器 - Git Blame 每一行代码都有记录—如何用git一步步探索项目的历史 - Alexia(minmin) - 博客园Git &amp; Gitlab 使用指南 一、Git 有什么奇技淫巧？ 如何以光速查看一行代码的提交记录 在保存所有的文件的情况下，删除所有的commit记录： 检出 1git checkout --orphan latest_branch 添加所有文件夹 1git add -A 评论消息改动 1git commit -am "just come and commit" 删除分支 1git branch -D master 将现有分支设置为master 1git branch -m master push 1git push -f origin master 在尝试过所有命令都不能把你从深渊里挽救出来的时候, git reflog 也许能起作用。 比如撤销一次 rebase（rebase 可是会直接修改历史的，一定要了解原理后再使用） Undoing a git rebase 每次 merge 完总是出现很多 .orig 文件，使用 git clean -f 干掉所有 untracked files rebase 一个 diverged 分支一直要解决冲突很痛苦，可以尝试在自己的分支先 squash 一下，git rebase -i，然后再 rebase 主干，解决一次冲突就 ok 了 本地有很多其实早就被删除的远程分支，可以用 git remote prune origin 全部清除掉，这样再 checkout 别的分支时就清晰多了. 1git bisect 有没有过写了一天的代码，checkin无数，结果突然发现之前没注意的地方break的时候？这个时候要在茫茫commits里寻找那个错误的commit是多么的痛苦啊。git-bisect就是大救星！git-bisect本质上就是一个二分法，用起来也很简单： 123git bisect start #startgit bisect bad #current branch is badgit bisect good &lt;SHA-1&gt; #some old commit that is good 然后只要不停的告诉git当前commit是不是好的， 1git bisect good or 1git bisect bad 就能找到罪魁祸首了！ 二、Git log常见用法 三、git checkout 命令详解 四、git重要的三个命令stash, checkout, reset的一些总结 正常的情形，修改工作区的文件然后add，commit，我使用git一般的流程是：git status ——&gt; git stash save “message…”——&gt; git pull –&gt; git stash pop ——&gt; git add . 或 git add filename ——&gt; git commit -m ‘message…’ ——&gt; git push 其中 . 表示所有的文件。 只需要撤销工作区的文件修改，即用暂存区的文件覆盖工作区中的文件 git checkout – filename 当修改的文件已经add到暂存区，需要撤销这次添加，即撤销上一次git add filename 操作： git reset – filename / git reset HEAD filename 撤销暂存区内所有的文件改动:git reset / git reset HEAD 当对上次提交不满意，可以让HEAD指针回退，而暂存区和工作区可以不用动 git reset –soft HEAD^ 如果让工作区不改变，而暂存区和引用（HEAD指针）回退一次 git reset –mixed HEAD^ 当需要彻底撤销最近的提交，HEAD指针、暂存区、工作区都回到上次的提交状态，自上一次以来的提交全部丢失 git reset –hard HEAD^ git stash 用于保存和恢复工作进度。 git stash 保存当前的工作进度。会分别对暂存区和工作区的状态进行保存。 git stash list 显示进度列表。此命令显然暗示了git stash 可以多次保存工作进度，并用在恢复时候选择。 git stash drop [] 删除一个存储的进度。默认删除最新的进度。 git stash clear 删除所有存储的进度。 git stash pop [–index] [] –index 参数：不仅恢复工作区，还恢复暂存区 指定恢复某一个具体进度。如果没有这个参数，默认恢复最新进度 如：以下命令恢复编号为0的进度的工作区和暂存区 1# git stash pop --index stash@&#123;0&#125; 如果不使用任何参数，会恢复最新保存的工作进度，并将恢复的工作进度从存储的工作进度列表中清除。 如果提供参数（来自git stash list显示的列表），则从该中恢复。恢复完毕也将从进度列表中删除。 选项–index除了恢复工作区的文件外，还尝试恢复暂存区。这也就是为什么恢复进度的时候显示的状态和保存进度前的略有不同。 git stash [save [–patch] [-k|–[no]keep-index] [-q|–quiet] []] 这条命令实际上是git stash命令的完整版。 save，即如果需要在保存工作进度的时候使 用指定的说明，必须使用如下格式： git stash save “message…” 使用参数–patch会显示工作区和HEAD的差异，通过对差异文件的编辑决定在进度中 最终要保存的工作区的内容，通过编辑差异文件可以在进度中排除无关内容。 使用-k或者–keep-index参数，在保存进度后不会将暂存区重置。默认会将暂存区和工 作区强制重置。 git stash apply [–index] [] 除了不删除恢复的进度之外，其余和git stash pop 命令一样。 检出命令git checkout是git最常用的命令之一，同时也是一个很危险的命令，因为这条命令会重写工作区。检出命令的用法如下：用法一：git checkout [-q] [] [–] …用法二：git checkout []用法三：git checkout [-m] [[-b]–orphan] ] [] 注：&lt;1&gt; 为了避免路径和引用（或者提交ID）同名而发生冲突，可以在前用两个连续的短线（短号）–作为分隔。&lt;2&gt; 在用法一中， 省略commit：用暂存区的文件覆盖工作区的文件。 加上commit：用指定提交中的文件覆盖暂存区和工作区中的文件。 &lt;3&gt;在用法二中，会改变HEAD头指针 加上：因为只有HEAD切换到一个分支才可以对提交进行跟踪，否则仍然会进入“分离头指针”的状态。在“分离头指针”状态下的提交不能被引用关联到，从而可能丢失。 所以用法二（加上）最主要的作用就是切换到某分支。(2）省略：则相当于对工作区进行状态检查。&lt;4&gt;在用法三中，主要是创建和切换到新的分支（），新的分支从指定的提交开始创建。新分支和我们熟悉的master分支没有什么实质的不同，都是在refs/heads命名空间下的引用。 下图所示的版本库模型图描述了git checkout实际完成的操作。使用： git checkout branch 检出branch分支。要完成图中的三个步骤，更新HEAD以指向branch分支，以及用branch 指向的树更新暂存区和工作区。 git checkout / git checkout HEAD 汇总显示工作区、暂存区与HEAD的差异。 git checkout – filename 用暂存区中filename文件来覆盖工作区中的filename文件。相当于撤销自上次执行git add filename以来（如果执行过）的本地修改。 git checkout – . / git checkout . 这条命令最危险！会撤销所有本地的修改（相对于暂存区）。相当于用暂存区的所有文件直接覆盖本地文件，不给用户任何确认的机会！ git reset是Git最常用的命令之一，也是最危险最容易误用的命令。用法一：git reset [-q] [] [–] …用法二：git reset [–soft –mixed | –hard | –merge | –keep] [-q] []注：（1）第一种用法（包含了路径的用法）不会重置引用，更不会改变工作区，而是用指定提交状态()下的文件()替换掉暂存区中的文件。例如：git reset HEAD 相当于取消之前执行的git add 命令时改变的暂存区。（2）第二种用法（不使用路径的用法）则会重置引用。根据不同的选项，可以对暂存区或工作区进行重置。参照下面的版本库模型图，可以看不同的参数对第二种重置语法的影响。命令格式：git reset [–soft | –mixed | –hard] []（1）使用参数–soft，如 git reset –soft 会执行上图中的操作①。即只更改引用的指向，不改变暂存区和工作区。（2）使用参数–mixed或者不使用参数（默认为–mixed），如 git reset 会执行上图中的操作①和②。即更改引用的指向及重置暂存区，但是不改变工作区。（3）使用参数–hard，如git reset –hard 会执行上图中的全部动作①、②、③，（理解为此时工作区、暂存区、commit都相同）即： ①替换引用的指向。引用指向新的提交ID。 ②替换暂存区。替换后，暂存区的内容和引用指向的目录树一致。 ③替换工作区。替换后，工作区的内容变得和暂存区一致，也和HEAD所指向的目录树内容相同。注： 引用即HEAD指针使用：git reset / git reset HEAD仅用HEAD指向的目录树重置暂存区，工作区不会受到影响，相当于将之前用git add命令更新到暂存区的内容撤出暂存区。引用也未改变，因为引用重置到HEAD相当于没有重置。git reset – filename / git reset HEAD filename仅将文件filename 的改动撤出暂存区，暂存区中其他文件不改变。相当于命令git add filename 的反射操作。git reset –soft HEAD^工作区和暂存区不改变，但是引用向前回退一次。当对最新的提交说明或者提交的更改不满意时，撤销最新的提交以便重新提交。之前提到过修补提交命令git commit –amend，用于对最新的提交进行重新提交以修补错误的提交说明或者错误的提交文件。修补提交命令实际上相当于执行了下面两条命令。（注：文件.git/COMMIT_EDITMSG保存了上次的提交日志） git reset –soft HEAD^ git commit -e -F .git/COMMIT_EDITMSGgit reset HEAD^ / git reset –mixed HEAD^工作区不改变，但是暂存区会回退到上一次提交之前，引用也会回退一次。git reset –hard HEAD^彻底撤销最近的提交。引用回退到前一次，而且工作区和暂存区都会回退到上一次提交的状态。自上一次以来的提交全部丢失。 五、如何以光速查看一行代码的提交记录 怎么查是谁写的？ 命令行工具 git blame1git blame -L 99,99 package.json 即使把这个命令设置为快捷方式，一行一行的查询也是非常耗费精力的，那么有没有一眼可以看到的方式呢？那就是直接在 GitHub 上查。]]></content>
  </entry>
  <entry>
    <title><![CDATA[vscode]]></title>
    <url>%2F2019%2F06%2F12%2Fyuque%2Fvscode%2F</url>
    <content type="text"><![CDATA[VSCode 拓展推荐 使用说明 相似功能的插件，不推荐全都装上，请挑选一个使用 本列表所有插件均已测试使用过，但不代表不存在问题 任何插件本身的问题，请到对于代码仓库提交 issue 插件 名称 简述 Auto Close Tag 自动闭合 HTML 标签 Auto Import import 提示 Auto Rename Tag 修改 HTML 标签时，自动修改匹配的标签 Babel JavaScript babel 插件，语法高亮 Babelrc .babelrc 文件高亮提示 Beautify css/sass/scss/less css/sass/less 格式化 Better Align 对齐赋值符号和注释 Better Comments 编写更加人性化的注释 Bookmarks 添加行书签 Bracket Pair Colorizer 用不同颜色高亮显示匹配的括号 Can I Use HTML5、CSS3、SVG 的浏览器兼容性检查 Code Outline 展示代码结构树 Code Runner 运行选中代码段（支持多数语言） Code Spell checker 单词拼写检查 CodeBing 快速打开 Bing 并搜索，可配置搜索引擎 Color Highlight 颜色值在代码中高亮显示 Color Info 小窗口显示颜色值，rgb,hsl,cmyk,hex 等等 Color Picker 拾色器 CSS-in-JS CSS-in-JS 高亮提示和转换 Dash 集成 Dash Debugger for Chrome 调试 Chrome Document This 注释文档生成 DotENV .env 文件高亮 EditorConfig for VS Code EditorConfig 插件 Emoji 在代码中输入 emoji endy 将输入光标跳转到当前行最后面 ESLint ESLint 插件，高亮提示 File Peek 根据路径字符串，快速定位到文件 filesize 状态栏显示当前文件大小 Find-Jump 快速跳转到指定单词位置 Font-awesome codes for html FontAwesome 提示代码段 ftp-sync 同步文件到 ftp Git Blame 在状态栏显示当前行的 Git 信息 Git History(git log) 查看 git log gitignore .gitignore 文件语法 GitLens (Git 增强)显示文件最近的 commit 和作者，显示当前行 commit 信息 GraphQL for VSCode graphql 高亮和提示 Guides 高亮缩进基准线 Gulp Snippets Gulp 代码段 HTML CSS Class Completion CSS class 提示 HTML CSS Support css 提示（支持 vue） HTMLHint HTML 格式提示 htmltagwrap 快捷包裹 html 标签 htmltagwrap 包裹 HTML Import Beautify import 分组、排序、格式化 Import Cost 行内显示导入（import/require）的包的大小 Indenticator 缩进高亮 IntelliSense for css class names css class 输入提示 JavaScript (ES6) code snippets ES6 语法代码段 JavaScript Standard Style Standard 风格 JS Refactor 代码重构工具，提取函数、变量重命名等等 JSON to TS JSON 结构转化为 typescript 的 interface JSON Tools 格式化和压缩 JSON jumpy 快速跳转到指定单词位置 language-stylus Stylus 语法高亮和提示 Less IntelliSense less 变量与混合提示 Lodash Lodash 代码段 Log Wrapper 生产打印选中变量的代码 markdownlint Markdown 格式提示 MochaSnippets Mocha 代码段 Node modules resolve 快速导航到 Node 模块 npm 运行 npm 命令 npm Intellisense 导入模块时，提示已安装模块名称 Output Colorizer 彩色输出信息 Partial Diff 对比两段代码或文件 Path Autocomplete 路径完成提示 Path Intellisense 另一个路径完成提示 Polacode 将代码生成图片 PostCss Sorting css 排序 Prettier - Code formatter prettier 官方插件 Prettify JSON 格式化 JSON Project Manager 快速切换项目 Quokka.js 不需要手动运行，行内显示变量结果 React Native Storybooks storybook 预览插件，支持 react React Playground 为编辑器提供一个 react 组件运行环境，方便调试 React Standard Style code snippets react standar 风格代码块 REST Client 发送 REST 风格的 HTTP 请求 Sass sass 插件 Settings Sync VSCode 设置同步到 Gist Sort lines 排序选中行 Sort Typescript Imports typescript 的 import 排序 String Manipulation 字符串转换处理（驼峰、大写开头、下划线等等） stylelint css/sass/less 代码风格 SVG Viewer SVG 查看器 Syncing vscode 设置同步到 gist Test Spec Generator 测试用例生成（支持 chai、should、jasmine） TODO Parser Todo 管理 TS/JS postfix completion ts/js 后缀提示 TSLint TypeScript 语法检查 Types auto installer 自动安装@types 声明依赖 TypeScript Hero TypeScript 辅助插件，管理 import、outline 等等 TypeScript Import TS 自动 import TypeScript Import Sorter import 整理排序 Typescript React code snippets React Typescript 代码段 TypeSearch TS 声明文件搜索 Version Lens package.json 文件显示模块当前版本和最新版本 vetur 目前比较好的 Vue 语法高亮 View Node Package 快速打开选中模块的主页和代码仓库 VS Live Share 实时多人协助 VSCode Great Icons 文件图标拓展 vscode-database 操作数据库，支持 mysql 和 postgres vscode-icons 文件图标，方便定位文件 vscode-random 随机字符串生成器 vscode-spotify 集成 spotify，播放音乐 vscode-styled-components styled-components 高亮支持 vscode-styled-jsx styled-jsx 高亮支持 Vue TypeScript Snippets Vue Typescript 代码段 VueHelper Vue2 代码段（包括 Vue2 api、vue-router2、vuex2） Wallaby.js 实时测试插件 12345678910111213141516171819202122232425262728293031323334353637&#123; "breadcrumbs.enabled": true, "editor.tabSize": 2, "editor.renderWhitespace": "boundary", "editor.cursorBlinking": "smooth", "editor.minimap.renderCharacters": false, "editor.fontFamily": "'Fira Code', 'Droid Sans Mono', 'Courier New', monospace, 'Droid Sans Fallback'", "editor.fontLigatures": true, "explorer.confirmDragAndDrop": false, "extensions.autoUpdate": false, "files.insertFinalNewline": true, "git.autofetch": true, "git.path": "F:\\Program Files\\Git\\cmd\\git.exe", "search.exclude": &#123; "**/node_modules": true, "**/dist": true &#125;, "typescript.locale": "en", "window.titleBarStyle": "custom", "window.title": "$&#123;dirty&#125;$&#123;activeEditorMedium&#125;$&#123;separator&#125;$&#123;rootName&#125;", "window.zoomLevel": 1, "workbench.activityBar.visible": true, "workbench.colorTheme": "Plastic - deprioritised punctuation", "workbench.iconTheme": "vscode-great-icons", "workbench.startupEditor": "newUntitledFile", "eslint.autoFixOnSave": true, "eslint.validate": ["javascript", "javascriptreact", "vue"], "vsicons.projectDetection.autoReload": true, "vsicons.dontShowNewVersionMessage": true, "tslint.autoFixOnSave": true, "debugwrapper.wrappers": &#123; "default": "console.log('$eSEL', $SEL)" &#125;, "prettier.tslintIntegration": true, "cSpell.userWords": ["Unmount"], "jest.autoEnable": false&#125; Visual Studio Code 最好的功能、插件和设置 让 create-react-app 支持 do 表达式 1.先安装@babel/plugin-proposal-do-expressions2.在.babelrc里配置： 1"plugins": ["@babel/plugin-proposal-do-expressions"] 3.vsCode 不支持 ES6 do{}表达式，这样设置即可： 全局安装：npm install -g eslint 安装 babel-eslint: npm install –save-dev babel-eslint 安装 eslint-plugin-react(如果你用 react 的话): npm install –save-dev eslint-plugin-react 创建’.eslintrc’文件 12345678910111213141516171819202122232425262728293031323334353637383940414243&#123; "env": &#123; "browser": true, "node": true, "es6": true, "jest": true, "jquery": true &#125;, "parser": "babel-eslint", "parserOptions": &#123; "ecmaVersion": 6, "sourceType": "module", "ecmaFeatures": &#123; "arrowFunctions": true, "binaryLiterals": true, "blockBindings": true, "classes": true, "defaultParams": true, "destructuring": true, "forOf": true, "generators": true, "modules": true, "objectLiteralComputedProperties": true, "objectLiteralDuplicateProperties": true, "objectLiteralShorthandMethods": true, "objectLiteralShorthandProperties": true, "octalLiterals": true, "regexUFlag": true, "regexYFlag": true, "spread": true, "superInFunctions": true, "templateStrings": true, "unicodeCodePointEscapes": true, "globalReturn": true, "jsx": true, "experimentalObjectRestSpread": true &#125; &#125;, "plugins": ["react"], "rules": &#123; "strict": 0 &#125;&#125; 关闭 vscode 的语法验证:”javascript.validate.enable” : false vscode 主题背景设置]]></content>
  </entry>
  <entry>
    <title><![CDATA[Theme]]></title>
    <url>%2F2019%2F06%2F11%2Fyuque%2FTheme%2F</url>
    <content type="text"><![CDATA[根据Hexo博客的自动发布体系，想要完整的主题，也有主题收集 hexo主题：https://hexo.io/themes/ next主题：https://theme-next.iissnan.com/]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo同步语雀文章一]]></title>
    <url>%2F2019%2F06%2F11%2Fyuque%2FHexo%E5%90%8C%E6%AD%A5%E8%AF%AD%E9%9B%80%E6%96%87%E7%AB%A0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[创建 Hexo 博客已经有 Hexo 博客的可以跳过。如果你是 Jekyll ，也可以跳过。 安装 Node.js 安装 Hexo 脚手架 12345npm install -g hexo-clihexo init blogcd blognpm install or yarn installhexo server Hexo建站参考Hexo官方文档：https://hexo.io/zh-cn/docs/ 安装语雀文章下载插件yuque-hexo 是一个 Node.js 环境下的语雀下载器，使用 npm 安装 安装 yuque-hexo 注册语雀，创建知识库，获得你的个人路径和知识库的名字，比如我的博客的知识库是 :https://www.yuque.com/fangcao/api 在 Hexo 博客的目录下面的 package.json 中，进行下面的配置 123456789101112131415161718192021222324252627282930313233343536373839&#123; "name": "hexo-site", "version": "0.0.0", "private": true, "hexo": &#123; "version": "3.8.0" &#125;, "dependencies": &#123; "hexo": "^3.8.0", "hexo-generator-archive": "^0.1.5", "hexo-generator-category": "^0.1.3", "hexo-generator-index": "^0.2.1", "hexo-generator-tag": "^0.2.0", "hexo-renderer-ejs": "^0.3.1", "hexo-renderer-marked": "^1.0.1", "hexo-renderer-stylus": "^0.3.3", "hexo-server": "^0.3.3" &#125;, "yuqueConfig": &#123; "baseUrl": "https://www.yuque.com/api/v2", "login": "fangcao", "repo": "api", "mdNameFormat": "title", "postPath": "source/_posts/yuque", "token": "放上自己的语雀token" &#125;, "scripts": &#123; "clean": "hexo clean", "clean:yuque": "DEBUG=yuque-hexo.* yuque-hexo clean", "deploy": "hexo deploy", "publish": "npm run clean &amp;&amp; npm run deploy", "dev": "hexo s", "sync": "DEBUG=yuque-hexo.* yuque-hexo sync", "reset": "npm run clean:yuque &amp;&amp; npm run sync" &#125;, "devDependencies": &#123; "yuque-hexo": "^1.6.1" &#125;&#125; 参数名 含义 默认值 postPath 文档同步后生成的路径 source/_posts/yuque cachePath 文档下载缓存文件 yuque.json mdNameFormat 文件名命名方式 (title / slug) title adapter 文档生成格式 (hexo/markdown) hexo concurrency 下载文章并发数 5 baseUrl 语雀 API 地址 - login 语雀 login (group) - repo 语雀仓库短名称 - onlyPublished 只展示已经发布的文章 如果不是 Hexo 博客，则需要按照上面的文件保存一个 package.json 到博客目录，并且配置 postPath 为正确的文章目录 同步文章 1yuque-hexo sync 语雀同步过来的文章会生成两部分文件； yuque.json: 从语雀 API 拉取的数据 source/_posts/yuque/*.md: 生成的 md 文件 支持配置 front-matter, 语雀编辑器编写示例如下: 语雀编辑器示例，可参考hexo的终极玩法 配置GitHub pages首先需要一个GitHub账号然后可以具体可参照官方教程 改变主题这是官方的主题网站将主题clone到你的theme，在配置文件中将theme改变为你下载的主题名称然后编译，运行，发布。使用next主题的可以参考官方网址 配置Travis CI之前也有不少文章用不同的方法解决上述的问题，例如利用 Dropbox 同步或者利用 Github 的 Webhooks 进行自动部署。这些方法需要付出一定的成本，因为都需要利用到一台 VPS 去完成。而今有一个更加简单而且免费的方法去完成 hexo 的自动部署，就是利用 Travis CI。重点来了，详细步骤可参考用 Travis CI 自动部署 hexo，手把手教你Travis CI,作者已经说的比较详细。需要注意的一点是：在package.json中增加depoly的命令行语句，防止travis在自动执行到npm run deploy这一步的时候报找不到该script的错。 123&quot;scripts&quot;: &#123; &quot;deploy&quot;: &quot;hexo clean &amp;&amp; hexo g -d&quot;&#125;, 上述代码加在dependencies同级即可。 查看TravisCi https://travis-ci.org/fangcao7618/fangcao7618.github.io 主题： 主题选择：next 主题主题二：https://hexo.io/themes/ https://theme-next.org/ 例子：https://www.jinrishici.com/]]></content>
  </entry>
  <entry>
    <title><![CDATA[通过 ngrok 实现 ssh 内网穿透]]></title>
    <url>%2F2019%2F06%2F11%2Fyuque%2F%E9%80%9A%E8%BF%87%20ngrok%20%E5%AE%9E%E7%8E%B0%20ssh%20%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%2F</url>
    <content type="text"><![CDATA[ngrok用 ssh 访问一台主机，如果和主机在一个局域网中或者主机拥有公网 IP，就可以使用 ssh 命令直接连接主机的 IP 地址，但是大部分公司和家庭内部都是局域网，并不能给局域网内的每一台主机都分配一个公网 IP，这时候就需要进行内网穿透，才能从外部连接到局域网内的主机。ngrok 是一个反向代理工具，可以实现将内网的端口暴露到公网，通过 ngrok，也能将 ssh 使用的端口暴露出去，以此实现 ssh 的内网穿透。 注册并下载 ngrok访问 https://ngrok.com/ 注册 ngrok 账号并下载 ngrok 客户端。 查看 ngrok 的 token访问 https://dashboard.ngrok.com/auth 查看 token并复制。 在内网机器上启动 ngrok连接 ngrok 账号 1ngrok authtoken 5TqUhMnum6ntDE8Z5HkNb_49F9ffzzcV9V7pKLVdDYc 启动 ngrok 并打开 22 端口转发 1ngrok tcp 22 --log=stdout &gt; &quot;$HOME/ngrok.log&quot; --region ap &amp; 其中 region 的 ap 代表 ngrok 新加坡节点，访问速度相比美国节点会快一些。访问 https://ngrok.com/docs#config-options 可以查看支持的所有区域。访问 http://127.0.0.1:4040。可以看到一个tcp开头的地址，通过访问这个地址，就可以转发到本机的 22 端口上。 通过 ssh 访问内网机器查看到转发地址后，就可以在外网通过 ssh 命令访问内网机器来。以上图为例，ssh 访问的命令是： 1ssh -p 10502 username@0.tcp.ap.ngrok.io 需要注意的问题由于所有流量都要经过 ngrok 服务器，而 ngrok 的服务节点又只有美国、新加坡等地，所以速度上还是比较慢的。另外，如果 ngrok 的服务节点存在安全隐患的话，存在敏感内容的泄漏的可能性。]]></content>
  </entry>
  <entry>
    <title><![CDATA[语雀 + netlify 自动部署静态博客]]></title>
    <url>%2F2019%2F06%2F11%2Fyuque%2F%E8%AF%AD%E9%9B%80%20%2B%20netlify%20%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[语雀 + netlify 1. netlify 配置1一、使用github或者gitlab登陆netlify首先，打开netlify网站(https://app.netlify.com/)然后使用github或者gitlab账号登录。二、根据github/gitlab仓库创建网站点击New site from Git按钮： 根据你的仓库所在平台选择，以下三选一：选择你需要部署的仓库：设置部署选项，包括三点： 部署分支（对应下图中 Branch to deploy）:顾名思义就是你的git仓库的分支，默认选择为master分支 打包命令（对应下图中 Build command）：就是你的打包命令，诸如 npm run build，gulp build 之类；如果本身已是静态文件，不需打包编译，这一栏则不填 打包后目录（对应下图中 Publish directory）：即执行完打包命令之后静态文件所在目录，诸如 dist，_site 之类；如果本身已是静态文件，这一栏则不填 完成之后点击途中 deploy site 按钮 三、设置域名，绑定域名进行完第二步，我们可以看到自动化部署已经开始运行了，而且过不多久，我们的网站就已经可以利用netlify域名就行访问了，如下图：可以看到netlify为我们随机生成了一个netlify下的域名，这里我们可以更改其前缀，并绑定到我们自己的域名下：&gt;&gt; 更改netlify域名前缀：首先，点击上图中 Site settings 按钮，然后在下方点击 Change site name 按钮，然后在弹出框中输入自己需要更改的前缀名，点击保存即可，如下图所示：&gt;&gt; 绑定到自己的域名下：首先，点击上上图中 Domain settings 按钮，然后在下方点击 Add custom domain 按钮，然后在弹出框中输入自己需要绑定的完整域名，点击保存，如下图所示：这个时候会显示 ！Check DNS configuration，因为我们还没有设置域名解析到netlify服务器，所以这个时候需要到你自己域名的相应服务商网站登录之后在需要绑定的域名下添加一条CNAME解析，解析的主机记录即对应的netlify域名值（这里即 codernie.netlify.com）ok，过一会儿就可以使用自己的域名访问自己的网站啦 四、生成HTTPS证书，实现HTTPS访问第四部中的Domain settings 中往下拉，可以看到 HTTPS 几个大字母：点击 Verify DNS configuration 按钮，待它变成下方绿色按钮之后，再点击：然后在弹出框中点击确认，过一会儿之后就可以使用https访问你的小站啦：看到自己的小站前面可以有绿色的安全字样，是不是很酷炫，而且很放心，再也不用担心运营商在自己的网站上挂广告啦，哈哈哈。。。等等，是不是还差了点什么：对啊，还没有强制跳转https，OK，继续 五、强制HTTP跳转HTTPS访问在第四步 Domain settings 再往下翻一点，可以看到 Force HTTPS，只需点击 Force HTTPS 即可实现，是不是很方便，如下图： 六、设置redirect利用netlify实现自动化部署和HTTPS就写到这里了。https://app.netlify.com/sites/stoic-murdock-f3d33b/settings/general 2. netlify 配置2前往 Settings -&gt; Build &amp; Deploy 找到 Build hooks，添加一个 build hook 3. 语雀配置URL 填入刚刚从 netlify 生成的 hook 链接 所有更新触发：该知识库下的任何一篇文档的更新都会触发 WebHook 仅主动推送更新触发：只在文档发布或更新的时候勾选了「文档有较大更新，推送给关注人」才会触发 WebHook 同步语雀文章Gatsby -&gt; https://github.com/Raincal/gatsby-source-yuqueVuePress -&gt; https://github.com/ulivz/vuepress-plugin-yuqueHexo -&gt; https://github.com/x-cold/yuque-hexo完成上面三步后，就可以尝试发布新文章啦！参考文章Hexo 博客终极玩法：云端写作，自动部署]]></content>
  </entry>
  <entry>
    <title><![CDATA[gatsbyjs]]></title>
    <url>%2F2019%2F06%2F10%2Fyuque%2Fgatsbyjs%2F</url>
    <content type="text"><![CDATA[gatsbyjs]]></content>
  </entry>
  <entry>
    <title><![CDATA[为什么开始]]></title>
    <url>%2F2019%2F06%2F10%2Fyuque%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%80%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[H5，即是html5，超文本标记语言，用于描述网页内容结构的语言，网页编程中由它有负责描述页面数据和信息 JS，即是JavaScript，广泛用于web应用开发中的脚本语言，负责响应用户的操作，为网页添加动态功能 native APP，即传统的原生APP开发模式，Android基于Java语言，底层调用Google的 API；iOS基于Objective-C或者Swift语言，底层调用App官方提供的API Hybrid App，即原生和web的混合开发模式，由原生提供统一的API给js调用，实现跨平台的效果 很久以前，这是hexo制作出的博客，是长这样的，当时，觉得好玩，记录了一下，后面就忘记了… 现在又重新捡起来，对过去的一些回忆吧。]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript语言基础知识点总结]]></title>
    <url>%2F2019%2F06%2F10%2Fyuque%2FJavaScript%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[写给Node.js新手的7个小技巧]]></title>
    <url>%2F2019%2F06%2F10%2Fyuque%2F%E5%86%99%E7%BB%99Node.js%E6%96%B0%E6%89%8B%E7%9A%847%E4%B8%AA%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[一些我更愿意在开始就知道东西利用 Node.js 开发是一个非常有趣，和令人满足的过程， 他有3万多个模块可以选择使用，并且所有的模块可以非常容易的集成入现有的应用之中。 无论如何，对于一些刚开始使用Node.js 开发的的人来说，很容易碰壁，在这个文章中，我会提到在你学习过程中遇到的问题。 贴士 1: 在开发环境使用 nodemon, 在生产环境使用pm2当你第一次开发Node.js应用的时候，其中一件事情就是一次又一次的运行[file].js 就和揭伤疤一样。 当我第一次开发的node app时候，这个让我感到异常挫败和痛苦， 尤其是每当我修改很小东西的时候需要control+c 幸运的是我发现了一个非常棒的工具Nodemon. 你可以利用以下的命令来安装。 npm install -g nodemonNodemon 是一个令人惊叹的工具， 当你全局安装他以后，可以通过 nodemon [file].js 来启动你的node.js scripts，它会告诉nodemon来监视你的script和scripts的所有变化，这样的Node.js开发方式非常震撼以及让大大提高开发速度。 那么，生产环境又如何，除非你用了heroku，Nodejitsu或者其他一些好的 Node.js 平台(也许他们有类似的功能)，但是碰巧你用了EC2 或者一些其他的云平台来运行你的Node.js app，你如何能然保证这是一个始终运行的Node.js app？ 案就是PM2, PM2 是一个类似于Nodemon的工具，不同之处在于它用于生产环境，和Nodemon相似的地方在于他会监控你的app的任何修改或者重新部署，但是有更好的一面， PM2 在遭遇到崩溃的时候，他会正确重启你的app. PM2的优胜之处在于当你要将app需要多核处理的时候，PM2内部集成的负载均衡可以让你很容易的去指定运行多少个实例。 pm2 start app.js -i max-i参数目的是指定运行多少个实例，在这个例子中 PM2 使用了一个常量max来扩展你的app运转到你最大的核数，不要忘记Node 平时只会运行在单核！ 贴士 2: Async 或者 Q当你专注于写了更多的node.js apps的时候，你肯定领略了什么是回调地狱。如果你还不知道,这里有一个例子： function register(name, password, cb){ checkIfNameExists(name, function(err, result){ if(err){ return cb(“error”); } checkIfPasswordGood(password, function(err, result){ if(err){ return cb(“error”); } createAccount(name,password, function(err,result){&lt;br /&gt; if(err){&lt;br /&gt; return cb(“error”);&lt;br /&gt; }&lt;br /&gt; createBlog(name, function(err, result){&lt;br /&gt; sendEmail(name, function(err, result){&lt;br /&gt; callback(result);&lt;br /&gt; });&lt;br /&gt; });&lt;br /&gt; });&lt;br /&gt; });&lt;br /&gt; });&lt;br /&gt; }&lt;br /&gt;这显然不是一个有用或者令人折服的代码， 反而进入一种回调地狱般两难的境地，是你的话将如何避免？一个简单的办法是使用events， 但是我个人不建议这么做，因为使用events来调用只有一个用途的私有方法，足以令人受挫。所以你该怎么做? 这里有两个编译好的模块async.js和Q, 他们两个都可以防止落入回调地狱。 Async.js或者 ‘async’ 让你可以容易的执行一些连续或者平行的任务，在不依赖一个又一个的嵌套循环前提下. 下面是一些来自Async的readme，写明了他支持的模式，如需获取全部的支持方式请去他们的github主页查看。 async.map([‘file1’,’file2’,’file3’], fs.stat, function(err, results){ // results is now an array of stats for each file }); async.filter([‘file1’,’file2’,’file3’], fs.exists, function(results){ // results now equals an array of the existing files}); async.parallel([ function(){ … }, function(){ … } ], callback); async.series([ function(){ … }, function(){ … } ]); async.waterfall([ function(callback){ callback(null, ‘one’, ‘two’); }, function(arg1, arg2, callback){ callback(null, ‘three’); }, function(arg1, callback){ // arg1 now equals ‘three’ callback(null, ‘done’); } ], function (err, result) { // result now equals ‘done’ });如果我们用async的waterfall来修改之前的例子,结果将更加容易阅读, 再也不用让你的代码看起来像一个死亡金字塔. 另一个重要的库叫做Q. 这个库是一个暴漏promises的概念，Promise 是一个含有’promise’方法的返回对象，他提供了一个最终的返回值，非常优雅的将javascripts的异步和node.js紧密联系在一起。 promiseMeSomething() .then(function (value) { }, function (reason) { });这个 promise me 方法正确返回了一个对象，对象将在传入value的时候调用这个方法当，并且他提供了一个额外的callback来处理失败后的返回值。 这是一个非常有条理的方式来避免回调地狱，如果你重写我们之前的那个例子，你可以非常容易的让这些函数正确被调用并执行。 就和我之前说的一样，我很不愿创建只有一个用途的一堆功能，相反的在’then’之后传入一个方法名，仅仅创建了一个匿名的内部功能和传递,当然了选择权始终在你手里。 总的来说，当你落入回调地狱的时候，是时候去看看 async.js或者Q吧。 我的选择? 当然是 Q贴士 3: 轻松调试 Node.js apps如果你从一个IDE重度集成的语言比如java 或者C# 转来调试Node.js,，你一定会感到很困扰，大部分新加入node的开发者采用了’flow’的调试模式，从这一刻开始你最好的朋友就是console.log 但是依然有更常见的调试方式来代替， Node.js 内置了一个调试器你可以称为 node debug，不过我更喜欢的 node-inspector 他们的github说 “Node Inspector 是一个使用Blink Developer Tools (以前称为WebKit Web Inspector)node.js调试器的界面,” 简而言之，node-inspector 可以让你用任何你想用的编辑器和chrome web tools来调试你的应用,这是多么的性感。 Node-inspector 可以让你做一些非常酷的事情,比如实时修改,单步调试,注入以及一堆其他非常酷的东西。 让我们来根据指示一步一步安装。 https://github.com/node-inspector/node-inspector 贴士 4: Nodefly一旦你有你的应用程序正常运行，你可能会问自己，你怎么可以监视它的性能和配置文件，以确保您的应用程序运行在最佳的速度。最简单的答案是一个伟大的服务，我称为Nodefly。 用简单的一行代码Nodefly开始监视你的应用程序内存泄漏，测量redis用了多久，mongo查询和一堆其他很酷的东西。 http://www.nodefly.com 贴士 5: 利用NPM进行模块管理Node做最常见的事情之一是通过NPM安装软件包。Node有一个惊人的包管理器安装所有指定在你的package.json的manifest文件中的模块。然而，所有初学者都会碰上保持的package.json文件中您所使用的所有的模块都是最新版。 这似乎是一个痛苦的过程,总是打开的package.json来更新新模块的依赖，但许多人不知道的是npm会为你做这个！ 非常简单运行 npm install - save module_name 然后 npm将自动更新你的package.json 包含正确的模块和版本。 npm install - save module_name贴士 6: 不要检查node_modules 文件夹虽然我们的话题一直是modules和npm，但是并不是不是很多人都知道，你不应该提交node_modules文件夹。这背后最大的原因是，没有必要提交这个文件夹。只要有人下载你的代码，他们可通过运行NPM来安装和下载所有需要的模块。 您可能会说，它是不是一个大问题，如果检查node_modules，但是，如果下载代码的人使用了和你编译modules不一样的操作系统的来安装通过NPM？你的应用程序将会崩溃，下载代码的人将不知道为什么会如此！ 举个例子bcrypt以及sentimental如果当在您安装在主机系统上编译他们，因为他们用了本地C语言组件来编译。 避免检查node_modules文件夹的方式是加入.gitignore // .gitignore node_modules/*贴士 7: 别忘记返回初学者经常犯一个很常识的错误,就是忘记callback后的返回值,虽然有些时候，这没有影响，有很多时候，你会遇到奇怪的问题，因为你的回调被调用两次。 让我们看一个简单的例子 function do(err,result, callback){ if(err){ callback(“error”); } callback(“good”); }乍一看，这个片段是有道理的。如果有错误，在回调中发送“错误。如果不发送return，调用callaback后这个函数不会停下来。它只是将移动到调用回callback(“good”)。 这样做在长期和复杂的代码行里面会节省几个小时的调试。]]></content>
  </entry>
  <entry>
    <title><![CDATA[学习Git]]></title>
    <url>%2F2019%2F06%2F10%2Fyuque%2F%E5%AD%A6%E4%B9%A0Git%2F</url>
    <content type="text"><![CDATA[Git是一个免费开源的分布式版本控制系统，用于以高效、迅速的方式处理从很小到非常大的项目。Github是程序员的名片。代码，是程序员沟通的最直接的手段。 使用Git应该是每一位程序员的必备技能（钟情于SVN的亲们勿喷），Git被很多IT公司使用并在开源届和圈内有着巨大的声誉，之前团队做项目经常使用的也都是SVN现在接触了Github后，学习掌握Git也成了顺理成章的事情。希望这篇短文可以帮助到Git的初学者，我们共同学习。 Git入门Git本身非常容易掌握，同样学习Git也很容易，通过下面几个网站你就可以轻松掌握Git。 Git的官方网站提供了Git的所有文档。墙内用户可以参考Git Reference。 书籍：《Pro Git》提供在线的中文版和英文版。 Github与Code School联合提供了一个在线互动教程：Try Git，除此之外Git Immersion也是个不错的选择。各种英文看不懂？来看看Git 简易指南 。 进阶篇：Git图解，Git Magic，Think like a Git。 Github入门Github是一群有趣的人在做的有趣的事，Github不仅仅简单的是Git服务器，更是发展成了Social Coding，在Github你可以得到的绝对超出你的想象。 Github提供了官方的帮助信息和他们的博客。 《Git权威指南》一书的作者编写的GotGitHub是一份非常好的学习资料。 好文两篇：如何高效利用Github，Gthub初级运用。 最好的学习当然是Learning by doing！]]></content>
  </entry>
  <entry>
    <title><![CDATA[gongsi]]></title>
    <url>%2F2019%2F06%2F10%2Fyuque%2Fgongsi%2F</url>
    <content type="text"><![CDATA[$$ 表示整行公式：$$ \sum_{i=1}^n a_i=0$$$$ f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$$$ \sum^{j-1}{k=0}{\widehat{\gamma}{kj} z_k}$$ 这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如：Here is an example of AppleScript: 123tell application "Foo" beepend tell]]></content>
  </entry>
  <entry>
    <title><![CDATA[兼容所有浏览器的菱形]]></title>
    <url>%2F2019%2F06%2F10%2Fyuque%2F%E5%85%BC%E5%AE%B9%E6%89%80%E6%9C%89%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%8F%B1%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;菱形裁剪&lt;/title&gt; &lt;script type="text/javascript" charset="utf-8" src="js/raph.js"&gt;&lt;/script&gt; &lt;style type="text/css" charset="utf-8"&gt; #canvas &#123; background-color: #F4F4F4; left: 0; position: absolute; top: 0; &#125; #paper &#123; left: 0; position: relative; top: 0; &#125; h2 &#123; text-align: center; &#125; #vic1, #vic2, #vic3 &#123; position:absolute; left:0; top:0; &#125; shape, span &#123; font-size: 16px; font-family:'Microsoft YaHei'; color: #ffffff; font-style: oblique; display:block; height:100%; width:100%; text-align:center; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="canvas"&gt; &lt;div id="paper"&gt; &lt;div id="vic1"&gt;&lt;/div&gt; &lt;div id="vic2"&gt;&lt;/div&gt; &lt;div id="vic3"&gt;&lt;/div&gt; &lt;div id="vic4"&gt;&lt;/div&gt; &lt;div id="vic5"&gt;&lt;/div&gt; &lt;div id="vic6"&gt;&lt;/div&gt; &lt;div id="vic7"&gt;&lt;/div&gt; &lt;div id="vic8"&gt;&lt;/div&gt; &lt;div id="vic9"&gt;&lt;/div&gt; &lt;div id="vic10"&gt;&lt;/div&gt; &lt;div id="vic11"&gt;&lt;/div&gt; &lt;div id="vic12"&gt;&lt;/div&gt; &lt;div id="vic13"&gt;&lt;/div&gt; &lt;div id="vic14"&gt;&lt;/div&gt; &lt;div id="vic15"&gt;&lt;/div&gt; &lt;div id="vic16"&gt;&lt;/div&gt; &lt;div id="vic17"&gt;&lt;/div&gt; &lt;div id="vic18"&gt;&lt;/div&gt; &lt;div id="vic19"&gt;&lt;/div&gt; &lt;div id="vic20"&gt;&lt;/div&gt; &lt;div id="vic21"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; (function(Raphael,wh) &#123; var attr = &#123; fill: "#fff", stroke: "#BCBCBC", "stroke-width": 1 &#125;, attr2 = &#123; fill: "#F8F8F8", stroke: "#BBBBBB", "stroke-width": 1 &#125;, attr3 = &#123; fill: "#795755", stroke: "#BBBBBB", "stroke-width": 1, "opacity": "0", "cursor": "pointer" &#125;, attr4 = &#123; fill: "#fff", font: "40px Georgia", "opacity": "0", 'text-anchor': 'start' &#125;, x = 30/146*wh, //距离横坐标点 这里也可以根据角度而计算 y = 30/146*wh, //距离竖坐标点 这里也可以根据角度而计算 width = wh, height = wh, xiejiao = parseInt(width * Math.sqrt(2)), //对角线 plength = document.getElementById("paper").getElementsByTagName("div").length, //总个数 itemCount = 9, //每行显示的个数 row = plength % itemCount == 0 ? plength / itemCount : parseInt(plength / itemCount) + 1, //行数 R = Raphael("paper", xiejiao * (itemCount / 2 + 0.5), xiejiao * (row + 0.5)), //绘制画布宽度 aus = &#123;&#125;, //声明数组 pstrs = attr, temp, H1 = 0, L1 = "", key = "", imagesL1 = 0, imagesH1 = 0, _index = 0; for (var i = 0; i &lt; row; i++) &#123; //console.log("第" + i + "行"); for (var j = 1; j &lt;= itemCount; j++) &#123; _index = j + i * itemCount; if (_index &gt; plength) &#123; break; &#125; //console.log(j); if (j % 2 != 0) &#123; pstrs = attr; L1 = i * xiejiao + "r45t-0"; H1 = j == 1 ? 0 : (j - 1) / 2 * xiejiao; imagesH1 = (xiejiao - 40) / 2 + xiejiao * i; imagesL1 = H1 + 30; //console.log("奇数:" + j + ":" + H1 + " " + L1 + "图:" +imagesL1+ ":"+ imagesH1); &#125; else &#123; pstrs = attr2; L1 = (i * xiejiao + xiejiao) + "r45t-" + width; H1 = j / 2 * xiejiao; imagesH1 = (0.5 * xiejiao + 30 - 40) * 2 + xiejiao * i; imagesL1 = (j / 2 - 0.5) * xiejiao + 35; //console.log("偶数:" + j + ":" + H1 + " " + L1+ "图:" +imagesL1+ ":"+ imagesH1); &#125; //绘制最底层的形状 R.path(Raphael.format("M&#123;0&#125;,&#123;1&#125;h&#123;2&#125;v&#123;3&#125;h&#123;4&#125;z", x, y, width, height, -width)).transform("t" + H1 + "," + L1 + ",0s1").attr(pstrs); //绘制内容图片 R.image("images/big_1.jpg", imagesL1, imagesH1, 133, 40); //图片的位置及大小 //绘制遮罩层 temp = R.path(Raphael.format("M&#123;0&#125;,&#123;1&#125;h&#123;2&#125;v&#123;3&#125;h&#123;4&#125;z", x, y, width, height, -width)).transform("t" + H1 + "," + L1 + ",0s1").attr(attr3); //绘制遮罩层上面的说明文字 R.text(imagesL1 + 20, imagesH1 + 20, "60." + _index+"a").attr(attr4).data("i", _index+"a"); key = "vic" + _index; aus[key] = temp; &#125; &#125; for (var state in aus) &#123; aus[state].color = Raphael.getColor(); (function(st, state) &#123; st[0].style.cursor = "pointer"; //console.log(st.next[0].childNodes[0].innerHTML.length*parseInt(st.next[0].style.fontSize)/2); st.next[0].onmouseover = function() &#123; st.animate(&#123; "opacity": ".5" &#125;); st.next.animate(&#123; "opacity": "1.0" &#125;); &#125;; st.next[0].onmouseout = function() &#123; st.animate(&#123; "opacity": "0" &#125;); st.next.animate(&#123; "opacity": "0" &#125;); &#125;; st[0].onmouseover = function() &#123; st.animate(&#123; "opacity": ".5" &#125;); st.next.animate(&#123; "opacity": "1.0" &#125;); &#125;; st[0].onmouseout = function() &#123; st.animate(&#123; "opacity": "0" &#125;); st.next.animate(&#123; "opacity": "0" &#125;); &#125;; &#125;)(aus[state], state); &#125;; &#125;)(Raphael,146); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[babel笔记]]></title>
    <url>%2F2019%2F06%2F10%2Fyuque%2Fbabel%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[bable bable 官网英文版本: https://babeljs.io/docs/en/ bable 官网中文版本: https://www.babeljs.cn/docs/git源码地址：&gt; https://github.com/babel/website]]></content>
  </entry>
  <entry>
    <title><![CDATA[vuepress]]></title>
    <url>%2F2019%2F06%2F06%2Fyuque%2FVuePress%2F</url>
    <content type="text"><![CDATA[介绍VuePress 由两部分组成：第一部分是一个极简静态网站生成器，它包含由 Vue 驱动的主题系统和插件 API，另一个部分是为书写技术文档而优化的默认主题，它的诞生初衷是为了支持 Vue 及其子项目的文档需求。 1234567891011# 安装yarn global add vuepress@next # 或者：npm install -g vuepress@next# 新建一个 markdown 文件echo '# Hello VuePress!' &gt; README.md# 开始写作vuepress dev .# 开始写作vuepress dev .]]></content>
  </entry>
  <entry>
    <title><![CDATA[web前端学习资料收集]]></title>
    <url>%2F2019%2F06%2F06%2Fyuque%2Fweb%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[读谷歌开发指南其实谷歌除了一个分很好的学习指南，但很多人都不知道。DOM(Document Object Mode) 前端学习地址和查询地址 各种开发文档大全 —–https://devdocs.io/ 开发者手册–腾讯云 多看 JavaScript指南 知乎 掘金 WordPress - 百度百科 全球最大中文百科全书 语雀–https://cn.wordpress.org/–http://www.wordpress.org.cn/ 前端免费学习网 segmentfault 学习技能，解决难题 Topics 浏览 Github 上最常用的主题 GitHub Explore Mozilla 开发者网络，简称 MDN w3schools.com https://developer.mozilla.org MDN 源于开发者，服务开发者 慕课网 懒人图库 力扣 Mac开发配置手册 推荐的经典的前端书籍 《JavaScript 忍者秘籍》 《JavaScript 高级程序设计》 《编写可维护的 JavaScript》 《Javascript 语言精粹》 《锋利的 jQuery》 《JavaScript DOM 编程艺术（第二版）》 《学习 JavaScript 数据结构与算法》 《JavaScript 权威指南》 《JavaScript 忍者秘籍》 《高性能 JavaScript》 《ECMAScript 6 标准入门》 《Build Your Own AngularJS》 《Effective JavaScript:编写高质量 JavaScript 代码的 68 个有效方法》 《你不知道的 JavaScript（上）》 《单页 Web 应用：JavaScript 从前端到后端》 《HTML5 与 CSS3 基础教程（第八版）》 《深入浅出 HTML 与 CSS》 《CSS 揭秘》 《HTML5 权威指南》 《CSS 权威指南》 《精通正则表达式》 深入理解 JavaScript 特性 Java Web 应用开发 Web全栈工程师学习大纲 推荐库 网站 文章收集 JavaScript面试题 vue面试题 ## 前端性能监控 产品]]></content>
  </entry>
</search>
