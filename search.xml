<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[原生App项目集成flutter混合开发详细指南]]></title>
    <url>%2F2019%2F07%2F12%2Fyuque%2F%E5%8E%9F%E7%94%9FApp%E9%A1%B9%E7%9B%AE%E9%9B%86%E6%88%90flutter%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[方案选择目前主流的混合开发方案有两种集成方式：源码集成： 也就是谷歌官方提供的方案[github.com/flutter/flu…]产物集成： Flutter项目单独开发，开发完成后发布成aar包或者iOS的framework形式，原生项目依赖flutter输出的制品即可。具体可以参考闲鱼的文章两种方式各有优劣，其实产物集成更好一些，不过即使是进行产物集成，也需要弄懂源码集成的方式，因为当有很多和原生交互的功能进行开发的时候，源码集成的方式可以直接调试会方便很多。根据目前我们的情况：1.参与人员都要进行flutter开发、2.持续发布和构建我可以修改控制我们现在这个项目选择了源码集成的方式。 为原生项目集成flutter整个的集成方案是参考谷歌方法：[github.com/flutter/flu…]，但是有一些不一样，我是创建了一个flutter项目后，在原生的项目中使用git submodule的形式进行管理的。 1.创建flutter module project我们假定已经有了原生的项目Native-iOS和Native-Android；现在我们需要创建我们的flutter项目。 把我们的flutter的channel切换到master(master分支下是flutter的preview版本)flutter channel master 创建flutter模块的项目flutter create -t module {moduleName}我这里创建一个flutter的模块项目叫flutter_module 1234567891011➜ flutter create -t module flutter_moduleCreating project flutter_module... flutter_module/test/widget_test.dart (created) ... ... flutter_module/.idea/workspace.xml (created)Running &quot;flutter packages get&quot; in flutter_module... 7.2sWrote 12 files.All done!Your module code is in flutter_module/lib/main.dart.复制代码 创建成功后我们可以看一下目录结构 12345678910111213141516171819➜ flutter_module git:(master) ✗ tree -L 2 -a.├── .android│ ├── Flutter│ ├── app│ ├── ...├── .gitignore├── .ios│ ├── Config│ ├── Flutter│ ├── ...│ └── Runner.xcworkspace├── lib│ └── main.dart├── pubspec.lock├── pubspec.yaml└── test └── widget_test.dart复制代码 在flutter的模块项目中包含有一个隐藏的.android和.ios目录这个目录下是可运行的Android和iOS项目，我们的flutter代码还是在lib下编写，注意在.android和.ios目录下都有一个Flutter目录，这个是我们flutter的库项目了。也就是Android用来生成aar，iOS用来生产framework的库。如果我们用flutter create xxx 生成的纯flutter项目是没有这个Flutter目录的。 把该项目使用git管理起来，稍后我们要在native项目中以子模块的形式添加进去。 12345➜ cd flutter_module➜ git initInitialized empty Git repository in /Users/zhiqiangdeng/Documents/ProjectSource/FlutterProject/flutter_module/.git/➜ flutter_module git:(master) ✗复制代码 初始化git仓库后我们先编辑一下项目下的.gitignore文件，当前这个文件是把项目下的–.ios和.android忽略掉的。这个两个项目我们需要跟踪一下，大家可以去github上找一下iOS和Android的gitignore模版文件，然后添加到这个两个目录中，然后把顶层目录的文件作出如下修改，删除.android和.ios添加.ios/Flutter/Generated.xcconfig.gitignore文件: 1234-.android/-.ios/+.ios/Flutter/Generated.xcconfig复制代码 上面的内容做一些更正，不需要编辑.gitignore文件使用自动生成的即可。.android和.ios目录在每次执行flutter packages get命令会自动生成（团队其他成员拉取代码后没有.android和.ios执行一下flutter packages get即可） 提交你的flutter模块项目到你的git服务器(我提交到github上了[github.com/zakiso/flut…]大家可以参考)123git remote add origin &#123;你的flutter module的仓库地址&#125;git push origin master复制代码 2.给iOS项目集成flutter1.进入我们原生的iOS项目根目录中，为它添加一个git submodule，把我们的flutter项目拉取下来. 123git submodule add &#123;你的flutter module的仓库地址&#125;git submodule update复制代码 2.在项目的Podfile文件中添加下面的代码，在每次执行pod install会运行podhelper.rb 12345678910platform :ios, &apos;8.0&apos;use_frameworks!target &apos;MyApp&apos; do pod &apos;AFNetworking&apos;, &apos;~&gt; 2.6&apos; xxxxend#添加如下两行代码，路径修改为我们的fluter module的路径flutter_application_path = &apos;./flutter-module-demo&apos; eval(File.read(File.join(flutter_application_path, &apos;.ios&apos;, &apos;Flutter&apos;, &apos;podhelper.rb&apos;)), binding)复制代码 3.打开Xcode关闭bitcode配置Build Settings-&gt;Build Options-&gt;Enable Bitcode4.添加编译脚本，打开Xcode在 Build Phases中添加New Run Script Phase在里面填入如下脚本 123&quot;$FLUTTER_ROOT/packages/flutter_tools/bin/xcode_backend.sh&quot; build&quot;$FLUTTER_ROOT/packages/flutter_tools/bin/xcode_backend.sh&quot; embed复制代码 5.项目的配置完成现在需要生成一些配置文件a. 进入原生项目的flutter模块目录中执行flutter packages get命令b. 回到原生项目根目录执行pod install 1234567891011121314151617➜ cd flutter-module-demo➜ flutter-module-demo git:(master) flutter packages getRunning &quot;flutter packages get&quot; in flutter-module-demo... 0.4s➜ flutter-module-demo git:(master) cd ..➜ FlutterNativeiOS git:(master) ✗ pod installAnalyzing dependenciesFetching podspec for `Flutter` from `./flutter-module-demo/.ios/Flutter/engine`Fetching podspec for `FlutterPluginRegistrant` from `./flutter-module-demo/.ios/Flutter/FlutterPluginRegistrant`Downloading dependenciesUsing AFNetworking (2.6.3)Installing Flutter (1.0.0)Installing FlutterPluginRegistrant (0.0.1)Generating Pods projectIntegrating client projectSending statsPod installation complete! There are 3 dependencies from the Podfile and 3 total pods installed.复制代码 到此为止我们的原生项目就已经集成好了flutter项目了。5.在原生项目中使用flutter，下面以swift项目为例修改AppDelegate.swift:注意AppDelegate是集成自FlutterAppDelegate 123456789101112131415import UIKitimport Flutterimport FlutterPluginRegistrant // Only if you have Flutter Plugins.@UIApplicationMainclass AppDelegate: FlutterAppDelegate &#123; var flutterEngine : FlutterEngine?; // Only if you have Flutter plugins. override func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool &#123; self.flutterEngine = FlutterEngine(name: &quot;io.flutter&quot;, project: nil); self.flutterEngine?.run(withEntrypoint: nil); GeneratedPluginRegistrant.register(with: self.flutterEngine); return super.application(application, didFinishLaunchingWithOptions: launchOptions); &#125;&#125;复制代码 修改Controller代码 123456789101112131415import UIKitimport Flutterclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() let button = UIButton(type:UIButtonType.custom) ... self.view.addSubview(button) &#125; @objc func handleButtonAction() &#123; let flutterEngine = (UIApplication.shared.delegate as? AppDelegate)?.flutterEngine; let flutterViewController = FlutterViewController(engine: flutterEngine, nibName: nil, bundle: nil)!; self.present(flutterViewController, animated: true, completion: nil) &#125;复制代码 RUN….3.iOS项目集成过程梳理整个的集成过程其实总得来说是如下三个步骤：1.将flutter项目放入原生项目的文件夹下2.在podfile中添加podhelper.rb配置3.在Xcode的build phases添加&quot;$FLUTTER_ROOT/packages/flutter_tools/bin/xcode_backend.sh&quot;iOS编译脚本。其中podhelper.rb文件位于我们flutter模块项目的.ios/Flutter/podhelper.rb下，大家查看它的源码可以发现，它有下面几个作用：1.把Flutter（flutterEngine）和FlutterPluginRegistrant两个库用pod给原生项目导入进入2.如果flutter项目有用到flutter plugin插件，把插件用pod导入3.导入Generated.xcconfig的相关配置信息，在podhelper.rb同级别的目录下还有一个Generated.xcconfig文件，这个文件在使用flutter create xx、flutter run xxx、flutter packages get命令的时候如果该文件不存在则会生成这个文件。这个文件内容如下：123456789// This is a generated file; do not edit or check into version control.FLUTTER_ROOT=/Users/zhiqiangdeng/.flutter_wrapper/1.2.2-pre.43FLUTTER_APPLICATION_PATH=/Users/zhiqiangdeng/Documents/ProjectSource/XcodeProject/lianhua-order-iOS/order-check-module-flutterFLUTTER_TARGET=lib/main.dartFLUTTER_BUILD_DIR=buildSYMROOT=$&#123;SOURCE_ROOT&#125;/../build/iosFLUTTER_BUILD_NAME=1.0.0FLUTTER_BUILD_NUMBER=1复制代码 他记录了当前flutter sdk的目录位置，以及版本号，还有项目模块的目录位置。这个文件的内容在执行pod install的时候会被写入到xcode build setting中，在执行完pod install之后，可以在原生项目根目录使用xcodebuild -showBuildSettings|grep flutter 查看相关的信息。最后一步就是运行程序，运行程序的时候在Build phase添加了xcode_backend.sh该脚本会使用到上面pod install给xcode build setting设置的那些环境变量，然后找到项目目录生成AppFramework。 4.给原生Android项目集成FlutterAndroid的文章很多，这里不再详细描述了1.在原生Android项目中添加子模块，将上面创建的flutter module项目拉取到原生安卓项目中 123git submodule add &#123;你的flutter module的仓库地址&#125;git submodule update复制代码 2.在根目录的settings.gradle中添加如下配置12345setBinding(new Binding([gradle: this])) evaluate(new File( &apos;&#123;xxxxx你的flutter module目录&#125;/.android/include_flutter.groovy&apos; )) 复制代码 3.在原生项目的app目录下的build.gradle文件中添加Flutter库的依赖1234dependencies &#123; implementation project(&apos;:flutter&apos;)&#125;复制代码 4.在原生代码中集成flutter跳转到flutter页面我使用了一个新的Activity进行跳转。具体可以参看源码 12345678910Button open = findViewById(R.id.openBtn);open.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(); intent.setClass(MainActivity.this, MyFlutterActivity.class); startActivity(intent); &#125;&#125;);复制代码 1234567891011121314151617181920212223public class MyFlutterActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_flutter); final FlutterView flutterView = Flutter.createView( this, getLifecycle(), &quot;route1&quot; ); final FrameLayout layout = findViewById(R.id.flutter_container); layout.addView(flutterView); final FlutterView.FirstFrameListener[] listeners = new FlutterView.FirstFrameListener[1]; listeners[0] = new FlutterView.FirstFrameListener() &#123; @Override public void onFirstFrame() &#123; layout.setVisibility(View.VISIBLE); &#125; &#125;; flutterView.addFirstFrameListener(listeners[0]); &#125;&#125;复制代码 5.团队中其他同事协同开发 拉取项目源码git clone xxxxx{项目地址} 初始化项目中的子模块git submodule init &amp;&amp; git submodule update 执行flutter packages get (有时候可能出现无法运行可以进入.ios和.android中分别执行pod install 和 gradle assembleDebug,或者flutter build ios,flutter build apk等命令构建一次) Run… Android从原生跳到Flutter模块的黑屏问题，在网上看到很多说设置透明主题的但是没有用，后来看到一种先隐藏显示，等待渲染好第一帧后才显示flutter页面的方法。这里要注意一点要在布局中先把flutter的Container布局设置为InVisible状态，不要使用Gone，用gone的话是不显示也不渲染，用InVisible不显示但是会渲染界面占位置，等待渲染完成后再设置为Visible即可。 6.flutter的版本管理在我们的开发过程中遇到了一个问题，就是各个开发者使用的flutter sdk版本不一致，导致一些库无法运行，在网上也遇到有相同问题的人，提出了模仿gradle wrapper来做一个flutter_wrapper的思路。于是我根据自己的需要写了一个flutter_wrapper的小工具。它的主要作用是统一开发人员的本地flutter环境。使用说明 在你的项目根目录中执行命令下载脚本curl -O https://raw.githubusercontent.com/zakiso/flutterw/master/flutterw &amp;&amp; chmod 755 flutterw 下载好脚本后在根目录中使用./flutterw init该命令会收集你当前系统中的flutter版本，并将相关信息写入flutter_wrapper.properties文件中，团队中所有成员都会以该版本号做为该项目的标准版本 将flutterw文件和flutter_wrapper.properties文件添加到git中提交到仓库里 其他成员拉取代码后在项目中使用flutter命令的地方使用./flutterw代替，如果使用ide请选择home目录下对应版本的sdk包 flutterw做了什么？ 使用flutterw的时候会获取当前目录下的flutter_wrapper.properties文件中的版本号 去用户的${HOME}/flutter_wrapper/{版本号}/ 目录下查找是否有该版本sdk 如果没有该版本sdk会下载下来，然后使用该目录下的sdk执行命令 注意事项如果flutter版本是preview的版本是直接使用master的最新代码来管理的。大家可以查看源码很简单，根据自己的需要定制。项目demo我已经传到github中：有遇到问题的可以参考项目源码 原生Android集成Flutter项目： github.com/zakiso/flut… 原生iOS集成Flutter项目： github.com/zakiso/flut… Flutter模块项目： github.com/zakiso/flut… Flutter_Wrapper: github.com/zakiso/flut…最后： 我们整个项目都是使用git进行管理的，虽然每个开发者都需要安装flutter环境，但是对于小团队来说成本并不高，加上flutter_wrapper也保证了版本的一致性。iOS开发者可以在原来的iOS项目中开发flutter的项目，Android开发者可以在原android项目中开发flutter，flutter开发者也可以自己单独开发flutter项目，这种方式其实对于开发者来说也是很方便的。Everything 用flutter开发的一款App，把记账本日记本，行程，待办等等都装进一个App里everythings.app/转自：https://juejin.im/post/5c6eba82518825626b76f0eb]]></content>
  </entry>
  <entry>
    <title><![CDATA[常用的判断技巧]]></title>
    <url>%2F2019%2F07%2F11%2Fyuque%2F%E5%B8%B8%E7%94%A8%E7%9A%84%E5%88%A4%E6%96%AD%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[1、 用于整数的奇偶性判断 一个整数a, a &amp; 1 这个表达式可以用来判断a的奇偶性。二进制的末位为0表示偶数，最末位为1表示奇数。使用a%2来判断奇偶性和a &amp; 1是一样的作用，但是a &amp; 1要快好多。 123var a=3,b=6;a&amp;1 //1b&amp;1 //0 2、 判断n是否是2的正整数冪 (!(n&amp;(n-1)) )&amp;&amp; n 举个例子：如果n = 16 = 10000， n-1 = 1111那么：10000&amp; 1111———-** 0再举一个例子：如果n = 256 = 100000000， n-1 = 11111111那么：100000000&amp;11111111————–0好！看完上面的两个小例子，相信大家都有一个感性的认识。从理论上讲，如果一个数a他是2的正整数幂，那么a 的二进制形式必定为1000…..（后面有0个或者多个0），那么结论就很显然了。 1234567var a=n=&gt;(!(n&amp;(n-1)) )&amp;&amp; na(16) //16a(13) //falsea(2) //2a(4) //4a(5) //falsea(1) //1 3、 统计n中1的个数 朴素的统计办法是：先判断n的奇偶性，为奇数时计数器增加1，然后将n右移一位，重复上面步骤，直到移位完毕。朴素的统计办法是比较简单的，那么我们来看看比较高级的办法。 举例说明，考虑2位二进制数 n=11，里边有2个1，先提取里边的偶数位10，奇数位01，把偶数位右移1位，然后与奇数位相加，因为每对奇偶位相加的和不会超过“两位”，所以结果中每两位保存着数n中1的个数；相应的如果n是四位整数 n=0111，先以“一位”为单位做奇偶位提取，然后偶数位移位（右移1位），相加；再以“两位”为单位做奇偶提取，偶数位移位（这时就需要移2位），相加，因为此时没对奇偶位的和不会超过“四位”，所以结果中保存着n中1的个数，依次类推可以得出更多位n的算法。整个思想类似分治法。在这里就顺便说一下常用的二进制数：0xAAAAAAAA=101010101010101010101010101010100x55555555 = 1010101010101010101010101010101（奇数位为1，以1位为单位提取奇偶位） 0xCCCCCCCC = 110011001100110011001100110011000x33333333 = 110011001100110011001100110011（以“2位”为单位提取奇偶位） 0xF0F0F0F0 = 111100001111000011110000111100000x0F0F0F0F = 1111000011110000111100001111（以“8位”为单位提取奇偶位） 0xFFFF0000 =111111111111111100000000000000000x0000FFFF = 1111111111111111（以“16位”为单位提取奇偶位） 例如：32位无符号数的1的个数可以这样数： 举个例子吧，比如说我的生日是农历2月11，就用211吧，转成二进制：n = 11010011计算n = ((n &amp; 0xAAAAAAAA) &gt;&gt; 1) + (n &amp; 0x55555555);得到 n = 10010010计算n = ((n &amp; 0xCCCCCCCC) &gt;&gt; 2) + (n &amp; 0x33333333);得到 n = 00110010计算n = ((n &amp; 0xF0F0F0F0) &gt;&gt; 4) + (n &amp; 0x0F0F0F0F);得到 n = 00000101 —————–à无法再分了，那么5就是答案了。 12345678910111213141516171819var count_one=n=&gt;&#123; //0xAAAAAAAA，0x55555555分别是以“1位”为单位提取奇偶位 n = ((n &amp; 0xAAAAAAAA) &gt;&gt; 1) + (n &amp; 0x55555555); //0xCCCCCCCC，0x33333333分别是以“2位”为单位提取奇偶位 n = ((n &amp; 0xCCCCCCCC) &gt;&gt; 2) + (n &amp; 0x33333333); //0xF0F0F0F0，0x0F0F0F0F分别是以“4位”为单位提取奇偶位 n = ((n &amp; 0xF0F0F0F0) &gt;&gt; 4) + (n &amp; 0x0F0F0F0F); //0xFF00FF00，0x00FF00FF分别是以“8位”为单位提取奇偶位 n = ((n &amp; 0xFF00FF00) &gt;&gt; 8) + (n &amp; 0x00FF00FF); //0xFFFF0000，0x0000FFFF分别是以“16位”为单位提取奇偶位 n = ((n &amp; 0xFFFF0000) &gt;&gt; 16) + (n &amp; 0x0000FFFF); return n;&#125;count_one(211) //5 4、对于正整数的模运算（注意，负数不能这么算） 先说下比较简单的：乘除法是很消耗时间的，只要对数左移一位就是乘以2，右移一位就是除以2，传说用位运算效率提高了60%。乘2^k众所周知： n&lt;&lt;k。所以你以后还会傻傻地去敲25664的结果10264吗？直接2566&lt;&lt;4就搞定了，又快又准确。 除2^k众所周知： n&gt;&gt;k。 那么 mod 2^k 呢？（对2的倍数取模）*n&amp;((1&lt;&lt;k)-1)用通俗的言语来描述就是,对2的倍数取模，只要将数与2的倍数-1做按位与运算即可。好！方便理解就举个例子吧。思考：如果结果是要求模2^k时，我们真的需要每次都取模吗？ 在此很容易让人想到快速幂取模法。快速幂取模算法**经常做题目的时候会遇到要计算 a^b mod c 的情况，这时候，一个不小心就TLE了。那么如何解决这个问题呢？位运算来帮你吧。 首先介绍一下秦九韶算法：(数值分析讲得很清楚) 把一个n次多项式f(x) = a[n]x^n+a[n-1]x^(n-1)+……+a[1]x+a[0]改写成如下形式： f(x) = a[n]x^n+a[n-1]x^(n-1))+……+a[1]x+a[0] = (a[n]x^(n-1)+a[n-1]x^(n-2)+……+a[1])x+a[0] = ((a[n]x^(n-2)+a[n-1]x^(n-3)+……+a[2])x+a[1])x+a[0] =. ….. = (……((a[n]x+a[n-1])x+a[n-2])x+……+a[1])x+a[0]. 求多项式的值时，首先计算最内层括号内一次多项式的值，即 v[1]=a[n]x+a[n-1] 然后由内向外逐层计算一次多项式的值，即 v[2]=v[1]x+a[n-2] v[3]=v[2]x+a[n-3] …… v[n]=v[n-1]x+a[0]这样，求n次多项式f(x)的值就转化为求n个一次多项式的值。 好！有了前面的基础知识，我们开始解决问题吧 由(a ×b) mod c=( (a mod c) × b) mod c.我们可以将 b先表示成就：b = a[t] × 2^t + a[t-1]× 2^(t-1) + …… + a[0] × 2^0. (a[i]=[0,1]).这样我们由 a^b mod c = (a^(a[t] × 2^t + a[t-1]× 2^（t-1） + …a[0] × 2^0) mod c.然而我们求 a^( 2^(i+1) ) mod c=( (a^(2^i)) mod c)^2 mod c .求得。具体实现如下：使用秦九韶算法思想进行快速幂模算法，简洁漂亮 // 快速计算 (a ^ p) % m 的值 // 快速计算 (a ^ p) % m 的值int64 FastM(int64 a, int64 p, __int64 m){if (p == 0) return 1;int64 r = a % m;__int64 k = 1;while (p &gt; 1){if ((p &amp; 1)!=0){k = (k * r) % m;}r = (r * r) % m;p &gt;&gt;= 1;}return (r * k) % m;} http://acm.pku.edu.cn/JudgeOnline/problem?id=3070 5、计算掩码比如一个截取低6位的掩码：0×3F用位运算这么表示：(1&lt;&lt; 6) - 1这样也非常好读取掩码，因为掩码的位数直接体现在表达式里。按位或运算很简单，只要a和b中相应位出现1，那么a|b的结果相应位也为1。就不多说了。6、子集 枚举出一个集合的子集。设原集合为mask，则下面的代码就可以列出它的所有子集：]]></content>
  </entry>
  <entry>
    <title><![CDATA[颜色工具]]></title>
    <url>%2F2019%2F07%2F11%2Fyuque%2F%E9%A2%9C%E8%89%B2%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[ColorHexa RGB颜色值与十六进制颜色码转换工具https://www.sioe.cn/yingyong/yanse-rgb-16/ Flutter Color一个颜色由四个通道组成：红、绿、蓝和alpha通道 12345678910@override Widget build(BuildContext context) &#123; return new RotationTransition( turns: _animation, child: new Container( width: 200.0, height: 200.0, color: const Color(0xFFFF0000), //第一个0xff表示透明度100%,后面的6位代表颜色； )); &#125; 0xFFFF0000以0x开始的数据表示16进制，计算机中每位的权为16，即（16进制)10 = (10进制)1×16备注：这里的0是数字0，不是字母O！ 编程中，我们常用的还是10进制0x16进制]]></content>
  </entry>
  <entry>
    <title><![CDATA[Flutter for Web介绍]]></title>
    <url>%2F2019%2F07%2F09%2Fyuque%2FFlutter%20for%20Web%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[如何评价 Flutter for Web？针对 Web 的 Flutter 框架的技术预览版：https://flutter.dev/webGithub 仓库：https://https://github.com/flutter/flutter_webter_web示例程序：https://https://flutter.github.io/samples/ Flutter for Web架构图https://dart.dev/tutorials/web/get-started 1.安装 Dart12$ pub global activate webdev$ pub global activate stagehand 2.安装 webdev 和 stagehand:Stagehand- A Dart project generator 12$ pub global activate webdev$ pub global activate stagehand 3.创建一个wep app1234mkdir quickstartcd quickstartstagehand web-simplepub get 获取包 4.运行app12webdev servewebdev serve --auto restart 加入了热重新加载 如果觉得webdev serve –auto restart 太麻烦，可以尝试 flutter pub global run webdev serve –auto restart 5.打包发布1webdev build flutter项目和flutter web项目的不同 s/]]></content>
  </entry>
  <entry>
    <title><![CDATA[函数组件与类有什么区别？]]></title>
    <url>%2F2019%2F07%2F09%2Fyuque%2F%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E4%B8%8E%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[原文链接： overreacted.ioReact 函数组件与 React 类有什么区别？规范有段时间给出的答案是，类能提供更多的属性访问功能（例如 state ）。借助 Hooks 的话，这点是毫无疑问的。可能你听说过其中一种的性能更好，到底是哪一种呢？ 然而许多此类评判基准都是 不全面的 ，因此我会很谨慎从中的总结出结论 。性能好坏主要取决于代码实现的功能而不是你选择函数还是类的实现方式。我们研究发现，尽管两者的优化策略稍微c有点 不一样，但它们的性能差异是可以忽略的。此外我们不推荐 重写你的组件，除非你有其他的原因并且不介意当吃螃蟹的人。Hooks 还算是新功能 (就像 2014 年的 React), 而且有的“最佳做法”教程还未采用。那我们该怎么办呢，React 函数和类的有根本的区别吗？当然，它们的核心思想是不一样的.。在这篇文章中，我将会着眼于它们最大的区别函数组件自从 2015 年 被介绍 后一直存在，但总被忽视： 函数组件捕获渲染值。 让我们看看这是什么意思。 注意：本文对函数组件或类的评价。我只是在描述这两种编程模式在 React 中的区别。关于如果更广泛得使用函数组件，请参考 Hooks FAQ. 请思考以下组件。 1234567891011function ProfilePage(props) &#123; const showMessage = () =&gt; &#123; alert(&apos;Followed &apos; + props.user); &#125;; const handleClick = () =&gt; &#123; setTimeout(showMessage, 3000); &#125;; return ( &lt;button onClick=&#123;handleClick&#125;&gt;Follow&lt;/button&gt; );&#125; 这里有一个按钮，通过 setTimeout 模拟网络请求，然后弹出一个确认框。例如，如果 ‘props.user’ 是’Dan’，点击按钮3秒后会显示’Follow Dan’。如此简单。(注意，以上的例子用箭头函数还是函数声明都没关系。’function handleClick()’ 也能完全实现同样的功能。)我们如何用类来实现同样的功能呢？ 直接的转换就是这样: 1234567891011class ProfilePage extends React.Component &#123; showMessage = () =&gt; &#123; alert(&apos;Followed &apos; + this.props.user); &#125;; handleClick = () =&gt; &#123; setTimeout(this.showMessage, 3000); &#125;; render() &#123; return &lt;button onClick=&#123;this.handleClick&#125;&gt;Follow&lt;/button&gt;; &#125;&#125; 这两段代码通常都被认为是等价的。人们常常能够不受限制的在这两种模式间进行重构，却没有注意到它们的含义。然而，这两段代码有细微的差别 仔细看看，发现了吗？说实话，我观察了一段时间才发现。如果你想亲自发现的话，这里有个在线例子 作为预告 本文剩余部份解释它们的区别，以为这些区别的重要性。 继续之前，我想强调下，我所描述的区别与 React Hooks 没有任何关系。以上的例子都没有用到 Hooks 呢！这些都是关于 React 中组件函数与类的差别。如果你打算在 React 应用中大量使用函数组件，你可能会希望了解这些差别。 我们将通过 React 应用中一个普遍的 bug 来说明它们的差别。打开这个 沙盒例子 ，里面有个当前配置文件选择器，和上面两个 ProfilePage — 分别渲染一个 Follow 按钮。尝试一下顺序操作: 点击 其中一个 Follow 按钮。 改变 3 秒内选择其它配置文件。 阅读 警告框文字。 你会发现一个神奇得区别: ProfilePage 函数组件, 外 Dan 的配置文件点击 Follow。 然后导航到 Sophie 的配置文件，弹出的警告仍然是 ‘Followed Dan’。 ProfilePage 类, 则会弹出 ‘Followed Sophir ‘: 在这个例子里，第一种行为才是正确的。如果我关注了一个人，然后导航到另一个人的配置文件，我的组件不应该弄混我所关注的。 这里类的实现很明显是不对的。(尽管你应该 关注 Sophie though.) 那么为什么我们的类组件会这样呢？让我们仔细看看类组件里的showMessage 方法: 1234class ProfilePage extends React.Component &#123; showMessage = () =&gt; &#123; alert(&apos;Followed &apos; + this.props.user); &#125;; 这个类方法读取的是this.props.user. Props 在 React 中是不可变的，因此它们从未改变。 然而， this _变了_，而且一直都是可变的。确实，类的核心就是 this 。React 自身是不断得变化的，所以你能够获得最新的 render 和生命周期方法。因此，如果我们触发请求的时候，重渲染了组件，this.props 将会改变。导致showMessage 读取到的 user 来自 “太新” 的props。这里发现了一个关于用户界面的有趣观察。如果说 UI 是当前应用程序概念化的 state，事件处理器是渲染结果的一部分 — 就像视觉输出一样。那么我们的事件处理器 “属于” 带有特定 props 和 state 的特定 render。然而，设置超时回调读取 this.props Our showMessage 打破了这个关联。回调不再与任何指定的 render “捆绑”，因此 “丢失了” 正确的 props。 从 this 读取的信息切断了这种联系。 如果不存在函数组件。 我们如何解决这个问题？我们希望有某些办法 “修复” render 与正确的 props 之间的联系， 使得 showMessage回调执行时读取到他们。props 在某些地方丢失了。其中一种方法是在事件早期就读取 this.props ，然后将它明确的传递给 timeout 的完成时处理器: 123456789101112class ProfilePage extends React.Component &#123; showMessage = (user) =&gt; &#123; alert(&apos;Followed &apos; + user); &#125;; handleClick = () =&gt; &#123; const &#123;user&#125; = this.props; setTimeout(() =&gt; this.showMessage(user), 3000); &#125;; render() &#123; return &lt;button onClick=&#123;this.handleClick&#125;&gt;Follow&lt;/button&gt;; &#125;&#125; 这是 有效的。然而，这种方法会是代码变得累赘并且随着时间推移容易出错。如果我们需要更多的 prop 怎么办？如果我们需要访问 state 呢？ 如果 showMessage 调用其它方法，并且该方法需要读取 this.props.something 或者 this.state.something，我们又会遇到同样的问题。 导致我们必须将 this.props 和 this.state 作为参数传递给每一个在 showMessage 中调用到的方法。这样做会破坏类的效率。 同时也难以记忆和执行，这就是为什么人们经常需要处理 bug 的原因。将 alert 内嵌到 handleClick 也不能解决最大的问题。我们希望构建的代码是能够由多个方法组成，同时能够读取到调用时所关联的 render 对应的 props 和 state。这个问题并不只存在 React 中 — 你可以用任何一个 UI 库重构这个例子，将数据存放在一个像this. 的易变对象中将方法绑定到构造函数中能解决吗？ 123456789101112131415class ProfilePage extends React.Component &#123; constructor(props) &#123; super(props); this.showMessage = this.showMessage.bind(this); this.handleClick = this.handleClick.bind(this); &#125; showMessage() &#123; alert(&apos;Followed &apos; + this.props.user); &#125; handleClick() &#123; setTimeout(this.showMessage, 3000); &#125; render() &#123; return &lt;button onClick=&#123;this.handleClick&#125;&gt;Follow&lt;/button&gt;; &#125;&#125; 不，这样不能解决任何问题。记住，这个问题是我们读取 this.props 太晚了 — 而不是我们使用的语法有问题！然而，如果我们使用 JavaScript 的闭包，就没有这个问题了。通常会避免使用闭包，是因为 很难 确定易变变量的值。但是在 React 中，props 和 state 都是不可变的！ (或者至少是强烈建议不要改变。) 这就消除了闭包最大的绊脚石。这意味着，如果关闭了特定 render的 props 或者 state，你依然可以正确的获取到它们: 1234567891011121314class ProfilePage extends React.Component &#123; render() &#123; // Capture the props! const props = this.props; // Note: we are *inside render*. // These aren&apos;t class methods. const showMessage = () =&gt; &#123; alert(&apos;Followed &apos; + props.user); &#125;; const handleClick = () =&gt; &#123; setTimeout(showMessage, 3000); &#125;; return &lt;button onClick=&#123;handleClick&#125;&gt;Follow&lt;/button&gt;; &#125;&#125; 你能够 “捕获到” 当时 render 的 props:这种方式能确保任何的内部代码 (包括 showMessage) 都能 得到指定 render 的 props。React 再也不会 “动我们的奶酪了”。我们能够在内部添加各种想要辅助函数，并且它们都能捕获到正确的 props 和 state。 闭包拯救了我们！ 上面的例子 是正确的，但看起来很奇怪。如果一个类将方法定义在 render 里而不是使用类方法的意味着什么？的确，我们可以通过移除类这个 “壳” 以简化代码: 1234567891011function ProfilePage(props) &#123; const showMessage = () =&gt; &#123; alert(&apos;Followed &apos; + props.user); &#125;; const handleClick = () =&gt; &#123; setTimeout(showMessage, 3000); &#125;; return ( &lt;button onClick=&#123;handleClick&#125;&gt;Follow&lt;/button&gt; );&#125; 像上面，依然能够捕获到 props — React 将它们作为参数传递。 不像 this， props不会被 React 改变。如果在函数定义内解构 props就更明显了: 12345678910function ProfilePage(&#123; user &#125;) &#123; const showMessage = () =&gt; &#123; alert(&apos;Followed &apos; + user); &#125;; const handleClick = () =&gt; &#123; setTimeout(showMessage, 3000); &#125;; return ( &lt;button onClick=&#123;handleClick&#125;&gt;Follow&lt;/button&gt; );&#125; 当父组件用不同的 props 渲染 ProfilePage， React 会再次调用 ProfilePage 函数。但我们已经触发的点击事件处理器还是“属于”之前的拥有自己 user 值的 render，showMessage 调用时会读取这个值。 它们都完好无损。这就是为什么，函数组件的 例子，点击 Follow Sophie 的配置文件，再选择 Sunil 仍然弹出 ‘Followed Sophie’ 的原因:这表现是正确的。 (尽管你可能是想 follow Sunil too!) 现在我们明白 了React 中函数组件和类的最大区别了: 函数组件能够捕获渲染过的值。 通过 Hooks，同样的原理也适用于 state。 思考一下例子: 123456789101112131415161718function MessageThread() &#123; const [message, setMessage] = useState(&apos;&apos;); const showMessage = () =&gt; &#123; alert(&apos;You said: &apos; + message); &#125;; const handleSendClick = () =&gt; &#123; setTimeout(showMessage, 3000); &#125;; const handleMessageChange = (e) =&gt; &#123; setMessage(e.target.value); &#125;; return ( &lt;&gt; &lt;input value=&#123;message&#125; onChange=&#123;handleMessageChange&#125; /&gt; &lt;button onClick=&#123;handleSendClick&#125;&gt;Send&lt;/button&gt; &lt;/&gt; );&#125; (这里有个 在线例子.)然而这不是一个很好的消息应用程序 UI，但也说明了同样的观点：如果我发送了特定的消息，组件不应该弄混实际发送的消息。该函数组件的 message 捕获到的 state “属于” 浏览器触发点击事件处理器时的 render。 因此 message 被设置为我点击 “Send” 时 input 的值。 我们知道了 React 中的函数默认会捕获 props 和 state。 但是如果我们 希望 读取最新的，而不是属于特定 render 的 props 或者 state 时怎么办？ 如果我们希望 “读取将来的数据呢”?在类中，你能够通过读取this.props 或者 this.state 做到这些，因为 this 自身是可变的。React 改变了它。在函数组件中，你也可以拥有一个被所有组件 render 共享的可变值。 它就是 “ref”: 12345function MyComponent() &#123; const ref = useRef(null); // You can read or write `ref.current`. // ...&#125; 然而你必须自己管理它。A ref 与实例属性一样 。它是进入可变世界的安全舱。你可能熟悉 “DOM refs”，但 ref 的概念更广泛。它仅仅是一个能够让你放置东西的盒子。视觉上，this.something 和something.current一样。实际上它们概念上也是一样的。默认情况下，React 在函数组件里不会为最新的 props 或者 state 创建 refs。而大多数情况下你也不需要它们，为它们赋值是白费功夫的。 但你可以手动跟踪这些值: 1234567891011function MessageThread() &#123; const [message, setMessage] = useState(&apos;&apos;); const latestMessage = useRef(&apos;&apos;); const showMessage = () =&gt; &#123; alert(&apos;You said: &apos; + latestMessage.current); &#125;; const handleSendClick = () =&gt; &#123; setTimeout(showMessage, 3000); &#125;; const handleMessageChange = (e) =&gt; &#123; setMessage(e.target.value); latestMessage.current = e.target.value; &#125;; 如果我们在showMessage里读取 message ，我们将会看到按下发送按钮时的消息。但当我们读取 latestMessage.current，我们得到的是最新的值， —即使在按下发送按钮后继续输入。你可以自行比较这 两个 示例 的差别。 ref 是一种 “退出” 渲染一致性的方法，在某些情况下能够用得上。通常，你应该避免在渲染时读取或者设置 refs，因为它们是可变的。我们希望保持渲染的可预测性。 然而，如果我们希望得到特定 prop 或者 state 的最新值，手动更新 ref 会很麻烦。 我们可以使用 effect 来自动更新: 1234567function MessageThread() &#123; const [message, setMessage] = useState(&apos;&apos;); // Keep track of the latest value. const latestMessage = useRef(&apos;&apos;); useEffect(() =&gt; &#123; latestMessage.current = message; &#125;); const showMessage = () =&gt; &#123; alert(&apos;You said: &apos; + latestMessage.current); &#125;; (这里有个 示例。)我们在 effect 内部 赋值，那么 ref 的值只会在 DOM 更新后改变。这样确保了我们的变化不会破坏如 Time Slicing 和 Suspense 等依赖于可中断渲染的特性。通常情况下不需要这样使用 ref。 捕获 props 或者 state 是更好的选择。 不过, 使用imperative APIs能够很方便的解决 intervals 和订阅这类问题。请记住，你能跟踪任一值，如 — 一个 prop，一个 state 变量，整个 props 对象,，甚至是一个函数。这种方式能够很方便的优化像useCallback频繁变化这种情况。不过，使用 reducer往往是 更好的解决方式. (未来的一个博客主题！) 本文中，我们研究了类中常见的 bug，以及如果使用闭包修复。然而，你可能会注意到，当你尝试使用指定的依赖数组来优化 Hooks 时，会遇到由闭包未更新导致的 bug。那么闭包是问题所在吗？我不这么认为。正如我们上面看到的，闭包确实帮助我们 修复了 这个难以发现的问题。同样的，在并发模式下使用闭包能更容易编写正确的代码。因为组件内部逻辑屏蔽了渲染过的 props 和 state。目前为止我所见过的情况， “旧闭包” 问题都是由于错误的假设 “函数是不会变化的”或者 “props 永远保持不变”导致的。 事实并非如此，我希望本文有助于澄清。函数更新时会覆盖它们的 props 和 state — 因此它们的标识也同样重要。这不是 bug，是函数组件的一个特性。函数不应该被如 useEffect 或者 useCallback的“依赖数组”排除在外， (通常是通过useReducer 或者 the useRef来解决以上问题 — 接下来将分析如何选择它们。)当我们的 React 代码主要使用函数编写时，我们需要调整对 优化代码 以及 会随着时间变化的值的认识。正如 Fredrik 所说: 至今为止我所发现的应用 hook 最好的中心思想是 ”代码想任一值一样，任何时候都能改变”。 函数也不例外。在 React 的学习材料中普及需要点时间。它需要对类的认识做些调整。我希望这篇文章能够你以新的眼光看待类。React 函数总是能捕获到它们需要的值 — 现在我们明白了其中的原因。它们是完全不同的精灵。 转自：https://www.zcfy.cc/article/how-are-function-components-different-from-classes]]></content>
  </entry>
  <entry>
    <title><![CDATA[是时候开始使用 CSS 自定义属性了]]></title>
    <url>%2F2019%2F07%2F09%2Fyuque%2F%E6%98%AF%E6%97%B6%E5%80%99%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8%20CSS%20%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E4%BA%86%2F</url>
    <content type="text"><![CDATA[原文链接： www.smashingmagazine.com在今天，css预加载已经成为了前端开发的一个标准。预加载的一个主要优势就是可以让你使用变量。它可以让你避免复制黏贴你的代码，并且简化了开发和重构。我们用预加载来存储颜色、字体偏好，布局的细节——几乎是我们在css里面用到的所有东西。但是预加载的变量有一些使用上的限制： 你不能动态的改变他们。 他们不能认出DOM结构。 他们不能用JavaScript读取和改变。 为了解决这样或那样的问题，社区发明了CSS自定义属性。本质上这看上去和实现起来就像CSS变量。并且他们的实现方式就像他们的名字一样。自定义属性为前端开发打开了新的大门。 深入阅读: A Detailed Introduction To Custom Elements Houdini: Maybe The Most Exciting Development In CSS You’ve Never Heard Of Turn Your AMP Up To 11: Everything You Need To Know About Google’s Accelerated Mobile Pages A Better iOS Architecture: A Deep Look At The Model-View-Controller Pattern申明和使用自定义属性的语法在你开始学习心得预处理器或者框架的使用通常的问题是你必须学习新的语法。每一种预处理器都使用不同的方法申明变量。通常使用一个保留字符作为开始——举个例子，Sass的$、LESS的@。CSS自定义属性同样也是用保留字符 --来引入声明。但是好处是你只需要学一遍语法就能在所有浏览器上使用。你可能会问，“为什么不使用已经有的语法？”这是有原因的。简单来说这提供了一种在任何预处理器中使用自定义属性的方式。在这种方式下我们可以使用自定义属性，预处理器也不会编译他们，所以这些属性会直接输出到编译后的CSS中。并且你也可以重复使用预处理器变量在源文件中，这个我稍后会细说。（关于这个名字：因为他们的想法和目标非常相似，有些时候自定义属性被叫做CSS变量，尽管正确名称叫CSS自定义属性，往下读你就会明白为什么这个名字是最正确的。）所以要声明一个变量来代替常用的CSS属性，就像color或者padding，用--连接一个自定义名称属性就可以：1234.box&#123; --box-color: #4d4e53; --box-padding: 0 10px;&#125; 属性的值可以是任何有效的CSS值：颜色、字符串、布局甚至是表达式。这里是有效的自定义属性的例子： 12345678910111213:root&#123; --main-color: #4d4e53; --main-bg: rgb(255, 255, 255); --logo-border-color: rebeccapurple; --header-height: 68px; --content-padding: 10px 20px; --base-line-height: 1.428571429; --transition-duration: .35s; --external-link: &quot;external link&quot;; --margin-top: calc(2vh + 20px); /* Valid CSS custom properties can be reused later in, say, JavaScript. */ --foo: if(x &gt; 5) this.width = 10;&#125; 以防万一你不知道什么是:root匹配，在HTML里他就等同与html标签，但是具有更高的特异性。自定义属性和其他的CSS属性一样是动态的、级联的。这意味着他们能在任何时候被改变是由浏览器来进行的。为了使用自定义的变量，你需要使用var()CSS函数，并且提供属性参数： 12345678.box&#123; --box-color:#4d4e53; --box-padding: 0 10px; padding: var(--box-padding);&#125;.box div&#123; color: var(--box-color);&#125; 声明和用例var()函数有一个非常便利的提供默认值的方法。如果你不确信自定义属性已经被定义并且需要一个默认值，函数的第二个参数用来作为默认值的: 123456.box&#123; --box-color:#4d4e53; --box-padding: 0 10px; /* 10px is used because --box-margin is not defined. */ margin: var(--box-margin, 10px);&#125; 你可能会希望在声明新的变量的时候能重复使用已有的变量值： 1234567.box&#123; /* The --main-padding variable is used if --box-padding is not defined. */ padding: var(--box-padding, var(--main-padding)); --box-text: &apos;This is my box&apos;; /* Equal to --box-highlight-text:&apos;This is my box with highlight&apos;; */ --box-highlight-text: var(--box-text)&apos; with highlight&apos;;&#125; 运算：+，-，*，/既然我们习惯使用预处理器和其他语言，我们也希望在处理变量的时候能使用基本运算。为了达到这个目的，CSS提供了calc()函数，作用当自定义属性的值被改变的时候浏览器会重新计算表达式： 1234567:root&#123; --indent-size: 10px; --indent-xl: calc(2*var(--indent-size)); --indent-l: calc(var(--indent-size) + 2px); --indent-s: calc(var(--indent-size) - 2px); --indent-xs: calc(var(--indent-size)/2);&#125; 特别是当你想用一个没有单位的值得时候，就需要使用calc()函数： 1234567:root&#123; --spacer: 10;&#125;.box&#123; padding: var(--spacer)px 0; /* DOESN&apos;T work */ padding: calc(var(--spacer)*1px) 0; /* WORKS */&#125; 作用域和继承在讨论CSS自定义属性的作用域之前，我们先来回顾一下JavaScript和预处理器的作用域。这样就能更好的认识他们之间的区别。我们知道在JavaScript中如果在函数中使用var关键字声明变量，那么他的作用域就在函数里面。同样的我们可以使用let和const关键字，但他们的作用域相对于变量的块作用域。在JavaScript中闭包(closure)是一个可以访问外部函数变量的函数——作用域链。闭包有三个作用域链： 它自己的作用域（即 变量定义在大括号中） 外部函数的变量 全局变量 (View large version)预处理器也是相同的，让我们用Sass来举个例子。因为这大概是今天最流行的预处理器了。在Sass中有两种类型的变量：当前作用域变量(local) 和 全局变量。一个全局变量能被申明在选择器和构造器（比如mixin）外，其他的变量就是当前作用域变量。任何嵌套的代码块都可以访问封闭变量（如JavaScript）。(View large version)这意味着在Sass中变量的作用域完全依赖代码的嵌套结构。然而CSS自定义属性完全和其他的CSS属性一样使用级联方式默认继承。当然你也不能在CSS中定义一个在选择器外的属于全局的自定义属性变量，因为这不是有效的CSS。自定义属性的全局作用域实际上就是:root的作用域，这里面定义的属性就是全局的。让我们用已知的语法知识和Sass的例子来创建一个使用原生的CSS自定义属性的例子，首先是HTML： 1234567global&lt;div class=&quot;enclosing&quot;&gt; enclosing &lt;div class=&quot;closure&quot;&gt; closure &lt;/div&gt;&lt;/div&gt; 然后是CSS: 1234567891011:root &#123; --globalVar: 10px;&#125;.enclosing &#123; --enclosingVar: 20px;&#125;.enclosing .closure &#123; --closureVar: 30px; font-size: calc(var(--closureVar) + var(--enclosingVar) + var(--globalVar)); /* 60px for now */&#125; 在CODEPEN中查看代码 css-custom-properties-time-to-start-using 1 by Serg Hospodarets (@malyw) on CodePen. 对自定义属性的更改将立即应用于所有实例到目前为止我们还没有看出他和Sass变量有什么区别。然而让我们重新给变量赋值：在Sass中，是无效的： 123456.closure &#123; $closureVar: 30px; // local variable font-size: $closureVar +$enclosingVar+ $globalVar; // 60px, $closureVar: 30px is used $closureVar: 50px; // local variable&#125; 在CODEPEN中查看代码 css-custom-properties-time-to-start-using 3 by Serg Hospodarets (@malyw) on CodePen.但是在CSS中计算的值改变了。因为font-size的值因为--closureVar值得改变重新计算了： 123456.enclosing .closure &#123; --closureVar: 30px; font-size: calc(var(--closureVar) + var(--enclosingVar) + var(--globalVar)); /* 80px for now, --closureVar: 50px is used */ --closureVar: 50px;&#125; 在CODEPEN中查看代码 css-custom-properties-time-to-start-using 2 by Serg Hospodarets (@malyw) on CodePen.这是第一个非常大的区别：如果你对自定义属性重新赋值，浏览器会重新计算所有的变量和calc()表达式。 预处理器不能识别DOM结构假如我们想在除了class是highlighted的div上使用默认的font-size下面是 HTML代码： 123456&lt;div class=&quot;default&quot;&gt; default&lt;/div&gt;&lt;div class=&quot;default highlighted&quot;&gt; default highlighted&lt;/div&gt; 让我们使用CSS自定义属性： 12345678.highlighted &#123; --highlighted-size: 30px;&#125;.default &#123; --default-size: 10px; /* Use default-size, except when highlighted-size is provided. */ font-size: var(--highlighted-size, var(--default-size));&#125; 因为第二个div元素使用了highlighted类，在highlighted类上的属性就提供给这个元素了。在这里就意味着，--hightlighted-size: 30px被提供了。是的font-size的属性被重新赋值了。一切都是这么直截了当的运行：在CODEOPEN上查看代码 css-custom-properties-time-to-start-using 4 by Serg Hospodarets (@malyw) on CodePen.接下来让我们尝试使用Sass来实现同样的例子： 12345678910111213.highlighted &#123; $highlighted-size: 30px;&#125;.default &#123; $default-size: 10px; /* Use default-size, except when highlighted-size is provided. */ @if variable-exists(highlighted-size) &#123; font-size: $highlighted-size; &#125; @else &#123; font-size: $default-size; &#125;&#125; 结果显示他们都使用默认字体大小：在CODEOPEN上查看代码 css-custom-properties-time-to-start-using 5 by Serg Hospodarets (@malyw) on CodePen.这是因为所有的Sass的计算和进程都发生在编译过程中，所以理所当然的他不知道DOM结构，所以依赖代码结构。如你所见自定义属性在变量作用域和通常的css级联样式上具有优势。并且能够识别DOM结构。和普通的CSS属性使用相同的语法规则。第二个例外是CSS自定义属性能动态的识别DOM结构 CSS关键字和all属性CSS自定义属性遵守与常规CSS自定义属性相同的规则。这意味着您可以为其分配任何常见的CSS关键字： inherit 此CSS关键字应用元素的父对象的值。 initial 这将应用CSS规范中定义的初始值（空值，或在某些CSS自定义属性的情况下）。 unset 在自定义属性中，如果属性是继承的，则应用继承的值，如果属性是初始化的值，则引用初始化值。 revert 这会将该属性重置为用户代理样式表建立的默认值（在CSS自定义属性的情况下为空值）。以下是例子： 123456.common-values&#123; --border: inherit; --bgcolor: initial; --padding: unset; --animation: revert;&#125; 我们来看另外一个例子。假设你想构建一个组件，并且想要确保没有其他样式或自定义属性被无意中应用（在这种情况下，通常会使用模块化的CSS解决方案）。现在还有另一种方法：使用allCSS属性。这个简写将重置所有CSS属性。与CSS关键字一起，我们可以执行以下操作： 123.my-wonderful-clean-component&#123; all: initial;&#125; 这会为我们的组件重置所有的样式：不幸的是，all关键字不会重置自定义属性。关于是否添加 -- 前缀，这将重置所有CSS自定义属性，正在进行讨论。所以在将来，一个完整的重置会是这样的： 1234.my-wonderful-clean-component&#123; --: initial; /* reset all CSS custom properties */ all: initial; /* reset all other CSS styles */&#125; CSS自定义属性用例有许多自定义属性使用的方式，在这里我会展示他们中最有趣的部分。 模拟不存在的CSS规则这些CSS变量的名称是自定义属性，那为什么我们不能用它来模拟不存在的CSS属性？有很多比如translateX/Y/Z,background-repeat-x/y(仍然不能跨浏览器兼容)，box-shadow-color。让我们试着模拟最后一个属性。在这个例子里当hover的时候我们改变box-shadow的颜色。我们只想遵循DRY规则（不要重复你自己），所以我们只是改变它的颜色，而不是在：hover部分重复box-shadow的整个值。（变量的改变会重新计算var()和calc()） 12345678.test &#123; --box-shadow-color: yellow; box-shadow: 0 0 30px var(--box-shadow-color);&#125;.test:hover &#123; --box-shadow-color: orange; /* Instead of: box-shadow: 0 0 30px orange; */&#125; 在CODEOPEN上查看代码 Emulating “box-shadow-color” CSS property using CSS Custom Properties by Serg Hospodarets (@malyw) on CodePen. 颜色主题自定义属性有一个最常用的用例就是应用程序中的颜色主题。自定义属性就是用来解决这类问题的。所以，让我们为一个组件提供一个简单的颜色主题（应用程序可以遵循相同的步骤）。这是button组件的代码： 12345678.btn &#123; background-image: linear-gradient(to bottom, #3498db, #2980b9); text-shadow: 1px 1px 3px #777; box-shadow: 0px 1px 3px #777; border-radius: 28px; color: #ffffff; padding: 10px 20px 10px 20px;&#125; 我们假设要反转颜色主题。第一步是将所有颜色变量扩展到CSS自定义属性并重写我们的组件。重写后的代码： 12345678910111213141516.btn &#123; --shadow-color: #777; --gradient-from-color: #3498db; --gradient-to-color: #2980b9; --color: #ffffff; background-image: linear-gradient( to bottom, var(--gradient-from-color), var(--gradient-to-color) ); text-shadow: 1px 1px 3px var(--shadow-color); box-shadow: 0px 1px 3px var(--shadow-color); border-radius: 28px; color: var(--color); padding: 10px 20px 10px 20px;&#125; 这有我们需要的一切。使用它，我们可以将颜色变量重写为反转值，并在需要时应用它们。例如，我们可以添加全局inverted类（例如，body元素），并在应用颜色时更改颜色： 123456body.inverted .btn&#123; --shadow-color: #888888; --gradient-from-color: #CB6724; --gradient-to-color: #D67F46; --color: #000000;&#125; 以下是一个演示，您可以在其中单击一个按钮来添加和删除全局类：demo在CODEOPEN中查看代码 css-custom-properties-time-to-start-using 9 by Serg Hospodarets (@malyw) on CodePen.如果不重复代码，在CSS预处理器中无法实现此行为。使用预处理器，您将始终需要覆盖实际的值和规则，这往往会导致额外的CSS。使用CSS自定义属性，解决方案可以尽可能的干净，复制黏贴是可以避免的。因为只需要对变量进行重新赋值。 在JavaScript中使用自定义属性以前，要将数据从CSS发送到JavaScript，我们经常不得不采取技巧，通过CSS输出中的纯JSON编写CSS值，然后从JavaScript读取它。现在，我们可以轻松地使用JavaScript中的CSS变量进行交互，使用众所周知的.getPropertyValue()和.setProperty()方法读取和写入它们，这些方法用于通常的CSS属性: 1234567891011121314151617181920212223/*** Gives a CSS custom property value applied at the element* element &#123;Element&#125;* varName &#123;String&#125; without &apos;--&apos;** For example:* readCssVar(document.querySelector(&apos;.box&apos;), &apos;color&apos;);*/function readCssVar(element, varName)&#123; const elementStyles = getComputedStyle(element); return elementStyles.getPropertyValue(`--$&#123;varName&#125;`).trim();&#125;/*** Writes a CSS custom property value at the element* element &#123;Element&#125;* varName &#123;String&#125; without &apos;--&apos;** For example:* readCssVar(document.querySelector(&apos;.box&apos;), &apos;color&apos;, &apos;white&apos;);*/function writeCssVar(element, varName, value)&#123; return element.style.setProperty(`--$&#123;varName&#125;`, value);&#125; 假设我们有一系列的媒体查询值 1234.breakpoints-data &#123; --phone: 480px; --tablet: 800px;&#125; 因为我们只想在JavaScript中重用它们 - 例如，在Window.matchMedia()中，我们可以轻松地从CSS中获取它们 1234const breakpointsData = document.querySelector(&apos;.breakpoints-data&apos;);// GETconst phoneBreakpoint = getComputedStyle(breakpointsData) .getPropertyValue(&apos;--phone&apos;); 为了展示如何从JavaScript分配自定义属性，我创建了一个交互式3D CSS 立方体demo，以响应用户操作。这不是很难我们只需要添加一个简单的背景，然后放置五个立方体面与transform属性的相关值：translateZ（），translateY（），rotateX（）和rotateY（）。为了提供正确的视角，我向页面添加了以下内容： 12345678910#world&#123; --translateZ:0; --rotateX:65; --rotateY:0; transform-style:preserve-3d; transform: translateZ(calc(var(--translateZ) * 1px)) rotateX(calc(var(--rotateX) * 1deg)) rotateY(calc(var(--rotateY) * 1deg));&#125; 唯一缺少的是交互性。当鼠标移动时，演示应该更改X和Y视角（–rotateX和-rotateY），当鼠标滚动（–translateZ）时应该放大和缩小）。这是JavaScript的诀窍： 1234567891011121314151617// EventsonMouseMove(e) &#123; this.worldXAngle = (.5 - (e.clientY / window.innerHeight)) * 180; this.worldYAngle = -(.5 - (e.clientX / window.innerWidth)) * 180; this.updateView();&#125;;onMouseWheel(e) &#123; /*…*/ this.worldZ += delta * 5; this.updateView();&#125;;// JavaScript -&gt; CSSupdateView() &#123; this.worldEl.style.setProperty(&apos;--translateZ&apos;, this.worldZ); this.worldEl.style.setProperty(&apos;--rotateX&apos;, this.worldXAngle); this.worldEl.style.setProperty(&apos;--rotateY&apos;, this.worldYAngle);&#125;; 现在，当用户移动鼠标时，演示会更改视图。您可以通过移动鼠标并使用鼠标滚轮放大和缩小来检查：demo在CODEOPEN中查看代码 css-custom-properties-time-to-start-using 10 by Serg Hospodarets (@malyw) on CodePen.基本上，我们只是更改了CSS自定义属性的值。其他（旋转和放大和缩小）都是由CSS完成的。提示：调整CSS自定义属性值的最简单方法之一就是在CSS生成的内容中显示其内容（在简单的情况下，例如使用字符串），以便浏览器将自动显示当前应用的值： 123body:after &#123; content: &apos;--screen-category : &apos;var(--screen-category);&#125; 您可以在纯CSS演示（无HTML或JavaScript）中查看。 （调整窗口大小，查看浏览器会自动反映更改后的CSS自定义属性值。） 浏览器支持主流浏览器都支持了CSS自定义属性:(View large version)这意味着你可以自己开始使用它们。如果您需要支持旧版浏览器，您可以学习语法和使用示例，并考虑并行切换或使用CSS和预处理器变量的可能方法。当然，我们需要能够检测CSS和JavaScript中的支持，以便提供回退或增强功能。这很容易对于CSS，您可以使用带有虚拟功能查询的@supports条件： 123456@supports ( (--a: 0)) &#123; /* supported */&#125;@supports ( not (--a: 0)) &#123; /* not supported */&#125; 在JavaScript中，您可以使用与CSS.supports（）静态方法相同的虚拟自定义属性： 1234567const isSupported = window.CSS &amp;&amp; window.CSS.supports &amp;&amp; window.CSS.supports(&apos;--a&apos;, 0);if (isSupported) &#123; /* supported */&#125; else &#123; /* not supported */&#125; 我们看到，CSS自定义属性在每个浏览器中仍然不可用。知道这一点，您可以通过检查它们是否受支持来逐步增强您的应用程序。例如，您可以生成两个主要的CSS文件：一个具有CSS自定义属性，另一个没有它们，其中属性是内联的（我们将在稍后讨论一些方法）。默认加载第二个。然后，如果支持自定义属性，只需检查JavaScript并切换到增强版本即可: 123&lt;!-- HTML --&gt;&lt;link href=&quot;without-css-custom-properties.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;all&quot; /&gt; 1234567// JavaScriptif(isSupported)&#123; removeCss(&apos;without-css-custom-properties.css&apos;); loadCss(&apos;css-custom-properties.css&apos;); // + conditionally apply some application enhancements // using the custom properties&#125; 这只是一个例子。往下看，有更好的选择。 如何开始使用它们针对最近的一项调查，Sass已经成为了开发社区中预处理器的最佳选择。所以，让我们考虑开始使用CSS自定义属性或使用Sass为他们做准备的方法。我们有一些观点。 1. 手动检查代码支持手动检查代码中自定义属性是否支持的方法的一个优点是如果它可行我们就可以直接用它（不要忘记我们已经切换到Sass）： 123456789101112$color: red;:root &#123; --color: red;&#125;.box &#123; @supports ( (--a: 0)) &#123; color: var(--color); &#125; @supports ( not (--a: 0)) &#123; color: $color; &#125;&#125; 这种方法确实有许多缺点，其中不仅仅是代码变得复杂，而且复制和粘贴变得很难维护。 2. 使用自动转换CSS的插件PostCSS生态系统今天提供了几十个插件。它们中的几个在生成的CSS输出中处理自定义属性（内联值），并使它们工作，假设您仅提供全局变量（即，您只声明或更改：根选择器中的CSS自定义属性），因此它们的值可以轻松内联。其中一个例子就是postcss-custom-properties这个插件提供了几个优点：它使语法工作;它与PostCSS的所有基础设施兼容;并且不需要太多的配置。但是有一些缺点。该插件需要您使用CSS自定义属性，因此您没有准备项目以从Sass变量切换的路径。此外，您将无法对转换进行很多控制，因为在Sass被编译为CSS之后完成。最后，插件不提供很多调试信息。 3. css-vars Mixin我开始在我大多数项目里使用CSS自定义属性并且尝试了很多策略： 用cssnext从Sass切换到PostCSS . 从Sass变量切换到纯CSS自定义属性 在Sass中使用CSS变量来检测是否支持它们。 通过这些经验，我开始寻找一个可以满足我的标准的解决方案： 它应该很容配合Sass来使用 应该直接使用，并且语法必须尽可能接近原生的CSS自定义属性。 将CSS输出从内联值切换到CSS变量应该很容易。 熟悉CSS自定义属性的团队成员将能够使用该解决方案。 应该有一种方法有使用变量的调试信息。 因此，我创建了css-vars，一个Sass mixin，可以在Github上找到。使用它，你就可以使用CSS自定义属性语法。 使用 css-vars Mixin声明变量，使用的mixin如下： 12345678$white-color: #fff;$base-font-size: 10px;@include css-vars(( --main-color: #000, --main-bg: $white-color, --main-font-size: 1.5*$base-font-size, --padding-top: calc(2vh + 20px))); 使用这些变量，用var()函数： 123456body &#123; color: var(--main-color); background: var(--main-bg, #f00); font-size: var(--main-font-size); padding: var(--padding-top) 0 10px;&#125; 这为您提供了一种从一个地方（从Sass）控制所有CSS输出并开始熟悉语法的方法。此外，您可以使用mixin重用Sass变量和逻辑。当您想要支持的所有浏览器都使用CSS变量时，您需要做的就是添加： 1`$css-vars-use-native: true;` 而不是调整生成的CSS中的变量属性，mixin将开始注册自定义属性，并且var()实例将转到生成的CSS而不进行任何转换。这意味着您将完全切换到CSS自定义属性，并具有我们讨论的所有优点。如果你想打开有用的调试信息，如下： 1`$css-vars-debug-log: true;` 这会给你 当变量没有被定义却被使用的日志 变量被重复定义的日志 当默认值代替了未定义变量值的日志 结束语现在你对CSS自定义属性有了更多的了解，包括语法、优势、一些有用的例子还有如何在JavaScript中进行交互你需要知道如何确认他们是否被支持，他们和CSS预处理器的变量有什么区别，以及如何在浏览器支持之前开始使用原生的CSS变量。这是开始使用CSS自定义属性并为浏览器支持做准备的最佳时机。(rb, vf, al, il)]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSS 与 JS 动画的底层机制 + 如何优化它们的性能]]></title>
    <url>%2F2019%2F07%2F09%2Fyuque%2FCSS%20%E4%B8%8E%20JS%20%E5%8A%A8%E7%94%BB%E7%9A%84%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6%20%2B%20%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E5%AE%83%E4%BB%AC%E7%9A%84%E6%80%A7%E8%83%BD%2F</url>
    <content type="text"><![CDATA[原文链接： blog.sessionstack.com转载：https://www.zcfy.cc/article/under-the-hood-of-css-and-js-animations-how-to-optimize-their-performance 这是致力于探索 JavaScript 及其组件的系列文章中的第 13 篇。在找寻与介绍这些核心组件的过程中，我们也分享了我们在开发SessionStack时的一些规则（SessionStack 是一个用来帮助用户实时发现与重现其应用弱点的 JavaScript 应用，因此非常注重鲁棒性与高性能。）如果你没看过之前的文章，可以看一下这里： 引擎、运行时、调用栈的介绍 Google’s V8 引擎内部 + 如何写优化过代码的5个贴士 内存管理 + 处理 4 种常见的内存泄漏 异步编程中的 event loop + 5 个写更好的 async/await 的方法 深入了解 WebSockets 和 HTTP/2与SSE +如何选择正确的方法 对 WebAssembly 的比较 + 为什么在某些情况下，它比JavaScript更好 Web Workers 的组成 + 5 个使用场景 Service Workers 的生命周期与使用场景 Web 推送通知的机制 使用 MutationObserver 来追踪 DOM 变化 渲染引擎与优化性能小贴士 在网络层之下 + 如何提高网络层的性能与安全性概览正如大家所知，动画在创建引人注目的 web 应用程序中扮演着重要的角色。随着用户越来越多地将注意力转移到用户体验上，企业开始意识到完美无缺、令人愉快的用户体验的重要性，web应用程序变得越来越重，并具有更动态的UI。这一切都需要更复杂的动画，以便在在用户的整个使用过程中更流畅地进行状态转换 —— 今天，这甚至被认为不是什么特别的事情。用户正变得越来越高级，默认情况下，他们期望具有快速响应和交互性棒的用户界面。然而，让你的界面动起来并不一定是简单的。什么交互需要动画，什么时候应该动画，动画应该有什么样的感觉，这些都是棘手的问题。JavaScript 动画 vs CSS 动画创建web动画的两种主要方法是使用JavaScript和CSS，两者本身没有对与错。所以这种 PK 完全取决于你想实现什么。CSS 动画想让屏幕上东西动起来的话，最简单的方法就是 CSS 动画。我们从一个小例子开始：把一个元素在 X 和 Y 轴上都位移 50px，通过 CSS transition 来设置一个 1000ms 的动画当 move class 被添加上时，transform 值被改变，运动开始了除了过渡时间（transition duration），还有一个 缓动（easing） 选项，这就完成了动画了。我们将会在下面进一步介绍缓动如果您像上面的代码片段一样创建单独的CSS类来管理动画，那么您可以使用JavaScript来切换每个动画。如果你有以下元素:然后你可以使用JavaScript来切换每个动画的开关:上面的代码片段获取box类的所有元素，并添加move类以触发动画。这样做会给你的应用提供很好的平衡。您可以专注于使用JavaScript管理状态，并简单地在目标元素上设置适当的类，让浏览器处理动画。然后，您可以侦听元素上的transitionend事件，但前提是您能够放弃对Internet Explorer旧版本的支持：侦听在转换结束时触发的转换事件，如下所示：除了使用CSS转换，您还可以使用CSS动画（animation），这允许您对单个动画关键帧（keyframes）、持续时间和迭代（iterations）有更多的控制。 关键帧用于指示浏览器在给定的点上CSS属性需要具有哪些值，并填补空白。 让我们看一个例子:这是它的样子(quick demo)—— https://sessionstack.github.io/blog/demos/keyframes/使用CSS动画，您可以将定义动画与元素本身分离开，并使用animation-name属性选择所需的动画。CSS动画有时还需要加供应商前缀，在Safari、Safari Mobile和Android中使用-webkit。Chrome、Opera、Internet Explorer和Firefox都没有前缀。许多工具可以帮助您创建所需CSS的前缀版本，允许您在源文件中编写无前缀版本。 JavaScript 动画与使用CSS转换或动画相比，使用JavaScript创建动画更加复杂，但它通常会为开发人员提供更强大的功能。JavaScript动画是作为代码的一部分编写的。您还可以将它们封装在其他对象中。要重新创建前面描述的CSS转换，可以用 JavaScript 这么搞：默认情况下，Web动画只修改元素的表示。如果您想让您的对象保持在它被移动到的位置，那么您应该在动画完成时修改它的底层样式。这就是为什么我们在上面的例子中监听 finish 事件，并设置 box.style。将属性转换为相等的translate(150px, 200px)，这与动画执行的第二个转换相同。使用JavaScript动画，您可以在每一步完全控制元素的样式。这意味着您可以减慢动画、暂停动画、停止动画、反转动画，并根据需要操作元素。如果您正在构建复杂的、面向对象的应用程序，这尤其有用，因为这时你往往需要对动画有一个更好的封装。 缓动是什么？更自然的动效能让用户对你的web应用程序感到更舒服，从而带来更好的用户体验。在大自然中，其实没有什么东西是从一点线性地移动到另一点的。事实上，因为我们不是在真空中，会有不同的因素导致物体在我们周围的物理世界中运动时会加速或减速。人类的大脑天生就期待这种运动，所以当你在为网络应用程序制作动画时，你应该充分理解这一点。有一些术语你需要理解: “ease in” — 这是一个开始缓慢，然后加速的运动。 “ease out” —这是一个开始很快，然后减速的运动 这两者可以组合在一起，例如 “ease in out”.缓动让你的动画看起来更自然。 缓动的关键词CSS转换和动画允许您选择您想要使用的缓动类型。有不同的关键字影响缓动效果。你也可以完全定制自己的缓动动画。下面是一些你可以在CSS中使用的缓动关键字： linear（线性） ease-in（加速） ease-out（减速） ease-in-out（先加速后减速） 让我们把它们通读一遍，看看它们到底是什么意思。 Linear 动画没有任何缓动效果的动画称为线性（linear）动画。下面是线性变化的示意图：随着时间的推移，值均匀变大。线性运动时，物体往往会看起来不自然。一般来说，你应该避免线性运动。这是一个线性动画的简单实现: 减速(Ease-out) 动画正如前面提到的，与线性动画相比，缓动会使动画开始得更快，而在最后会变慢。它的示意图是这样的：一般来说，对于UI工作来说，减速缓动效果最好，因为快速的开始会给动画一种响应的感觉，而结尾的慢速则可以理解为是运动末尾的自然效果。有很多方法可以达到放松效果，但最简单的是CSS中的 easy-out 关键字: 1transition: transform 500ms ease-out; 加速(Ease-in)动画这与减速（ease-out）动画相反——开始慢，结束快。这是示意图：与减速缓动动画相比，加速缓动动画会给人一种不寻常的感觉，因为它们启动缓慢，会产生一种无响应的感觉。结束时运动很快也会让用户产生一种奇怪的感觉，因为现实世界中的物体在趋于停止时往往会减速。要使用加速缓动动画，与使用减速缓动与线性动画一样，你可以用如下关键字： 1transition: transform 500ms ease-in; （先加速后减速）Ease-in-out 动画这个动画是加速动画和减速动画的结合。示意图如下：不要让动画持续时间太长，因为这会让你的 UI 看起来像是没有响应。要使用先加速后减速动画, 可以使用如下关键字： 1transition: transform 500ms ease-in-out; 自定义缓动您可以定义自己的缓动曲线，以更好的控制缓动效果。事实上， ease-in, ease-out, linear, ease 关键字都是在 贝塞尔曲线（Bézier curves） 预定义好的, 这三个关键字对应的曲线在 CSS transitions specification 与 Web Animations specification 都有详细的说明 贝塞尔曲线（Bézier curves）让我们看看贝塞尔曲线的是怎么工作的。一条贝塞尔曲线需要四个值，或者更准确地说，它需要两对数字。每一对描述了贝塞尔曲线控制点的X和Y坐标。Bezier曲线的起始点坐标为(0,0)，结束点坐标为(1,1)。这两个控制点的X值必须在[0,1]范围内，而虽然规范没有明确具体是多少，但每个控制点的Y值是可以超过[0,1]限制的。即使每个控制点的X和Y值稍有变化，也会得到完全不同的曲线。让我们来看看两幅贝塞尔曲线的图形，这两幅曲线上的点虽然距离很近，但坐标不同。再看这个：如你所见，这两张图大相径庭。第一个控制点有(0.045,0.183)的向量差，第二个控制点有(-0.427，-0.054)的向量差。第二个曲线的CSS是这样的: 1transition: transform 500ms cubic-bezier(0.465, 0.183, 0.153, 0.946); 前两个数字是第一个控制点的X和Y坐标，后两个数字是第二个控制点的X和Y坐标。 性能优化动画应该保持60fps，否则会对用户体验造成负面影响。和世界上的其他事物一样，动画也不是没有代价的。动画的一些属性要比其他属性代价更小一些。例如，动画元素的宽度和高度会改变其几何形状，并可能导致页面上的其他元素移动或改变大小。这个过程称为布局。我们在之前的一篇文章中更详细地讨论了布局和渲染。通常，您应该避免动画的属性触发 reflow 或 repaint。对于大多数现代浏览器，这意味着将动画限制在了 opacity 和 transform 上。 Will-change您可以使用will-change通知浏览器您打算更改元素的属性。这允许浏览器在进行更改之前进行最适当的优化。但是，不要过度使用will-change，因为这样做会导致浏览器浪费资源，从而导致更多的性能问题。为 transforms 和 opacity 添加 will-change 如下所示: 123.box &#123; will-change: transform, opacity;&#125; 这项特性在 Chrome、Firefox和Opera 中都支持的很好。 在 JavaScript 与 CSS 中的选择你可能已经预料到了——这个问题没有正确答案。你只需要记住以下几件事： 基于css的动画，以及原生支持的Web动画，通常在名为“合成线程”的线程上处理。它不同于浏览器的“主线程”，在“主线程”中执行样式、布局、绘制和JavaScript。这意味着，如果浏览器在主线程上运行一些昂贵的任务，这些动画可以继续运行而不会被中断。 transforms 与 opacity 的变化，在很多情况下，也可以被合成线程来处理。 如果任何动画触发了 repaint 、reflow 或两者，则需要“主线程”来完成工作。无论动画基于CSS，还是基于 JavaScript，都是如此，repaint 或 reflow 的开销可能大过你的 CSS 和 JavaScript 执行逻辑，从而使动画本身变得毫无意义。 选择合适的东西来制作动画很棒的动画可以为你的用户添加乐趣和互动性。你可以对你喜欢的任何东西(无论宽度、高度、位置、颜色或背景)加动画，但你需要注意潜在的性能瓶颈。选择不当的动画会对用户体验产生负面影响，因此动画需要有效而适度。动画越少越好。动画只是为了让你的用户体验感觉自然，但不要过度动画。 使用动画来支持交互不要因为你能做就去做动画。相反，你的目的是使用巧妙的动画来加强用户交互。要避免你的动画不必要地打断或阻碍了用户活动。 避免动画的那些昂贵属性唯一比动画放置不当更糟的是那些导致页面卡顿的动画。这种类型的动画会让用户非常不爽。在SessionStack中使用动画非常简单。一般来说，我们遵循上面提到的实践，但是由于UI的复杂性，我们也有更多使用动画的场景。SessionStack必须将终端用户在浏览web应用程序时遇到问题时发生的一切重建为视频。为此，SessionStack 仅利用我们的库在会话期间收集的数据：用户事件、DOM更改、网络请求、异常、调试消息等。我们的播放器经过高度优化，能够正确呈现和使用收集到的所有数据，以便从视觉和技术角度对终端用户的浏览器及其中发生的一切进行像素级的完美模拟。为了确保复制的感觉是自然的，特别是在用户会话又长又重的情况下，我们使用动画来适当地指示加载/缓冲，并遵循关于如何实现它们的最佳实践，这样我们就不会占用太多CPU时间，让 event loop 保持空闲来呈现会话。如果你愿意，有一个免费的计划 试一试 sessionstack. 资源 https://developers.google.com/web/fundamentals/design-and-ux/animations/css-vs-javascript https://developers.google.com/web/fundamentals/design-and-ux/animations/ https://developers.google.com/web/fundamentals/design-and-ux/animations/animations-and-performance]]></content>
  </entry>
  <entry>
    <title><![CDATA[Flutter macOS 开发环境搭建笔记]]></title>
    <url>%2F2019%2F07%2F09%2Fyuque%2FFlutter%20macOS%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本文主要记录在 macOS 系统上搭建 Flutter 开发环境的过程，以及遇到的问题和解决办法，供大家参考。 1. 系统环境Flutter 同时支持在 Windows、macOS、Linux 等主流操作系统上进行开发，如下图所示：本文的环境搭建主要参考了官方的 Get started 教程，同时你也可以在 Flutter 中文网 或者 Flutter 中文开发者论坛 查阅相关中文翻译文档。我们这里进行实践的操作系统信息为： macOS Mojave 10.14 (64-bit) 2. 安装 Flutter 和 Dart SDK 2.1 网络环境在安装之前，先插个题外话，由于众所周知的原因，Google 提供的服务在中国大陆一直都是无法访问或者速度很慢，所以在下载一些资源时，我们通常需要翻墙或者选择一个与官方同步的可信的镜像站点作为替代。不过，Flutter 官方也很贴心地专门为中国用户写了一个教程，如何更快的下载资源、搭建环境以及执行 flutter 相关命令： Using Flutter in China 2.2 获取 Flutter根据 Flutter SDK Archive 页面的介绍，我们可以选择安装三种不同版本的 Flutter，分别如下： Dev channel：开发版本 Beta channel：测试版本 Master channel：最新版本，直接从 GitHub repo 中克隆获取最新的 SDK。 由于 Flutter 目前还没正式发布 Release 版本，所以我们建议选择相对比较稳定 Beta 版 SDK。在本文撰写的时候，最新的为 v0.10.2-beta，下载地址如下： https://storage.googleapis.com/flutter_infra/releases/beta/macos/flutter_macos_v0.10.2-beta.zip 但由于这个 URL 在国内下载特别慢（400+ MB），根据 Using Flutter in China 介绍，我们可以改成如下国内镜像地址进行下载，替换前缀为 https://storage.flutter-io.cn 即可： https://storage.flutter-io.cn/flutter_infra/releases/beta/macos/flutter_macos_v0.10.2-beta.zip2.3 安装 Flutter我们把上述下载的 flutter_macos_v0.10.2-beta.zip 拷贝到 $HOME/Flutter/ 目录下（可自行选择任意其他目录），然后进行解压： 12 $ cd ~/Flutter$ unzip ./flutter_macos_v0.10.2-beta.zip 此时，flutter 命令就在解压后的 flutter/bin 目录下。比如在我们这里，其完整路径为：$HOME/Flutter/flutter/bin/flutter。接下来，我们需要把 flutter 命令所在目录添加到系统的 PATH 变量中，方便后续在任何终端直接使用，而不用切换到特定目录。我们可直接在命令行中执行 export PATH=$PATH:$HOME/Flutter/flutter/bin，不过该命令只能在当前的终端窗口暂时设置 PATH 变量，关闭终端后就失效了。因此，要想永久地将 Flutter 添加到 PATH 中，需要在 $HOME 用户目录下的 .bashrc、.bash_profile 或者 .vimrc 等文件中（不同系统终端环境可能会不太一样）添加如上命令。由于我的 macOS 的终端环境使用的是 ZSH，所以我需要在 $HOME/.zshrc 文件中进行添加。此外，对于国内用户在使用 flutter 命令时，同样地，我们需要切换镜像源以加快速度，节省时间。根据文档，需要为此设置两个环境变量：PUB_HOSTED_URL 和 FLUTTER_STORAGE_BASE_URL，然后再运行 Flutter 命令行工具。这里推荐 Flutter 官方中文社区的镜像如下，当然我们可以选择其他的源。 12 export PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 综上，这里我们需要在 $HOME/.zshrc 文件中添加如下几行命令： 2.4 Dart SDK我们知道，Flutter 使用 Dart 语言进行开发应用程序，为了方便起见，我们下载的 Flutter SDK 已经同时包含了 Dart SDK，放在下面目录中： flutter/bin/cache/dart-sdk 3. 平台设置/编译环境在添加完 flutter 命令到 PATH 后，我们可以打开终端，在命令行中执行 flutter doctor，进行检查相关工具或者配置是否完整，我们第一次运行时，可能会得到如下图信息：我们看到一堆问题，接下来，我们只要根据上述结果和建议，一步步进行完善配置就好了。此外，macOS 支持为 iOS 和 Android 开发 Flutter 应用程序，所以我们同时也需要先完成这两个平台的相关编译环境配置，以便能够构建并运行第一个 Flutter Demo。 3.1 iOS 配置 安装 Xcode 9.0+ 或更新版本； 设置 iOS 模拟器； 安装 Homebrew、Cocoapod、Carthage 等 iOS 开发必要工具； 安装 iOS 真机调试工具： 12345 $ brew update$ brew install –HEAD usbmuxd$ brew link usbmuxd$ brew install –HEAD libimobiledevice$ brew install ideviceinstaller ios-deploy PS：如果你安装上述工具出行错误，请参考这个 issues，先卸载 usbmuxd 和 libimobiledevice 后重新安装，加上 –HEAD。 3.2 Android 配置 下载安装 Android Studio，然后启动根据“安装向导”进行相关初始化配置； 设置你的 Android 设备 设置 Android 模拟器 更详细的教程请参考官方 Platform setup，或者上述相关中文翻译文档。 4. 配置 IDE接下来我们需要配置一下 Flutter 的集成开发环境（IDE），以方便我们进行开发和调试。我们可以使用任何文本编辑器与命令行工具来构建 Flutter 应用程序。但这里推荐在 Android Studio、IntelliJ 或 VS Code 等优秀的编辑器上添加 Flutter 开发插件，即可获得代码自动补全，语法高亮，Widget 编辑助手，运行和调试的支持等一系列实用的功能。 4.1 命令行 创建工程 Create a new Flutter project in the specified directory. 1 flutter create 连接设备 List all connected devices. 1 flutter devices 运行工程 Run your Flutter application on an attached device or in an emulator. 1 flutter run [options] 4.2 Visual Studio CodeVS Code 是一个轻量级编辑器，支持 Flutter 运行和调试。 安装 VS Code 我们可以在这里下载并安装最新版本的 VS Code，本文安装的版本为 1.29.0 安装 Flutter 和 Dart 插件 启动 VS Code，在菜单栏中选择 View（查看）-&gt; Command Palette…（命令面板…），输入 ‘install’，然后选择 Extensions: Install Extension 安装扩展，接着在搜索框输入 ‘flutter’， 在搜索结果列表中选择 ‘Flutter’，点击 Install（安装），同时会自动安装 ‘Dart’ 依赖，最后重启 VS Code 即可生效。 验证配置 打开 View（查看）-&gt; Command Palette…（命令面板…），输入 ‘doctor’，然后选择 Flutter: Run Flutter Doctor，进行检查：查看 OUTPUT 窗口中的输出是否有问题，并按建议解决即可。至此，VS Code 的 Flutter 开发环境搭建好了。 4.3 Android StudioAndroid Studio 为 Flutter 提供了更加完整的 IDE 体验，毕竟它们都是 Google 的“亲儿子”。 安装 Android Studio 我们可以在这里下载并安装最新版本的 Android Studio（推荐 3.0+ 或更高版本），本文安装的版本为 3.2.1，此外 Android Studio 依赖 Java 环境，我们这里安装的 JDK 版本如下： Java 8 Update 191 (1.8.0_191-b12) 当然，我们也可以选择使用 IntelliJ IDEA。 安装 Flutter 和 Dart 插件 启动 Android Studio，打开插件设置（在 macOS 上为 Preferences -&gt; Plugins），然后选择 Browse repositories… 按钮，搜索 Flutter 插件，点击 Install（安装）此时会自动提示安装 Dart 插件，点击 Yes 接受即可。最后，重启 Android Studio，Flutter 开发环境就搭建好了。 4.4 大功告成当我们完成上面所有开发环境的配置，并通过 USB 连接上真机设备或者打开 iOS/Android 模拟器，然后再执行 flutter doctor 可得到如下结果，一切 OK 了： 5. Hello World这部分我们简单介绍一下如何创建一个 Flutter 的 Hello World 工程。上面提到，我们可以使用命令行、VS Code 或者 Android Studio/IntelliJ 等作为开发环境，综合比较，我们推荐 Android Studio。启动 Android Studio，如下图，选择 Start a new Flutter project（或者在菜单栏选择 File -&gt; New Flutter Project）接下来，我们可以参考官方的 Test drive 教程以及 Android Studio 的向导，创建工程，然后编译运行，并体验 Flutter 的热重载（Hot Reload），详见上述教程，我们这里不再赘述。这里需要注意的是，当我们在 Android Studio 创建新的 Flutter 工程，或者打开一个已有的 Flutter 工程时，可能会提示没有配置 Flutter 或者 Dart SDK 环境，如下图：此时，我们需要打开 Android Studio 的偏好设置（Preferences），手动配置相关路径。首先选择 Preferences -&gt; Languages &amp; Frameworks -&gt; Flutter，填写 Flutter SDK path，如下图所示，我们这里填写的路径为 $HOME/Flutter/flutter（取决于你 Flutter 的安装路径）：同样地，在左侧选中 Dart，然后填写 Dart SDK path，如下图，我们这里填写的路径为 $HOME/Flutter/flutter/bin/cache/dart-sdk（取决于你 Flutter 的安装路径）： 6. Flutter 相关资源 Flutter 官网：https://flutter.io/ Flutter GitHub 项目：https://github.com/flutter/flutter Flutter 社区中文资源（官方）：https://flutter-io.cn/ Flutter 中文网：https://flutterchina.club/ Flutter 中文开发者论坛：http://flutter-dev.cn/ Flutter 中文文档：http://doc.flutter-dev.cn/ Flutter 中文 CodeLabs：https://codelabs.flutter-io.cn/ Flutter 示例项目：https://itsallwidgets.com/ https://github.com/Solido/awesome-flutter https://github.com/awesome-tips/flutter-resources 转自：https://kangzubin.com/flutter-dev-env/]]></content>
  </entry>
  <entry>
    <title><![CDATA[10个流行的JavaScript面试题]]></title>
    <url>%2F2019%2F07%2F05%2Fyuque%2F10%E4%B8%AA%E6%B5%81%E8%A1%8C%E7%9A%84JavaScript%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1.如何理解 JS 中的this关键字？JS 初学者总是对 this 关键字感到困惑，因为与其他现代编程语言相比，JS 中的这this关键字有点棘手。 “this” 一般是表示当前所在的对象，但是事情并没有像它应该的那样发生。JS中的this关键字由函数的调用者决定，谁调用就this就指向哪个。如果找不到调用者，this将指向windows对象。来几个粟子第一个例子很简单。 调用 test对象中的 func()，因此func() 中的’this’指向的是 test 对象，所以打印的 prop 是 test 中的 prop，即 42。 12345678var test = &#123; prop: 42,func: function()&#123; return this.prop;&#125;, &#125;;console.log (test.func()); // 42复制代码 如果我们直接调用getFullname函数，第二个例子将打印出&#39;David Jones&#39;，因为此时 this 找不到调用者，所以默认就为 window 对象，打印的 fullname 即是全局的。 1234567891011121314var fullname = ‘David Jones’var obj =&#123;fullname: ‘Colin Brown’,prop:&#123; fullname:’Aurelio Deftch’, getFullname: function()&#123; return this.fullname; &#125; &#125;&#125;var test = obj.prop.getFullnameconsole.log(test()) // David Jonesobj.prop.getFullname() // ‘Aurelio Deftch’ 复制代码 2. 由于 this 关键字很混乱，如何解决这个问题有很多方法可以解决这个问题; 但是，无论你选择哪种解决方案，最重要的是要知道你决定让 this 指向哪个对象。一旦你弄清楚了this指向的对象，你就可以直接将它改成对象名。 否则，使用bind，call，apply函数也可以解决问题。 3.什么是闭包当我第一次解释闭包时，我常说函数中的函数;但是，它没有正确地描述闭包的确切含义。闭包是在另一个作用域内创建一个封闭的词法范围。它通常会自动返回来生成这个词法环境。这个环境由创建闭包时在作用域内的任何局部变量组成。它就像一个微型工厂，用这些原料生产出具有特定功能的产品。 123456789function add(n)&#123; var num = n return function addTo(x)&#123; return x + num &#125;&#125;addTwo = add(2)addTwo(5) 复制代码 闭包的另一个应用是创建私有变量和方法。JavaScript不像Java那样可以很好地支持oop。在JS中没有明确的方法来创建私有方法，但是闭包可以私有方法。 4.解释一下变量的提升变量的提升是JavaScript的默认行为，这意味着将所有变量声明移动到当前作用域的顶部，并且可以在声明之前使用变量。初始化不会被提升，提升仅作用于变量的声明。 1234var x = 1console.log(x + '——' + y) // 1——undefinedvar y = 2复制代码 5. JavaScript如何处理同步和异步情况尽管JavaScript是一种只有一个调用堆栈的单线程编程语言，但它也可以使用一个称为事件循环(event loop)的机制来处理一些异步函数。从基本级别了解JavaScript如何工作是理解JS如何处理异步的关键部分。如图所示，调用堆栈是定位函数的位置。一旦函数被调用，函数将被推入堆栈。然而，异步函数不会立即被推入调用堆栈，而是会被推入任务队列(Task Queue)，并在调用堆栈为空后执行。将事件从任务队列传输到调用堆栈称为事件循环。 6. 如何理解事件委托在DOM树上绑定事件监听器并使用JS事件处理程序是处理客户端事件响应的典型方法。 从理论上讲，我们可以将监听器附加到HTML中的任何DOM元素，但由于事件委派，这样做是浪费而且没必要的。** 什么是事件委托？这是一种让父元素上的事件监听器也影响子元素的技巧。 通常，事件传播（捕获和冒泡**）允许我们实现事件委托。 冒泡意味着当触发子元素（目标）时，也可以逐层触发该子元素的父元素，直到它碰到DOM绑定的原始监听器（当前目标）。 捕获属性将事件阶段转换为捕获阶段，让事件下移到元素; 因此，触发方向与冒泡阶段相反。 捕获的默认值为false。 7. 如何理解高阶函数JavaScript中的一切都是对象，包括函数。我们可以将变量作为参数传递给函数，函数也是如此。我们调用接受和或返回另一个函数称为高阶函数的函数。 8. 如何区分声明函数和表达式函数123456789// 声明函数function hello() &#123; return "HELLO"&#125; // 表达式函数 var h1 = function hello() &#123; return "HELLO"&#125;复制代码 两个函数将在不同的时期定义。在解析期间定义声明，在运行时定义表达式;因此，如果我们控制台打印 h1，它将显示HELLO。 9.解释原型继承是如何工作的JavaScript不是一种面向对象的友好编程语言，但它仍然使用继承的思想来实现依赖关系，并使用许多内置函数使其灵活使用。了解原型继承的工作原理将使你很好地理解JavaScript知识，从而避免概念上的误用。最好在大脑中描绘一下JavaScript的整个机制，以了解原型继承。JavaScript中有一个超级对象，所有对象都将从中继承。 &#39;__ proto__&#39;指向的对象的Prototype内部属性。 原型(prototype )包含一个构造函数，使对象能够从中创建实例。 __proto__始终存在于对象中，并且分层指向它所属的原型，直到null，这称为原型链。 10. 解释一下严格模式(strict mode)严格模式用于标准化正常的JavaScript语义。严格模式可以嵌入到非严格模式中，关键字 ‘use strict’。使用严格模式后的代码应遵循JS严格的语法规则。例如，分号在每个语句声明之后使用。 交流干货系列文章汇总如下，觉得不错点个Star，欢迎 加群 互相学习。 github.com/qq449245884… 链接：https://juejin.im/post/5d0976c66fb9a07efa091bcf]]></content>
  </entry>
  <entry>
    <title><![CDATA[js教程]]></title>
    <url>%2F2019%2F07%2F04%2Fyuque%2Fjs%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[JS 教程 JS 教程 JS 简介 JS 使用 JS 输出 JS 语句 JS 语法 JS 注释 JS 变量 JS 运算符 JS 算数 JS 赋值 JS 数据类型 JS 函数 JS 对象 JS 事件 JS 字符串 JS 字符串方法 JS 数字 JS 数字方法 JS 数组 JS 数组方法 JS 数组排序 JS 数组迭代 JS 日期 JS 日期格式 JS 日期获取方法 JS 日期设置方法 JS 数学 JS 随机 JS 逻辑 JS 比较 JS 条件 JS Switch JS Loop For JS Loop While JS Break JS 类型转换 JS 位运算 JS 正则表达式 JS 异常 JS 作用域 JS Hoisting JS 严格模式 JS this 关键词 JS Let JS Const JS 调试 JS 样式指南 JS 最佳实践 JS 错误 JS 性能 JS 保留词 JS 版本 JS 版本 ES5 JS 版本 ES6 JS JSON JS 表单 JS 表单 JS 表单 API JS 对象 JS 对象定义 JS 对象属性 JS 对象方法 JS 对象访问器 JS 对象构造器 JS 对象原型 JS ECMAScript 5 JS 函数 JS 函数定义 JS 函数参数 JS 函数调用 JS 函数 Call JS 函数 Apply JS 闭包 JS HTML DOM DOM 简介 DOM 方法 DOM 文档 DOM 元素 DOM HTML DOM CSS DOM 动画 DOM 事件 DOM 事件监听程序 DOM 导航 DOM 节点 DOM 集合 DOM 节点列表 JS Browser BOM JS Window JS Screen JS Location JS History JS Navigator JS 弹出框 JS Timing JS Cookies JS AJAX AJAX 简介 AJAX XMLHttp AJAX 请求 AJAX 响应 AJAX XML 文件 AJAX PHP AJAX ASP AJAX 数据库 AJAX 应用程序 AJAX 实例 JS JSON JSON 简介 JSON 语法 JSON vs XML JSON 数据类型 JSON 解析 JSON 字符串化 JSON 对象 JSON 数组 JSON PHP JSON HTML JSON JSONP JS vs jQuery jQuery 选择器 jQuery HTML jQuery CSS jQuery DOM JS 实例 JS 实例 JS HTML DOM JS HTML 输入 JS HTML 对象 JS HTML 事件 JS Browser JS 测验 JS 参考手册 JavaScript 对象 HTML DOM 对象 建站手册 网站构建 万维网联盟 (W3C) 浏览器信息 网站品质 语义网 职业规划 网站主机 关于 W3School 帮助 W3School 广告刊例 JavaScript 特殊字符 你可以在 JavaScript 中使用反斜杠来向文本字符串添加特殊字符。 插入特殊字符反斜杠用来在文本字符串中插入省略号、换行符、引号和其他特殊字符。请看下面的 JavaScript 代码：var txt=”We are the so-called &quot;Vikings&quot; from the north.”document.write(txt)在 JavaScript 中，字符串使用单引号或者双引号来起始或者结束。这意味着上面的字符串将被截为：We are the so-called。要解决这个问题，就必须把在 “Viking” 中的引号前面加上反斜杠 ()。这样就可以把每个双引号转换为字面上的字符串。var txt=”We are the so-called \&quot;Vikings\&quot; from the north.”document.write(txt)现在 JavaScript 就可以输出正确的文本字符串了：We are the so-called “Vikings” from the north。这是另一个例子：document.write (“You \&amp; me are singing!”) 上面的例子会产生以下输出：You &amp; me are singing!下面的表格列出了其余的特殊字符，这些特殊字符都可以使用反斜杠来添加到文本字符串中： 代码 输出 \‘ 单引号 \“ 双引号 \&amp; 和号 \\ 反斜杠 \n 换行符 \r 回车符 \t 制表符 \b 退格符 \f 换页符 JavaScript 参考手册 JavaScript 实例 JavaScript 测验]]></content>
  </entry>
  <entry>
    <title><![CDATA[从头开始创建一个 React 应用]]></title>
    <url>%2F2019%2F07%2F04%2Fyuque%2F%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%20React%20%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[作者：紫心人链接：https://zhuanlan.zhihu.com/p/36137966来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 同样的是一篇学习笔记，不过更像是简单翻译+再加工。并不详细介绍 React 的写法。主要内容是：如何从无到有，创建并运行起来一个 React 应用。 React 简介一句话介绍： React 是用于构建用户界面的 JavaScript 库。针对的是 View 层。虽然 React 只是视图层的一个 Library，但并非开箱即用。React 使用了很多较新的语法和关键字，浏览器并不完全支持。要使用 React 就必须将这些内容做一下处理。这样才能在浏览器下运行起来我们创建的 React 应用。 create-react-appReact 官方提供了一个脚手架用于初始化React项目，使用 create-react-app 可以简化手动设置流程。 官方网站的 Tutorial 也是以此为例。 123456789# 安装 create-react-app 并创建 my-app 项目$ npm install -g create-react-app$ create-react-app my-app# 或者# npm版本在5.2.0+ 可以使用 npx 命令，简洁 $ npx create-react-app my-app# 进入项目目录，启动项目$ cd my-app$ npm start 执行命令结束后信息使用 create-react-app ，你只需要执行命令之后等待安装完依赖，就可以创建一个已经配置好的 React 应用程序，并可以基于此开始你的项目开发。这对新手无疑是很友好的。如果你希望在老项目中引入 React，或着探究 React 到底是怎么运行起来的。那就需要自己动手来配置了。我们使用 Babel 和 Webpack 来解决这个问题。 新建项目我们先使用 npm init 和 git init 来初始化一个项目，然后增加下面三个文件夹： 1234.+-- dist+-- public+-- src 在 public 目录中，存放所有静态资源。其中需要新建一个 index.html 文件，并写入如下内容（下面的HTML内容拷贝自 React 官方文档，并做了一些非常小的修改）： 12345678910111213141516&lt;!-- sourced from https://raw.githubusercontent.com/reactjs/reactjs.org/master/static/html/single-file-example.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt; &lt;title&gt;React Starter&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;noscript&gt; You need to enable JavaScript to run this app. &lt;/noscript&gt; &lt;script src=&quot;../dist/bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 需要注意的是上面内容的第十行（为什么没有行数。。。假装有），也就是 1&lt;div id=&quot;root&quot;&gt;&lt;/div&gt; 这是 React 应用通过JS插入 DOM 结构的根节点。它会在配置 React 入口文件的时候用到。还有第十四行 引入了一个名为 bundle 的 js 文件。 1&lt;script src=&quot;../dist/bundle.js&quot;&gt;&lt;/script&gt; 这是 React 通过 webpack 打包后最终输出的文件，名字随意。不过本教程中我们使用 bundle。现在我们已经配置好了 HTML 内容。接下来还有更多配置。首先，为了保证我们编写的 React 代码可以编译为浏览器可执行的代码，我们需要使用 Babel做编译工作。 Babel这里解释一下 Babel 起到什么作用：为了更好的在模块化开发，避免模板和组件分离，减少复杂性。 React 使用 JSX 语法，将 HTML 模板直接嵌入到了 JS 代码里面，这样就做到了模板和组件关联。但是 JS 不支持这种包含 HTML 的语法，所以需要通过工具将 JSX 编译输出成 JS 代码才能使用。而 Babel 就是我们使用的 编译 工具（不仅转换JSX，还有 ES6+ 语法等）关于 Babel 的安装和配置可以查看我之前的一篇笔记：在此处，我们需要安装： 1$ npm install --save-dev babel-core@6.26.0 babel-cli@6.26.0 babel-preset-env@1.6.1 babel-preset-react@6.24.1 因为后续会用到 webpack 。所以此处安装了 babel-core。而这个包也正是主要用来转换我们 React 代码的 Babel 包。然后在项目根目录下创建 .babelrc， 配置如下： 123&#123; &quot;presets&quot;: [&quot;env&quot;, &quot;react&quot;]&#125; env 和 react 预设集分别用于转换 ES6+ 和 React 代码。Babel 就这么简单带过，实际内容也不是很难，比较好理解。 Webpack如果对 webpack 没有概念，需要先去了解一下。一些关于 webpack 的入门内容也可以查看我的另一篇学习笔记：配置 webpack。我们需要安装如下依赖包： 1npm install --save-dev webpack@4.6.0 webpack-cli@2.0.14 webpack-dev-server@3.1.3 style-loader@0.21.0 css-loader@0.28.11 babel-loader@7.1.4 其中 webpack-dev-server 是为了方便开发过程，将我们的项目在未打包前运行在一个开发服务器上，并且可以配置 修改代码后重新加载页面，这样可以在浏览器中即时反馈代码的修改。style-loader css-loader babel-loader 用于加载处理打包过程中 css 和 js 等文件。其中 babel-loader 将 webpack 和之前安装的 babel 结合起来，将 JSX 语法的 js 文件转化后再打包。 安装之后在项目根目录下创建 webpack.config.js 文件，配置如下： 12345678910111213141516171819202122232425262728293031const path = require(&quot;path&quot;);const webpack = require(&quot;webpack&quot;);const bundlePath = path.resolve(__dirname, &quot;dist/&quot;);module.exports = &#123; entry: &quot;./src/index.js&quot;, module: &#123; rules: [ &#123; test: /\.(js|jsx)$/, exclude: /(node_modules|bower_components)/, loader: &apos;babel-loader&apos;, options: &#123; presets: [&apos;env&apos;] &#125; &#125;, &#123; test: /\.css$/, use: [ &apos;style-loader&apos;, &apos;css-loader&apos; ] &#125; ] &#125;, resolve: &#123; extensions: [&apos;*&apos;, &apos;.js&apos;, &apos;.jsx&apos;] &#125;, output: &#123; publicPath: bundlePath, filename: &quot;bundle.js&quot; &#125;, devServer: &#123; contentBase: path.join(__dirname,&apos;public&apos;), port: 3000, publicPath: &quot;http://localhost:3000/dist&quot; &#125;, plugins: [ new webpack.HotModuleReplacementPlugin() ]&#125;; 此处不再详解每个配置项。补充一下之前学习笔记中没有提到的内容。rules 下的 exclude 字段：用来配置需要排除（不去这些目录下寻找 test 字段正则匹配的文件）的目录或文件resolve 字段：指定 webpack 可以解析哪些拓展名的文件，配置后可以在 文件引入时不带拓展名。devServer 字段： 配置开发服务器，指定服务在本地运行的端口、根目录、静态资源实际目录等。最后 plugins 字段里，我们加入了一个 Hot Module Replacement 插件的实例。这个用于 热更新，避免每次代码修改后刷新页面。 两个保证 React 运行起来的工具到此就配置完成了。接下来就是 React 方面的配置。 React安装 react 和 react-dom： 1$ npm install --save react@16.3.2 react-dom@16.3.2 安装完成后，我们需要在 src 目录下新建一个 React 应用程序的入口文件 index.js。我们需要在这个文件中告诉 React 在哪里插入你想渲染的页面。这个文件十分简单，不过也可以做更多配置。 1234567import React from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;import App from &quot;./App.js&quot;;ReactDOM.render( &lt;App /&gt;, document.getElementById(&quot;root&quot;)); ReactDOM.render是一个函数，它会告诉 React 渲染什么以及在哪里渲染它：此处我们渲染了一个名 App 组件（接下来会创建这个组件）。渲染的位置是 ID 为 ‘root’ 的DOM元素。还记得前面我们单独提到的 public/index.html 文件中的第十行。也就是这个 div 元素： 1&lt;div id=&quot;root&quot;&gt;&lt;/div&gt; 这就是 React 要渲染的位置。现在我们在相同的 src 目录下创建 App.js 文件，并插入如下代码（如果你使用 create-react-app 脚手架，此部分应该很熟悉）： 123456789101112import React, &#123; Component&#125; from &quot;react&quot;import &quot;./App.css&quot;class App extends Component&#123; render()&#123; return( &lt;div className=&quot;App&quot;&gt; &lt;h1&gt; Hello, World! &lt;/h1&gt; &lt;/div&gt; ) &#125;&#125;export default App 我们看到这里使用 import 引入了一个 css 文件。我们之前使用 webpack 做了相应的配置，所以可以将 css 文件当做模块引入进来（当然也可以使用scss，相应的配置webpack就好）。接下来在 src 目录下继续创建 App.css文件，并插入如下代码： 1234.App &#123; margin: 1rem; font-family: Arial, Helvetica, sans-serif;&#125; 最后你的目录将会是这样的： 1234567891011.+-- public| +-- index.html+-- src| +-- App.css| +-- App.js| +-- index.js+-- .babelrc+-- package-lock.json+-- package.json+-- webpack.config.js 到此我们手动完成了整个 React 项目从无到有的创建。现在可以使用 webpack-dev-server –mode development 命令来运行这个项目。不过我建议将这个命令配置到 package.json 中，使用 npm start 命令启动项目。你可能会发现 执行命令以后 dist 文件夹下并没有内容产生。那是因为 devServer 生成的文件会直接放在内存中运行，当服务关闭时，这些文件就随之消失了。如果需要生成打包后的文件，可以配置一个 npm 的 build 命令为：webpack –mode production这样执行 npm run build 后就可以在 dist 文件夹下看到文件了。 总结在我是个特别新的新手的时候，我只会使用各种框架提供的 CLI 来创建一个新的项目。一度对各种概念很是疑惑，不得其解。通过对 babel 、webpack 等工具了解、使用之后，算是对这一套东西在脑子里有了一个粗浅的系统概念。整个配置过程并不复杂，不过涉及了两个工具可能会让新手疑惑。而且这些配置仅仅是支撑起 React 运行起来，还有更多深入的配置需要学习和探索。 参考文章：Creating a React App… From Scratch —— Jedai SaboteurTutorial —— React Create React App 中文文档]]></content>
  </entry>
  <entry>
    <title><![CDATA[create-react-app创建的项目中registerServiceWorker.js文件的作用]]></title>
    <url>%2F2019%2F07%2F04%2Fyuque%2Fcreate-react-app%E5%88%9B%E5%BB%BA%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%B8%ADregisterServiceWorker.js%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[使用React官方的脚手架工具create-react-app创建的项目，目录中会存在registerServiceWorker.js这个文件，这个文件的作用是什么呢？这个文件可以使用也可以不使用，使用它可以使你的react项目变成一个PWA（Progressive Web Application）, 也就是说，在线上，只要访问过一次你的网站，下一次即使没有网络，这个应用依然可以被访问。当然，它的好处不仅这么一点点，在移动端打开项目时，如果你用的是chrome或者firefox这样的高级浏览器，浏览器会给你的页面不太一样的显示，你的网页看起来会更像原生App，实际上体验也更爽。在项目的public目录下，存在一个manifest.json文件，你可以在这里对你的网页做一些配置，当用户访问网页，生成一个网页的桌面快捷方式时，会以这个文件中的内容作为图标和文字的显示内容。配置好manifest.json, 使用registerServiceWorker.js，用户完全可以把你的网页快捷方式放到桌面上，因为你的网页此时支持离线访问，所以用起来和原生app的体验很接近。大家可以做这样一个试验： 创建一个项目 运行npm run build 然后在本地开一个服务器，把build目录中的内容放在服务器的根目录下 通过localhost的域名访问服务器 访问过一次之后，断掉网络，重新访问 你会发现，即使没有网络，这个时候依然可以访问你的应用。需要注意的是，只有打包生成线上版本的react项目时，registerServiceWorker.js才会有效。本地开发时，这个文件没什么效果，因为如果本地开发使用这个文件，有可能会因为缓存造成调试问题。还需要注意的是，项目在本地，通过localhost域名访问，支持http协议。如果真正放到线上，如果想让registerServiceWorker.js生效，服务器必须采用https协议，这也是为什么很多同学本地测试好用，线上就不好用的原因。registerServiceWorker.js中的这些功能，并不是React所独创的内容，而是React对PWA的一个实现，PWA未来的发展前景不错，从扩展视野角度也值得大家一看，如果你想了解更多，可以访问PWA的官方手册，这里讲解了PWA底层关于serviceWorker很多的内容，非常有趣：https://codelabs.developers.google.com/codelabs/your-first-pwapp/#0codelabs.developers.google.com发布于 2018-02-08React渐进式网络应用程序（PWA）]]></content>
  </entry>
  <entry>
    <title><![CDATA[RxJS]]></title>
    <url>%2F2019%2F07%2F04%2Fyuque%2FRxJS%2F</url>
    <content type="text"><![CDATA[官网github地址：https://github.com/ReactiveX/rxjs 异步复杂度要到什么程度才需要用到Rxjs？给大家介绍一个很直观的网站，用动画的方式演示了大部分Rxjs的Operator的执行过程，以及功能相似的Operator之间的比较。https://reactive.how/RxJS至于event,就像以前Jquery至于dom，lodash/underscore至于data。现在Jquery和lodash/underscore可以完全ES6+代替了。 用具体的实现例子去实现 RxJS, 原文地址 An Animated Intro to RxJS | CSS-Tricks hi 我也是初学者 来分享一点自己的心得1. 从【能解决什么问题】开始学习rx到底是解决什么问题，是怎么解决得更好等等，来建立对rx的基本认识途径: 百度，google，stackoverflow搜索2. 从【一个简单可运行的demo】开始学习rx基本用法途径-1: Hello RxJS系列（分享自知乎网）知乎专栏作者@太狼 途径-2: githun搜索rx demo3. 【官网】开始学习rx 基本几大概念，api和用法等。最好每个api都动手做一做，下面分享的第二个网站有每个api的效果图。(我有些是边翻译边看哈哈)分享-1: rx5.x官网http://reactivex.io/rxjs/manual/overview.html分享-2: api效果图网RxJS - Javascript library for functional reactive programming.4. 【进阶】学习更多实际用途与基本原理途径：angular2表单监控，angular2 http等5. 【实战】开始用rxjs动手做个完整项目或者在根据项目情况中考虑加入rx完 构建流式应用—RxJS详解原文地址最近在 Alloyteam Conf 2016 分享了《使用RxJS构建流式前端应用》，会后在线上线下跟大家交流时发现对于 RxJS 的态度呈现出两大类:有用过的都表达了 RxJS 带来的优雅编码体验，未用过的则反馈太难入门。所以，这里将结合自己对 RxJS 理解，通过 RxJS 的实现原理、基础实现及实例来一步步分析，提供 RxJS 较为全面的指引，感受下使用 RxJS 编码是怎样的体验。 目录 常规方式实现搜索功能 RxJS · 流 Stream RxJS 实现原理简析 观察者模式 迭代器模式 RxJS 的观察者 + 迭代器模式 RxJS 基础实现 Observable Observer RxJS · Operators Operators ·入门 一系列的 Operators 操作 使用 RxJS 一步步实现搜索功能 总结 常规方式实现搜索做一个搜索功能在前端开发中其实并不陌生，一般的实现方式是：监听文本框的输入事件，将输入内容发送到后台，最终将后台返回的数据进行处理并展示成搜索结果。 var text = document.querySelector('#text'); text.addEventListener('keyup', (e) =>{ var searchText = e.target.value; // 发送输入内容到后台 $.ajax({ url: search.qq.com/${searchText}, success: data => { // 拿到后台返回数据，并展示搜索结果 render(data); } }); });上面代码实现我们要的功能，但存在两个较大的问题： 多余的请求当想搜索“爱迪生”时，输入框可能会存在三种情况，“爱”、“爱迪”、“爱迪生”。而这三种情况将会发起 3 次请求，存在 2 次多余的请求。 已无用的请求仍然执行一开始搜了“爱迪生”，然后马上改搜索“达尔文”。结果后台返回了“爱迪生”的搜索结果，执行渲染逻辑后结果框展示了“爱迪生”的结果，而不是当前正在搜索的“达尔文”，这是不正确的。 减少多余请求数，可以用 setTimeout 函数节流的方式来处理，核心代码如下 var text = document.querySelector('#text'), timer = null; text.addEventListener('keyup', (e) =>{ // 在 250 毫秒内进行其他输入，则清除上一个定时器 clearTimeout(timer); // 定时器，在 250 毫秒后触发 timer = setTimeout(() => { console.log('发起请求..'); },250) })已无用的请求仍然执行的解决方式，可以在发起请求前声明一个当前搜索的状态变量，后台将搜索的内容及结果一起返回，前端判断返回数据与当前搜索是否一致，一致才走到渲染逻辑。最终代码为 var text = document.querySelector('#text'), timer = null, currentSearch = ''; text.addEventListener(&apos;keyup&apos;, (e) =&gt;{&lt;br /&gt; clearTimeout(timer)&lt;br /&gt; timer = setTimeout(() =&gt; {&lt;br /&gt; // 声明一个当前所搜的状态变量&lt;br /&gt; currentSearch ＝ &apos;书&apos;; var searchText = e.target.value;&lt;br /&gt; $.ajax({&lt;br /&gt; url: `search.qq.com/${searchText}`,&lt;br /&gt; success: data =&gt; {&lt;br /&gt; // 判断后台返回的标志与我们存的当前搜索变量是否一致&lt;br /&gt; if (data.search === currentSearch) {&lt;br /&gt; // 渲染展示&lt;br /&gt; render(data);&lt;br /&gt; } else {&lt;br /&gt; // ..&lt;br /&gt; }&lt;br /&gt; } &lt;br /&gt; });&lt;br /&gt; },250)&lt;br /&gt; })&lt;br /&gt;&lt;/script&gt;&lt;br /&gt;上面代码基本满足需求，但代码开始显得乱糟糟。我们来使用 RxJS 实现上面代码功能，如下&lt;br /&gt;var text = document.querySelector(&apos;#text&apos;);&lt;br /&gt;var inputStream = Rx.Observable.fromEvent(text, &apos;keyup&apos;)&lt;br /&gt; .debounceTime(250)&lt;br /&gt; .pluck(&apos;target&apos;, &apos;value&apos;)&lt;br /&gt; .switchMap(url =&gt; Http.get(url))&lt;br /&gt; .subscribe(data =&gt; render(data));&lt;br /&gt;可以明显看出，**基于 RxJS 的实现，代码十分简洁！** RxJS · 流 StreamRxJS 是 Reactive Extensions for JavaScript 的缩写，起源于 Reactive Extensions，是一个基于可观测数据流在异步编程应用中的库。RxJS 是 Reactive Extensions 在 JavaScript 上的实现，而其他语言也有相应的实现，如 RxJava、RxAndroid、RxSwift 等。学习 RxJS，我们需要从可观测数据流(Streams)说起，它是 Rx 中一个重要的数据类型。流是在时间流逝的过程中产生的一系列事件。它具有时间与事件响应的概念。下雨天时，雨滴随时间推移逐渐产生，下落时对水面产生了水波纹的影响，这跟 Rx 中的流是很类似的。而在 Web 中，雨滴可能就是一系列的鼠标点击、键盘点击产生的事件或数据集合等等。 RxJS 基础实现原理简析对流的概念有一定理解后，我们来讲讲 RxJS 是怎么围绕着流的概念来实现的，讲讲 RxJS 的基础实现原理。RxJS 是基于观察者模式和迭代器模式以函数式编程思维来实现的。 观察者模式观察者模式在 Web 中最常见的应该是 DOM 事件的监听和触发。 订阅：通过 addEventListener 订阅 document.body 的 click 事件。 发布：当 body 节点被点击时，body 节点便会向订阅者发布这个消息。 document.body.addEventListener('click', function listener(e) { console.log(e);},false); document.body.click(); // 模拟用户点击将上述例子抽象模型，并对应通用的观察者模型 迭代器模式迭代器模式可以用 JavaScript 提供了 Iterable Protocol 可迭代协议来表示。Iterable Protocol 不是具体的变量类型，而是一种可实现协议。JavaScript 中像 Array、Set 等都属于内置的可迭代类型，可以通过 iterator 方法来获取一个迭代对象，调用迭代对象的 next 方法将获取一个元素对象，如下示例。var iterable = [1, 2]; var iterator = iterableSymbol.iterator; iterator.next(); // => { value: "1", done: false}iterator.next(); // => { value: "2", done: false} iterator.next(); // => { value: undefined, done: true}元素对象中：value 表示返回值，done 表示是否已经到达最后。遍历迭代器可以使用下面做法。var iterable = [1, 2];var iterator = iterableSymbol.iterator; while(true) { let result; try { result = iterator.next(); // { observer.next(2); observer.complete(); return () => console.log('disposed');}); 创建 ObserverObserver 可以声明 next、err、complete 方法来处理流的不同状态。var Observer = Rx.Observer.create( x => console.log('Next:', x), err => console.log('Error:', err), () => console.log('Completed'));最后将 Observable 与 Observer 通过 subscribe 订阅结合起来。var subscription = Observable.subscribe(Observer);RxJS 中流是可以被取消的，调用 subscribe 将返回一个 subscription，可以通过调用 subscription.unsubscribe() 将流进行取消，让流不再产生。看了起来挺复杂的？换一个实现形式：// @Observables 创建一个 Observablesvar streamA = Rx.Observable.of(2); // @Observer streamA$.subscribe(Observer)streamA.subscribe(v => console.log(v));将上面代码改用链式写法，代码变得十分简洁：Rx.Observable.of(2).subscribe(v => console.log(v)); RxJS · Operators 操作 Operators 操作·入门Rx.Observable.of(2).subscribe(v => console.log(v));上面代码相当于创建了一个流(2)，最终打印出2。那么如果想将打印结果翻倍，变成4，应该怎么处理呢？方案一?： 改变事件源，让 Observable 值 X 2Rx.Observable.of(2 * 2 /* console.log(v));方案二?： 改变响应方式，让 Observer 处理 X 2Rx.Observable.of(2).subscribe(v => console.log(v * 2 / v * 2) / console.log(v));map 操作跟数组操作的作用是一致的，不同的这里是将流进行改变，然后将新的流传出去。在 RxJS 中，把这类操作流的方式称之为 Operators(操作)。RxJS提供了一系列 Operators，像map、reduce、filter 等等。操作流将产生新流，从而保持流的不可变性，这也是 RxJS 中函数式编程的一点体现。关于函数式编程，这里暂不多讲，可以看看另外一篇文章 《谈谈函数式编程》到这里，我们知道了，流从产生到最终处理，可能经过的一些操作。即 RxJS 中 Observable 将经过一系列 Operators 操作后，到达 Observer。Operator1 Operator2Observable ----|-----------|-------> Observer 一系列的 Operators 操作RxJS 提供了非常多的操作，像下面这些。Aggregate,All,Amb,ambArray,ambWith,AssertEqual,averageFloat,averageInteger,averageLong,blocking,blockingFirst,blockingForEach,blockingSubscribe,Buffer,bufferWithCount,bufferWithTime,bufferWithTimeOrCount,byLine,cache,cacheWithInitialCapacity,case,Cast,Catch,catchError,catchException,collect,concatWith,Connect,connect_forever,cons,Contains,doAction,doAfterTerminate,doOnComplete,doOnCompleted,doOnDispose,doOnEach,doOnError,doOnLifecycle,doOnNext,doOnRequest,dropUntil,dropWhile,ElementAt,ElementAtOrDefault,emptyObservable,fromNodeCallback,fromPromise,fromPublisher,fromRunnable,Generate,generateWithAbsoluteTime,generateWithRelativeTime,Interval,intervalRange,into,latest (Rx.rb version of Switch),length,mapTo,mapWithIndex,Materialize,Max,MaxBy,mergeArray,mergeArrayDelayError,mergeWith,Min,MinBy,multicastWithSelector,nest,Never,Next,Next (BlockingObservable version),partition,product,retryWhen,Return,returnElement,returnValue,runAsync,safeSubscribe,take_with_time,takeFirst,TakeLast,takeLastBuffer,takeLastBufferWithTime,windowed,withFilter,withLatestFrom,zipIterable,zipWith,zipWithIndex关于每一个操作的含义，可以查看官网进行了解。operators 具有静态（static）方法和实例（ instance）方法，下面使用 Rx.Observable.xx 和 Rx.Observable.prototype.xx 来简单区分，举几个例子。Rx.Observable.ofof 可以将普通数据转换成流式数据 Observable。如上面的 Rx.Observable.of(2)。Rx.Observable.fromEvent除了数值外，RxJS 还提供了关于事件的操作，fromEvent 可以用来监听事件。当事件触发时，将事件 event 转成可流动的 Observable 进行传输。下面示例表示：监听文本框的 keyup 事件，触发 keyup 可以产生一系列的 event Observable。var text = document.querySelector('#text');Rx.Observable.fromEvent(text, 'keyup') .subscribe(e => console.log(e));Rx.Observable.prototype.mapmap 方法跟我们平常使用的方式是一样的，不同的只是这里是将流进行改变，然后将新的流传出去。上面示例已有涉及，这里不再多讲。Rx.Observable.of(2) .map(v => 10 * v) .subscribe(v => console.log(v));Rx 提供了许多的操作，为了更好的理解各个操作的作用，我们可以通过一个可视化的工具 marbles 图 来辅助理解。如 map 方法对应的 marbles 图如下箭头可以理解为时间轴，上面的数据经过中间的操作，转变成下面的模样。Rx.Observable.prototype.mergeMapmergeMap 也是 RxJS 中常用的接口，我们来结合 marbles 图(flatMap(alias))来理解它上面的数据流中，产生了新的分支流(流中流)，mergeMap 的作用则是将分支流调整回主干上，最终分支上的数据流都经过主干的其他操作，其实也是将流中流进行扁平化。Rx.Observable.prototype.switchMapswitchMap 与 mergeMap 都是将分支流疏通到主干上，而不同的地方在于 switchMap 只会保留最后的流，而取消抛弃之前的流。除了上面提到的 marbles，也可以 ASCII 字符的方式来绘制可视化图表，下面将结合 Map、mergeMap 和 switchMap 进行对比来理解。 123456789@Map @mergeMap @switchMap ↗ ↗ ↗ ↗-A------B--&gt; a2 b2 a2 b2 -2A-----2B-&gt; / / / / / / / / a1 b1 a1 b1 / / / / -A-B-----------&gt; -A-B----------&gt; --a1-b1-a2-b2--&gt; --a1-b1---b2--&gt; mergeMap 和 switchMap 中，A 和 B 是主干上产生的流，a1、a2 为 A 在分支上产生，b1、b2 为 B 在分支上产生，可看到，最终将归并到主干上。switchMap 只保留最后的流，所以将 A 的 a2 抛弃掉。Rx.Observable.prototype.debounceTimedebounceTime 操作可以操作一个时间戳 TIMES，表示经过 TIMES 毫秒后，没有流入新值，那么才将值转入下一个操作。RxJS 中的操作符是满足我们以前的开发思维的，像 map、reduce 这些。另外，无论是 marbles 图还是用 ASCII 字符图这些可视化的方式，都对 RxJS 的学习和理解有非常大的帮助。 使用 RxJS 一步步实现搜索示例RxJS 提供许多创建流或操作流的接口，应用这些接口，我们来一步步将搜索的示例进行 Rx 化。使用 RxJS 提供的 fromEvent 接口来监听我们输入框的 keyup 事件，触发 keyup 将产生 Observable。var text = document.querySelector('#text');Rx.Observable.fromEvent(text, 'keyup') .subscribe(e => console.log(e));这里我们并不想输出事件，而想拿到文本输入值，请求搜索，最终渲染出结果。涉及到两个新的 Operators 操作，简单理解一下： Rx.Observable.prototype.pluck('target', 'value')将输入的 event，输出成 event.target.value。 Rx.Observable.prototype.mergeMap()将请求搜索结果输出回给 Observer 上进行渲染。 var text = document.querySelector('#text');Rx.Observable.fromEvent(text, 'keyup') .pluck('target', 'value') // Http.get(url)) // render(data))上面代码实现了简单搜索呈现，但同样存在一开始提及的两个问题。那么如何减少请求数，以及取消已无用的请求呢？我们来了解 RxJS 提供的其他 Operators 操作，来解决上述问题。 Rx.Observable.prototype.debounceTime(TIMES)表示经过 TIMES 毫秒后，没有流入新值，那么才将值转入下一个环节。这个与前面使用 setTimeout 来实现函数节流的方式有一致效果。 Rx.Observable.prototype.switchMap()使用 switchMap 替换 mergeMap，将能取消上一个已无用的请求，只保留最后的请求结果流，这样就确保处理展示的是最后的搜索的结果。 最终实现如下，与一开始的实现进行对比，可以明显看出 RxJS 让代码变得十分简洁。var text = document.querySelector('#text');Rx.Observable.fromEvent(text, 'keyup') .debounceTime(250) // Http.get(url)) // render(data)) 总结本篇作为 RxJS 入门篇到这里就结束，关于 RxJS 中的其他方面内容，后续再拎出来进一步分析学习。RxJS 作为一个库，可以与众多框架结合使用，但并不是每一种场合都需要使用到 RxJS。复杂的数据来源，异步多的情况下才能更好凸显 RxJS 作用，这一块可以看看民工叔写的《流动的数据——使用 RxJS 构造复杂单页应用的数据逻辑》 相信会有更好的理解。附:RxJS(JavaScript) https://github.com/Reactive-Extensions/RxJSRxJS(TypeScript ) https://github.com/ReactiveX/rxjs查看更多文章 >>https://github.com/joeyguo/blog]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSS 实现类似原生效果的 1px 边框]]></title>
    <url>%2F2019%2F07%2F03%2Fyuque%2FCSS%20%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BC%BC%E5%8E%9F%E7%94%9F%E6%95%88%E6%9E%9C%E7%9A%84%201px%20%E8%BE%B9%E6%A1%86%2F</url>
    <content type="text"><![CDATA[一.使用border-image实现类似iOS7的1px底边iOS7已经发布有一段时间，扁平化设计风格有很多值得称赞的地方，其中有很多设计细节都是值得研究的。首先，来看下面iOS设置的截图中的border：从上面的截图可以看到iOS7的设计是非常精细的，border是一根非常细的线。这篇文章将说明如何使用border-image实现iOS7的border效果。在看下面的内容之前，需要先了解devicePixelRatio和border-image，不熟悉的同学请自行脑补： 设备像素比devicePixelRatio简单介绍 CSS3 border-image详解、应用及jQuery插件border属性实现效果我们在实现border时通常都是使用border属性，如下：12345.border-1px &#123; border-width: 1px 0; border-style: solid; border-color: #333;&#125; 显示效果对比：上面这张图片可以看到，在手机上border无法达到我们想要的效果。这是因为devicePixelRatio特性导致，iPhone的devicePixelRatio==2，而border-width: 1px描述的是设备独立像素，所以，border被放大到物理像素2px显示，在iPhone上就显得较粗。 使用border-image属性实现物理1px通常手机端的页面设计稿都是放大一倍的，如：为适应iphone retina，设计稿会设计成640*960的分辨率，图片按照2倍大小切出来，在手机端看着就不会虚化，非常清晰。同样，在使用border-image时，将border设计为物理1px，如下：样式设置： 12345.border-image-1px &#123; border-width: 1px 0px; -webkit-border-image: url("border.png") 2 0 stretch; border-image: url("border.png") 2 0 stretch;&#125; 显示效果对比：这里在手机上的效果和iOS7已经非常接近了。样例：http://maxzhang.github.com/examples/border1px/index.htmlNote: border.png也可以直接使用的base64替代 1234.border-image-1px &#123; border-width: 1px 0px; -webkit-border-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAAECAYAAABP2FU6AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKTWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28AAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0ST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaOWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHiwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryMAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0lYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHiNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYAQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6cwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBiewhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1cQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqOY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hMWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgohJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSUEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/pdLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Yb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7OUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsbdi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83MDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxrPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1U27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H08PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+Hvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsGLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjgR2yIuB9pGZkX+X0UKSoyqi7qUbRTdHF09yzWrORZ+2e9jvGPqYy5O9tqtnJ2Z6xqbFJsY+ybuIC4qriBeIf4RfGXEnQTJAntieTE2MQ9ieNzAudsmjOc5JpUlnRjruXcorkX5unOy553PFk1WZB8OIWYEpeyP+WDIEJQLxhP5aduTR0T8oSbhU9FvqKNolGxt7hKPJLmnVaV9jjdO31D+miGT0Z1xjMJT1IreZEZkrkj801WRNberM/ZcdktOZSclJyjUg1plrQr1zC3KLdPZisrkw3keeZtyhuTh8r35CP5c/PbFWyFTNGjtFKuUA4WTC+oK3hbGFt4uEi9SFrUM99m/ur5IwuCFny9kLBQuLCz2Lh4WfHgIr9FuxYji1MXdy4xXVK6ZHhp8NJ9y2jLspb9UOJYUlXyannc8o5Sg9KlpUMrglc0lamUycturvRauWMVYZVkVe9ql9VbVn8qF5VfrHCsqK74sEa45uJXTl/VfPV5bdra3kq3yu3rSOuk626s91m/r0q9akHV0IbwDa0b8Y3lG19tSt50oXpq9Y7NtM3KzQM1YTXtW8y2rNvyoTaj9nqdf13LVv2tq7e+2Sba1r/dd3vzDoMdFTve75TsvLUreFdrvUV99W7S7oLdjxpiG7q/5n7duEd3T8Wej3ulewf2Re/ranRvbNyvv7+yCW1SNo0eSDpw5ZuAb9qb7Zp3tXBaKg7CQeXBJ9+mfHvjUOihzsPcw83fmX+39QjrSHkr0jq/dawto22gPaG97+iMo50dXh1Hvrf/fu8x42N1xzWPV56gnSg98fnkgpPjp2Snnp1OPz3Umdx590z8mWtdUV29Z0PPnj8XdO5Mt1/3yfPe549d8Lxw9CL3Ytslt0utPa49R35w/eFIr1tv62X3y+1XPK509E3rO9Hv03/6asDVc9f41y5dn3m978bsG7duJt0cuCW69fh29u0XdwruTNxdeo94r/y+2v3qB/oP6n+0/rFlwG3g+GDAYM/DWQ/vDgmHnv6U/9OH4dJHzEfVI0YjjY+dHx8bDRq98mTOk+GnsqcTz8p+Vv9563Or59/94vtLz1j82PAL+YvPv655qfNy76uprzrHI8cfvM55PfGm/K3O233vuO+638e9H5ko/ED+UPPR+mPHp9BP9z7nfP78L/eE8/sl0p8zAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAcSURBVHjaBMEBDQAADMMgckv1r20H1WxzoNoPAER9BjAKc4kUAAAAAElFTkSuQmCC") 2 0 stretch;&#125; 使用 CSS3 transform 实现1234567891011121314151617181920212223242526272829.border-1px &#123; position: relative;&#125;.border-1px:after &#123; position: absolute; content: ''; top: -50%; bottom: -50%; left: -50%; right: -50%; -webkit-transform: scale(0.5); transform: scale(0.5); border-top: 1px solid #666; border-bottom: 1px solid #666;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[流程图绘制]]></title>
    <url>%2F2019%2F07%2F03%2Fyuque%2F%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%BB%98%E5%88%B6%2F</url>
    <content type="text"><![CDATA[https://roadmap.sh/frontend]]></content>
  </entry>
  <entry>
    <title><![CDATA[Egret Developer游戏开发]]></title>
    <url>%2F2019%2F07%2F03%2Fyuque%2FEgret%20Developer%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[http://developer.egret.com/cn/https://www.egret.com/products/microclient.htmlhttp://developer.egret.com/cn/github/egret-docs/Engine2D/projectConfig/cmdManual/index.html命令行手册]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端跨框架跨平台框架]]></title>
    <url>%2F2019%2F07%2F02%2Fyuque%2F%E5%89%8D%E7%AB%AF%E8%B7%A8%E6%A1%86%E6%9E%B6%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[http://omijs.org https://github.com/Tencent/omi https://uniapp.dcloud.io/ 桌面应用程序：使用 JavaScript, HTML 和 CSS 构建跨平台的桌面应用pomotroidhttps://github.com/Splode/pomotroidhttps://electronjs.org/apps/pomotroid移动端：[flutter](https://flutter.dev/)**]]></content>
  </entry>
  <entry>
    <title><![CDATA[webpack学习]]></title>
    <url>%2F2019%2F07%2F02%2Fyuque%2Fwebpack%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[http://webpack.github.io/analyse/https://webpack.js.org/]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端数据库]]></title>
    <url>%2F2019%2F07%2F02%2Fyuque%2F%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[pouchdb :https://pouchdb.com/]]></content>
  </entry>
  <entry>
    <title><![CDATA[流程图]]></title>
    <url>%2F2019%2F07%2F02%2Fyuque%2F%E6%B5%81%E7%A8%8B%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[Roadmap：产品蓝图如何设计https://roadmap.sh]]></content>
  </entry>
  <entry>
    <title><![CDATA[LAVAS基于 Vue.js 的 PWA 解决方案]]></title>
    <url>%2F2019%2F07%2F02%2Fyuque%2FLAVAS%E5%9F%BA%E4%BA%8E%20Vue.js%20%E7%9A%84%20PWA%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[https://lavas.baidu.com/ 基于 Vue.js 的 PWA 解决方案 帮助开发者快速搭建 PWA 应用，解决接入 PWA 的各种问题]]></content>
  </entry>
  <entry>
    <title><![CDATA[React知识点综合运用实例]]></title>
    <url>%2F2019%2F07%2F02%2Fyuque%2FReact%E7%9F%A5%E8%AF%86%E7%82%B9%E7%BB%BC%E5%90%88%E8%BF%90%E7%94%A8%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[https://www.imooc.com/learn/971]]></content>
  </entry>
  <entry>
    <title><![CDATA[基于实例的 React16 傻瓜课程]]></title>
    <url>%2F2019%2F07%2F02%2Fyuque%2F%E5%9F%BA%E4%BA%8E%E5%AE%9E%E4%BE%8B%E7%9A%84%20React16%20%E5%82%BB%E7%93%9C%E8%AF%BE%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[https://www.imooc.com/learn/1045]]></content>
  </entry>
  <entry>
    <title><![CDATA[React 16实现订单列表及评价功能]]></title>
    <url>%2F2019%2F07%2F02%2Fyuque%2FReact%2016%E5%AE%9E%E7%8E%B0%E8%AE%A2%E5%8D%95%E5%88%97%E8%A1%A8%E5%8F%8A%E8%AF%84%E4%BB%B7%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[https://www.imooc.com/learn/1061]]></content>
  </entry>
  <entry>
    <title><![CDATA[React16.8+Next.js+Koa2开发Github全栈项目]]></title>
    <url>%2F2019%2F07%2F02%2Fyuque%2FReact16.8%2BNext.js%2BKoa2%E5%BC%80%E5%8F%91Github%E5%85%A8%E6%A0%88%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[https://www.imooc.com/topic/fullstack]]></content>
  </entry>
  <entry>
    <title><![CDATA[nodejs]]></title>
    <url>%2F2019%2F07%2F02%2Fyuque%2Fnodejs%2F</url>
    <content type="text"><![CDATA[https://www.imooc.com/topic/nodejs Node.js实例教程https://coding.imooc.com/class/320.html 前端晋升全栈工程师必备课程 Node.js 从零开发web server博客项目]]></content>
  </entry>
  <entry>
    <title><![CDATA[React]]></title>
    <url>%2F2019%2F07%2F02%2Fyuque%2FReact%2F</url>
    <content type="text"><![CDATA[https://www.imooc.com/topic/webframe优秀的人 就要用优秀的Web前端框架 steamer-reacthttps://github.com/steamerjs/steamer-react/tree/dev]]></content>
  </entry>
  <entry>
    <title><![CDATA[React高级教程之高阶组件]]></title>
    <url>%2F2019%2F07%2F02%2Fyuque%2FReact%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B%E4%B9%8B%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[https://www.imooc.com/learn/1075 https://www.imooc.com/video/18267 高阶组件 高阶组件介绍高阶组件的定义及原理高阶组件在项目中的常见应用通用高阶组件如何封装 高阶函数基本概念（High Order Component,HOC） 高阶组件就是接受一个组件作为参数并返回一个新组件的函数 高阶组件是一个函数，并不是组件函数可以作为参数被传递1setTimeOut(()=&gt;&#123;console.log(1)&#125;,1000) 函数可以作为返回值输出12345function foo(x)&#123; return function()&#123; return x; &#125;&#125; 高阶组件不是一个组件 高阶组件应用 代理方式的高阶组件返回的新组件类直接继承自React.Component类，新组件扮演的角色传入参数组件的一个代理，在新组件的render函数中，将被包裹的组件渲染出来，除了高阶组件自己要做的工作，其余功能全部转手给了被包裹的组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139A.jsx/* *代理方式的高阶组件 */import React, &#123; Component &#125; from "react";export default title =&gt; WrappedComponent =&gt; class A extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; inputvalue: "" &#125;; &#125; onInputChange = e =&gt; &#123; this.setState(&#123; inputvalue: e.target.value &#125;); &#125;; refc(instance) &#123; //instance是WrappedComponent的实例 console.log(instance); // instance.getName &amp;&amp; console.log(instance.getName()); &#125; render() &#123; const &#123; age, ...otherProps &#125; = this.props; const newProps = &#123; inputvalue: this.state.inputvalue, onInput: this.onInputChange &#125;; return ( &lt;div className="a-container"&gt; &lt;div className="header"&gt; &lt;div&gt;&#123;title&#125;&lt;/div&gt; &lt;div&gt;×&lt;/div&gt; &lt;/div&gt; &lt;div className="content"&gt; 我是高阶组件A &lt;WrappedComponent sex=&#123;"男"&#125; &#123;...otherProps&#125; ref=&#123;this.refc.bind(this)&#125; &#123;...newProps&#125; /&gt; &lt;/div&gt; &lt;/div&gt; ); &#125; &#125;;B.jsximport React, &#123; Component &#125; from "react";import A from "./A";// import D from "./D";// @Dclass B extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; value: "" &#125;; &#125; changeInput(e, parame) &#123; console.log(e.target.value, parame); this.setState(&#123; value: e.target.value &#125;); &#125; getName() &#123; return "我是B组件"; &#125; render() &#123; return ( &lt;div&gt; 我是组件B &lt;br /&gt; &lt;input type="text" &#123;...this.props&#125; /&gt; &lt;br /&gt; &lt;input type="text" value=&#123;this.state.value&#125; onChange=&#123;e =&gt; &#123; this.changeInput(e, "wfc"); &#125;&#125; /&gt; &lt;br /&gt; 我的名字叫:&#123;this.props.name&#125; &lt;br /&gt; 我的年龄是:&#123;this.props.age&#125; &lt;br /&gt; 我的性别是：&#123;this.props.sex&#125; &lt;img src=&#123;require("../images/B.jpg")&#125; alt="" /&gt; &lt;/div&gt; ); &#125;&#125;export default A("提示")(B);// export default B;C.jsximport React, &#123; Component &#125; from "react";import A from "./A";@A("警告")class C extends Component &#123; getName() &#123; return "我是C组件"; &#125; render() &#123; return ( &lt;div&gt; &lt;input type="text" &#123;...this.props&#125; /&gt; &lt;img src=&#123;require("../images/C.jpg")&#125; alt="" /&gt; &lt;/div&gt; ); &#125;&#125;export default C;App.jsimport React from "react";import B from "./components/B";import C from "./components/C";import "./App.css";function App() &#123; return ( &lt;div className="App"&gt; &lt;B name=&#123;"张三"&#125; age=&#123;18&#125; /&gt; &lt;C /&gt; &lt;/div&gt; );&#125;export default App; 继承方式的高阶组件采用继承关联作为参数的组件和返回的组件，假如传入的组件参数是WrappedComponent,那么返回的组件就直接继承自WrappedComponent 操纵prop 操纵生命周期函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970D.jsx/* * 继承方式的高阶函数组件 */import React from "react";const modifyPropsHOC = WrappedComponent =&gt; class NewComponent extends WrappedComponent &#123; componentWillMount() &#123; console.log("我是修改后的生命周期"); &#125; render() &#123; const element = super.render(); const newStyle = &#123; color: element.type === "div" ? "red" : "green" &#125;; const newProps = &#123; ...this.props, style: newStyle &#125;; return React.cloneElement( element, newProps, element.props.children ); &#125; &#125;;export default modifyPropsHOC;E.jsximport React, &#123; Component &#125; from "react";import D from "./D";@Dclass E extends Component &#123; componentWillMount() &#123; console.log("我是原始生命周期"); &#125; render() &#123; return &lt;div&gt;我是div&lt;/div&gt;; &#125;&#125;export default E;F.jsximport React, &#123; Component &#125; from "react";import D from "./D";@Dclass F extends Component &#123; render() &#123; return &lt;p&gt;我是P&lt;/p&gt;; &#125;&#125;export default F;App.jsimport React from "react";import E from "./components/E";import F from "./components/F";import "./App.css";// const BComponent = A(B);function App() &#123; return ( &lt;div className="App"&gt; &lt;E /&gt; &lt;F /&gt; &lt;/div&gt; );&#125;export default App; 高阶组件显示名12345678910111213141516171819202122232425262728293031323334353637/** * @description 继承方式的高阶函数组件 * @author wfc * @date 2019-07-05 * @param &#123;*&#125; WrappedComponent * @returns */import React from "react";const modifyPropsHOC = WrappedComponent =&gt; class NewComponent extends WrappedComponent &#123; static displayName = `NewComponent($&#123;getDispalyName( WrappedComponent )&#125;)`; componentWillMount() &#123; console.log("我是修改后的生命周期"); &#125; render() &#123; const element = super.render(); const newStyle = &#123; color: element.type === "div" ? "red" : "green" &#125;; const newProps = &#123; ...this.props, style: newStyle &#125;; return React.cloneElement( element, newProps, element.props.children ); &#125; &#125;;//高阶组件显示名function getDispalyName(WrappedComponent) &#123; console.log(WrappedComponent); return WrappedComponent.displayName || WrappedComponent.name || "Component";&#125;export default modifyPropsHOC; 高阶组件实战项目搭建 1.create-react-app tabbar 2.Tabbar静态布局实现去https://www.iconfont.cn/搜图标 添加图标到项目 1234567891011121314151617181920212223242526272829303132333435363738tabbar/index.jsimport React, &#123; Component &#125; from "react";import "./index.css";const tarbarArr = [ &#123; img: "icon-home", text: "首页" &#125;, &#123; img: "icon-fenlei_", text: "分类" &#125;, &#123; img: "icon-gouwuche", text: "购物车" &#125;, &#123; img: "icon-yonghu", text: "用户" &#125;];export default class index extends Component &#123; render() &#123; return ( &lt;div className="tabbar"&gt; &lt;div className="tabbar-content"&gt; &#123;tarbarArr.map((v, i) =&gt; ( &lt;div key=&#123;i&#125; className="tarbar-item"&gt; &lt;div className=&#123;`iconfont $&#123;v.img&#125;`&#125; /&gt; &lt;div className=""&gt;&#123;v.text&#125;&lt;/div&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125; 3.Tabbar绑定点击事件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657tabbar/index.jsimport React, &#123; Component &#125; from "react";import "./index.css";const tarbarArr = [ &#123; img: "icon-home", text: "首页" &#125;, &#123; img: "icon-fenlei_", text: "分类" &#125;, &#123; img: "icon-gouwuche", text: "购物车" &#125;, &#123; img: "icon-yonghu", text: "用户" &#125;];export default class index extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; index: 0 &#125;; &#125; itemChange = i =&gt; &#123; this.setState(&#123; index: i &#125;); &#125;; render() &#123; return ( &lt;div className="tabbar"&gt; &lt;div className="tabbar-content"&gt; &#123;tarbarArr.map((v, i) =&gt; ( &lt;div key=&#123;i&#125; className=&#123;`tarbar-item$&#123; this.state.index === i ? " active" : "" &#125;`&#125; onClick=&#123;() =&gt; &#123; this.itemChange(i); &#125;&#125; &gt; &lt;div className=&#123;`iconfont $&#123;v.img&#125;`&#125; /&gt; &lt;div className=""&gt;&#123;v.text&#125;&lt;/div&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125; 4.Tabbar添加路由react-router 1234567891011121314151617181920router.jsimport React from "react";import &#123; BrowserRouter, Route, Switch &#125; from "react-router-dom";// const Home = () =&gt; &lt;div&gt;home&lt;/div&gt;;import Home from './pages/home';import Category from "./pages/category";import Car from "./pages/car";import User from "./pages/user";export default () =&gt; ( &lt;BrowserRouter&gt; &lt;Switch&gt; &lt;Route path="/home" component=&#123;Home&#125; /&gt; &lt;Route path="/category" component=&#123;Category&#125; /&gt; &lt;Route path="/car" component=&#123;Car&#125; /&gt; &lt;Route path="/user" component=&#123;User&#125; /&gt; &lt;/Switch&gt; &lt;/BrowserRouter&gt;); 5.Tabbar添加路由切换12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364tabbar/index.jsimport React, &#123; Component &#125; from "react";import &#123; Link &#125; from "react-router-dom";import "./index.css";const tarbarArr = [ &#123; img: "icon-home", text: "首页", link: "/home" &#125;, &#123; img: "icon-fenlei_", text: "分类", link: "/category" &#125;, &#123; img: "icon-gouwuche", text: "购物车", link: "/car" &#125;, &#123; img: "icon-yonghu", text: "用户", link: "/user" &#125;];export default class index extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; index: 0 &#125;; &#125; itemChange = i =&gt; &#123; this.setState(&#123; index: i &#125;); &#125;; render() &#123; return ( &lt;div className="tabbar"&gt; &lt;div className="tabbar-content"&gt; &#123;tarbarArr.map((v, i) =&gt; ( &lt;Link to=&#123;v.link&#125; key=&#123;i&#125; className=&#123;`tarbar-item$&#123; this.state.index === i ? " active" : "" &#125;`&#125; onClick=&#123;() =&gt; &#123; this.itemChange(i); &#125;&#125; &gt; &lt;div className=&#123;`iconfont $&#123;v.img&#125;`&#125; /&gt; &lt;div className=""&gt;&#123;v.text&#125;&lt;/div&gt; &lt;/Link&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125; 6.其它页面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687pages/home.jsimport React, &#123; Component &#125; from "react";import Tabbar from "../components/tabbar";export default class home extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;img className="bg" src=&#123;require("../static/images/home.jpg")&#125; alt="" /&gt; &lt;Tabbar /&gt; &lt;/div&gt; ); &#125;&#125;car.js category.js user.js 以此类推tabbar/index.jsimport React, &#123; Component &#125; from "react";import &#123; Link &#125; from "react-router-dom";import "./index.css";const tarbarArr = [ &#123; img: "icon-home", text: "首页", link: "/home" &#125;, &#123; img: "icon-fenlei_", text: "分类", link: "/category" &#125;, &#123; img: "icon-gouwuche", text: "购物车", link: "/car" &#125;, &#123; img: "icon-yonghu", text: "用户", link: "/user" &#125;];export default class index extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; index: 0 &#125;; &#125; itemChange = i =&gt; &#123; this.setState(&#123; index: i &#125;); &#125;; render() &#123; const url = window.location.href; return ( &lt;div className="tabbar"&gt; &lt;div className="tabbar-content"&gt; &#123;tarbarArr.map((v, i) =&gt; ( &lt;Link to=&#123;v.link&#125; key=&#123;i&#125; className=&#123;`tarbar-item$&#123; url.indexOf(v.link) &gt; -1 ? " active" : "" // this.state.index === i ? " active" : "" &#125;`&#125; onClick=&#123;() =&gt; &#123; this.itemChange(i); &#125;&#125; &gt; &lt;div className=&#123;`iconfont $&#123;v.img&#125;`&#125; /&gt; &lt;div className=""&gt;&#123;v.text&#125;&lt;/div&gt; &lt;/Link&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125; 因为每个页面都加了tabbar，判断条件必须编程url，不然不准。 7.使用高阶组件改写Tabbar编写高阶组件1.实现一个普通组件2.将普通组件使用函数包裹 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293tabbar/index.jsimport React, &#123; Component &#125; from "react";import &#123; Link &#125; from "react-router-dom";import "./index.css";const tarbarArr = [ &#123; img: "icon-home", text: "首页", link: "/home" &#125;, &#123; img: "icon-fenlei_", text: "分类", link: "/category" &#125;, &#123; img: "icon-gouwuche", text: "购物车", link: "/car" &#125;, &#123; img: "icon-yonghu", text: "用户", link: "/user" &#125;];const Tabbar = WrappedComponent =&gt; class Tabbar extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; index: 0 &#125;; &#125; itemChange = i =&gt; &#123; this.setState(&#123; index: i &#125;); &#125;; render() &#123; const url = window.location.href; return ( &lt;React.Fragment className="tabbar-container"&gt; &lt;div className="tabbar-children"&gt; &lt;WrappedComponent /&gt; &lt;/div&gt; &lt;div className="tabbar"&gt; &lt;div className="tabbar-content"&gt; &#123;tarbarArr.map((v, i) =&gt; ( &lt;Link to=&#123;v.link&#125; key=&#123;i&#125; className=&#123;`tarbar-item$&#123; url.indexOf(v.link) &gt; -1 ? " active" : "" &#125;`&#125; onClick=&#123;() =&gt; &#123; this.itemChange(i); &#125;&#125; &gt; &lt;div className=&#123;`iconfont $&#123;v.img&#125;`&#125; /&gt; &lt;div className=""&gt;&#123;v.text&#125;&lt;/div&gt; &lt;/Link&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; &lt;/React.Fragment&gt; ); &#125; &#125;;export default Tabbar;// pages/home.jsimport React, &#123; Component &#125; from "react";import Tabbar from "../components/tabbar";class Home extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;img className="bg" src=&#123;require("../static/images/home.jpg")&#125; alt="" /&gt; &lt;/div&gt; ); &#125;&#125;export default Tabbar(Home);car.js category.js user.js一次类推 总结回顾高阶组件概述高阶组件实现高阶组件应用高阶组件使用出现的问题高阶组件实战回顾与总结]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端JavaScript面试技巧]]></title>
    <url>%2F2019%2F07%2F02%2Fyuque%2F%E5%89%8D%E7%AB%AFJavaScript%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[https://coding.imooc.com/class/115.html 揭秘一线互联网企业前端JavaScript高级面试https://coding.imooc.com/class/190.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[基于TypeScript从零重构axios]]></title>
    <url>%2F2019%2F07%2F02%2Fyuque%2F%E5%9F%BA%E4%BA%8ETypeScript%E4%BB%8E%E9%9B%B6%E9%87%8D%E6%9E%84axios%2F</url>
    <content type="text"><![CDATA[https://coding.imooc.com/class/330.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[React劲爆新特性Hooks 重构去哪儿网火车票PWA]]></title>
    <url>%2F2019%2F07%2F02%2Fyuque%2FReact%E5%8A%B2%E7%88%86%E6%96%B0%E7%89%B9%E6%80%A7Hooks%20%E9%87%8D%E6%9E%84%E5%8E%BB%E5%93%AA%E5%84%BF%E7%BD%91%E7%81%AB%E8%BD%A6%E7%A5%A8PWA%2F</url>
    <content type="text"><![CDATA[https://coding.imooc.com/class/348.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[React服务器渲染原理解析与实践]]></title>
    <url>%2F2019%2F07%2F02%2Fyuque%2FReact%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[https://coding.imooc.com/class/276.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[ES6零基础教学 解析彩票项目]]></title>
    <url>%2F2019%2F07%2F02%2Fyuque%2FES6%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E5%AD%A6%20%E8%A7%A3%E6%9E%90%E5%BD%A9%E7%A5%A8%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[https://coding.imooc.com/class/98.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[Javascript 设计模式系统讲解与应用]]></title>
    <url>%2F2019%2F07%2F02%2Fyuque%2FJavascript%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%B2%E8%A7%A3%E4%B8%8E%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[https://coding.imooc.com/class/255.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[koa]]></title>
    <url>%2F2019%2F07%2F01%2Fyuque%2Fkoa%2F</url>
    <content type="text"><![CDATA[https://coding.imooc.com/class/178.htmlKoa2框架从0开始构建预告片网站随着 ES6/7 的普及推广，Koa2 框架也逐步走入大小公司一线工程师的视野，作为即将在前端工作中占据一席之地的框架，Koa2 学习势在必行。这一次 Scott 老师通过完整的网站项目，以及足够篇幅的源码解读，为你讲解 Koa2 框架的原理、实战项目中的作用，以及与其他三方库框架的结合使用姿势，小伙伴们不要错过哦！ 遇到的问题 koa框架到底为我们做了什么 他的内部到底是什么样子 他向下一直到Nodejs底层，到底是怎么处理事件循环的 一个异步的HTTP过程，到底是怎么进行的 课程概况 做什么？开发一个可以实时更新的预告片网站 哪些功能网站首页、网站首页播放窗口、网站播放详情页、网站详情、同类推荐、网站后台登录、网站后台管理列表等 技术栈Koa2+Nodejs+MongoDB+Puppeteer+Parcel+AntDesign 第1章 2018年的编程姿势 第2章 ES6/7必会的语法特性 第3章 解读Koa2框架源码及API 第4章 Koa2/Koa1/Express 的框架对比 第5章 快速搭建一个Koa2静态资源网站 第6章 利用Puppeteer+子进程爬取高难度数据 第7章 彩蛋篇 - 学习Nodejs底层知识 第8-12章 全程实战开发预告片网站 第13章 项目优化及Parcel编译打包 第14章 课程回顾总结 课程收获 从0开始掌握一个网站的开发历程 从表象的API调用掌握到框架内核底层原理 掌握Nodejs事件循环/单线程/异步IO等诸多概念 会在Nodejs中使用模版引擎 会使用Pupeteer爬取高难度网站数据 会使用Parcel对Bootstrap多页静态网站进行打包 会使用Parcel对AntDesign单页万盏进行打包 会在Koa2中使用MongoDB数据库 会掌握如何在Koa2项目中进行MVC设计与API分层]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端构建]]></title>
    <url>%2F2019%2F07%2F01%2Fyuque%2F%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[browserify 使用browserify-shime来加载第三方类库homebrew 使用coffeescript和Es6来优化代码]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端性能优化]]></title>
    <url>%2F2019%2F07%2F01%2Fyuque%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[基础知识认知http://www.imooc.com/learn/580 Web前端性能优化https://coding.imooc.com/class/130.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[npm 基本用法和实用技巧]]></title>
    <url>%2F2019%2F07%2F01%2Fyuque%2Fnpm%20%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E5%92%8C%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[基本用法 安装与升级 安装 升级 安装指定版本的 npm 常用命令 npm install npm uninstall npm update npm ls npm adduser npm init npm publish npm unpublish npm deprecate npm dist-tag npm view npm link npm conifg 工作原理 实用技巧 pacakge.json dependencies optionalDependencies peerDependencies bundledDependencies bin config .npmrc .npmignore scripts shrinkwrap cache基本用法安装与升级安装安装 Node.js 时会自动安装 npm。1nvm install 4 升级1npm install npm -g 安装指定版本的 npm1npm install npm@2 -g 常用命令 npm install 根据 package.json 文件安装依赖。 1npm install 安装指定的依赖包。 1npm install [&lt;@scope&gt;/]&lt;pkg&gt; 如果当前目录中存在 package.json 文件，则安装满足文件中版本规则的最高版本；否则安装最新版本依赖包。 安装指定版本的依赖包。 123npm install [&lt;@scope&gt;/]&lt;pkg&gt;@&lt;tag&gt;npm install [&lt;@scope&gt;/]&lt;pkg&gt;@&lt;version&gt;npm install [&lt;@scope&gt;/]&lt;pkg&gt;@&lt;version range&gt; 从本地位置安装依赖。 12npm install &lt;folder&gt;npm install &lt;tarball file&gt; 可以用 npm pack 生成 &lt;tarball file&gt; 从网络位置安装依赖。 123npm install &lt;tarball url&gt;npm install &lt;git:// url&gt;npm install &lt;github username&gt;/&lt;github project&gt; 常用参数： -g, --global：安装全局依赖，如果没有指定依赖包名，则将当前目录中的包安装至全局 -S, --save：安装依赖的同时将该依赖写入 dependencies -D, --save-dev：安装依赖的同时将该依赖写入 devDependencies -O, --save-optional：安装依赖的同时将该依赖写入 optionalDependencies -E, --save-exact：写入 package.json 时带有确切版本号 --no-optional：不安装 optional dependencies，可继承 --only={dev[elopment]|prod[uction]}：无视 NODE_ENV，只安装 devDependencies 或仅安装除了 devDependencies 之外的依赖项 --dry-run：走一遍安装的过程并报告结果，但实际上没有安装任何依赖 别名：i npm uninstall 删除一个指定的依赖包，并且完全移除为了该包而安装的任何文件 1npm uninstall [&lt;@scope&gt;/]&lt;pkg&gt;[@&lt;version&gt;]... [-S|--save|-D|--save-dev|-O|--save-optional] 常用参数：与 npm install 类似 别名：remove、rm、r、un、unlink npm update 升级所有依赖包至版本规则允许的最新版本，并安装缺失的依赖包 1npm update [&lt;pkg&gt;...] 常用参数： -g：升级全局依赖包 --dev：同时升级在 devDependencies 中的依赖包 --depth Infinity：从 npm@2.6.1 起 npm update 默认仅升级顶层依赖，使用该参数升级所有依赖包 --save：升级依赖包，同时记录升级后的版本 别名：up、upgrade npm ls 以树形结构打印依赖包及其版本 1npm ls [[&lt;@scope&gt;/]&lt;pkg&gt; ...] 常用参数： --json：以 JSON 格式输出 --long：输出额外信息 --global：输出全局依赖信息 --depth &lt;int&gt;：输出依赖树的最大深度 --prod[uction]：仅输出 dependencies 中的依赖 --dev：仅输出 devDependencies 中的依赖 别名：list、la、ll npm adduser登录 npm 1npm adduser npm init 提问，然后产生一个 package.json 文件 1npm init [-f|--force|-y|--yes] 常用参数： -f, --force, -y, --yes：使用默认的答案，不再提问 --scope &lt;scope&gt;：指定新模块的 scope，例如 mtfenpm publish 发布一个新的包，或一个包的新版本 1npm publish [&lt;tarball&gt;|&lt;folder&gt;] [--tag &lt;tag&gt;] [--access &lt;public|restricted&gt;] 如果没有 tarball 或 folder 被指定，则使用当前目录 常用参数： --tag &lt;tag&gt;：给被发布的包注册指定的 tag，如果没有该参数，则默认使用 latestnpm unpublish取消发布一个包，或一个包的某些版本1npm unpublish [&lt;@scope&gt;/]&lt;pkg&gt;[@&lt;version&gt;] npm deprecate弃用一个包，或一个包的某些版本，尝试安装这些弃用包的用户将会收到警告 1npm deprecate &lt;pkg&gt;[@&lt;version&gt;] &lt;message&gt; npm dist-tag 给一个包的某个版本注册 tag 1npm dist-tag add &lt;pkg&gt;@&lt;version&gt; [&lt;tag&gt;] 移除一个 tag 1npm dist-tag rm &lt;pkg&gt; &lt;tag&gt; 显示指定包的所有 tag 1npm dist-tag ls [&lt;pkg&gt;] npm view 显示一个包的详细信息1npm view [&lt;@scope&gt;/]&lt;name&gt;[@&lt;version&gt;] [&lt;field&gt;[.&lt;subfield&gt;]...] &lt;field&gt; 和 &lt;subfield&gt; 表示输出信息中的字段 别名：info、show、v npm link将一个本地目录中的模块符号链接至一个项目的依赖中，实现上述功能需要两步： 在模块目录中执行下面的命令，创建一个从全局依赖指向当前目录的符号链接 1npm link 12/usr/local/Cellar/nvm/0.25.4/versions/node/v4.4.4/lib/node_modules/handgrip-&gt; /Users/Dylan/handgrip 在其他目录中执行下面的命令，创建一个从局部依赖指向全局依赖的符号链接1npm link [&lt;@scope&gt;/]&lt;pkg&gt;[@&lt;version&gt;] [&lt;@scope&gt;/]&lt;pkg&gt;[@&lt;version&gt;] 所表示已经执行了第一步的模块，或其所包含的版本 1234# npm link handgrip/Users/Dylan/koalition-boilerplate/node_modules/handgrip-&gt; /usr/local/Cellar/nvm/0.25.4/versions/node/v4.4.4/lib/node_modules/handgrip-&gt; /Users/Dylan/handgrip 由于依赖通过符号链接的方式组织，在模块目录中的修改可以立即在其他目录中生效。 npm conifg 设置一个配置项 12npm config set &lt;key&gt; &lt;value&gt; [-g|--global]npm set &lt;key&gt; &lt;value&gt; [-g|--global] 如果配置项的值阙如，将采用默认值 true。 读取一个配置项 12npm config get &lt;key&gt;npm get &lt;key&gt; 删除一个配置项 1npm config delete key 列出所有的配置 1npm config list 在编辑器中打开配置文件 1npm config edit 使用 --global 来打开全局配置文件。 工作原理 下面的内容基本上翻译了 npm v3 Dependency Resolution、npm3 Duplication and Deduplication、npm3 Non-determinism 这三篇文章 npm v3 依赖解析的主要思想：尽可能地减少间接依赖安装目录的深度，最理想的情况是与直接依赖安装在同一目录下，通过这种方式来减少依赖目录的嵌套，缓解整个依赖目录层次过深的问题。（因为 Windows 中文件路径的长度不能大于 260 个字符。）🌰：假如我们有模块 A，模块 A 依赖了模块 B。 然后我们创建了已依赖模块 A 的应用 App。在执行 npm install 的时候，npm v3 会把模块 A 及其依赖模块 B 都安装在 /node_modules 目录中。（npm v2 则会把模块 B 会嵌套在模块 A 中。） 此时，我们的应用 App 又需要依赖模块 C，而模块 C 依赖了另一个版本的模块 B。 然而，由于模块 B v1.0 已经被安装在了顶层依赖目录中，模块 B v2.0 就无法安装到同一位置了。这种情况下，npm v3 将会默认采用 npm v2 的行为，将这个新的模块 B 嵌套在依赖它的模块中，也就是说，把模块 B v2.0 安装到模块 C 中。 在控制台打印出依赖树和目录树。 如果再安装一个依赖模块 B v1.0 或 v2.0 会怎么样呢？此时，我们的应用 App 又需要依赖模块 D，而模块 D 与模块 C 一样，依赖了模块 B v2.0。 由于模块 B v1.0 已经被安装在了顶层依赖目录中，模块 B v2.0 就无法安装到同一位置了。因此，尽管模块 C 中已经有了一份拷贝，模块 B v2.0 还是被安装到了模块 D 中（否则就 requrie 不到了）。 如果一个间接依赖被两个以上的包所依赖，且不能安装在顶层依赖目录中，那么这个间接依赖会被复制一份，并嵌套在直接依赖的目录中。相反地，如果一个间接依赖被两个以上的包所依赖，且被安装在顶层依赖目录中，那么这个依赖就不会被复制，而被依赖它的包所共享。🌰，我们又加了一个依赖模块 E，模块 E 与模块 A 一样，依赖了模块 B v1.0。 由于模块 B v1.0 已经安装再来顶层依赖目录中，所以不需要复制并嵌套该模块，直接安装模块 E，然后模块 E 就可以与模块 A 共享模块 B v1.0 了。 在控制台打印出依赖树和目录树。 如果我们把模块 A 升级至 v2.0，模块 A v2.0 不再依赖模块 B v1.0，而是依赖模块 B v2.0，这会怎么样呢？执行 npm install mod-a@2，npm v3 将做以下事情： 移除模块 A v1.0 安装模块 A v2.0 保留模块 B v1.0，因为模块 E 仍旧依赖它 由于模块 B v1.0 还在顶层依赖目录中，模块 B v2.0 被嵌套安装在模块 A v2.0 中 在控制台打印出依赖树和目录树。 最后，我们吧模块 E 升级至 v2.0，模块 E v2.0 同样不再依赖模块 B v1.0，而是依赖模块 B v2.0。 npm v3 将做以下事情： 移除模块 E v1.0 安装模块 E v2.0 由于没有模块依赖模块 B v1.0，移除该模块 由于顶层依赖目录中没有模块 B，在该目录中安装模块 B v2.0 在控制台打印出依赖树和目录树。 现在，模块 B v2.0 几乎出现在了每一个依赖目录中，这显然不够简洁，我们可以执行： 1npm dedupe 这条命令可以仅保留顶层依赖目录中的模块 B v2.0，而移除其他次级目录中的拷贝。在控制台打印出目录树。 我们让 App 回到刚才的一个状态： 在这个🌰中，我们的应用有以下 package.json 文件：{ “name”: “example3”, “version”: “1.0.0”, “description”: “”, “main”: “index.js”, “scripts”: { “test”: “echo &quot;Error: no test specified&quot; &amp;&amp; exit 1” }, “keywords”: [], “author”: “”, “license”: “ISC”, “dependencies”: { “mod-a”: “^1.0.0”, “mod-c”: “^1.0.0”, “mod-d”: “^1.0.0”, “mod-e”: “^1.0.0” }}如果此时运行 npm install，控制台会输出以下结果： 然后，我们再次把模块 A 升级到 v2.0，模块 A v2.0 不在依赖模块 B v1.0，而是依赖模块 B v2.0： 1npm install mod-a@2 --save 控制台输出： 此时，我们的依赖目录看起来是这样的： 而且我们得到了一个新的 package.json：{ “name”: “example3”, “version”: “1.0.0”, “description”: “”, “main”: “index.js”, “scripts”: { “test”: “echo &quot;Error: no test specified&quot; &amp;&amp; exit 1” }, “keywords”: [], “author”: “”, “license”: “ISC”, “dependencies”: { “mod-a”: “^2.0.0”, “mod-c”: “^1.0.0”, “mod-d”: “^1.0.0”, “mod-e”: “^1.0.0” }}接着，我们运行： 1npm install 控制台输出： 依赖目录变成了： 总结： 依赖目录的结构取决于依赖安装的顺序 npm install （不带参数）安装出的依赖目录结构是稳定的，因为 package.json 中依赖的排列顺序总是字典序 npm v3 需要尽可能的减少间接依赖安装目录的深度，于是不得不从树根至树叶一级一级遍历下来，寻找可用的最远祖先节点，严重延长了依赖的安装时间 实用技巧 pacakge.json dependencies版本号的写法： version: 必须匹配确切的版本号 &gt;version、&gt;=version、&lt;version、&lt;=version ~version：如果 minor 级的版本被确定的话，允许 patch 级的版本变化；否则允许 minor 级版本变化 ~1.2.3 := &gt;=1.2.3 &lt;1.3.0 ~1.2 := &gt;=1.2.0 &lt;1.3.0 ~1 := &gt;=1.0.0 &lt;2.0.0 ~0.2.3 := &gt;=0.2.3 &lt;0.3.0 ~0 := &gt;=0.0.0 &lt;1.0.0 ~1.2.3-beta.2 := &gt;=1.2.3-beta.2 &lt;1.3.0 ^version：允许版本号中不修改最左非零位及其前缀的所有版本号更高的变化 ^1.2.3 := &gt;=1.2.3 &lt;2.0.0 ^0.2.3 := &gt;=0.2.3 &lt;0.3.0 ^0.0.3 := &gt;=0.0.3 &lt;0.0.4 ^1.2.3-beta.2 := &gt;=1.2.3-beta.2 &lt;2.0.0 ^0.0.3-beta := &gt;=0.0.3-beta &lt;0.0.4 ^1.2.x := &gt;=1.2.0 &lt;2.0.0 ^0.0.x := &gt;=0.0.0 &lt;0.1.0 ^0.0 := &gt;=0.0.0 &lt;0.1.0 ^1.x := &gt;=1.0.0 &lt;2.0.0 1.2.x：1.2.0、1.2.1 等，不包括 1.3.0 * 或空：任何版本 version1 - version2：&gt;=version1 &lt;=version2 range1 || range2 tag：指定 tag file:...：本地路径 http://...、git...：网络路径 git://github.com/user/project.git#commit-ish git+ssh://user@hostname:project.git#commit-ish git+ssh://user@hostname/project.git#commit-ish git+http://user@hostname/project/blah.git#commit-ish git+https://user@hostname/project/blah.git#commit-ish user/repo#commit-ish：GitHub 仓库optionalDependenciesoptionalDependencies 中的依赖安装失败时，npm 不会停止整个安装过程。模块本身应当处理由于依赖安装失败导致依赖缺失的问题，🌰如：try { var foo = require(‘foo’) var fooVersion = require(‘foo/package.json’).version} catch (er) { foo = null}if ( notGoodFooVersion(fooVersion) ) { foo = null} // .. then later in your program .. if (foo) { foo.doFooThings()} peerDependenciespeerDependencies 表示当前模块适配其他某些模块，也就是只有当那些指定的模块被安装时，当前模块才会被安装。🌰如：{ “name”: “tea-latte”, “version”: “1.3.5”, “peerDependencies”: { “tea”: “2.x” }}表示确保模块 tea-latte 只能同模块 tea 2.x 一起安装。 如果 peerDependencies 中的模块没有被明确依赖的话，npm v2 会自动安装这些模块，但 npm v3 不会再安装这些模块，而是输出一个警告。 bundledDependenciesbundledDependencies 表示在当前模块打包或发布时，需要被置于模块内部的依赖。使用的时机： 使用的依赖不是来自于 npm，或者修改了这个依赖 使用开发者自己的项目作为依赖 希望在模块中包含一些文件bin将可执行的文件安装到 PATH 中。可能安装到的位置有：12345# global:/usr/local/opt/nvm/versions/node/v4.4.4/bin//usr/local/bin/# local:./node_modules/.bin/ 🌰：{ “bin” : { “myapp” : “./cli.js” } }当安装这个模块时，npm 会创建一个指向 cli.js 的符号链接。{ “name”: “my-program”, “version”: “1.2.5”, “bin”: “./path/to/program” }上面的写法等价于：{ “name”: “my-program”, “version”: “1.2.5”, “bin” : { “my-program” : “./path/to/program” } } configpackage.json 文件中的 config 字段可以用来设置模块脚本中可以用到的配置参数。🌰，如果一个模块有：{ “name” : “foo”, “config” : { “port” : “8080” } }那么在模块脚本（如 start）中就可以通过 process.env.npm_package_config_port，访问到这个配置。这个配置也可以被命令 npm config set foo:port 8001 覆盖。 .npmrc配置文件有： 项目配置文件（/path/to/my/project/.npmrc） 用户配置文件（~/.npmrc） 全局配置文件（/path/to/node/etc/npmrc） 内置配置文件（/path/to/npm/npmrc） 环境变量用法： 1prefix = $&#123;HOME&#125;/.npm-packages 数组用法： 12key[] = &quot;first value&quot;key[] = &quot;second value&quot; 项目配置文件和用户配置文件的权限必须设置为只能被当前用户读写（0600），否则该配置文件会被 npm 忽略 可以通过 npm config 命令来管理配置文件。常用配置项： cache：npm 本地缓存目录，默认 ~/.npm cache-max：保持缓存项目且不向 registry 检查的最长时间，单位秒，默认 Infinity，缓存中的数据不会自动删除除非执行 npm cache clean 命令 cache-min：保持缓存项目且不向 registry 检查的最短时间，单位秒，默认 10，可以置为 999999 等以尽量延长缓存生效时间 depth：npm ls 等命令中的默认深度，默认 Infinity editor：npm 默认使用的编辑器 engine-strict：如果置为 true，npm 将会拒绝安装不符合当前 Node.js 版本的模块 force：强力执行一些命令 生命周期脚本执行失败不再阻塞安装过程 发布会覆盖已经发布的版本 访问 registry 时会跳过缓存 global：全局模式 globalconfig：全局配置文件的路径 global-style：以安装全局依赖的方式安装局部依赖，只有直接依赖会被放在顶层依赖目录中 https-proxy：代理 if-present：如果置为 true，npm run-script 就不会在脚本找不到时报错 ignore-scripts：如果置为 true，npm 就不会运行 package.json 定义的脚本 init-module：指定 npm init 命令运行的模块 init-author-name：npm init 使用的默认作者名 init-author-email：npm init 使用的默认作者邮箱 init-author-url：npm init 使用的默认作者 URL init-license：npm init 使用的默认许可证 init-version：npm init 使用的默认版本号 json：npm ls 等命令输出 JSON 格式的数据 link：如果置为 true，如果全局依赖中有合适的包，安装局部依赖时将会直接链接到这个全局依赖的包；如果全局依赖中没有该包的任何版本，则全局安装这个包，并链接到局部依赖中；其他情况则在局部依赖中安装该包 long：npm ls 和 npm search 显示额外信息 message：npm version 写在 git 提交中的信息，%s 将被替换为版本号 npat：安装时运行测试 onload-script：指定一个在 npm 加载时 require() 的包，编程使用 npm 时可能会有用 only：与命令中的 --only 效果类似 optional：如果置为 false，则不安装 optionalDependencies 中的依赖 prefix：指定安装全局依赖的路径 production：如果置为 true，则开启生产模式，npm install 将不安装开发依赖，声明周期脚本运行时自动设置 NODE_ENV=&quot;production&quot; registry：指定 npm registry 的 URL rollback：移除安装失败的模块 save：与命令中的 --save 效果类似 scope：与命令中的 --scope 效果类似 shrinkwrap：如果置为 false，安装时忽略 npm-shrinkwrap.json progress：如果置为 false，不显示进度条 loglevel：设置输出日志的 level，置为 silly 可以显示全部日志 .npmignore当模块目录中存在 .gitignore 但没有 .npmignore 时，npm 将会忽略 .gitignore 中的文件。如果目录中存在 .npmignore，npm 将会根据 .npmignore 忽略文件。默认被 npm 忽略，不需要添加到 .npmignore 中的文件： .*.swp ._* .DS_Store .git .hg .npmrc .lock-wscript .svn .wafpickle-* config.gypi CVS npm-debug.log 除了 bundled dependencies 外，node_modules 中的所有文件也会被忽略。下面的文件即使添加到 .npmignore 中的文件也不会被忽略： package.json README（及其变体） CHANGELOG（及其变体） LICENSE、LICENCE scriptsnpm 支持的生命周期脚本有： prepublish: 发布模块之前执行，也在不带任何参数的局部 npm install 之前执行 publish、postpublish: 发布模块之后执行 preinstall: 安装该模块之前执行 install、postinstall: 安装该模块之后执行 preuninstall、uninstall: 移除该模块之前执行 postuninstall: 移除该模块之后执行 preversion、version: 修改模块版本号之前执行 postversion: 修改模块版本号之后执行 pretest、test、posttest: 在 test 命令的前后执行 prestop、stop、poststop: 在 stop 命令的前后执行 prestart、start、poststart: 在 start 命令的前后执行. prerestart、restart、postrestart: 在 restart 命令的前后执行，如果 restart 脚本没有提供，restart 命令将会执行 stop 脚本再执行 start 脚本 对于自定义名称的脚本，可以通过 npm run-script &lt;pkg&gt; &lt;stage&gt; 来执行，匹配名称的 pre 和 post 命令同样也会执行。 shrinkwrapnpm shrinkwrap 可以用来锁定依赖的版本号。一个使用的🌰： 我们有模块 A： { “name”: “A”, “version”: “0.0.1”, “dependencies”: { “B”: “&lt;0.1.0” }} 模块 B： { “name”: “B”, “version”: “0.0.1”, “dependencies”: { “C”: “&lt;0.1.0” }} 和模块 C： { “name”: “C”, “version”: “0.0.1”} 这三个模块都只有 0.0.1 这一个版本。此时运行 npm install A，将会得到： 123A@0.0.1`-- B@0.0.1 `-- C@0.0.1 如果模块 B 发布了 0.0.2 版本，此时运行npm install A，将会得到： 123A@0.0.1`-- B@0.0.2 `-- C@0.0.1 但是模块 A 的作者希望安装原来的版本，那么他可以运行： 1npm shrinkwrap 然后在项目目录下得到了一个npm-shrinkwrap.json文件： { “name”: “A”, “version”: “0.0.1”, “dependencies”: { “B”: { “version”: “0.0.1”, “from”: “B@&lt;0.1.0”, “resolved”: “https://registry.npmjs.org/B/-/B-0.0.1.tgz&quot;, “dependencies”: { “C”: { “version”: “0.0.1”, “from”: “C@&lt;0.1.0”, “resolved”: “https://registry.npmjs.org/C/-/C-0.0.1.tgz&quot; } } } }} npm shrinkwrap命令根据当前目录中的 node_modules 目录锁定了依赖版本号，此时再运行npm install，该命令的行为将变为： 重新构造 npm-shrinkwrap.json 中描述的依赖树，如果一个依赖项中的 resolved 字段可用，则使用该字段获取依赖，否则使用 version 字段来获取依赖 以普通的方式安装 npm-shrinkwrap.json 中缺失的依赖 添加或升级依赖包的方法： 添加或升级一个依赖包 1npm install --save &lt;pkg&gt; 升级所有依赖包 1npm install --no-shrinkwrap 注意事项： 如果 node_modules 目录中的依赖比 package.json 中定义的多或者少，npm shrinkwrap 命令将会失败 npm shrinkwrap 命令不锁定 devDependencies 中依赖的版本，即 npm-shrinkwrap.json 中不包含开发依赖；如果希望锁定开发依赖的版本，则需要在运行命令时加上 --dev 参数 shrinkwrap 不会继承，即执行过程中不会访问依赖的 npm-shrinkwrap.json 文件；但是，依赖中如果有 npm-shrinkwrap.json 文件，在安装该依赖的时就会按照这个文件来安装相关的模块到 node_modules 目录中，如果没有 npm-shrinkwrap.json 文件，开发者需要在使用 shrinkwrap 前自行确认 node_modules 目录中的依赖都是有效的；shrinkwrap 总是据当前目录中的 node_modules 目录中的内容锁定依赖版本号 cachenpm 将数据缓存在 npm config get cache 命令指定的路径中。当局部安装一个模块时，npm 会执行以下步骤： 检查缓存中的模块信息文件（.cache.json，包括 ETag 等信息）是否存在并在免检时间内 如果存在合适的缓存信息文件且没有超过免检时间，执行步骤 6 获取该模块的最新信息文件，然后计算出合适的模块版本号 如果缓存中有该版本号的模块，则执行步骤 6 下载该版本号的模块，并将其载入缓存中 取缓存中的文件，并将其安装至目标路径中 npm cache 命令的用法： 向缓存中添加指定的模块： 1234npm cache add &lt;tarball file&gt;npm cache add &lt;folder&gt;npm cache add &lt;tarball url&gt;npm cache add &lt;name&gt;@&lt;version&gt; 显示缓存中的数据： 1npm cache ls [&lt;path&gt;] 清空缓存： 1npm cache clean [&lt;path&gt;] npm 缓存的改进方案： local-npm：一个本地 npm 镜像，但是仅缓存已经安装过的模块，没有网络时自动回退到本地 npm_lazy 转自：https://github.com/theicebear/npm-basic-usage]]></content>
  </entry>
  <entry>
    <title><![CDATA[REST]]></title>
    <url>%2F2019%2F07%2F01%2Fyuque%2FREST%2F</url>
    <content type="text"><![CDATA[REST是什么？ 万维网软件架构风格 用来创建网络服务 为何叫REST Representational State Transfer Representational:数据的表现形式（JSON、XML……） State:当前状态或者数据 Transfer:数据传输 通过REST的6个限制详细了解它 客户-服务器（Client-Server） 关注点分离 服务端专注数据存储，提升了简单性 前端专注用户界面，提升了可移植性 无状态（Stateless） 所有用户会话信息都保存在客户端 每次请求必须包括所有信息，不能依赖上下文信息 服务端不用保存会话信息，提升了简单性、可靠性、可见性 缓存（Cache） 所有服务端响应都要被标为可缓存或不可缓存 减少前后端交互，提升了性能 统一接口（Uniform Interface） 接口设计尽可能统一通用，提升了简单性、可见性 接口与实现解耦，使前后端可以独立开发迭代 分层系统（Layered System） 每层只知道相邻的一层，后面隐藏的就不知道了 客户端不知道是和代理还是真实服务器通信 其他层：安全层、负载均衡、缓存层等 按需代码（Code-On-Demand可选） 客户端可以下载运行服务端传来的代码（比如JS） 通过减少一些功能，简化了客户端 RESTful API简介 什么是RESTful API？符合REST架构风格的API RESTful API 具体什么样子？基本的URI，如：https//api.github.com/users标砖HTTP方法，如GET，POST，PUT，PATCH，DELETE传输的数据媒体类型，如：JSON，XML 现实举例GET /users#获取user列表GET /users/12#查看某个具体的userPOST /users#新建一个userPUT /users/12#更新user12DELETE/users/12 #删除user12 github接口文档：https://developer.github.com/v3/repos/ GitHub API示例]]></content>
  </entry>
  <entry>
    <title><![CDATA[基于websocket的火拼俄罗斯（单机版）]]></title>
    <url>%2F2019%2F07%2F01%2Fyuque%2F%E5%9F%BA%E4%BA%8Ewebsocket%E7%9A%84%E7%81%AB%E6%8B%BC%E4%BF%84%E7%BD%97%E6%96%AF%EF%BC%88%E5%8D%95%E6%9C%BA%E7%89%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[https://www.imooc.com/learn/882]]></content>
  </entry>
  <entry>
    <title><![CDATA[基于Websocket的火拼俄罗斯（基础）]]></title>
    <url>%2F2019%2F07%2F01%2Fyuque%2F%E5%9F%BA%E4%BA%8EWebsocket%E7%9A%84%E7%81%AB%E6%8B%BC%E4%BF%84%E7%BD%97%E6%96%AF%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[https://www.imooc.com/learn/861]]></content>
  </entry>
  <entry>
    <title><![CDATA[nodejs调试]]></title>
    <url>%2F2019%2F07%2F01%2Fyuque%2Fnodejs%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[使用Inspector调试Node.js程序 Inspector介绍http://nodejs.cn/api/inspector.html 使用Inspector调试Node.js的优势 可查看当前上下文的变量 可观察当前函数调用堆栈 不侵入代码 可在暂停状态下执行指定代码 12mkdir node-debugcode node-debug 在mac中使用vscode的命令code以及使用命令行在vscode中打开文件夹使用command + shift + p，并输入shell，选择Shell Command:Install ‘code’ command in PATH,如上图。完成后，即可使用vscode的命令行 code. 如何用code命令打开文件夹1.在新窗口中打开文件夹cd到需要打开的文件夹下，然后使用code -n .上面指令中的-n 表示new window2.在原窗口中打开文件夹cd到需要打开的目录下，使用code -r .上面指令中的-r表示 reuse window至于code的其它命令，可以使用code -h查看和学习。 1234567891011let v = 0;function a(v) &#123; let v2 = 100; v += v2;&#125;function b() &#123; a(v);&#125;b(); devtoolsFrontendUrl用于谷歌浏览器调试 Inspector的构成以及原理 WebSockets服务（监听命令） Inspector协议 http://nodejs.cn/api/inspector.html HTTP服务（获取元信息） ### 激活调试 如何激活调试1node --inspect app.js 因为代码执行完了，所以没有下文了 我们接下来弄一个可以一直看的 那用express弄一个http://www.expressjs.com.cn/ 例子有了 1node app.js 关闭指定的端口号：lsof -i:端口号 kill -9 6422 为什么node –inspect app.js 不能激活**这样设置后就好了 激活调试后会发生什么 Node进程通过WebSockets监听调试信息 启动一个HTTP服务，提供元信息 如何调试没有激活的Node.js程序？ 在Linux和OSX上，可以监听到SIGUSR1发送的调试信息 调试客户端Chrome DevTools 访问chrome://inspect 点击配置按钮，确保Host和Port对应 访问元信息中的devtoolsFrontendUrl 点击绿色小图标 调试客户端-Chrome devtools 调试客户端-vscode 启动方式：按F5 这种方式适合简单的场景 配置launch.json or “打开自动附加” 添加参数后面在配置文件里面可以配置成点击调试面板，两处任意一个都行，都可以开启调试添加配置可以启动多个服务 调试动作 数据展现 Log Point RERL命令行参数介绍带领大家解读官网文档，并通过实际案例介绍；debugger调试器]]></content>
  </entry>
  <entry>
    <title><![CDATA[禁止Macoofie]]></title>
    <url>%2F2019%2F07%2F01%2Fyuque%2F%E7%A6%81%E6%AD%A2Macoofie%2F</url>
    <content type="text"><![CDATA[1.sudo su 2.ps -ef | grep Mc 3.pkill -f Mc]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端开发全面知识库]]></title>
    <url>%2F2019%2F07%2F01%2Fyuque%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%85%A8%E9%9D%A2%E7%9F%A5%E8%AF%86%E5%BA%93%2F</url>
    <content type="text"><![CDATA[前端开发全面知识库，包括HTML5，CSS3和js的基本框架知识，以及DOM和BOM操作的基础知识和一些基本工具和IDE。学习本篇，你将了解到以下知识。 核心 Core HTML5W3C HTML 5 教程W3C HTML5 Chinese Interest Group Wiki菜鸟教程 HTML5 教程 | 菜鸟教程HTML5中文门户 HTML5中国：中国最大的HTML5中文门户 - Powered by Discuz! CSS3W3C CSS教程 CSS 教程W3C CSS3教程 CSS3 教程菜鸟教程CSS教程 CSS 教程 | 菜鸟教程菜鸟教程CSS3教程 CSS3 教程 | 菜鸟教程CSS参考手册 CSS参考手册_web前端开发参考手册系列 JSW3C JavaScript 教程菜鸟教程 JavaScript 教程 | 菜鸟教程廖雪峰js教程 Home - 廖雪峰的官方网站js标准参考教程-阮一峰JavaScript 标准参考教程（alpha） jQueryW3C jQuery 教程菜鸟教程 jQuery 教程 | 菜鸟教程极客学院 jQuery教程_jQuery开发中文手册[PDF]下载-极客学院Wiki廖雪峰 http://www.liaoxuefeng.com/wiki/参考手册 jQuery API 中文文档(适用jQuery 1.0 - jQuery 3.1)参考手册 jquery 在线手册 ES6阮一峰ES6 ECMAScript 6入门极客学院 ECMAScript 6 入门-极客学院WikiJavaScript 标准参考 阮一峰JavaScript 标准参考教程（alpha） 插件parallel.js: 前后端通用的一个并行库zepto: 用于现代浏览器的兼容 jQuery 的库totoro: 稳定的跨浏览器测试工具TheaterJS: 一个用于模拟人输入状态的 JS 库stellar.js: 前端用于实现异步滚动效果的库，现已不再维护skrollr: 另一款实现一步滚动的开源库，使用人数众多，可实现各种狂拽酷炫掉渣天的前端效果，看真相Framework7: 前端框架，是开发人员可以基于 web 技术构建 IOS7 程序regulex: 用于生成 正则表达式 的可视化流程图markdown-it: 新型 Markdown 解析器，快速，支持插件multiline: 用于 Javascript 中的多行文本，类似于 Ruby 的 HERE Docscreenfull.js: 全屏插件，支持各大浏览器lunr.js: 类似于 Solr, 但是用于浏览器上的全文搜索引擎，可以为 JSON 创建索引，离线也可以使用jquery.hotkeys: jQuery 插件，用于绑定热键breach_core: Javascript 编写的 Browser (浏览器)octocard: 用于生成 Github 信息卡片的库github-cards: 用于生成 Github 信息卡片的库money.js: 轻量级货币转换库，web 和 node 皆可用accounting.js: 轻量级的数字、货币转换库javascript-algorithms: Javascript 实现的各种算法集合lazy.js: 类似于 underscore, 但是会延迟执行，某些场景下，性能会有很大的提升seajs: 前端模块加载器，解决模块化、依赖等问题jQuery-One-Page-Nav: 单页应用中一个用于处理导航栏的库js.js: Javascript 实现的 javascript JITjquery-ui: jQuery 团队开发的 UI 相关的前端库，功能强大todomvc: 分别基于 AngularJS/EmberJS/Backbone等实现的 TODO List, 帮助开发者选择前端 MVC 库localForage: Mozilla 出品，用于离线存储，基于IndexedDB, WebSQL 或者 localStorage, 提供一致的接口EventEmitter: 浏览器版的 EventEmitterjquery.serializeJSON: jQuery 插件，用于将 form 表单序列化成 JSON 数据knockout: 前端 MVVM 框架，用于开发富前端应用mermaid: 可以根据文本生成流程图，类似于 Markdown 的语法js-sequence-diagrams: 另一款可以根据文本生成流程图的库，类似于 Markdown 的语法flow: 一个用来检测 Javascript 语法错误的库， Facebook 出品zoomooz: jQuery 插件，用来处理浏览器缩放fancyBox: 一个用于放大缩小图片、Web 内容或者多媒体元素的库，优雅大方mithril.js: 轻量型前端 MVC 框架，部分使用场景下性能优于 Angular.js 和 Reactbackbone: 强大的前端 MVC 库，鼻祖级前端库，最初为了配合 Rails 来模块化前端应用，兼容性良好 (兼容到 IE6)，插件丰富，性能良好jquery.smartbanner: smartbanner 是从 IOS6 开始支持的一个新特性, 这个插件提供了对早期 IOS4/5 和 Android 的支持jquery.scrollTo: 在页面上以一个元素为起始以动画的方式移动(ScrollTo)到另一个元素， 支持回退等jScrollPane: 自定义的滚动条，让所有浏览器都显示一样的滚动条onepage-scroll: 提供类似于 iPhone6 展示页类似的效果，适用于单页应用，兼容到 IE8scrollMonitor: 前端插件用来监控元素的滚动事件(进入、退出等)，性能很好ScrollMagic: 神奇的滚动交互效果插件，可以在滚动的过程中设置各种各样的动态效果infinite-scroll: 滚动加载，滚动到最下到自动加载， Paul Irish 大神之作animatable: 仅仅依靠 border-width 和 background-position 实现的各种动态效果，看真相Fluidbox: 页面上内嵌图片的放大缩小效果，类似于 Medium 中的效果jquery-validation: jQuery 的一个插件，用于校验 Form 表单BigVideo.js: jQuery 的一个插件, 用于实现大背景(视频、图片)效果emscripten: 一款基于 LLVM, 可以将 C/C++ 转换成 Javascript 的工具，使得 Javascript 可以近乎 Native 的速度qrcode-generator: 各种语言的二维码生成工具device.js: 一个可以检测设备类型的工具，可以让我们根据不同的设备来为其定制响应的 Javascript 和 CSSjquery-qrcode: jQuery 插件，用来生成二维码Wookmark-jQuery: jQuery 的一个插件，可以用来实现瀑布流的效果isotope: 可以用来过滤、排列布局，实现美观的动态布局切换效果，Demolazysizes: 功能强大的图片延迟加载工具，可以首先加载一个低质量的图片，然后再加载高质量的图片progressbar.js: 简洁美观的进度条，扁平化pigshell: 一个由 Javascript 实现的Shell, 将互联网当做一个大的文件系统, 通过 cd/ls/cat…..等命令, 可以访问 Facebook/Twitter/Google Drive 等网络服务spectrum: Js实现的颜色选择器 (Colorpicker)jQuery.countdown: jQuery 倒计时插件summernote: WYSIWYG 富文本编辑器awesomplete: 非常轻型的一个自动补全 JS 库, 没有任何依赖, 配置简单, 美观switchery: IOS 7 上 Switch 的 JS 实现, 支持 IE8 及以上浏览器trix: Basecamp 公司出品的富文本编辑器，简洁小巧sensor.js: 在智能移动设备浏览器上，通过HTML5的api使用移动设备的功能。定位、运动、倾斜等hyhyhy: 用于创建 基于 HTML5 的 演示文稿swipebox: jQuery 插件，用于处理移动端的触摸事件FileAPI: 前端用户处理文件（拖放、多文件上传等）Sortable: 现代浏览器上用于实现元素拖拽排序的功能，支持 Meteor, AngularJS, React，不依赖 jQuerySwiper: 用于实现浏览器上的滑动切换效果，支持硬件加速matter-js: 2D 物理效果引擎，碰撞、弹跳等jQTouch: 用于辅助创建手机端的 Web 应用，支持主题、Zepto.js 等snabbt.js: 一个利用 Javascript 和 CSS transform 的 animation 库c3: 基于 D3 的图表库echarts: 企业级图表库，百度开发parallax.js: 一个用于响应智能手机 orientation 的库jQuery-Animate-Enhanced: jQuery 动画库的一个增强，用于现代浏览器wysihtml: 富文本编辑器，适用于现代浏览器slip: 一个通过滑动或者拖拽来操控列表的库evil-icons: 一个矢量图库，提供 Ruby/Node 等支持PhotoSwipe: JS 的一个图片展示库focusable: 是页面上一个元素高亮的库，有图有真相firefox.html: Firefox 在浏览器端的实现 —— HTML 版的 Firefoxjquery-mobile: jQuery 团队开发的用于辅助手机端 web app 开发的库，基于 HTML5mobile-angular-ui: 基于angularjs和bootstarp的web app开发框架interact.js: 一个适用于现代浏览器的，用于处理 手势、拖放、缩放等的库rebound-js: 实现部分物理效果，Facebook 出品basket.js: 基于 LocalStorage 的资源加载器，可以用来缓存 script 和 css, 手机端使用速度快于浏览器直接缓存iscroll: 高性能的滚动(scroll)处理库，功能强大，支持各种事件，不依赖任何的库，且插件丰富, 大众点评的手机端列表滚动就是用这个库处理的metrics-graphics: 基于 D3 的图表库，简洁、高效，Mozilla 出品accessible-html5-video-player: Paypal 出品的 Video 播放器loading: 几种 Loading 效果，基于 SVGflippant.js: 一款能够漂亮的网页元素翻转效果库，代码许久不更新，不过作为源码学习还是不错的move.js: 基于 CSS3 的前端动画框架scrollReveal.js: 使元素以非常酷帅的方式进入画布 (Viewpoint)，看 DemoModernizr: 一个用来检测 HTML5 和 CSS3 支持情况的库foundation: 另一款前端模版框架，类似于 BootstrapFlat-UI: Bootstrap 的一款主题，简洁美观iCheck: 一款漂亮的 Checkbox 插件Swipe: 非常轻量级的一个图片滑动切换效果库, 性能良好, 尤其是对手机的支持, 压缩后的大小约 5kbslick: 功能异常强大的一个图片滑动切换效果库SocialButtons: 漂亮的社交按钮sweetalert: 一个非常美观的用于替换浏览器默认 alert 的库web-animations-js: Javascript 实现的 Web Animation APIvivus: 可以动态描绘 SVG 的 JS 库, 支持多种动画plyr: 轻量, 小巧, 美观的 HTML5 视频播放器timesheet.js: 基于 HTML5 &amp; CSS3 时间表slideout: 一个非常美观的侧滑菜单 包管理工具 Package Managers NPM菜鸟教程NPM 使用介绍 NPM 使用介绍 | 菜鸟教程淘宝 NPM 镜像 淘宝 NPM 镜像npm 模块安装机制简介 npm 模块安装机制简介 - 阮一峰的网络日志npm包搜索地址 npm BowerBower中文网 BowerBower：客户端库管理工具-阮一峰 JavaScript 标准参考教程（alpha） Yarnyarn中文网 https://yarnpkg.com/zh-Hans/快速、可靠、安全的依赖管理YARN 简介 YARN 简介 编辑器 Text Editors WebStorm官网下载 Download WebStorm: The Smartest JavaScript IDE前端网破解版下载 前端工具库 - 前端网（QDFuns） VScode官网下载 Visual Studio Code - Code Editing. Redefinedvscode 插件精选 - 献给所有前端工程师vscode 插件推荐 - 献给所有前端工程师（更新与2017.3.6） SublimeText官网下载 The text editor you’ll fall in love with前端网破解版插件版下载 前端工具库 - 前端网（QDFuns）SublimeCodeIntel: Sublime Text 的代码补全工具，支持多种语言Emmet：一个用于提高开发效率的编辑器插件，前身是Zen codingSublimeLinter: 一个提供代码质量检测的插件SublimeTmpl：快速新建指定的模版文件Syntax-highlighting-for-Sass：sass代码高亮插件MarkdownEditing: Sublime Text 强大的 Markdown 扩展, 提供快捷键, 主题等ApplySyntax: 辅助检测语法插件CTags: Sublime Text Ctags 支持插件, 需要安装 ctagssublime-react: React 代码高亮 Atom官网下载 A hackable text editor for the 21st Century HBuilder官网下载 DCloud - HBuilder、5+、mui、流应用、HTML5专家 JS框架 JS Frameworks BackboneBackbone.js API中文文档Backbone.js API中文文档 AngularJs中文官方文档Angularangularjs中文网AngularJS中文网angularjs教程AngularJS中文网Angular 基础入门Angular 基础入门 - 汪磊 - 博客园angular-masonry: Masonry 的 AngularJS 插件，用于瀑布流angular-schema-form: 根据 JSON 生成响应的 Form 表单restangular: Angular 中用来处理 RESTful API 的插件，可替代 $resourceng-cordova: Cordova 常用组件的 Angular 版本angular-translate: Angular 的国际化 (I18n)ng-inspector: Chrome 插件，用于调试 Angularangularjs-style-guide: AngularJS 代码风格ngReact: React 的 Angular 插件，可以在 Angular 中使用 React Componentsmaterial: Google Material Design 效果的 Angular 实现angular-local-storage: Angular 插件, 提供了对 localStorage 的友好支持, 并对不支持的浏览器使用 cookie 优雅降级angular-filter: 一组有用的 Angular Filtersbindonce: Angular 插件, 用于减少 Watcher 的数量, 提升性能 React英文官方文档Hello World - React中文官方文档入门教程 | Reactgitbooks手册React 概览 | React 入门教程阮一峰react入门React 入门实例教程 - 阮一峰的网络日志阮一峰React Router入门React Router 使用教程React Router 中文文档React Router 中文文档react-redux 中文文档Redux 中文文档 Join the chat at https://gitter.im/camsong/redux-in-chinese阮一峰Redux 入门教程阮一峰的网络日志react: React 框架源代码react-native: Facebook 出品的使用 React 开发 IOS 原生应用的框架react-hot-loader: 实时调整 React 组件效果grunt-react: React 的 Grunt 组件, 用于将 JSX 编译成 JStouchstonejs: 基于 React 的手机应用前端框架essential-react: 基于 React, ES6, React-Router的一个应用脚手架react-router: React 路由解决方案 Vuevue官方vue.jsvuex官方Introduction · GitBookvue-router官方Introduction · GitBook UI框架 UI Frameworks Bootstrap最受欢迎的 HTML、CSS 和 JS 框架 Bootstrap 中文文档 · Bootstrap 是世界上最流行的、移动设备优先的、响应式前端开发框架。 Ionic一款接近原生的Html5移动App开发框架 会html css js就可以开发apphttp://www.ionic.wang/ FoundationFoundation 中文网 迄今为止最好的响应式前端框架Foundation中文网 | 方便更多热爱Foundation中文网框架的攻城师们分享、交流自己在前端设计、开发方面的心得。 FrozenUI移动端服务的前端框架FrozenUI - 专注于移动web的UI框架 materializecss基于Material Design的主流前端响应式框架手册 - Materialize - ?spm=5176.100239.blogcont71256.188.tjoyi2 mui最接近原生APP体验的高性能前端框架MUI-最接近原生APP体验的高性能前端框架 AntDesign和react配合的UI框架A UI Design Language eleme和vue配合的UI框架Element JS预处理 JS Preprocessors TypeScriptTypeScript 入门教程 菜鸟教程菜鸟教程 - 学的不仅是技术，更是梦想！TypeScript中文网TypeScript中文网 · TypeScript–JavaScript的超集TypeScript教程gitbookhttps://www.gitbook.com/ CoffeeScriptCoffeeScript 中文CoffeeScript 中文CoffeeScript 实用手册 极客学院CoffeeScript 教程_极客学院 Wiki 过程自动化 Process Automation GruntGrunt中文网JavaScript世界的构建工具 – Grunt中文网 Gulpgulp.js 中文网基于流的自动化构建工具。 | gulp.js 中文网gulp详细入门教程一点 | gulp详细入门教程前端构建工具gulpjs的使用介绍及技巧前端构建工具gulpjs的使用介绍及技巧 - 无双 - 博客园Gulp开发教程Gulp开发教程（翻译） - w3ctech - 中国最大的前端技术社区 模板引擎 Templating Handlebarshandlebarsjs官网Minimal Templating on SteroidsHandlebars中文文档http://www.360doc.com/content/Handlebars.js 中文文档Handlebars.js 中文文档Handlebars的使用方法文档整理Handlebars的使用方法文档整理(Handlebars.js) - 推酷 Hamlhaml官方文档haml/hamlhaml入门haml入门 - 姚攀的博客 - 博客频道 - CSDN.NET JadeJade 官方的英文文档Jade的使用_jade 教程_w3cplusJade的使用Jade的使用_jade 教程_w3cplus带你学习Jade模板引擎视频带你学习Jade模板引擎-慕课网 构建工具 Build Tools RequireJSRequireJS 英文网RequireJSRequireJS 中文网RequireJS 中文网require.js的用法-阮一峰阮一峰的网络日志 seajsseajs文档A Module Loader for the WebSeaJS从入门到原理SeaJS从入门到原理 - 推酷 Browserify官网Browserifygithubhttps://github.com/substack/node-browserify/ WebpackWebpack 中文指南介紹 | Webpack 中文指南webpack的实例VICHILY’S BLOGwebpack的入门VICHILY’S BLOG一小时包教会 —— webpack 入门指南一小时包教会 – webpack 入门指南 CSS预处理器 CSS Preprocessors Sasssass入门sass入门 - sass教程sass参考手册Sass 参考手册 | Sass 中文文档SASS用法指南-阮一峰阮一峰的网络日志 Lessless中文网Less 中文网less快速入门快速入门 | Less.js 中文文档 stylusstylus中文文档-张鑫旭stylus中文文档 “ 综述 “ 张鑫旭-鑫空间-鑫生活亲们阿里云云栖社区已开通专栏，欢迎关注阅读：我是程序员 - 知乎专栏 转自：https://zhuanlan.zhihu.com/p/25604225]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于H5页面在iPhoneX适配]]></title>
    <url>%2F2019%2F06%2F28%2Fyuque%2F%E5%85%B3%E4%BA%8EH5%E9%A1%B5%E9%9D%A2%E5%9C%A8iPhoneX%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[1. iPhoneX的介绍 屏幕尺寸我们熟知的iPhone系列开发尺寸概要如下：△ iPhone各机型的开发尺寸转化成我们熟知的像素尺寸：△ 每个机型的多维度尺寸倍图其实就是像素尺寸和开发尺寸的倍率关系，但这只是外在的表现。倍图核心的影响因素在于PPI（DPI），了解屏幕密度与各尺寸的关系有助于我们深度理解倍率的概念：《基础知识学起来！为设计师量身打造的DPI指南》iPhone8在本次升级中，屏幕尺寸和分辨率都遗传了iPhone6以后的优良传统；然而iPhone X 无论是在屏幕尺寸、分辨率、甚至是形状上都发生了较大的改变，下面以iPhone 8作为参照物，看看到底iPhone X的适配我们要怎么考虑。我们看看iPhone X尺寸上的变化： 2. iPhoneX的适配—安全区域(safe area)苹果对于 iPhone X 的设计布局意见如下： 核心内容应该处于 Safe area 确保不会被设备圆角(corners)，传感器外壳(sensor housing，齐刘海) 以及底部的 Home Indicator 遮挡。也就是说 我们设计显示的内容应该尽可能的在安全区域内； 3. iPhoneX的适配—适配方案viewport-fit 3.1 PhoneX的适配，在iOS 11中采用了viewport-fit的meta标签作为适配方案；viewport-fit的默认值是auto。 viewport-fit取值如下： auto 默认：viewprot-fit:contain;页面内容显示在safe area内 cover viewport-fit:cover,页面内容充满屏幕 viewport-fit meta标签设置(cover时) 3.2 css constant()函数 与safe-area-inset-top &amp; safe-area-inset-left &amp; safe-area-inset-right &amp; safe-area-inset-bottom的介绍 如上图所示 在iOS 11中的WebKit包含了一个新的CSS函数constant()，以及一组四个预定义的常量：safe-area-inset-left, safe-area-inset-right, safe-area-inset-top和 safe-area-inset-bottom。当合并一起使用时，允许样式引用每个方面的安全区域的大小。 3.1当我们设置viewport-fit:contain,也就是默认的时候时;设置safe-area-inset-left, safe-area-inset-right, safe-area-inset-top和 safe-area-inset-bottom等参数时不起作用的。 3.2当我们设置viewport-fit:cover时：设置如下body { padding-top: constant(safe-area-inset-top); //为导航栏+状态栏的高度 88px padding-left: constant(safe-area-inset-left); //如果未竖屏时为0 padding-right: constant(safe-area-inset-right); //如果未竖屏时为0 padding-bottom: constant(safe-area-inset-bottom);//为底下圆弧的高度 34px } 4. iPhoneX的适配—高度统计viewport-fit:cover + 导航栏&lt;br /&gt; ![](https://cdn.nlark.com/yuque/0/2019/png/263301/1561712771737-029c9ed2-c76e-4d04-be0a-57f1bedb5064.png#align=left&amp;display=inline&amp;height=936&amp;originHeight=936&amp;originWidth=517&amp;size=0&amp;status=done&amp;width=517)&lt;br /&gt; 5.iPhoneX的适配—媒体查询注意这里采用的是690px(safe area高度)，不是812px; 12345@media only screen and (width: 375px) and (height: 690px)&#123; body &#123; background: blue; &#125;&#125; 6.iphoneX viewport-fit 问题总结1.关于iphoneX 页面使用了渐变色时；如果viewport-fit:cover; 1.1在设置了背景色单色和渐变色的区别，如果是单色时会填充整个屏幕，如果设置了渐变色 那么只会更加子元素的高度去渲染；而且页面的高度只有690px高度，上面使用了padding-top:88px; body固定为： 1&lt;body&gt;&lt;div class="content"&gt;this is subElement&lt;/div&gt;&lt;/body&gt; 1.单色时： * { padding: 0; margin: 0; } body { background:green; padding-top: constant(safe-area-inset-top); //88px /padding-left: constant(safe-area-inset-left);/ /padding-right: constant(safe-area-inset-right);/ /padding-bottom: constant(safe-area-inset-bottom);/ }2.渐变色 * { padding: 0; margin: 0; } body { background:-webkit-gradient(linear, 0 0, 0 bottom, from(#ffd54f), to(#ffaa22)); padding-top: constant(safe-area-inset-top); //88px /padding-left: constant(safe-area-inset-left);/ /padding-right: constant(safe-area-inset-right);/ /padding-bottom: constant(safe-area-inset-bottom);/ } 解决使用渐变色 仍旧填充整个屏幕的方法；CSS设置如下 Designing Websites for iPhone X: Respecting the safe areas * { padding: 0; margin: 0; } html, body { height: 100%; } body { padding-top: constant(safe-area-inset-top); padding-left: constant(safe-area-inset-left); padding-right: constant(safe-area-inset-right); padding-bottom: constant(safe-area-inset-bottom); } .content { background: -webkit-gradient(linear, 0 0, 0 bottom, from(#ffd54f), to(#ffaa22)); width: 100%; height: 724px; } this is subElement 2.页面元素使用了固定定位的适配即：{position:fixed;} 2.1 子元素页面固定在底部时；使用viewport-fit:contain时;可以看到bottom:0时只会显示在安全区域内； Designing Websites for iPhone X: Respecting the safe areas * { padding: 0; margin: 0; } /html,body {/ /height: 100%;/ /}/ body { background: grey; /padding-top: constant(safe-area-inset-top);/ /padding-left: constant(safe-area-inset-left);/ /padding-right: constant(safe-area-inset-right);/ /padding-bottom: constant(safe-area-inset-bottom);/ } .top { width: 100%; height: 44px; background: purple; } .bottom { position: fixed; bottom: 0; left: 0; right: 0; height: 44px; color: black; background: green; } this is top this is bottom 2.1 子元素页面固定在底部时；使用viewport-fit:cover时;可以看到bottom:0时只会显示在安全区域内； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455* &#123; padding: 0; margin: 0;&#125;/*html,body &#123;*/ /*height: 100%;*//*&#125;*/body &#123; background: grey; padding-top: constant(safe-area-inset-top); /*padding-left: constant(safe-area-inset-left);*/ /*padding-right: constant(safe-area-inset-right);*/ /*padding-bottom: constant(safe-area-inset-bottom);*/&#125;.top &#123; width: 100%; height: 44px; background: purple;&#125;.bottom &#123; position: fixed; bottom: 0; left: 0; right: 0; height: 44px; color: black; background: green;&#125; 添加html,body {width:100%;heigth:100%} 图1： * { padding: 0; margin: 0; } html,body { height: 100%; } body { background: grey; padding-top: constant(safe-area-inset-top); padding-left: constant(safe-area-inset-left); padding-right: constant(safe-area-inset-right); padding-bottom: constant(safe-area-inset-bottom); } .top { width: 100%; height: 44px; background: purple; } .bottom { position: fixed; bottom: 0; left: 0; right: 0; height: 44px; color: black; background: green; } 图2： * { padding: 0; margin: 0; } html,body { height: 100%; } body { background: grey; padding-top: constant(safe-area-inset-top); padding-left: constant(safe-area-inset-left); padding-right: constant(safe-area-inset-right); /padding-bottom: constant(safe-area-inset-bottom);/ } .top { width: 100%; height: 44px; background: purple; } .bottom { position: fixed; bottom: 0; left: 0; right: 0; height: 44px; color: black; background: green; } 2.3 关于alertView弹框 遮罩层的解决方案 alertView document.documentElement.style.fontSize = window.screen.width / 7.5 + 'px'; * { margin: 0; padding: 0; } html,body { width: 100%; height: 100%; } body { font-size: 0.32rem; padding-top: constant(safe-area-inset-top); padding-left: constant(safe-area-inset-left); padding-right: constant(safe-area-inset-right); padding-bottom: constant(safe-area-inset-bottom); } .content { text-align: center; } .testBut { margin: 50px auto; width: 100px; height: 44px; border: 1px solid darkgray; outline:none; user-select: none; background-color: yellow; } 弹框加载 function showLoading() { UIAlertView.show({ type:"input", title:"温馨提示", //标题 content:"VIP会员即将到期", //获取新的 isKnow:false }); var xx = new UIAlertView(); console.log(xx); } L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"width":150,"height":300,"position":"right"},"mobile":{"show":true,"scale":0.5},"react":{"opacity":0.9},"dialog":{"enable":true,"hitokoto":true},"log":false}); 参考资料： iPhone X的Web设计 iPhone X适配没那么复杂，但也不是看上去这么简单 剖析 iOS 11 网页适配问题 iPhone X(10)屏幕分辨率与适配 iPhone X 适配手Q H5 页面通用解决方案 转自：https://www.cnblogs.com/lolDragon/p/7795174.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[es6-7-8-9-10]]></title>
    <url>%2F2019%2F06%2F28%2Fyuque%2Fes6-7-8-9-10%2F</url>
    <content type="text"><![CDATA[奇舞读书会─深入理解ES6]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端ppt]]></title>
    <url>%2F2019%2F06%2F28%2Fyuque%2F%E5%89%8D%E7%AB%AFppt%2F</url>
    <content type="text"><![CDATA[模版：https://ppt.baomitu.com/conference剖析CSS-Tricks,为你所用：https://ppt.baomitu.com/d/88200f75#/ 让你的网页更丝滑：https://ppt.baomitu.com/d/b267a4a3#/ js动画原理与实现：https://ppt.baomitu.com/d/4a475069#/ 如何写好JavaScript：https://ppt.baomitu.com/d/53a0a9aa#/55JavaScript语言基础：https://ppt.baomitu.com/d/832d204b#/前端开发的常用设计模式：https://ppt.baomitu.com/d/a131a277#/深入理解ES6:https://ppt.baomitu.com/d/74f8b016#/更好的数组：https://ppt.baomitu.com/d/6a24bac0#/Promise与异步编程：https://ppt.baomitu.com/d/709188c6#/JavaScript中的类：https://ppt.baomitu.com/d/4d223381#/Symbol和Symbol属性：https://ppt.baomitu.com/d/f0f88258#/CSS创意与视觉表现：https://ppt.baomitu.com/d/113a1a80#/]]></content>
  </entry>
  <entry>
    <title><![CDATA[mock]]></title>
    <url>%2F2019%2F06%2F28%2Fyuque%2Fmock%2F</url>
    <content type="text"><![CDATA[zen-mockserver mockjs]]></content>
  </entry>
  <entry>
    <title><![CDATA[UI库和发布网站库]]></title>
    <url>%2F2019%2F06%2F27%2Fyuque%2FUI%E5%BA%93%E5%92%8C%E5%8F%91%E5%B8%83%E7%BD%91%E7%AB%99%E5%BA%93%2F</url>
    <content type="text"><![CDATA[UmiJs** now库可以发布打包好的包，并能外网浏览：https://dist.wangfangcao7618.now.sh/博客：https://public.wangfangcao7618.now.sh/我的DEMO库：https://build.wangfangcao7618.now.sh/#/ Materialhttps://material.io/design/https://material-theme-builder.glitch.me/ wangEditorhttp://www.wangeditor.com/index.html基于javascript和css开发的 Web富文本编辑器， 轻量、简洁、易用、开源免费 UIleader flex 国内5款优秀的WEB前端框架 1. JX（腾讯）官网地址：http://alloyteam.github.io/JX/#homeJX 是一个类似 Google Closure Library 的 Web 前端开发框架，服务于 WebQQ 等大规模的 WebApp。JX 是模块化的非侵入式Web前端框架，开发于2008年，并于2009年开源于GoogleCode ，于2012年切换到Github。 JX 框架同时适用于 Web Page 和 Web App 项目的开发，特别适合构建和组织大规模、工业级的Web App，腾讯 WebQQ、腾讯Q+等产品都是采用JX框架开发，兼容目前所有主流浏览器。腾讯团队打造的前端开发框架JX 2. KISSY（淘宝）官网：http://docs.kissyui.com/KISSY是淘宝的前端类库，几乎在淘宝的每个页面上都能看到它的身影。 3. Tangram（百度）官网：http://tangram.baidu.com/Tangram是一款实用的JavaScript基础库，通过它可以快速构建出高度互动的Web应用程序。Tangram具有全浏览器兼容，平滑升级体验以及自由定制输出最小尺寸的特点。 4、NEJ（网易）官网：http://nej.netease.com/NEJ一个简洁，美观，真正的跨平台web前端开发框架 5、QWrap（百度）官网：http://www.qwrap.com/QWrap是百度有啊前端团队推出的一个Javascript框架，支持IE6+、Firefox、Chrome、Safari、Opera等浏览器，在BSD协议下开源发布。1. 提供jQuery一样方便的dom功能，同时又打破jQuery“专注于dom”的约束，也提供非dom的许多功能。2. 提供prototype方便的原型功能，同时又提供Javascript1.6的泛型功能，并且提供用户有选择方便与严谨的自由。3. 提供YUI2一样的静态方法库，同时又用所谓的Helper规范来做到真正的绝对静态，让组件开发者可以发布出无依赖的组件。4. 学习YUI3的use，同时又摈弃YUI3的严谨性洁癖，让use更实用。5. QWrap独创特的Helper + Wrap + Retouch + Apps设计，让QWrap有更多的灵性等待你去发现。]]></content>
  </entry>
  <entry>
    <title><![CDATA[动画库收集]]></title>
    <url>%2F2019%2F06%2F27%2Fyuque%2F%E5%8A%A8%E7%94%BB%E5%BA%93%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[Catiline.js 腾讯 AlloyTeam Svg Iconhttps://icons8.com/icons/pack/free-icons–redhttps://www.easyicon.net/https://www.flaticon.com/free-icons/sword 简单轻量的 Javascript 运动引擎 to2to Caxhttps://github.com/dntzhang/cax/blob/master/README.md 各种动画地址 GKA 合成图片工具简单的、高效的帧动画生成工具. 使用简单(仅需一行命令) 内置多种图片优化 多类生成模板，支持定制 一键制作自适应等比缩放的雪碧图动画 gka 是一款简单的、高效的帧动画生成工具，图片处理工具。只需一行命令，快速图片优化、生成动画文件，支持效果预览。 一键式: 图片文件批量序列化重命名，生成帧动画文件，支持预览 性能佳: 支持相同图片复用✓ 图片空白裁剪✓ 合图优化✓ 图片压缩✓ 图片空白拆分优化✓ 图片像素差优化✓ 多倍图适配✓ 多模板: 内置多种文件输出模板，支持自定义模板 在线官方文档：https://gka.js.orggit Demo地址：https://github.com/fangcao7618/fangcao7618.github.io/tree/gka_branch 龙骨动画Egret Developerhttp://developer.egret.com/cn/http://dragonbones.com/cn/index.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[需要知道的JS的日期的知识，都在这了]]></title>
    <url>%2F2019%2F06%2F26%2Fyuque%2F%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84JS%E7%9A%84%E6%97%A5%E6%9C%9F%E7%9A%84%E7%9F%A5%E8%AF%86%EF%BC%8C%E9%83%BD%E5%9C%A8%E8%BF%99%E4%BA%86%2F</url>
    <content type="text"><![CDATA[转自：https://juejin.im/post/5d12b308f265da1b7c612746 https://date-fns.org/ https://momentjs.com/]]></content>
  </entry>
  <entry>
    <title><![CDATA[canvas]]></title>
    <url>%2F2019%2F06%2F26%2Fyuque%2Fcanvas%2F</url>
    <content type="text"><![CDATA[canvas博客： 更优雅地基于 canvas 在前端画海报]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo主题配置优化]]></title>
    <url>%2F2019%2F06%2F20%2Fyuque%2FHexo%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1.基本信息配置 基本信息包括：博客标题.作者.描述.语言等等。 打开 站点配置文件 ，找到Site模块 title: 标题subtitle: 副标题description: 描述author: 作者language: 语言（简体中文是zh-Hans）timezone: 网站时区（Hexo 默认使用您电脑的时区，不用写） 关于 站点配置文件 中的其他配置可参考站点配置 2.菜单设置 菜单包括：首页、归档、分类、标签、关于等等 我们刚开始默认的菜单只有首页和归档两个，不能够满足我们的要求，所以需要添加菜单，打开 主题配置文件 找到Menu Settings menu:home: / || home //首页archives: /archives/ || archive //归档categories: /categories/ || th //分类tags: /tags/ || tags //标签about: /about/ || user //关于 #schedule: /schedule/ || calendar //日程表 #sitemap: /sitemap.xml || sitemap //站点地图 #commonweal: /404/ || heartbeat //公益404 看看你需要哪个菜单就把哪个取消注释打开就行了；关于后面的格式，以archives: /archives/ || archive为例：|| 之前的/archives/表示标题“归档”，关于标题的格式可以去themes/next/languages/zh-Hans.yml中参考或修改||之后的archive表示图标，可以去Font Awesome中查看或修改，Next主题所有的图标都来自Font Awesome。 3.Next主题样式设置我们百里挑一选择了Next主题，不过Next主题还有4种风格供我们选择，打开 主题配置文件 找到Scheme Settings Schemesscheme: Musescheme: Mistscheme: Piscesscheme: Gemini 4种风格大同小异，本人用的是Gemini风格，你们可以选择自己喜欢的风格。 4.侧栏设置 侧栏设置包括：侧栏位置.侧栏显示与否.文章间距.返回顶部按钮等等 打开 主题配置文件 找到sidebar字段 sidebar: Sidebar Position - 侧栏位置（只对Pisces | Gemini两种风格有效） position: left //靠左放置 #position: right //靠右放置 Sidebar Display - 侧栏显示时机（只对Muse | Mist两种风格有效） #display: post //默认行为，在文章页面（拥有目录列表）时显示 display: always //在所有页面中都显示 #display: hide //在所有页面中都隐藏（可以手动展开） #display: remove //完全移除 offset: 12 //文章间距（只对Pisces | Gemini两种风格有效） b2t: false //返回顶部按钮（只对Pisces | Gemini两种风格有效） scrollpercent: true //返回顶部按钮的百分比 5.头像设置打开 主题配置文件 找到Sidebar Avatar字段 Sidebar Avataravatar: /images/header.jpg 这是头像的路径，只需把你的头像命名为header.jpg（随便命名）放入themes/next/source/images中，将avatar的路径名改成你的头像名就OK啦！ 6.评论系统 推荐指数 优点 缺点 Valine 4 每天30000条评论，10GB的储存 作者评论无标识 来必力/livere 4 多种账号登录 评论无法导出 畅言 3 美观 必须备案域名 gitment 3 简洁 只能登陆github评论 Disqus 1 需要翻*墙 来必力2.1. 登陆 来必力 获取你的 LiveRe UID。2.2. 填写LiveRe UID到主题配置文件_config.yml 7.添加标签页 添加一个标签页面，里面包含您网站中的所有标签。参考链接 一个创建³³名为tags页面 hexo new page “tags” 编辑标签页，设置页面类型为tags。 title: All tagsdate: 2014-12-22 12:39:04type: “tags” 添加tags到主题配置文件_config.yml里： menu: home: / archives: /archives tags: /tags 详细解释： 8.添加分类页 添加一个分类页面，里面包含您网站中的所有分类。 一个创建³³名为categories页面 hexo new page “categories” 编辑分类页，设置页面类型为categories。 title: All categoriesdate: 2014-12-22 12:39:04type: “categories” 添加 categories到主题配置文件_config.yml里： menu:home: /archives: /archivescategories: /categories 详细解释： 参考截图: 9.添加萌萌哒宠物具体参考官方文档：点击跳转 1.安装模块: npm install –save hexo-helper-live2d 2.配置请向Hexo的 _config.yml 文件或主题的 _config.yml 文件中添加配置.示例: 12345678910111213141516live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: use: live2d-widget-model-wanko display: position: right width: 150 height: 300 mobile: show: true 详解: 1234567891011121314151617live2d: enable: true # enable: false scriptFrom: local # 默认 pluginRootPath: live2dw/ # 插件在站点上的根目录(相对路径) pluginJsPath: lib/ # 脚本文件相对与插件根目录路径 pluginModelPath: assets/ # 模型文件相对与插件根目录路径 # scriptFrom: jsdelivr # jsdelivr CDN # scriptFrom: unpkg # unpkg CDN # scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url tagMode: false # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中 debug: false # 调试, 是否在控制台输出日志 model: use: live2d-widget-model-wanko # npm-module package name # use: wanko # 博客根目录/live2d_models/ 下的目录名 # use: ./wives/wanko # 相对于博客根目录的路径 # use: https://cdn.jsdelivr.net/npm/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # 你的自定义 url 3.模型有许多方法来使用不同的模型: a. live2d_models子目录名称 在您博客根目录下创建一个 live2d_models 文件夹. 在此文件夹内新建名为 shizuku （模型名字）的子文件夹. 在这里应当有一个 .model.json 文件 (例如 shizuku.model.json) 将子文件夹的名称输入 _config.yml 的 model.use 中. b. 相对于博客根目录的自定义路径您可直接输入相对于博客根目录的自定义路径到 model.use 中.示例: ./wives/wanko c. npm 模块名（走这步就可以了）现有模型：https://github.com/xiazeyu/live2d-widget-models对应的模型图片：https://huaji8.top/post/live2d-plugin-2.0/模型地址npm install –save live2d-widget-model-xxx 来安装然后你就可以通过向 model.use 键入包名 (live2d-widget-model-wanko) 来使用了. 10.首页阅读全文Hexo 的 Next 主题默认是首页显示你每篇文章的全文内容，但这会使你的首页篇幅过于冗长，针对这个问题我们可以这么做：用编辑器打开themes/next 目录下的_config.yml文件找到代码： auto_excerpt: enable: false length: 150 将enable的 false改成true，length可以设定文章预览的文本长度。 11.修改背景图片在 themes/*/source/css/_custom/custom.styl 中添加如下代码： // 添加背景图 bg.jpg为图片名称body{ background:url(/images/bg.jpg); background-size:cover; background-repeat:no-repeat; background-attachment:fixed; background-position:center;} 12.实现点击出现桃心效果 在/themes/*/source/js/src下新建文件click.js，接着把以下粘贴到click.js文件中。代码如下： 1!function(e,t,a)&#123;function n()&#123;c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:"+d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+","+d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999");requestAnimationFrame(r)&#125;function o()&#123;var t="function"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement("div");a.className="heart",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement("style");a.type="text/css";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName("head")[0].appendChild(a)&#125;function s()&#123;return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 在\themes*\layout_layout.swig文件末尾添加： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/click.js"&gt;&lt;/script&gt; 13.主页文章添加边框阴影效果打开 themes/*/source/css/_custom/custom.styl ,向里面加代码: 12345678// 主页文章添加阴影效果.post &#123; margin-top: 0px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125; 14.显示当前浏览进度修改themes/*/_config.yml，把 false 改为 true： 12345# Back to top in sidebarb2t: true# Scroll percent label in b2t buttonscrollpercent: true 15.博客文章置顶安装插件 12$ npm uninstall hexo-generator-index --save$ npm install hexo-generator-index-pin-top --save 然后在需要置顶的文章的Front-matter中加上top即可：top值越大表示优先级越高 12345---title: 2018date: 2018-10-25 16:10:03top: 10--- 设置置顶标志打开：/themes/*/layout/_macro/post.swig插入以下代码即可： 12345&#123;% if post.top %&#125; &lt;i class="fa fa-thumb-tack"&gt;&lt;/i&gt; &lt;font color=000000&gt;置顶&lt;/font&gt; &lt;span class="post-meta-divider"&gt; &lt;/span&gt;&#123;% endif %&#125; 16.生成博文插入图片参考：Nuub用Typora编写Markdown的可以修改成这样就直接复制图片过去了 17.取消文章目录自动编号修改主题配置文件那里的number为false 18.修改文章底部标签的图标修改主题模板/themes/next/layout/_macro/post.swig，搜索 rel=”tag”&gt;#，将 # 换成 19.静态资源压缩在站点目录下： 12$ npm install gulp -gnpm install gulp 安装gulp插件： 12345npm install gulp-minify-css --savenpm install gulp-uglify --savenpm install gulp-htmlmin --savenpm install gulp-htmlclean --savenpm install gulp-imagemin --save 在 Hexo 站点下新建 gulpfile.js文件，文件内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445var gulp = require('gulp');var minifycss = require('gulp-minify-css');var uglify = require('gulp-uglify');var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');var imagemin = require('gulp-imagemin');// 压缩css文件gulp.task('minify-css', function() &#123; return gulp.src('./public/**/*.css') .pipe(minifycss()) .pipe(gulp.dest('./public'));&#125;);// 压缩html文件gulp.task('minify-html', function() &#123; return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest('./public'))&#125;);// 压缩js文件gulp.task('minify-js', function() &#123; return gulp.src(['./public/**/.js','!./public/js/**/*min.js']) .pipe(uglify()) .pipe(gulp.dest('./public'));&#125;);// 压缩 public/demo 目录内图片gulp.task('minify-images', function() &#123; gulp.src('./public/demo/**/*.*') .pipe(imagemin(&#123; optimizationLevel: 5, //类型：Number 默认：3 取值范围：0-7（优化等级） progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片 interlaced: false, //类型：Boolean 默认：false 隔行扫描gif进行渲染 multipass: false, //类型：Boolean 默认：false 多次优化svg直到完全优化 &#125;)) .pipe(gulp.dest('./public/uploads'));&#125;);// 默认任务gulp.task('default', [ 'minify-html','minify-css','minify-js','minify-images']); 只需要每次在执行 generate 命令后执行 gulp 就可以实现对静态资源的压缩，压缩完成后执行 deploy 命令同步到服务器： 123456hexo ggulphexo dhexo clean &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo d 20.去掉图片边框NexT主题默认会有图片边框，不太好看，我们可以把边框去掉。打开 themes\Next\source\css_custom\custom.styl，添加如下CSS代码： 12345678/* 去掉图片边框 */.posts-expand .post-body img &#123; border: none; padding: 0px;&#125;.post-gallery .post-gallery-img img &#123; padding: 3px;&#125; 21.添加 关于页面hexo new page “about” 新建一个 关于我 页面。主题的 _config.yml 文件中的 menu 中进行匹配 123456menu: home: / //主页 categories: /categories //分类 archives: /archives //归档 tags: /tags //标签 about: /about //关于 （添加此行即可） 同理于标签页和分类页 22.添加字数统计.阅读时长 统计插件 配置NexT 主题默认已经集成了文章【字数统计】.【阅读时长】统计功能，如果我们需要使用，只需要在主题配置文件 _config.yml 中打开 wordcount 统计功能即可。如下所示： 12345678# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true # 单篇 字数统计 min2read: true # 单篇 阅读时长 totalcount: false # 网站 字数统计 separated_meta: true 修改完成主题配置文件后，启动服务预览： hexo server 访问 http://localhost:4000/ 链接，如果出现字数统计和阅读时长失效的情况，一般是因为没有安装 hexo-wordcount 插件，查看 Hexo 插件： hexo –debug 安装如果没有安装 hexo-wordcount插件，先安装该插件： npm i –save hexo-wordcount Node 版本 7.6.0 之前,请安装 2.x 版本 (Node.js v7.6.0 and previous) ，安装命令如下： npm install hexo-wordcount@2 –save 安装完成后，重新执行启动服务预览就可以了。 显示文字打开post.swig文件，路径如下：/themes/next/layout/_macro/post.swig修改【字数统计】，找到如下代码： 12345678910111213&lt;span title="&#123;&#123; __('post.wordcount') &#125;&#125;"&gt; &#123;&#123; wordcount(post.content) &#125;&#125;&lt;/span&gt;添加 “字” 到 &#123;&#123; wordcount(post.content) &#125;&#125; 后面，修改后为：&lt;span title="&#123;&#123; __('post.wordcount') &#125;&#125;"&gt; &#123;&#123; wordcount(post.content) &#125;&#125; 字&lt;/span&gt;同理，我们修改【阅读时长】，修改后如下：&lt;span title="&#123;&#123; __('post.min2read') &#125;&#125;"&gt; &#123;&#123; min2read(post.content) &#125;&#125; 分钟&lt;/span&gt; 效果预览图： 23.添加社交在主题配置文件找到social，添加需要的就可以，具体如下图可以自定义图标，默认的图标都是从图标库自动匹配的，||后面的就是在图标库的图标名 24.添加站内搜索1、安装 hexo-generator-searchdb 插件 npm install hexo-generator-searchdb –save 2、打开 站点配置文件 找到Extensions在下面添加 搜索search: path: search.xml field: post format: html limit: 10000 3、打开 主题配置文件 找到Local search，将enable设置为true 25.设置文字居中这一行需要居中设置方法： 这一行需要居中 注意：简书中此方法无效 26.点击爆炸效果实现方法跟那个红心是差不多的，首先在themes/next/source/js/src里面建一个叫fireworks.js的文件，代码如下： 1"use strict";function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color="#F00",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:"linear",duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(".fireworks");if(canvasEl)&#123;var ctx=canvasEl.getContext("2d"),numberOfParticules=30,pointerX=0,pointerY=0,tap="mousedown",colors=["#FF1461","#18FF92","#5A87FF","#FBF38C"],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+"px",canvasEl.style.height=window.innerHeight+"px",canvasEl.getContext("2d").scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;"sidebar"!==e.target.id&amp;&amp;"toggle-sidebar"!==e.target.id&amp;&amp;"A"!==e.target.nodeName&amp;&amp;"IMG"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener("resize",setCanvasSize,!1)&#125;"use strict";function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color="#F00",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:"linear",duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(".fireworks");if(canvasEl)&#123;var ctx=canvasEl.getContext("2d"),numberOfParticules=30,pointerX=0,pointerY=0,tap="mousedown",colors=["#FF1461","#18FF92","#5A87FF","#FBF38C"],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+"px",canvasEl.style.height=window.innerHeight+"px",canvasEl.getContext("2d").scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;"sidebar"!==e.target.id&amp;&amp;"toggle-sidebar"!==e.target.id&amp;&amp;"A"!==e.target.nodeName&amp;&amp;"IMG"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener("resize",setCanvasSize,!1)&#125;; 打开themes/next/layout/_layout.swig,在L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"width":150,"height":300,"position":"right"},"mobile":{"show":true,"scale":0.5},"react":{"opacity":0.9},"dialog":{"enable":true,"hitokoto":true},"log":false});上面写下如下代码： 12345&#123;% if theme.fireworks %&#125; &lt;canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" &gt;&lt;/canvas&gt; &lt;script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/js/src/fireworks.js"&gt;&lt;/script&gt;&#123;% endif %&#125; 打开主题配置文件，在里面最后写下： 12# Fireworksfireworks: true 完😀 27.设置文章加密访问这里使用第三方插件Hexo-Blog-Encrypt 1)首先，你需要在站点 _config.yml 中启用该插件1234# Security##encrypt: enable: true 2)给文章添加密码：1234567891011121314---title: hello worlddate: 2016-03-30 21:18:02tags: - fdsfadsfa - fdsafsdafpassword: Mikeabstract: Welcome to my blog, enter password to read.message: Welcome to my blog, enter password to read.---Eg：password: abstract: 此处遭到了封印message: 请输入正确的密码 password: 是该博客加密使用的密码 abstract: 是该博客的摘要，会显示在博客的列表页 message: 这个是博客查看时，密码输入框上面的描述性文字 对 TOC 进行加密如果你有一篇文章使用了 TOC，你需要修改模板的部分代码。这里用 landscape 作为例子： 你可以在 hexo/themes/landscape/layout/_partial/article.ejs 找到 article.ejs。 然后找到 &lt;% post.content %&gt; 这段代码，通常在30行左右。 使用如下的代码来替代它: 1234567891011&lt;% if(post.toc == true)&#123; %&gt; &lt;div id="toc-div" class="toc-article" &lt;% if (post.encrypt == true) &#123; %&gt;style="display:none" &lt;% &#125; %&gt;&gt; &lt;strong class="toc-title"&gt;Index&lt;/strong&gt; &lt;% if (post.encrypt == true) &#123; %&gt; &lt;%- toc(post.origin, &#123;list_number: true&#125;) %&gt; &lt;% &#125; else &#123; %&gt; &lt;%- toc(post.content, &#123;list_number: true&#125;) %&gt; &lt;% &#125; %&gt; &lt;/div&gt;&lt;% &#125; %&gt;&lt;%- post.content %&gt; 28 设置首页缩略图有两种方法，自行选择。 这个需要使用进行截断，上面的内容就是显示在主页的摘要，把图片放在上面就可以了。如果是文字也会进行分割。 在编写md文章的时候在头部添加photos:，如下所示： 1234567891011---title: categories: tags:copyright: truecomments: falsedescription: date: 2017-11-09 14:33:32top:photos: - "https://i.loli.net/2019/01/19/5c42f345b6b2f.jpg" 遇见西门 JuLi距离 Next官方文档 Hexo瞎折腾系列 NIkkkki睡不醒 二次元模型 https://l2dwidget.js.org/dev.html hexo-helper-live2d live2d-widget.js29 ECharts常规做法你可能也看到了，上面的图表在我的hexo搭建的博客中可以完美展示。这个是怎么做到的呢？ 首先，如果你用的是Yelee或者类似的主题，你应该可以很简单地直接参照这个博客去做。 我也是在看上面的博客的时候遇到了问题，如果我用Yelee主题的话是很简单的可以实现上面的效果的，但是我现在更喜欢的是现在的Next主题。这两个主题的结构不一样。 安装上文说的在所用主题目录下layout_partial文件夹中不存在，更不存在head.ejs Next目录：Yelee目录： Next主题做法由此看出，如果你和我一样使用Next主题的话上面的教程不能用。需要像我这样做： 下载js首先下载ECharts的js文件：ECharts 把js文件放到next主题的\source\js\src目录下： js文件的引用然后在next\layout\文件夹下，找到_layout.swig文件，并用文本查看器打开，在下面代码: 1234567891011121314&lt;main id="main" class="main"&gt; &lt;div class="main-inner"&gt; &lt;div class="content-wrap"&gt; &lt;div id="content" class="content"&gt; &#123;% block content %&#125;&#123;% endblock %&#125; &lt;/div&gt; &#123;% include '_third-party/duoshuo-hot-articles.swig' %&#125; &#123;% include '_partials/comments.swig' %&#125; &lt;/div&gt; &#123;% if theme.sidebar.display !== 'remove' %&#125; &#123;% block sidebar %&#125;&#123;% endblock %&#125; &#123;% endif %&#125; &lt;/div&gt;&lt;/main&gt; 的前面添加： 12&lt;!-- echarts --&gt;&lt;script type="text/javascript" src="/js/src/echarts.common.min.js"&gt;&lt;/script&gt; 保存退出。 安装hexo-tag-echarts插件在博客站点目录下执行npm install hexo-tag-echarts –save。 使用范例可以简单的找个例子试下，把下面代码放到一个博客的markdown文件中即可。注意不要使用代码块！！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&#123;% echarts 400 '81%' %&#125; &#123; tooltip: &#123; trigger: 'axis', axisPointer : &#123; // 坐标轴指示器，坐标轴触发有效 type: 'shadow' // 默认为直线，可选为：'line' | 'shadow' &#125; &#125;, legend: &#123; data: ['利润', '支出', '收入'] &#125;, grid: &#123; left: '3%', right: '4%', bottom: '3%', containLabel: true &#125;, xAxis: [ &#123; type: 'value' &#125; ], yAxis : [ &#123; type: 'category', axisTick: &#123; show: false &#125;, data: ['周一', '周二', '周三', '周四', '周五', '周六', '周日'] &#125; ], series : [ &#123; name: '利润', type: 'bar', itemStyle: &#123; normal: &#123; label: &#123; show: true, position: 'inside' &#125; &#125; &#125;, data: [200, 170, 240, 244, 200, 220, 210] &#125;, &#123; name: '收入', type: 'bar', stack: '总量', itemStyle: &#123; normal: &#123; label: &#123; show: true &#125; &#125; &#125;, data: [320, 302, 341, 374, 390, 450, 420] &#125;, &#123; name: '支出', type: 'bar', stack: '总量', itemStyle: &#123; normal: &#123; label: &#123; show: true, position: 'left' &#125; &#125; &#125;, data: [-120, -132, -101, -134, -190, -230, -210] &#125; ] &#125;; &#123;% endecharts %&#125; 之后你就应该能看到我的上面的ECharts图了。 优秀的设计博客：https://clovertuan.github.io/resume/ 优秀的设计博客：https://clovertuan.github.io/resume/ 优秀的星球博客：https://tzvetkov75.github.io/demo_blog/public/2017/02/05/hello-world/ https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/#toc-heading-18 转自：https://selfishluck.top/2018/12/21/Hexo%E4%B8%BB%E9%A2%98%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE/]]></content>
  </entry>
  <entry>
    <title><![CDATA[实例篇]]></title>
    <url>%2F2019%2F06%2F20%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Eg：password:abstract: 此处遭到了封印message: 请输入正确的密码 // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('echarts7358')); // 指定图表的配置项和数据 var option = { tooltip : { trigger: 'axis', axisPointer : { // 坐标轴指示器，坐标轴触发有效 type : 'shadow' // 默认为直线，可选为：'line' | 'shadow' } }, legend: { data:['利润', '支出', '收入'] }, grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true }, xAxis : [ { type : 'value' } ], yAxis : [ { type : 'category', axisTick : {show: false}, data : ['周一','周二','周三','周四','周五','周六','周日'] } ], series : [ { name:'利润', type:'bar', label: { normal: { show: true, position: 'inside' } }, data:[200, 170, 240, 244, 200, 220, 210] }, { name:'收入', type:'bar', stack: '总量', label: { normal: { show: true } }, data:[320, 302, 341, 374, 390, 450, 420] }, { name:'支出', type:'bar', stack: '总量', label: { normal: { show: true, position: 'left' } }, data:[-120, -132, -101, -134, -190, -230, -210] } ] } // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[语雀写作自动同步部署Hexo]]></title>
    <url>%2F2019%2F06%2F20%2Fyuque%2F%E8%AF%AD%E9%9B%80%E5%86%99%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%90%8C%E6%AD%A5%E9%83%A8%E7%BD%B2Hexo%2F</url>
    <content type="text"><![CDATA[语雀和Hexo之前都有单独使用过，都很舒服，今天偶然看到一篇大佬的文章，居然可以把这两个结合起来使用，这岂不是美滋滋，爽歪歪，所以说心动不如行动，搞起来~在实施的过程中，由于自己太菜，有好多坑，搞了好长时间才搞好，不容易，写这样一个文章记录一下 一、所需环境 1.操作系统最好Linux，若在Windows中就装一下虚拟机 2.所需环境软件 Git Node.Js Hexo Ruby二、实现步骤利用Hexo+Github+Triavs-ci来实现在语雀上面写着之后自动部署到Hexo上面去，这么做只能用舒服来形容，嘻嘻！1.介绍1）Hexo要怎么来部署就不要我在这多说什么了，我的博客有这样的教程，附上我的博客地址。2）Github作为一个程序猿必备，略过，没有的，嗯哼，可以不用看了。3）Triavs-ci开源持续集成构建项目，它与jenkins有点像，可以直接用你的Github账号登录，同步你的仓库，很是方便，页面也比较简洁好看。4）yuque-hexo一个Hexo的插件，看名字就知道用来干什么的了，所以你猜的没有错，他就是用来同步语雀到Hexo的插件，这是开源插件，附上开源库地址。感谢大佬的插件。使用起来也很简单就只需要安装好在package.json配置一下就好了。还在配置一下命令，不然编译生成的时候不会同步语雀的文章，也在package.json文件中配置具体可以参考我的package.json文件2.操作流程1）配置Hexo这里简单说一下要注意的地方，具体教程网上有很多。 增加hexo-deployer-git依赖，防止部署时报错。 copynpm install –save hexo-deployer-git 增加hexo-util到dev依赖，防止travis的npm版本&lt;3,出现的Error: Cannot find module ‘hexo-util’错误。 copynpm install –save-dev hexo-util 2）配置Github 在Github上面建两个库（也不一定要两个，也可以利用两个代码分支来进行，我这里用两个仓库做栗子） 一个仓库拥来存放Hexo编译前的代码库。另一个用来存放编译后用来开启Pages的仓库。在本地创建好的Hexo可以提交到源码的仓库了。可以也把Pages的也配置好。 3）配置Travis CI 第一步我们需要有一个 Travis-CI 的账号，直接进入Travis-CI官网，用自己的Github账号授权登录即可。 然后可以看到当前账号的所有代码仓库，接下来将博客项目的状态设置为启用。 第二步创建一个部署在 Travis CI 上面的 SSH key 利用这个 SSH key 可以让 Travis CI 向我们自己的项目提交代码(也就是将博客部署到Page)。这如果你在之前部署Hexo的时候已经创建过了，就可以直接用那个公钥来添加到Github里面去，添加好之后大概就是图片上的样子。 这里提一下，有的时候你的本地向GitHub提交提交不上去，但之前还是可以的，这时候可以检查GitHub的SSH密钥这里，可能是因为安全问题，官方给你暂时冻结了这个密钥，冻结的情况下这里的Delete旁边就会多一个激活按钮，点一下就好了。 第三步加密私钥 加密密钥的时候一定要在Linux操作系统下进行，不然travis-ci之后进行解密的时候会报错，目前官方就是这样的一个BUG，暂时无解。Windows的同学可以在Linux虚拟机中把你的Hexo源码仓库clone进行下面的操作。 这里还需要Ruby来支撑，所以还需安装Ruby，有几种方式，个人推荐还是老老实实编译安装最好 下载ruby 下载最新版的 Ruby 压缩文件。请点击这里下载。也可以使用wget命令 1- 下载 Ruby 之后，解压到新创建的目录下： 12$ tar -xvzf ruby-2.2.3.tgz $ cd ruby-2.2.3 1- 现在，配置并编译源代码，如下所示： 123$ ./configure$ make$ sudo make install 装后，通过在命令行中输入以下命令来确保一切工作正常： 123$ruby -vruby 2.2.3…… 如果一切工作正常，将会输出所安装的 Ruby 解释器的版本，如上所示。如果您安装了其他版本，则会显示其他不同的版本。 安装travis（如果在国内的网络环境下建议安装之前先换源) $ gem install travis 那么之前把公钥文件配置好了，然后现在就要配置私钥文件，在 hexo 项目下面建立一个 .travis 的文件夹来放置需要配置的文件和travis的配置文件travis.yml。Windows和Linux下无法创建和创建报错可以用命令mkdir ./.travis进行创建文件夹，用命令touch ./.travis.yml来创建travis的配置文件。切换到.travis文件夹下 1![image.png](https://cdn.nlark.com/yuque/0/2019/png/240833/1552316024043-dfd7b632-8a75-4634-ad76-4cb77158b415.png#align=left&amp;display=inline&amp;height=46&amp;name=image.png&amp;originHeight=57&amp;originWidth=721&amp;size=17007&amp;status=done&amp;width=577)&lt;br /&gt;用命令行工具登录： travis login –auto 这时候会让你输入你的Github账号（邮箱）和密码，也可以使用GitHub的Token来进行登录 travis login –github-token 具体的Token –auto 然后将私钥 id_rsa 复制到 .travis 文件夹，用命令行工具进行加密： $ travis encrypt-file id_rsa –add 这时候在之前创建好的.travis.yml文件里面就会被写入一些密钥的信息，大概如此：在你的Travis的项目设置中也会出现密钥 接下来就要配置 .travis.yml 首先我们要改一下生成的解密信息，因为这个里面的in和out的文件位置是相对于本地环境来生成的，如果在Travis上面跑的时候位置会发生变化这样运行的时候就会报错，改完之后大概这样子： 为了让 git 默认连接 SSH 还要创建一个 ssh_config 文件。在 .travis 文件夹下创建一个 ssh_config 文件，输入以下内容： Host github.com User git StrictHostKeyChecking no IdentityFile ~/.ssh/id_rsa IdentitiesOnly yes 这样，当向项目 push 代码的时候 travis CI 就会根据 .travis.yml 的内容去部署我们的项目了。具体可以参考我的.travis.yml文件这里要提一下，我们在向Hexo源码仓库Push的时候不要提交本地编译生成的node_modules文件夹，不然到时候在上面跑的时候会有权限问题，npm会根据package.json上面的信息自己下模块的，所以不用当选，具体的涉及到npm的运行原理这里不提了，想了解的可以自行百度哈。** 4）配置Serverless服务目前阿里云和腾讯云都有serverless服务，免费的额度完全够用了，下面介绍一下腾讯云如何配置 创建函数 serverless 函数配置 点击完成即可，之后在配置具体函数代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;?phpfunction main_handler($event, $context) &#123; // 解析语雀post的数据 $update_title = ''; if($event-&gt;body)&#123; $yuque_data= json_decode($event-&gt;body); $update_title .= $yuque_data-&gt;data-&gt;title; &#125; // default params $repos = ''; // 你的仓库id 或 slug $token = ''; // 你travis-cide的登录token $message = date("Y/m/d").':更新啦:'.$update_title; // 你这里是更新信息可自定义 $branch = 'master'; // 你GitHub分支 // post params $queryString = $event-&gt;queryString; $q_token = $queryString-&gt;token ? $queryString-&gt;token : $token; $q_repos = $queryString-&gt;repos ? $queryString-&gt;repos : $repos; $q_message = $queryString-&gt;message ? $queryString-&gt;message : $message; $q_branch = $queryString-&gt;branch ? $queryString-&gt;branch : 'master'; echo($q_token); echo('==='); echo ($q_repos); echo ('==='); echo ($q_message); echo ('==='); echo ($q_branch); echo ('==='); //request travis ci $res_info = triggerTravisCI($q_repos, $q_token, $q_message, $q_branch); $res_code = 0; $res_message = '未知'; if($res_info['http_code'])&#123; $res_code = $res_info['http_code']; switch($res_info['http_code'])&#123; case 200: case 202: $res_message = 'success'; break; default: $res_message = 'faild'; break; &#125; &#125; $res = array( 'status'=&gt;$res_code, 'message'=&gt;$res_message ); return $res;&#125;/** @description travis api , trigger a build* @param $repos string 仓库ID、slug* @param $token string 登录验证token* @param $message string 触发信息* @param $branch string 分支* @return $info array 回包信息*/function triggerTravisCI ($repos, $token, $message='yuque update', $branch='master') &#123; //初始化 $curl = curl_init(); //设置抓取的url curl_setopt($curl, CURLOPT_URL, 'https://api.travis-ci.org/repo/'.$repos.'/requests'); //设置获取的信息以文件流的形式返回，而不是直接输出。 curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1); //设置post方式提交 curl_setopt($curl, CURLOPT_CUSTOMREQUEST, "POST"); //设置post数据 $post_data = json_encode(array( "request"=&gt; array( "message"=&gt;$message, "branch"=&gt;$branch ) )); $header = array( 'Content-Type: application/json', 'Travis-API-Version: 3', 'Authorization:token '.$token, 'Content-Length:' . strlen($post_data) ); curl_setopt($curl, CURLOPT_HTTPHEADER, $header); curl_setopt($curl, CURLOPT_POSTFIELDS, $post_data); //执行命令 $data = curl_exec($curl); $info = curl_getinfo($curl); //关闭URL请求 curl_close($curl); return $info;&#125;?&gt; 这里有几个需要获取的参数： travis登录token，在travis-ci.org 中设置界面获取： 1- 仓库ID 或 扩展名 使用findder 或者 postman 发起一个请求： https://api.travis-ci.org/owner/github用户名/repos 配置触发方式 一般会得到这么个api：https://service-8x9gl1u7-1258196125.ap-shanghai.apigateway.myqcloud.com/release/yuque-hexo 5）配置语雀配置一个仓库（公开的仓库）的webhook:可以选择所有更新触发或者主动触发，主动触发的意思即发布需要勾选一个选项才会触发webhook。具体可参见语雀文档；将serverless生成的api填入,可以在链接后面带参数： 1234567token 登录tokenrepos 仓库idmessage 提交信息branch 分支示例：https://service-8x9gl1u7-1258196125.ap-shanghai.apigateway.myqcloud.com/release/yuque-hexo?repos=xxx&amp;token=xxx&amp;message=xxx&amp;branch=xxx 如果不在链接带参数则写在serverless函数内。 6）大功告成发布或者更新一篇文章后，我们前往travis-ci,可以看到已经触发了一次构建请求：构建完成后，咱们的博客上已经妥妥的展示出来拉~ 参考资料Nero的语雀 转自：https://sunnybob.github.io/2019/01/11/%E8%AF%AD%E9%9B%80%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hexo+GithubPages%E5%8D%9A%E5%AE%A2/]]></content>
  </entry>
  <entry>
    <title><![CDATA[流量统计]]></title>
    <url>%2F2019%2F06%2F19%2Fyuque%2F%E6%B5%81%E9%87%8F%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[如果你关心自己博客的访问数据，那么集成流量统计工具自然必不可少。统计站点流量访问的平台主要推荐以下三个： Google Analysis:google.com/intl/zh-CN/a，功能强大不用多说，由于国内Google的服务用不了，所以推荐海外站点使用。 CNZZ：http://web.umeng.com/ ，中文网站统计分析平台，口碑不错，目前和友盟合并被阿里收购。 百度统计：http://tongji.baidu.com/ ，正在研究，不多做评价。 统计功能同样集成简单，我索性把三家统计都集成了，做分析对比。]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何评价「多说」即将关闭？有什么替代方案？]]></title>
    <url>%2F2019%2F06%2F19%2Fyuque%2F%E5%A6%82%E4%BD%95%E8%AF%84%E4%BB%B7%E3%80%8C%E5%A4%9A%E8%AF%B4%E3%80%8D%E5%8D%B3%E5%B0%86%E5%85%B3%E9%97%AD%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[第三方评论系统推荐这几天在网上搜集了不少第三方评论系统，做了简单测评。原文太长，所以贴个链接：第三方评论系统推荐 - 水八口记。文中提到的评论系统有： Disqus HyperComments 来必力 IntenseDebate 畅言 网易云跟帖（已停止服务） 友言 Remarkbox Vuukle Muut Vicomi Civil Comments Widget Pack Rating &amp; Comment System Facebook comments Livefyre（已停止服务） Google+ Comments（非官方） HashOver Isso Staticman Gitment Gitalk Blog Comments2 Valine hexo评论从多说迁移到disqus鉴于duoshuo系统2017年6月1号停止维护,我决定把评论系统切换到 Disqus，即使可能会丢失全部的评论数据，我还是决定和多说一刀两断。 添加disqus 评论系统可以用到的评论系统有挺多的，多说，disqus等，这里只mark下disqus，disqus 的添加跟主题有关，因为hexo自带disqus，所以添加起来非常简单，这里讲下默认的主题landscape 和 上面演示的主题next整个切换过程其实很简单，在 Disqus 注册，然后在 Settings/Admin 中新建站点，接下来就是一步一步跟着向导程序走下去。然后在主题的配置文件，主题的配置文件，主题的配置文件，重要的说三遍，在主题的配置文件_config.yml的disqus后面添加website shortname中使用的唯一的disqus识别名字，这里我使用的是zyy1217。 Step 1：进入disqus官网， 点击蓝色框中链接，给自己的网站添加disqus， Step 2：点击后，出现下图，输入网站名字。然后在第二个输入框填写自己的唯一disqus识别名称，这个名称会在后面用到，比如我这里填写的是我最常用的absea。然后点击Next按钮 Step 3：上面点击Next后就会出现下面页面，这里面会有disqus在不同博客系统上或者其他系统上对应的代码。因为hexo自带支持disqus，所以不需要这里面的代码，这个页面的内容会在其他除hexo之外的博客系统中用到，如果是hexo搭建博客disqus，可以跳过 Step 4：然后在主题的配置文件，主题的配置文件，主题的配置文件，重要的说三遍，在主题的配置文件_config.yml的disqus后面添加step 2中使用的唯一的disqus识别名字。这里我使用的是absea，还有一点一定要注意，不要再跟目录下的_config.yml对评论进行设置 | 12 | # Disqusdisqus_shortname: absea || :— | :— | Step 5：然后输入 hexo s或者hexo server 就会出现disqus的效果：关于disqus评论框的样式美化可以参考Disqus Appearance Tweak不仅如此，我们还可以区分国内与国外GIT，分别显示多说与DISQUS 转自：http://zyy1217.com/2017/05/03/hexo%E8%AF%84%E8%AE%BA%E4%BB%8E%E5%A4%9A%E8%AF%B4%E8%BF%81%E7%A7%BB%E5%88%B0disqus/ Gitment Demo https://github.com/imsun/gitment Gitment：使用 GitHub Issues 搭建评论系统本以为自己都二十好几了，早就过了折腾博客系统的年龄，然而万万没想到多说倒闭了。 综合考虑了多家评论系统以后，我最终打算自己写一个。 Gitment 是作者实现的一款基于 GitHub Issues 的评论系统。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown / GFM 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。本博客评论系统已迁移至 Gitment。虽然 Gitment 只能使用 GitHub 账号进行评论，但考虑到博客受众，这是可以接受的。 项目地址 示例页面基础使用1. 注册 OAuth Application点击此处 来注册一个新的 OAuth Application。其他内容可以随意填写，但要确保填入正确的 callback URL（一般是评论页面对应的域名，如 https://imsun.net）。你会得到一个 client ID 和一个 client secret，这个将被用于之后的用户登录。2. 引入 Gitment将下面的代码添加到你的页面： | var gitment = new Gitment({id: '页面 ID', // 可选。默认为 location.hrefowner: '你的 GitHub ID',repo: '存储评论的 repo',oauth: {client_id: '你的 client ID',client_secret: '你的 client secret',},})gitment.render('container') || :— | 注意，上述代码引用的 Gitment 将会随着开发变动。如果你希望始终使用最新的界面与特性即可引入上述代码。如果你希望引用确定版本的 Gitment，则应该使用 npm 进行安装。 | $ npm install –save gitment || :— | 关于构造函数中的更多可用参数请查看 Gitment Options 3. 初始化评论页面发布后，你需要访问页面并使用你的 GitHub 账号登录（请确保你的账号是第二步所填 repo 的 owner），点击初始化按钮。之后其他用户即可在该页面发表评论。 自定义Gitment 很容易进行自定义，你可以写一份自定义的 CSS 或者使用一个新的主题。（主题可以改变 DOM 结构而自定义 CSS 不能）比如你可以通过自定义主题将评论框放在评论列表前面： | const myTheme = {render(state, instance) {const container = document.createElement(‘div’)container.lang = “en-US”container.className = ‘gitment-container gitment-root-container’container.appendChild(instance.renderHeader(state, instance))container.appendChild(instance.renderEditor(state, instance))container.appendChild(instance.renderComments(state, instance))container.appendChild(instance.renderFooter(state, instance))return container},}const gitment = new Gitment({// …theme: myTheme,})gitment.render(‘container’) || :— | 更多自定义内容请查看文档。 其他问题 语言问题考虑到 GitHub 本身使用英文，而本项目面向用户均为 GitHub 用户，所以作者没有提供中文支持的打算。实在有需求的可以通过自定义主题支持中文。 请勿滥用在开发这个项目时我就一直有一个疑虑：我这样做有没有滥用 GitHub？为此我仔细读了 GitHub Terms of Service中 API Terms 的部分，认为自己并没有违反协议。之后我向 GitHub 发邮件询问了这一问题。GitHub 给出的回复是： We’re pleased to see you making use of the tools and resources available on GitHub. 因此本项目的确没有违反 GitHub 使用协议。但我还是想提醒使用本项目的用户，请保持克制，切勿滥用。 样式版权在项目开源前作者曾实现了一个像素级抄袭 GitHub Issues 样式的界面，但在阅读 ToS 时发现违反了 Section F，并在和 GitHub 邮件沟通的过程中确认了这一行为是侵权的。因此便改成了现在的样式。请其他想要自定义样式的用户也留意版权问题。# Gitment写个 Web Server（一）需求 这段转自：https://imsun.net/posts/gitment-introduction/ GITALK 一个基于 Github Issue 和 Preact 开发的评论插件开始使用 GITHUB 第三方评论系统推荐2多说要下线了，国内博客圈哀鸿遍野。主流博主们还好，有原生评论系统可以用，只是社交分享的时候麻烦点。最近流行起来的静态博客的博主们就不太好了，除了一部分技术帝能够“自己动手，丰衣足食”，其他吃瓜博主要么积极地到处求攻略，要么懒得折腾干脆关了评论。Bitcron 不算静态博客，也有自己的评论系统，但处女座的我嫌评论的保存方式不太整洁，所以换博初始就打定了主意使用第三方评论。根据多年的经验和体验，我选择了算是全球最大的评论系统——Disqus。但是突然某一天我被残忍告知这货已经被中国局域网长城挡住了，当时内心是极度奔溃的。本来作为一个洋应用就没什么本地化可言，现在这种局面就更指望不上适应性的提升了，心里拔凉拔凉的。好在现在能建博客的大多也都有科学上网的实力，我也不似以前那么在意和网友的互动了。有当然好，没有也无所谓了。（悄悄说，博客是写给自己的，连评论系统都是给自己用的。有空翻翻以前的文章留个言，看看进步什么的，以前就一直在日记本上这么做。）虽然我不打算换掉 Disqus，但还是本着为人民服务的精神找了一些可以替代多说的第三方评论系统，不止静态博客，理论上来说也适用于所有独立博客系统。以下注释仅代表我个人的想法，详细信息请参照官方网站说明，根据个人需求进行选择安装使用。 Disqus1https://disqus.com 作为业界的龙头老大，相信大家都已经很熟悉了。根据 Datanyze 的统计，Disqus 在全球范围内拥有继 Facebook comments 之后排名第二的占有率，大约37%1。如果不是因为一些不可言说的原因，它的占有率可能还会更大。当然 Facebook comments 也是“受害者”之一，所以单就中国地区而言，Disqus 的占有率是最大的，超过半数2。以上这些数据都来源于国外的统计，如果算上国内的评论系统，我想多说应该是当之无愧的霸主了。数据来源 Datanyze / 制图 水八口Disqus 的好处不必多言，本身就是专业做评论系统的，功能齐全，支持 ssl，响应化设计，界面美观。我还特别喜欢它的一项多说没有的功能是，可以在文章 url 改变后迁徙评论到新文章下。比如前段时间我把间隔年日记从每日一篇改为每周一篇，统合之后便把每日一篇的评论都集中到新写的每周一篇里了。当然它也是有缺点的，我认为的最主要的缺点有两个。一是无法导出/导入自家评论。后台的导出设置只是为了备份，导出的文件没法重新导入。二是没法自定义样式。不过，最大的“缺点”应该算是国内无法使用了吧。身为资深博主，科学上网当然不在话下，但是并不能要求每个读者都有这项技能。所以这也成为了是否使用 Disqus 的最大障碍。前面说了那么多，如果用不了，都成了废话。2017年7月10日更新：我找到了两种可以科学使用 Disqus 的方法，但都不能登录 Disqus，只能使用访客留言通道。也就说你的评论并不会出现在你 Disqus 的 timeline 里。同时访客留言的网址也没法写入 Disqus 后台，但在代理状态下可以显示。综上所述，对于墙内的博主来说，代理就像 WP 的原生评论一样；而对于墙外的博主来说，原生的 Disqus 看不到访客网址，影响回访效率。即便如此，能够使用已经非常难得。 使用 Typlog 提供的 Disqus 代理服务，服务器费用 $10/年，操作简单3。无评论回复邮件提醒4。 使用 fooleap 的研究成果，免费，需要支持 PHP cURL 的虚拟主机和一颗不怕折腾的心。有评论回复邮件提醒5。 HyperComments1https://www.hypercomments.com 来自俄罗斯的评论系统，使用谷歌账号注册。免费用户支持一个网站和一个管理员，对于个人博客来说足够用了。个人用户$24/年，支持一个网站和三个管理员。14天免费试用。更多请参考官网价格页面。功能暂且不说，光看这清爽的界面，作为一只颜狗，我是服气的。HyperComments 颜值在线除了耀眼的颜值，它的功能和 Disqus 大同小异，有些高阶功能需要收费。另外身在俄罗斯的小伙伴可以以短信形式收到评论回复，听着就很高大上。最后说说大家最关心的问题，现阶段国内可以使用，但是，必须使用谷歌账号才能登陆留言，所以有点悬。谢谢小F的更正：免费版后台可以设置支持游客评论。 来必力1https://livere.com 来自韩国，使用邮箱注册。不得不承认颜值也很高，准确地说应该是萌。中国地区的本地化做得很不错，甚至可以用微信登陆留言，简直热泪盈眶。就这点来看，是多说最好的替代品。同时支持的登陆方式还有：新浪微博、QQ、百度、人人、豆瓣。顺带提一下在韩文和英文模式下的登陆方式：来必力、Kakao talk、Naver、Facebook、Twitter、Instagram、Line、GitHub、Tistory、Google+、Linkedin。来必力支持国内多家社交平台登陆国内可以使用。修改评论框样式是收费项目。修改评论只有一次机会。理论上来说注册一个来必力账号，绑定各个社交网站以后，之后用社交网站登陆留言也会同步到同一个账号里6。可以设置评论分享到社交网站。点击头像会像 Disqus 一样显示侧边栏，可以看以往评论。 IntenseDebate1https://www.intensedebate.com 是 WordPress 所在的 Automattic 旗下的产品。优点是支持游客评论。国内可以用，但听说加载略慢。曾经是 Disqus 强有力的对手。既然和 WordPress 同一东家，想必反垃圾邮件的功能应该做得不错。如果有 WordPress 账户就不需要额外注册，但很多用 WP 的都可以使用原生评论，这真是个奇妙的悖论。IntenseDebate 可以以游客身份留言（上图中未开启此项功能） 畅言1http://changyan.kuaizhan.com 搜狐旗下，大牌加持，安装需要备案号。界面还算清爽，不满意的话可以自定义样式。畅言可以自定义 CSS 网易云跟帖（已停止服务）1https://gentie.163.com 感谢小F的提醒：此产品将于2017年8月1日停止服务7。网易旗下，大牌加持，支持网易账号、新浪微博和 QQ 登陆。界面有点尴尬，因为会把地址写出来，比如北京市网友，有种当年各大门户网站下的留言既视感。对于小清新的个人博客来说可能是个不能接受的大坑。网易云跟帖有着网易一贯的“风味” 友言（已停止服务）1http://www.uyan.cc 感谢荏苒的提醒，友言官网已经打不开了，谷歌后得知2017年就不能使用了。可能是最像多说的评论系统。有评论统计、最新评论插件可以使用。JiaThis（加网）旗下产品。它家有加网的分享按钮（Share this），友荐的猜你喜欢（Related posts），加上友言的评论系统，博客三件套齐活儿了。支持 QQ、新浪微博、人人、开心网账号登陆。界面很像 Disqus。友言的家族成员还有加网和友荐 Remarkbox1https://www.remarkbox.com 一位外国友人的个人项目，主打就是“Disqus 的替代品”。因为从 WP 搬到静态博客，寻找第三方评论系统时不喜欢评论里有广告，所以就自己写了一个。好像还是 beta 版，还在增加功能。在测试评论里看到了代码高亮，果然是极客的世界。界面简洁。由于是个人项目，故对未来的发展持观望态度。Remarkbox 的未来会如何？ Vuukle1http://vuukle.com 来自印度。后台感觉跟 WordPress 比较像，还能看当前在线人数。我注册了一个账号试安装了一下没成功。（所以给我留下了不靠谱的感觉。也可能是我技术不够。）界面设计不错，支持 Google+ 和 Facebook 账号登陆，也可以以游客身份留言。Vuukle 支持游客评论 Muut1https://muut.com 免费计划竟然包含了无限流量、多语言、无广告和样式修改？！我想要欢呼！更惊喜的是评论可以用 Markdown，还能 ctrl+enter 发布。支持 Facebook、Twitter、Google+、Yahoo、Windows Live、Linkedin、GitHub、Reddit、Yandex、Disqus 账号登陆。注册可以用邮箱。Demo 页面有很多格式，NY Times 样式的侧边栏评论令人惊艳。私聊功能需要付费。输入评论时可以实时预览。Muut 令人惊艳 Vicomi1http://www.vicomi.com 免费用户支持一个域名。特点是可以选择心情表情。也因此界面有些凌乱。Vicomi 是评论界的表情帝 Civil Comments1https://www.getcivil.com/comments 邮箱注册，社交网站支持 Facebook 和 Twitter。界面友好干净，无功无过。Civil 旗下还有 Civil Live 和 Civil Reviews。专注 UGC (User Generated Content) 的样子。Civil Comments 使用手册（英文） Widget Pack Rating &amp; Comment System1https://widgetpack.com/comment-system 跟 Civil Comments 类似，除了评论系统，还有 Reviews、Rating 和 Google Reviews。免费用户支持一个域名和一位管理员。使用邮箱注册。留言可以使用以下社交网站登陆：Facebook、Twitter、Google+、Linkedin、Instagram、SoundCloud、Tumblr、ВКонтакте (VK)、OK、Мой Мир、Yahoo、LiveJournal、Яндекс。从这些网站中我看出来了，这也是一家来自俄罗斯的产品。评论框内嵌星级评分，据官方称，评分会显示在谷歌的搜索结果中。支持 ssl。Widget Pack Rating &amp; Comment System Facebook comments1https://developers.facebook.com/docs/plugins/comments 如果你的朋友都在使用 Facebook，这绝对是不二选择。就好比新浪微博出了个评论系统，亲戚朋友都能方便登陆留言，评论可以点赞，还能分享到微博让更多人看到，一气呵成。当年多说能够保持绝对地位的占有率，也是靠了支持国内各个社交平台登陆的力量。 Livefyre（已停止服务）被 Adobe 收购以后就不再是独立的评论系统了。它成为 Adobe Experience Manager 的一部分，简单说来就像是简书的评论部分一样8。因为在 Datanyze 的图表上看见它排名第四，也在谷歌后找到官方的安装网站，顺利取得代码，于是我原以为它还能使用。但在测试时看到了以下信息，于是我彻底死心了。竟然也是最近的事。 Notice: Livefyre Community Comments will become read-only starting March 9, 2017 and no longer available as of April 6, 2017. To export your comments, please visit, www.livefyre.com/installation/site/export/. For more information, please see https://docs.adobe.com/docs/en/aem/livefyre-announcements.html. 面对曾经的用户，Adobe 给出了两个备用选择：Disqus 和一个 WordPress 插件。这个插件可以在 Google+、Facebook comment、Disqus 和 WordPress 原生评论中切换，对于想兼顾国内外朋友的博主来说应该是个不错的选择。 Google+ Comments（非官方）高手在民间9。 HashOver1http://tildehash.com/?page=hashover 技术小白表示看不太懂，大家可以去官网围观一下。 Isso1https://posativ.org/isso 也是技术向的，我等小白就不妄加评论了。 Staticman1https://staticman.net 顾名思义，静态评论，逼格太高了。最适合托管在 GitHub Pages 上的 Jekyll 博客。对于没有 Git 经验的我，安装手册看起来太难了。 Gitment1https://github.com/imsun/gitment 感谢Fooleap的分享，官网给出的说明是： Gitment 是作者实现的一款基于 GitHub Issues 的评论系统。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown / GFM 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。 目测非常适合 GitHub 重度用户，并且博客受众也是 GitHub 用户的人。 Gitalk1https://gitalk.github.io 感谢Liu Joey的分享，官方 GitHub 页面上对此的介绍是： Gitalk 是一个基于 Github Issue 和 Preact 开发的评论插件。 Blog Comments21https://github.com/revir/nodebb-plugin-blog-comments2 从 NodeBB 官方博客的评论插件上修改而来，支持静态博客。 Valine1https://github.com/xCss/Valine 感谢林小沐的分享，官方中文教程声称这是「一款基于Leancloud的极简风评论系统」。另有进化版可供选择。 Self-host comments in Jekyll1https://flinhong.com/2017/03/25/self-host-comments-in-jekyll-using-firebase-database 感谢flinhong分享的造轮子方法，按照大神的原话是： 感兴趣的同学也来自己动手做一个，很适合静态博客。唯一的缺点就是用的 Google 的服务，需要那啥，大家懂的。 Commento1https://gitlab.com/commento/commento 感谢fc4soda的推荐： 支持 markdown 支持匿名、层级回复 支持锁定主题 免费 go写的不需要安装依赖，还有docker版 目前作者在考虑多国语言化 缺点：- 需要自己搭建服务- 目前手动审核评论似乎只能在主帖下面，无法在管理后台统一管理 后记这篇文章写了整整一天半，信息量之大是我最初没有想到的。因为找到的很多都是收费的，所以看过的评论系统可能有现在总结出来的两倍，工程量非常浩大，好在我坚持下来了。好久没有如此专注过一件事，写完的时候心里美滋滋的。在查找 Disqus 替代品的时候发现很多国外的评论系统也消失了不少，看来当初选择了 Disqus 真是押对了宝。对于第三方评论系统来说，盈利模式非常重要。免费的评论系统一般都在说 UGC，也就是用户产生内容。如果你的网站有很多读者，一起讨论可以创造出更多的价值。简单说起来就是大家一起赚钱，或者类似粉丝经济。所以我找到了很多只面对企业客户的评论系统就一点也不意外了，毕竟普通的个人身上很难产生赢利点。而幸存下来的免费评论系统，比如 Disqus，最终也没能逃脱在评论里插入广告的魔咒，因此得罪了不少用户，即使广告费有分成。另外很多社交网络都有自己的评论系统，反正都得注册，评论也不需要门槛。这对第三方评论系统的生存也是一个冲击。在搜集资料的过程中，我还发现了一个特别的现象，就是很多收费的评论系统都有免费的 WordPress 插件。所以好好珍惜手中的 WordPress 吧。最后，还是得安利一下我的“大房东”——Bitcron。论专注写作、简洁、本地化、先进技术，多年在博客圈打拼的我觉得它都是第一名。一站式解决所有问题，比当年惊艳我们的 FarBox 走得更远了。现在它不仅仅是一个博客，甚至可以变身成任何你想要的东西，这是它的野心，也给了我们信心。当然，评论框很美是有加分的。如果你有什么更好的推荐欢迎留言告诉我，我会补充在这篇文章里。 参考网站 再见，那些年我们一起用过的多说 - 荏苒.me Are there any free alternatives to Disqus? - Quora Disqus Alternatives - tips &amp; tricks - Hugo Discussion Alternative to Disqus Needed More Than Ever - support - Hugo Discussion Hashover-PHP开源评论系统 - Orro.ro Disqus Alternatives and Similar Software - AlternativeTo.net Improving Static Comments with Jekyll &amp; Staticman | Made Mistakes 如何评价“多说”即将关闭？有什么替代方案？ - 知乎]]></content>
  </entry>
  <entry>
    <title><![CDATA[doc命令]]></title>
    <url>%2F2019%2F06%2F19%2Fyuque%2Fdoc%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[mac 杀掉占用某个端口的进程两个小命令: lsof -i :端口 kill -9 进程ID]]></content>
  </entry>
  <entry>
    <title><![CDATA[go语言]]></title>
    <url>%2F2019%2F06%2F19%2Fyuque%2Fgo%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[Go 语言中文开源图书、资料或文档–Go的开源书籍 破解方法：https://www.cnblogs.com/pig66/p/10420947.html软件安装后的路径：/Applications/GoLand.app/Contents/bin破解包：jetbrains-agent.jar GoLand2019 激活码 此教程对最新2019版本GoLand有效！！！ 本教程对windows、mac、ubuntu全系统可用 此教程实时更新，请放心使用；如果有新版本出现猪哥都会第一时间尝试激活； goland官网下载地址：http://www.jetbrains.com/goland/download/ 汉化教程 激活出问题可扫描下方二维码，加入激活群寻求帮助！两种激活方式 永久激活：推荐优先使用，永久有效 有效期激活：如果你实在激活不了又着急使用，这是备选激活方案，简单快捷一、永久激活1.下载新版破解补丁点击链接 https://pan.baidu.com/s/16ALpz_BCXjsRkpS_PtD23A 下载补丁文件 jetbrains-agent.jar 并将它放置到 goland安装目录的\bin目录下（位置可随意，放这里是怕误操作删除了破解文件）。2.进入项目界面如果你之前已经使用有效期激活过可跳过此步骤，如果你是刚下载的GoLand，则需要点击激活窗口的“Evaluate for free”免费试用，然后再创建一个空项目，这样就可以进入到GoLand的工作页面3.修改配置文件进入到项目界面后，点击GoLand最上面的菜单栏中的 “Help” -&gt; “Edit Custom VM Options …”，如果提示是否要创建文件，请点”Yes”。 在打开的vmoptions编辑窗口末行添加：-javaagent:你goland的安装目录\jetbrains-agent.jar请仔细检查补丁路径是否正确，如果错误则会出现GoLand打不开的情况，这时候可以删除用户配置目录下的goland文件夹:windwos：C:\Users\用户名&lt;br /&gt;macos：/Library/Preferences/ubuntu：/.修改完配置文件之后重启GoLand修改完配置文件之后重启GoLand修改完配置文件之后重启GoLand 4.输入激活码重启GoLand之后，点击菜单栏中的 “Help” -&gt; “Register …”，这里有两种激活方式：一、选择最后一种License server激活方式，地址填入：http://jetbrains-license-server（应该会自动填上），或者点击按钮：”Discover Server”来自动填充地址，完成激活二、如果服务器激活方式无法激活，还可以选择Activation code方式激活，复制下面激活码即可 1D00F1BDTGF-eyJsaWNlbnNlSWQiOiJEMDBGMUJEVEdGIiwibGljZW5zZWVOYW1lIjoiaHR0cHM6Ly96aGlsZS5pbyIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiJVbmxpbWl0ZWQgbGljZW5zZSB0aWxsIGVuZCBvZiB0aGUgY2VudHVyeS4iLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiV1MiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSRCIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJDIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJEQiIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJNIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiRE0iLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJBQyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRQTiIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkdPIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUFMiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlBDIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlNVIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In1dLCJoYXNoIjoiODkwNzA3MC8wIiwiZ3JhY2VQZXJpb2REYXlzIjowLCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-3OPFIX9/KSL76ctAKOwpBPCCAfUhUbucdNbtqMaTqRryvKEvrFqCKncE0eMHA2YkrcP2CtV9LKjlIXhJMqp0N821Qv1AhuIJrDMBubqiEtiqnGkcGV35DF0GzyUQaUdN6fTbZna05riHzR6yzgEzo9R3RIzCTDMQdB/0EojWM0nCBkPsLdncZeDv3+Y+VA8ZH3/BBvzwR1e0gWsT3mfT9tIvwxPuEhNrQFNOP1PZOjC8nX9h/J7ag5X3JQL1CQVi4TnEipdy0fxKbDPKTloM3Y/bA23uaW+Q/JQFBRKRR0q3FYJ1DQuSc7YmeJ7Q2IHq7u5QYz8jPZJtP6PKs6g/tQ==-MIIECDCCAfCgAwIBAgIJAI5/xwNtz47cMA0GCSqGSIb3DQEBCwUAMBgxFjAUBgNVBAMMDUpldFByb2ZpbGUgQ0EwIBcNMTgwODIzMDcwNDA3WhgPMjExODA3MzAwNzA0MDdaMBExDzANBgNVBAMMBnByb2QzeTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAOZ3WopNRg9J8k3apGYFEUGRlvkRsQnQSEz1yMKY4YWg9ElxmuF0mQRAaIj3WOl1eqTn1CXsn4vXV7GODJk9A/rCqEk960sPesWn/RVz7zo5+KazE3Y9yYtwskKxlnkFNp82Kha6dUGDSwG2lYh0Sria2ByOhgr6gmyXtC0PKqlIlTAPcBvz0MEnKTZkxfSqdiHo/meTlMRd9885vr4P52Fd9Ryxe3yVAKZSP9ZzPmRvCvgF1oGCgobZJ5d7FvTwkGt2t4pjy/RlU6FDcXNMHLk4pfJqr3lnEkAh2MbCGlGo1i6Rc6DtgISuJn2AUkrQKhI6F0U7o9e5qPEOjNkhznMCAwEAAaNaMFgwCQYDVR0TBAIwADALBgNVHQ8EBAMCBaAwHQYDVR0OBBYEFJDgSMx4XrLktYOG827wP7VULTnJMB8GA1UdIwQYMBaAFDAS51akWaJlzxC2x4yP3iAYbqtxMA0GCSqGSIb3DQEBCwUAA4ICAQBxRyfCpL7q2VurGfh9XqaC4GsGp6ut3l/rOEyc6DP148A69DRmZ7saqfZW87DcLkmcynPhyBOxdcGwtwKlR9E/+X923JeL6VPQCTY5WyJKib36vQCnoC4ELTnw1yc51v2j+MaZXjrlzBIcCUocWK14WS4iBycUwLuMszz6rJ8xluuYDKDeNcS/AjQf+yTUfDXjktHLgcE27sSEQUQ+7bpbKHkJ5xBvaupJEPX+ndj7V2eD+/sO03jgnsWVa2nky7yDXX/5KCqzL5kAA1n2t2dWSJXxpac8O2bPyRhk6dUSwzNr+IjCjHqUKIouB0nosi85Q5MaIE0pwOOSggnawpnjmL3qDnsS/n7NUcX/mF4eiNQ8cMJmKIgfS6rntKuQY2zSod+4+G0AFbiihVTnKsRf7CiJa/VniZdaGdbclT8KzRnNKJ1TrPO8rVPjg+SpvqTq75xynS08/OXCpoJ3aVeBWZJYJmheHhvJw2RiNW2P2GSIw+m6HIIsthUtvvHqdKpIaThFHAOKmw0LpPO7uGs/z/Q3un7+lqSlW7akUoSCHdiAJ4wWv+qFEgE4mq8bKtHoa9yy6FZBoORbbRTj8WkS+UvCLN5p7kZenmKYnWCzBf02O1ULpMsR5WvKCGCekSwWf3lAF9lYTL12JaFTw9iH1nSkyvcu7AoXlWI50hOhmA== 5.查看有效期当你激活完毕后，GoLand右下角会有个Registration小长条提示框，大致的内容为：You copy is Licensed to XXX意思就会告诉你：兄弟，你已经激活成功了，激活码的许可来源是：XXX。查看有效期的步骤为点击：Help-&gt;About这里可以看到你的GoLand的版本号、许可来源、有效期、以及一些环境服务器激活是没有期限的，即为永久有效 激活码激活的有效期到2089年的 二、有效期激活如果使用有效期出现问题可先加激活群寻求帮助，还可以尝试使用有效期激活！ 1.修改hosts文件将0.0.0.0 account.jetbrains.com和0.0.0.0 www.jetbrains.com添加到hosts文件最后，注意hosts文件无后缀，如果遇到无法修改或权限问题，可以采用覆盖的方法去替换hosts文件修改后请检查hosts文件是否修改，激活码无法激活的原因99.99%是因为hosts没有修改正确Windows系统hosts文件路径为：c:\windows\system32\drivers\etcLinux系统hosts文件路径为：/etc 2.复制激活码打开PyCharm选择Activation code激活，然后复制下面的激活码点击激活。此激活码有效期为2020-03-11，大家可以关注微信公众号：裸睡的猪 或扫描下方二维码，在过期之前我会在公众号中推送新的激活码哦 156ZS5PQ1RF-eyJsaWNlbnNlSWQiOiI1NlpTNVBRMVJGIiwibGljZW5zZWVOYW1lIjoi5q2j54mI5o6I5p2DIC4iLCJhc3NpZ25lZU5hbWUiOiIiLCJhc3NpZ25lZUVtYWlsIjoiIiwibGljZW5zZVJlc3RyaWN0aW9uIjoiRm9yIGVkdWNhdGlvbmFsIHVzZSBvbmx5IiwiY2hlY2tDb25jdXJyZW50VXNlIjpmYWxzZSwicHJvZHVjdHMiOlt7ImNvZGUiOiJJSSIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9LHsiY29kZSI6IkFDIiwicGFpZFVwVG8iOiIyMDIwLTAzLTEwIn0seyJjb2RlIjoiRFBOIiwicGFpZFVwVG8iOiIyMDIwLTAzLTEwIn0seyJjb2RlIjoiUFMiLCJwYWlkVXBUbyI6IjIwMjAtMDMtMTAifSx7ImNvZGUiOiJHTyIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9LHsiY29kZSI6IkRNIiwicGFpZFVwVG8iOiIyMDIwLTAzLTEwIn0seyJjb2RlIjoiQ0wiLCJwYWlkVXBUbyI6IjIwMjAtMDMtMTAifSx7ImNvZGUiOiJSUzAiLCJwYWlkVXBUbyI6IjIwMjAtMDMtMTAifSx7ImNvZGUiOiJSQyIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9LHsiY29kZSI6IlJEIiwicGFpZFVwVG8iOiIyMDIwLTAzLTEwIn0seyJjb2RlIjoiUEMiLCJwYWlkVXBUbyI6IjIwMjAtMDMtMTAifSx7ImNvZGUiOiJSTSIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9LHsiY29kZSI6IldTIiwicGFpZFVwVG8iOiIyMDIwLTAzLTEwIn0seyJjb2RlIjoiREIiLCJwYWlkVXBUbyI6IjIwMjAtMDMtMTAifSx7ImNvZGUiOiJEQyIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9LHsiY29kZSI6IlJTVSIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9XSwiaGFzaCI6IjEyMjkxNDk4LzAiLCJncmFjZVBlcmlvZERheXMiOjAsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-SYSsDcgL1WJmHnsiGaHUWbaZLPIe2oI3QiIneDtaIbh/SZOqu63G7RGudSjf3ssPb1zxroMti/bK9II1ugHz/nTjw31Uah7D0HqeaCO7Zc0q9BeHysiWmBZ+8bABs5vr25GgIa5pO7CJhL7RitXQbWpAajrMBAeZ2En3wCgNwT6D6hNmiMlhXsWgwkw2OKnyHZ2dl8yEL+oV5SW14t7bdjYGKQrYjSd4+2zc4FnaX88yLnGNO9B3U6G+BuM37pxS5MjHrkHqMTK8W3I66mIj6IB6dYXD5nvKKO1OZREBAr6LV0BqRYSbuJKFhZ8nd6YDG20GvW6leimv0rHVBFmA0w==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQAF8uc+YJOHHwOFcPzmbjcxNDuGoOUIP+2h1R75Lecswb7ru2LWWSUMtXVKQzChLNPn/72W0k+oI056tgiwuG7M49LXp4zQVlQnFmWU1wwGvVhq5R63Rpjx1zjGUhcXgayu7+9zMUW596Lbomsg8qVve6euqsrFicYkIIuUu4zYPndJwfe0YkS5nY72SHnNdbPhEnN8wcB2Kz+OIG0lih3yz5EqFhld03bGp222ZQCIghCTVL6QBNadGsiN/lWLl4JdR3lJkZzlpFdiHijoVRdWeSWqM4y0t23c92HXKrgppoSV18XMxrWVdoSM3nuMHwxGhFyde05OdDtLpCv+jlWf5REAHHA201pAU6bJSZINyHDUTB+Beo28rRXSwSh3OUIvYwKNVeoBY+KwOJ7WnuTCUq1meE6GkKc4D/cXmgpOyW/1SmBz3XjVIi/zprZ0zf3qH5mkphtg6ksjKgKjmx1cXfZAAX6wcDBNaCL+Ortep1Dh8xDUbqbBVNBL4jbiL3i3xsfNiyJgaZ5sX7i8tmStEpLbPwvHcByuf59qJhV/bZOl8KqJBETCDJcY6O2aqhTUy+9x93ThKs1GKrRPePrWPluud7ttlgtRveit/pcBrnQcXOl1rHq7ByB8CFAxNotRUYL9IF5n3wJOgkPojMy6jetQA5Ogc8Sm7RG6vg1yow== 转自：https://www.cnblogs.com/pig66/p/10420947.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[promise源码]]></title>
    <url>%2F2019%2F06%2F19%2Fyuque%2Fpromise%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[了解Promise诞生的历史背景学会使用Promise解决异步回调带来的问题掌握Promise的进阶用法 异步操作的常见语法1234567document.getElementById('start').addEventListener('click',start,false);function start()&#123; //响应事件，进行响应的操作&#125;$('#start').on('click',start); 有了Node.js之后对异步的依赖进一步加剧了……无阻塞高并发 Promise详解123456789101112new Promise( //执行器 executor function(resolve,reject)&#123; // 一段耗时很长的异步操作 resolve();// 数据处理完成 reject();// 数据处理出错 &#125;).then(function A()&#123; //成功，下一步&#125;,function B()&#123; //失败，做相应处理&#125;) Promise实例一经创建，执行器立即执行 简单实例12345678console.log("here we go"); new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve("hello"); &#125;, 2000); &#125;).then(value =&gt; &#123; console.log(`$&#123;value&#125; world`); &#125;); 两步执行的范例1234567891011121314151617181920console.log("here we go"); new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve("hello"); &#125;, 2000); &#125;) .then(value =&gt; &#123; console.log(value); return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve("nihao"); &#125;, 1000); &#125;); &#125;) .then(value =&gt; &#123; console.log(`$&#123;value&#125; world`); &#125;);here we gohellonihao world 对已完成的Promise执行then123456789101112131415161718console.log("start");let promise = new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log("the promise fulfilled"); resolve("hello,world"); &#125;, 1000);&#125;);setTimeout(() =&gt; &#123; promise.then(value =&gt; &#123; console.log("value:", value); &#125;);&#125;, 0);startthe promise fulfilledvalue: hello,world 不管promise前面的状态是否完成，都会按它的队列去执行 then里不返回Promise1234567891011121314151617181920212223242526272829303132console.log("start");let promise = new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log("the promise fulfilled"); resolve("hello,world"); &#125;, 2000);&#125;) .then(value =&gt; &#123; console.log(value); console.log("everyone"); (function() &#123; console.log("比包"); return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log("Mr Lanrence"); resolve("Merry Xmas"); &#125;, 0); &#125;); &#125;)(); return false; &#125;) .then(value =&gt; &#123; console.log(value + " world"); &#125;);startthe promise fulfilledhello,worldeveryone比包false worldMr Lanrence 引出.then() .then()接受两个函数作为参数，分别代表fulfilled和rejected .then()返回一个新的Promise实例，所以它可以链式调用 当前面的Promise状态改变时，.then()根据其最终状态，选择特定的状态响应函数执行 状态响应函数可以返回新的Promise，或其他值 如果返回新的Promise,那么下一级.then()会在新Promise状态改变后执行 如果返回其它任何值，则会立刻执行下一级.then() .then()里有.then()的情况 因为.then()返回的还是Promise实例。 会等里面的.then()执行完，再执行外面的。 对于我们来说，此时最好将其展开，会更好读。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374console.log("start");let promise = new Promise(resolve =&gt; &#123; console.log("step1"); setTimeout(() =&gt; &#123; resolve("100"); &#125;, 1000);&#125;) .then(value =&gt; &#123; return new Promise(resolve =&gt; &#123; console.log("Step 1-1"); setTimeout(() =&gt; &#123; resolve(110); &#125;, 1000); &#125;) .then(value =&gt; &#123; console.log("Step 1-2"); return value; &#125;) .then(value =&gt; &#123; console.log("Step 1-3"); return value; &#125;); &#125;) .then(value =&gt; &#123; console.log(value); console.log("Step 2"); &#125;);startstep1Step 1-1Step 1-2Step 1-3110Step 2一样的效果可以这样改console.log("start");let promise = new Promise(resolve =&gt; &#123; console.log("step1"); setTimeout(() =&gt; &#123; resolve("100"); &#125;, 1000);&#125;) .then(value =&gt; &#123; return new Promise(resolve =&gt; &#123; console.log("Step 1-1"); setTimeout(() =&gt; &#123; resolve(110); &#125;, 1000); &#125;); &#125;) .then(value =&gt; &#123; console.log("Step 1-2"); return value; &#125;) .then(value =&gt; &#123; console.log("Step 1-3"); return value; &#125;) .then(value =&gt; &#123; console.log(value); console.log("Step 2"); &#125;);startstep1Step 1-1Step 1-2Step 1-3110Step 2 问题：下面的四种Promise的区别是什么 问题一 问题二 问题三（比较有欺骗性）doSomethingElse()也是一个promise 问题四 错误处理123456789101112console.log("start");new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; throw new Error("bye"); &#125;, 2000);&#125;) .then(value =&gt; &#123; console.log(value + " world"); &#125;) .then(error =&gt; &#123; console.log("Error: ", error, error.message); &#125;); 错误处理的两种做法： reject(‘错误信息’).then(null,message=&gt;{}) 123456789101112131415161718192021222324252627282930console.log("start");new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject("bye bye"); &#125;, 2000);&#125;).then( value =&gt; &#123; console.log(value + " world"); &#125;, value =&gt; &#123; console.log("Error: ", value); &#125;);一样的console.log("start");new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; // reject("bye bye"); throw new Error("bye bye"); &#125;, 2000);&#125;).then( value =&gt; &#123; console.log(value + " world"); &#125;, value =&gt; &#123; console.log("Error: ", value); &#125;); throw new Error(‘错误信息’).catch(message=&gt;{}) 123456789101112console.log("start");new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; throw new Error("bye"); &#125;, 2000);&#125;) .then(value =&gt; &#123; console.log(value + " world"); &#125;) .then(error =&gt; &#123; console.log("Error: ", error, error.message); &#125;); 推荐使用第二种，更加清晰好读，并且可以捕获前面的错误 强烈建议在所有队列最后都加上.catch(),以避免漏掉错误处理造成意想不到的问题 Promise.all 当所有子Promise都完成，该Promise完成，返回值是全部值的数组 有任何一个失败，该Promise失败，返回值是第一个失败的子Promise的结果与.map连用、实现队列]]></content>
  </entry>
  <entry>
    <title><![CDATA[程序员都在 GitHub 上开源过哪些高颜值的 Markdown 客户端]]></title>
    <url>%2F2019%2F06%2F19%2Fyuque%2F%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E5%9C%A8%20GitHub%20%E4%B8%8A%E5%BC%80%E6%BA%90%E8%BF%87%E5%93%AA%E4%BA%9B%E9%AB%98%E9%A2%9C%E5%80%BC%E7%9A%84%20Markdown%20%E5%AE%A2%E6%88%B7%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[2004 年，来自美国宾夕凡尼亚州的作家 John Gruber 发明了 Markdown，让人们可以通过更加易读易写的纯文本格式来进行写作，并可以很方便的转为 HTML 或 XHTML 等文档。Markdown 自推出之后受到了许多程序员的追捧，目前基本所有主流技术社区都支持使用 Markdown 来进行创作。在 GitHub 上，也诞生了许多优秀的 Markdown 客户端，我看了二十多个项目，简单筛选过滤后，最终挑选了这 5 个高颜值、用户体验佳的 Markdown 编辑器分享给你。 Pine 优雅清新的编辑器适用平台：macOS这是一款基于 Swift 4.2 编写的 Markdown 编辑器，拥有主题定制、LaTeX 编写、自动补全、自动保存、版本控制、Touch Bar 支持等功能。lukakerr/Pine暗黑模式的主题看着特别酷炫： 通过其设置界面，你可以很方便的挑选自己喜欢的文本字体，界面主题： 目前还有以下几项特性仍在开发中，感兴趣的同学可以保持关注： 支持编辑 CSS 文件来定制 Markdown 预览效果 优化侧边栏 文件夹监听同步 上下文菜单中加入更多操作Gridea 无缝对接静态博客的编辑器适用平台：macOS、Windows这个是最近刚在微博上推荐的一个项目，作者将其产品定位为一个静态的博客写作客户端，也即是说，你可以在客户端上面写作，然后顺便将文章发布到静态博客上。getgridea/gridea 相对于其它普通的 Markdown 编辑器，它有着以下特色： 对接了 GitHub、Coding Pages 的托管服务 内置 Gitalk 和 DisqusJS 两个评论系统 支持使用 OneDrive、Dropbox 等工具进行文章同步 支持外链的封面图 从上面列举出来的几项特性可以看到，Gridea 相对于普通的 Markdown 编辑器更加强大，如果你希望写作编辑与文章同步能无缝进行，不妨试下这个编辑器。另外作者还表示，Linux 版本正在开发中，你可以保持持续关注。 Notable 无限标签编辑器适用平台：macOS、Windows、Linux这是一款基于 AGPL 协议开源的 Markdown 编辑器，由于其界面清新、代码开源而受到不少程序员喜爱。notable/notable 主要有着以下几项基础功能： 无限标签嵌套 可导入印象笔记 文章分类 模糊搜索 语法高亮 多文章编辑 多文章搜索替换 支持主流桌面平台 之前我曾写过一篇完整文章介绍了该项目，在此便不多做赘述，感兴趣的同学可看下下面这篇文章。分享一款高颜值的、代码完全开源的 Markdown 编辑器 Mark Text 多模式形态编辑器适用平台：macOS、Windows、Linux这是一款基于 MIT 协议开源的 Markdown 编辑器，支持 WYSIWYG（所见即所得）的编辑方式，致力于给你提供一个专注的写作环境。marktext/marktext 该编辑器还内置了插件功能，你可以为其添加 KaTeX 数学公式、emoji 表情等插件扩展。在你编写完成后，还可以很方便的将 Markdown 导出为 HTML 或 PDF 文件。支持的主题也非常丰富多样： 最值得一提的是，该编辑器提供了源码模式、打字机模式、专注模式等 3 种写作模式。源代码模式： 专注模式： 你可以根据自己需求来选择合适的写作模式。 MacDown 资深老牌编辑器支持平台：macOS作为一款老牌的 Markdown 编辑器，相信很多人都听过 MacDown，该编辑器的灵感来源于另一款 Markdown 编辑器 - Mou。这款编辑器相对来说年代较为久远，但也比较稳定，如果你对稳定性的追求比较高，可以体验下这块编辑器。MacDownApp/macdown 我用哪款编辑器？除了 GitHub 上一些开源的 Markdown 编辑器之外，还有一些免费但不开源的编辑器，个人常用的一款是 Typora。现在你正在查看的这篇文章，就是在 Typora 上完成排版编辑的。我比较喜欢它的原因是因为他可以自定义主题样式，编辑所见即所得，用完即走，方便快捷。对代码开源没啥要求的同学也可以体验下。a markdown editor, markdown reader. 你平时主要用哪款 Markdown 编辑器呢？欢迎在评论区留言与我们分享。 推荐阅读：华山论剑，谈谈 GitHub 上那几个开源的前端编辑器完美融合 Git 的笔记软件，了解一下？如何知道你的个人隐私是否被泄露？ 转自：https://zhuanlan.zhihu.com/p/62776921]]></content>
  </entry>
  <entry>
    <title><![CDATA[那些让人用上就戒不掉的Chrome扩展]]></title>
    <url>%2F2019%2F06%2F19%2Fyuque%2F%E9%82%A3%E4%BA%9B%E8%AE%A9%E4%BA%BA%E7%94%A8%E4%B8%8A%E5%B0%B1%E6%88%92%E4%B8%8D%E6%8E%89%E7%9A%84Chrome%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[Chrome虽然已成为国内常用浏览器之一，但像父母、长辈、女朋友等这类小白用户还是不少。所以，今天我们就来盘点一下Chrome商店里那些让人用上就戒不掉的扩展，大部分都是新手小白也能够一秒上手的工具。虽然是入门级扩展，但用户基数都高达数十万甚至百万，它们的功能极其丰富，能大幅提升上网体验，往往会让小白用户初尝便上瘾，从此再也离不开…… 1. 入门新标签页——Infinity ProInfinity新标签页算是早被业内夸过无数次的国产插件了，分为基础版和Pro版，两个版本的下载量都很高。这是一款百万用户选择的新标签页，能够自由添加网站图标，还有丰富的云端高清壁纸，支持快速访问书签、天气、笔记、待办事项、扩展管理与历史记录等（据了解开发者已申请专利）。Infinity的壁纸是真的非常好看了，右键空白处就能直接下载下来。并且，Infinity Pro版在今年又新增了文件夹功能，一个新标签页能容纳更多的常用网站，并由此实现了分类功能。开发者处理反馈的速度也很快，两个版本这么多年都保持完全免费，非常良心了，是新手和老用户都喜爱并推崇的Chrome工具之一。 2. 广告屏蔽——Adblock、Adblock Plus屏蔽广告的插件无疑是受用面最广的，因为它对于所有使用者来说，用户体验的提升是最大的。毕竟在此之前，大家都饱受各个网站的侧边广告和弹出窗口的困扰，开启广告屏蔽后清静多了。Adblock和Adblock Plus在Chrome商店里都没有太大争议，二者选一就足够了。 3. 视频广告屏蔽——广告终结者如今各个视频网站的广告都越来越丧心病狂，动辄90秒的长度简直让人生无可恋。广告终结者不仅能清除网页上浮动广告，恶意弹窗等，还能屏蔽视频广告。因为是国产的扩展，所以在国内大部分视频平台上都能使用。 4. 鼠标悬停预览图片——Imagus将鼠标悬停在链接或缩略图上，就能够直接在当前页面弹出高清大图、HTML5 视频/音频等内容。对于微博、淘宝等用户来说，在浏览多图和图片版的长微博时，Imagus是非常方便的。 5.图片批量下载——Image Downloader快速识别当前网页上的所有图片，支持一键批量下载，并且能够根据像素、尺寸等筛选图片范围。 6.视频下载插件——Video Downloader professional视频下载是很多人的需求，而在大部分视频网站上，要做到这一点都必须经历一个繁琐的过程，比如下载客户端等等。Video Downloader professional则可以直接检测页面中的所有视频文件，并提供一键下载，对新手来说也非常友好。 7.浏览器清理大师——Clean Master一键清理浏览器缓存和垃圾、保护隐私，使浏览器更快更高效，支持按时间段清理：- 清理浏览器缓存，cookies，网站存储和其他垃圾。- 清理密码，使网站不会自动登录用户的个人帐户。- 清理浏览器历史记录，其他人永远不会知道用户的浏览过的网站。- 清理所有个人信息，用户的隐私将受到保护。 无法访问chrome应用商店的朋友，可在扩展迷网站下载安装。Download Chrome Extensions From Here!extfans.com 转自：https://zhuanlan.zhihu.com/p/47642312]]></content>
  </entry>
  <entry>
    <title><![CDATA[这 10 款堪称神器的插件，让你的 Chrome 成为最好用的浏览器]]></title>
    <url>%2F2019%2F06%2F19%2Fyuque%2F%E8%BF%99%2010%20%E6%AC%BE%E5%A0%AA%E7%A7%B0%E7%A5%9E%E5%99%A8%E7%9A%84%E6%8F%92%E4%BB%B6%EF%BC%8C%E8%AE%A9%E4%BD%A0%E7%9A%84%20Chrome%20%E6%88%90%E4%B8%BA%E6%9C%80%E5%A5%BD%E7%94%A8%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%2F</url>
    <content type="text"><![CDATA[距离我 上次 推荐 Chrome 扩展已经过去了近 4 个月时间，Chrome 应用商店里又涌现出了一大批颇有潜力的实力选手。本文我将介绍 10 款近期上架的 Chrome 新扩展，从标签页到网站内容抓取再到隐私保护，它们总有一款能满足你的口味。 QlearlyQlearly 是一款有些特殊的 Chrome 新标签页扩展，你可以用它一键保存当前打开的标签页，将自己的收藏夹、喜欢的网站、暂存备用的标签页等分组收纳，并在需要时快速开启。此外，你还可以与他人协作，并分享自己的标签页组，提高自己的工作效率。你可以在 Chrome 网上应用店 免费获取 Qlearly。 Spider工作中，你可能会有批量抓取网站内容的需求：淘宝上的商品介绍、网站上的新闻标题、表格中的行列数据……如果只是单纯的复制粘贴，之后还要费心整理，想要写个爬虫又考验编程水平。这时，不妨试试 Spider，它可以一键抓取网页上的结构化数据，并导出为 JSON 和 CSV 文件，轻松高效。你可以在 Chrome 网上应用店 免费获取 Spider。 Repl.itRepl.it 是一款允许你浏览器上编程的云端 IDE，支持编译并运行包括 C、Python、JavaScript、Ruby 等在内的超过 50 种语言，无需下载，即开即用。而其第三方 Chrome 扩展，则给任意网页中的代码片段增加了一键运行按钮，省去复制到本地编译的流程。你可以在 Chrome 网上应用店 免费获取 Repl.it。 Password Checkup不论你是自己发明了一套密码策略，还是用 1Password 等应用随机生成密码，都无法避免网站后台被拖库造成的安全隐患。为了最大限度地减少这一风险，Google 于近期推出了 Password Checkup 扩展，当检测到你正在使用的用户名和密码存在于 40 亿条泄露数据库内时，自动弹出提醒，保护个人隐私。你可以在 Chrome 网上应用店 免费获取 Password Checkup。 Web Activities时间线是 Windows 10 春季创意者更新带来的最重要变化之一，允许你在一处查看所有历史活动记录，如浏览器访问过的网页、使用过的文件等。而微软近期推出的 Web Activities 扩展将这一特性带到了 Chrome，并支持多设备同步浏览记录，体验近似原生。你可以在 Chrome 网上应用店 免费获取 Web Activities。 划词小窗搜索划词翻译扩展我们见得多了，例如我此前推荐过的 沙拉查词 和 达达划词翻译 都可以在选中单词后通过悬浮小窗查询释义。而划词小窗搜索的泛用性更广一些，可以调用 Google、百度或 Bing 通过小窗搜索选中的文本，无需离开当前页面。你可以在 Chrome 网上应用店 和 GitHub 免费获取划词小窗搜索。 Simplify Gmail为了完成 KPI，Google 大刀部把广受欢迎的 Inbox 砍掉了，如果你曾是 Inbox 忠实用户，可能会对陈旧的 Gmail 界面感到不适应。为了拯救你的收件箱，前 Inbox 设计师 Michael Leggett 开发了 Simplify Gmail 扩展，重新设计了按钮和元素的摆放位置，隐藏了侧边栏，让界面更加清爽干净。你可以在 Chrome 网上应用店 免费获取 Simplify Gmail。 Google Results Previewer使用 Google 搜索时，你可能需要同时浏览对比多个结果。这时，按首页排序一路点下去就未免过于低效。而 Google Results Previewer 就可以在当前页面小窗加载鼠标悬停的链接，并支持进一步交互，提高信息检索效率。需要注意的是，由于 Google Results Previewer 无法运行 JavaScript，部分网站可能会出现加载异常或失败等情况，仍待改进。你可以在 Chrome 网上应用店 免费获取 Google Results Previewer。 NoScriptNoScript 是 Firefox 上知名的隐私保护扩展，近期移植到了 Chrome 上，作用是禁止加载 JavaScript、Flash、Silverlight 等可能收集你个人信息的脚本，让你的浏览更加安全。不过，由于 JavaScript 已然成为了网页标配，禁用后会导致大多数网站无法正常访问，需要一段时间的白名单调教后才能正常使用。你可以在 Chrome 网上应用店 免费获取 NoScript。 简易扩展简易扩展的名字相当实诚，但功能性却毫不逊色。它可以帮助你快速切换用户代理、管理多个 Cookies、监听网络请求、改写静态和动态网址等，可谓前端开发者必备。你可以在 Chrome 网上应用店 免费获取简易扩展。关联阅读：读文章、剪藏网页、新标签页增强…… 这 10 个扩展让你的 Chrome 更好用 转自：https://zhuanlan.zhihu.com/p/65606735]]></content>
  </entry>
  <entry>
    <title><![CDATA[推荐几个超好用的Chrome插件]]></title>
    <url>%2F2019%2F06%2F19%2Fyuque%2F%E6%8E%A8%E8%8D%90%E5%87%A0%E4%B8%AA%E8%B6%85%E5%A5%BD%E7%94%A8%E7%9A%84Chrome%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[远方 New Tab每天打开新页面都是一段不期而遇的旅行简单的说，每次打开一个新的标签页，都会有一张看了心情很好的风景图~ uBlock Origin比较好用的清除广告的插件，图标也很可爱记得要下origin版本哦另外一个同名的是商业公司版本，害怕会加什么蜜汁优化来看一下效果，对付广告贼多的csdn The Great Suspender自动休眠你不用的标签页，节省内存再也不用怕浏览器后台偷偷挖矿了 ~ 其实是因为实习生配的mac只有4g内存，才发现了这个插件。不过chrome每个标签页一个进程，的确很很吃内存 有道网页翻译可以根据英语水平来动态调节翻译的程度哦比如可以这样： 下面推荐点开发中常用的插件 json-viewer自动格式化显示服务器返回的json串比如豆瓣电影Top250返回的是这样的：格式化之后是这样的！ Set Character Encoding快速设置网页的编码写爬虫的时候猜不透编码？自己试一下吧，所见即所得 octotreeGitHub看代码利器！可以直接看到代码的目录结构 Vimium像vim一样操控chrome什么？你想不用鼠标浏览网页？ 满足你j k 上下滑动f 定位网页链接vim 党会感动死的吧 就先推荐这么多大家有什么好用的插件也别藏着掖着分享出出来呀~]]></content>
  </entry>
  <entry>
    <title><![CDATA[11款插件让你的Chrome成为全世界最好用的浏览器！｜ Chrome插件推荐～]]></title>
    <url>%2F2019%2F06%2F19%2Fyuque%2F11%E6%AC%BE%E6%8F%92%E4%BB%B6%E8%AE%A9%E4%BD%A0%E7%9A%84Chrome%E6%88%90%E4%B8%BA%E5%85%A8%E4%B8%96%E7%95%8C%E6%9C%80%E5%A5%BD%E7%94%A8%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%81%EF%BD%9C%20Chrome%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90%EF%BD%9E%2F</url>
    <content type="text"><![CDATA[Chrome可以说是全世界最受欢迎的浏览器了，其快速、稳定的性能，简洁的设计以及多平台同步的功能都深受用户的推崇，然而很多人成为他的忠粉还是因为它强大的拓展性！在发现了这些功能实用又不太占地的小插件之后，简直要感叹：“原来这才是Chrome的正确打开方式啊！”用对了插件，工作效率真的是蹭蹭蹭往上飙啊！下面就为大家推荐这段时间我发现的比较优质的Chrome小插件，目前一共有11款，都可以在［Chrome网上应用店］下载，当然辣，只有科学上网才能访问哦～ 照顾以前没有使用过Chrome浏览器的朋友，先说一下［Chrome网上应用店］简单来说［Chrome网上应用店］可以让你通过使用应用、扩展程序和主题背景来自定义你的Chrome，打开Chrome点击“应用”即可进入：&gt; 在搜索框中输入关键字即可找到所需的应用或者拓展程序，也可以浏览经过分类和整理的合集发现新的内容：&gt; 此外，&gt; Chrome还支持多设备同步。登录到 Chrome 后，您可以从多台计算机访问自己的应用，而无需再在自己的所有计算机上记住软件密钥或重新安装软件。Chrome上有很多优质的应用，我也还在探索中，这一次先为大家推荐小插件，点赞多的话马上来更新应用篇哦～ 1、Infinity ／ Momentum ／ Google Art Project——定义你的新标签页自定义的第一步当然是选择自定义你的新标签页，这三款插件都是用来重新定义你的新标签页的。之所以推荐三款，是因为我觉得三款真的都很棒啊，我自己使用的是第一款“Infinity ”，比较符合我的使用习惯，将三款都介绍给大家，大家可以按自己的喜好来选择：没有使用插件之前，我们打开新的标签页（BTW，打开新标签页的快捷键是command＋T），显示的界面是这样的：这个界面是比较简洁，但是对于我们快速进入工作界面或某个网页其实不是很方便，这时候我们就需要小插件啦～ 1.1 Infinity在Chrome网上应用店中搜索Infinity ，然后将它添加到Chrome：成功添加之后，当你再打开新标签页，它就变成了这样，背景壁纸可以随意更换，点击右下角的小风车就可以了，你也可以上传自己喜欢的图片：还可以点击右上角的红色＋号按钮，添加更多你需要的网址到界面：喜欢 Infinity 是因为它比较接近我的使用习惯，点击图标就可以进入目标网页，还可以方便地查看历史记录、添加待办事项、获得天气情况等等。你还可以在添加更多常用网页到界面，Infinity 将一些比较主流的网站都收录在分类里面，方便你添加。此外，** Infinity 还有一个非常方便的功能，就是管理你的Chrome上的应用和插件！是的，用插件管理插件，因为Chrome上的插件五花八门，经常不注意就下了一大推，当然我们可以通过Chrome来管理，但比较不方便，使用 Infinity 的话，我们只需要点击界面上的“应用”图标，就可以轻松管理啦。Chrome上也有专门用来管理应用和插件的插件，但我觉得既然 Infinity 就能够实现的话，就不要再下其它的啦，过多的插件还是会影响浏览器的速度的。** 1.2 Momentum相比 Infinity ，Momentum的设计更加简洁，个人觉得背景图比 Infinity 的更好看一些，四个角分别有不同的功能，但缺点是不能直接进入目标页面，放张图大家自行感受一下： 1.3 Google Art Project除了以上两款比较常见的新标签页插件，还要向喜欢艺术的朋友推荐 Google Art Project，这是Google的一个文化艺术项目，希望探索世界各地的精彩故事和馆藏，将经典和精品展示给更多的人，附上这个计划的网址，没事上去看看艺术品也很赏心悦目：https://www.google.com/culturalinstitute/beta/同样还是在Chrome应用商店搜索 “Google Art Project” 然后添加，之后你的新标签页就会变成这样啦：背景每天都会更新，这样你就可以在浏览器标签页中欣赏 Google Cultural Institute 中的艺术计划精彩作品啦，点击还可以查看更多关于画作的信息。而右下角的按钮可以让你留言一些常用网址。 2、下载管理器——管理你的下载我们从网站上下载文件时，一般来说比较倾向于可以方便地看到下载进度和结果，Safari这一点上就比较好：不过在Chrome中，我们也可以通过安装插件来实现。搜索添加“下载管理器”，在插件栏就可以看到啦：3、Adblock Plus——无用广告拦截这款插件基本上是必备啦，评价比较高，用户非常多，我个人使用体验也还是很好的，安装之后基本上屏蔽了大部分垃圾广告，节约了时间也帮助你在浏览网页时集中注意力在目标内容上。 4、OneTab——管理你打开的网页我们平时在查阅资料或者工作的时候，常常不自觉就打开了一堆网站，当你想快速地点击到你的目标网站时，会发现十分不便，而且会把眼睛搞得很累，就像下图：OneTab 就是为解决这个问题诞生的，搜索添加它之后，点击插件栏中的 OneTab 图标，这些打开的网页就被全部集合到一起啦：OneTab 还有历史纪录，方便你浏览过去时间打开的网页，因此使用它除了管理你打开的网页之外，也比较不担心会丢失有用的网页。 5、右键搜——拓展你的右键非常喜欢的一款插件，添加之后，当我们点击右键就可以看到它啦。用它选中网页上的图片，就可以用 Google 或者 百度搜索这张图片，知道图片的更多信息以及跟它相近的其它图片。而当我们选中网页上的文字的时候，我们可以方便地利用 “右键搜”翻译文字，并且可以将生成二维码！从此用二维码来表个白简直是小意思了～ 6、Awesome screenshot——注释&amp;录屏主要功能有两个，一是录屏&gt; 二是捕获整个页面或任何部分，然后对捕获的图片进行注释，可以添加矩形，圆形，箭头，线条和文字，模糊敏感信息等。 作为一款小插件来说，我觉得它已经挺厉害了，有很多朋友说，Mac自带的录屏软件还有快捷键截图也已经很方便了，但我个人觉得插件的操作路径更短些，效率不就是这么一点点提高的吗？ 7、Imagus——悬停放大图片鼠标指针悬停在链接或缩略图上时直接在当前页面的弹出视图上显示这些图片、HTML5 视频/音频和内容专辑。喜欢淘宝、微博还有各类图片网站的朋友，这个插件绝对会极大提高你们的效率，将光标停放在图片上，图片就会自动放大啦～ 8、Video Downloader professional——自动识别下载资源我们在浏览网页的时候有时候需要把网页上的视频下载下来，而这常常需要借助第三放的下载软件，过程有时候十分复杂而且在电脑上装有些软件也很烦， Video Downloader professional的功能就是帮我们省去这一过程，它会自动检测网页中的所有的视频文件，提供一键下载，简直不要太方便！ 9、新媒体管家——帐号管理&amp;图文编辑顾名思义，新媒体管家的主要功能是管理你的新媒体帐号，目前支持以下平台：使用新媒体管家，可以让你同时管理几个平台的帐号，或一个平台上的多个帐号。添加帐号之后，就可以通过新媒体管家进入相应的帐号了。比如，对于微信公众平台来说，你可以添加多个帐号，并且同时登陆，一天之内只需要扫码登陆一次，便可以直接进入后台。除此之外，对于有写微信推文需要的人，新媒体管家的作用还体现在它可以帮助你完成推文的排版和编辑！以往我们在写推文的时候，可能需要借助135编辑器或者秀米，个人觉得135的板式比较多，秀米的排版比较好，所以有时候需要同时用两个平台才可以完成编辑，而中间可能会出现两个平台格式不通用的情况，非常麻烦。有了新媒体管家之后，通过它打开微信后台，选择新建素材，你会发现编辑页面变成了这样：也就是说，你可以直接在后台选择板式、调整边距、添加emoji；新增的小功能里面，还可以让你去别的地方采集样式，然后运用到你的推文里面；搜图功能帮你省去漫天找图、下载、上传的繁琐步骤。然而我最喜欢它的功能还是“热点中心”，通过它你可以快速地获取当天的热点！目前新媒体管家为用户呈现三个平台（微信热文、头条指数、知乎精选）的热门消息，包括了当日热词。你还可以通过它搜索公众号和文章，获取时间、阅读和点赞数等信息。此外，它还有一些非常实用的功能、比如营销日历，通过它你可以提前做好营销计划的选题和排期等等 10、印象笔记——网页标注和收藏必须推荐的一个插件，以前在Safari中就一直使用的一款小插件，可以快速保存、标注和分享网页上的一切内容，包括网页正文、图片、截屏和整个网页。相信很多人已经在用了，我个人的使用体验还是非常好的，有起是它在保存网页的时候，格式保留得很完整。 11、Google翻译Google翻译做得已经非常不错了，平时翻译文献的时候用Google 翻译基本上可以有7成的正确率，自己再稍作修改就行。Google 翻译的小插件主要是方便我们在浏览网页的时候，随手翻译不认识的字词句。使用的时候只需要选中需要翻译的部分，然后点击插件栏“Google翻译”的小图标就行。 先写到这，觉得有用的话点个赞哦～也欢迎大家留言来推荐你觉得好用的Chrome插件，有新的发现我也会及时更新到文章里面！ 更多精彩也欢迎大家关注微信公众平台 ［麦客范儿］！！！日常为你推荐：Mac／iPhone使用技巧、Mac／iPhone优质软件限免消息、趣味科技短视频～ 转自：https://zhuanlan.zhihu.com/p/27196557]]></content>
  </entry>
  <entry>
    <title><![CDATA[学算法，刷 LeetCode，GitHub 上这几个项目助你一臂之力]]></title>
    <url>%2F2019%2F06%2F19%2Fyuque%2F%E5%AD%A6%E7%AE%97%E6%B3%95%EF%BC%8C%E5%88%B7%20LeetCode%EF%BC%8CGitHub%20%E4%B8%8A%E8%BF%99%E5%87%A0%E4%B8%AA%E9%A1%B9%E7%9B%AE%E5%8A%A9%E4%BD%A0%E4%B8%80%E8%87%82%E4%B9%8B%E5%8A%9B%2F</url>
    <content type="text"><![CDATA[LeetCode 是一个汇集了诸多算法题库的编程网站，许多开发者在初学算法时，都会跑到 LeetCode 网站上面刷题，也有一些开发者为了过微软、Google、Facebook 等国际大企的面试，选择刷 LeetCode 来快速提升自己的编程能力与算法能力，以便顺利通过面试。于是，刷 LeetCode 的做法开始在技术圈传播开来，程序员彼此见面聊天时也会时不时问候几句，”你今天刷 LeetCode 了吗？”。在 GitHub 上，各种语言、不同版本的 LeetCode 题解项目也慢慢多了起来。。。今天，就让我们来简单盘点一下，GitHub 上那几个比较知名的 LeetCode 项目吧。希望对那些打算学习算法，或正在刷 LeetCode 的同学有所帮助。 C++ 题解库该仓库作为 LeetCode 题解库的鼻祖，由左耳朵耗子，也即是同学们常说的耗子叔于 2014 年创建，算是 GitHub 上创建最早的 LeetCode 题解库，同时也是现在 Star 数最高的一个。该项目主要实现了 C++ 的 LeetCode 题解，非常适合广大程序员查看。http://t.cn/R75PA91 Python &amp; Java项目作者 QiYuan Gong 是东南大学的博士生，现为英特尔公司的深度学习工程师，由于受到耗子叔 C++ 题解库的启发，在 GitHub 上创建了这个以 Python 与 Java 为主的题解库。现在身边不少搞算法的朋友，都以 Python 作为首选的编程语言，相信这个库你们一定会喜欢。http://t.cn/EabmDAN Swift 题解库项目作者故胤道长毕业于卡内基梅隆大学，先后就职于 Uber、Amazon 等公司，现在 Quora 担任 iOS 工程师，同时也是 GitHub 全美前 20 名的 Swift 开源作者之一。道长在 2016 年的时候创建了该库，并于微博进行推广后开始广为人知，后续不少开发者加入了项目维护，使得更新也较为频繁。该仓库按照数据结构与公司对 LeetCode 进行了分类，使其目录结构看起来更加清晰。目前收纳的有 Google、Facebook、Snapchat 等多家公司的 LeetCode 题解。http://t.cn/Rg87FJa Go 语言题解库最近国内某个知名企业的代码泄露，为 Go 语言的推广做出了不可磨灭的贡献，因此在这里，也为大家献上一个基于 Go 语言实现的题解库，希望你在阅读某个项目源码的时候，也别忘了多学点算法。http://t.cn/Exg9mPF LeetCode for VS Code 插件我们之前写过一篇文章《装上这几个 VSCode 插件后，上班划水摸鱼不是梦》，里面就推荐过这个 LeetCode 插件。该插件由微软的一名工程师开发，并于今年春节前正式上线，装上之后，就可以在 VSCode 上愉快的刷 LeetCode，在听音乐、看小说等沙雕插件横行的时代，该插件可谓是一股清流，建议当前有在刷 VSCode 的同学装一下。http://t.cn/Rk8r2ao GitHub 上其实还有其它一些 LeetCode 题解库，但由于项目作者许久未更新，给人感觉像是弃坑逃离，所以就不将其纳入到该统计列表中啦。有兴趣的同学可以自己到 GitHub 上翻一下。知乎用户胖君说过，现在刷 LeetCode 的，主要分两个流派，一个是「龟派」，一个是「兔派」。龟派在于把每个题目做得干干净净，滴水不漏，力求把所有解法都试一遍。兔派则是非常暴力的直接硬刷，追求以快制胜，直接上来就看答案，套模板，以解题、找工作作为首要目标，不带一丁点矜持。 你是属于哪一派的呢？欢迎在评论区与我们留言分享 推荐阅读：GitHub 上有哪些项目能帮你更好的学习编程？GitHub 上的这几个项目或许能帮你学好英语 转自：https://zhuanlan.zhihu.com/p/63916811]]></content>
  </entry>
  <entry>
    <title><![CDATA[给大家推荐几个浏览器插件(不用外网也能使用google了)]]></title>
    <url>%2F2019%2F06%2F19%2Fyuque%2F%E7%BB%99%E5%A4%A7%E5%AE%B6%E6%8E%A8%E8%8D%90%E5%87%A0%E4%B8%AA%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6(%E4%B8%8D%E7%94%A8%E5%A4%96%E7%BD%91%E4%B9%9F%E8%83%BD%E4%BD%BF%E7%94%A8google%E4%BA%86)%2F</url>
    <content type="text"><![CDATA[虽然一直知道谷歌浏览器有很多插件，但并不知道还有一些这么好的插件，不知道是不是我太落后了，今天我就给大家介绍几款自己常用的插件。 如果你不知道谷歌浏览器的插件在哪里的话，只需要在谷歌浏览器右上角菜单下选择【更多工具】-【扩展程序】， 然后点击【拓展程序】就可以看到Chrome网上应用商店了 在那里就可以下载各种插件了。（不过没有外网的话是进不来这个应用商店的）。 1.谷歌浏览器必备神器：谷歌访问助手这估计是我最喜欢的一个插件吧，有了这个插件就算没有外网也可以使用谷歌搜索，登录谷歌帐号，使用谷歌翻译，进去谷歌商店等了。 本来那些插件我们都是可以在谷歌插件商店下载的，但此时你不能上外网的话，无法在谷歌商店下载这个插件，我给大家找了一个按照这个插件的教程。谷歌访问助手安装教程：https://jingyan.baidu.com/article/d2b1d102a89a925c7f37d445.html（或者在我的公众号“苦逼的码农”后台直接回复”助手”获取对应的压缩包，里面包含安装方法）按照里面的教程就可以安装谷歌访问助手了，之后的插件就可以直接在谷歌商店那里下载了。不过需要注意的是，谷歌访问助手安装之后，并不可以访问推特等网站平台。 2.去广告插件：广告终结者广告终结者，各种花式广告瞬间完虐，这个神器可以清除几乎所有的网络广告，各种网络站上的广告轻松屏蔽，什么购物广告、浮动广告、视频广告、恶意弹窗、网络跟踪统统眼不见心为净。不过我使用的比较少，不过感觉装了后那些恶心的广告确实少了挺多，我想很多人都讨厌广告，因此介绍给大家。 3.OneTab：将无数Tab合并在一个页面这个插件是用来管理网页的，有时我们会在浏览器中打开了多个页面，会导致电脑变的很卡，这个插件可以帮你暂时把网页挂起，节省95%的内存，想要打开被合并的网页时可以随时恢复。使用之后： 4.必备翻译：Imtranslator网页翻译必备神器，有时阅读英文文档时，经常遇到不认识的单词，选中需要翻译的单词，这个插件可以很方便着帮你翻译出来，而且翻译之后会把对应的中文放在旁边，不怕等下又把单词忘记了，也可以翻译整个网页，不过需要注意的是，翻译是需要电脑可以上外网的，不过假如你按照我上面说的安装了谷歌访问助手，那就可以很方便着翻译了。 5.截图必备神器：FireShot有时想要对网页进行截图时，我是经常用微信带的截图功能的，这种很不方便，经常需要登录微信，而且如果想要截整个网页时也很不方便，这个插件可以帮我们很方便着进行截图，而且还可以存储为PDF等其他格式。 6.公众号必备编辑器：壹伴这个是编辑类插件，主要是针对微信公众号编辑页面的，可以一键排版，我最喜欢这个插件的主要原因是这个插件可以帮我很方便着找到各种封面图，不用自己调尺寸比例等。而且这个插件的一键排版也是挺方便的。 7.必须掌握的编辑语法：Markdown herMarkdown现在是越来越就行了，现在很多网站平台都提供支持Markdown语法来编辑各种文本，强烈建议大家学下用Markdown语法来写文章，不过就算该网站没有提供Markdown编辑器，我们也可以直接用插件Markdown here把我们所写的文本直接Markdown渲染一下，而且我们可以自定义配置自己喜欢的css样式，不想自定义的可以网上搜，一搜一大把，自己复制过来使用。 上面这些插件就是我平时用的插件，感觉还不错，介绍给大家。日后有遇到更好的插件，再来继续介绍…哈哈….]]></content>
  </entry>
  <entry>
    <title><![CDATA[GitHub 上见过哪些奇葩的 Chrome 插件]]></title>
    <url>%2F2019%2F06%2F19%2Fyuque%2FGitHub%20%E4%B8%8A%E8%A7%81%E8%BF%87%E5%93%AA%E4%BA%9B%E5%A5%87%E8%91%A9%E7%9A%84%20Chrome%20%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Google Chrome 作为程序员最常用的一款网页浏览器，凭借其强大的插件系统而广受赞赏，程序员作为上面一批最会折腾的用户，自然也不免俗的会在上面胡乱折腾出一些沙雕插件。而这其中，有不少插件代码还开源并托管到 GitHub 上。今天抽空跟大家分享下，我曾看过的那些比较沙雕的 Chrome 插件。 Flappy Octocat2013 年，一位来自越南的独立游戏开发者发布了一款鸟类飞行游戏，Flappy Bird。之后，在短短数月内，该游戏瞬间火爆各大社交网络，成为 2014 年最受欢迎的手游之一，当时我身边不少朋友的手机上都安装了这款游戏。一款爆品的诞生，往往也伴随着一些赝品的争相模仿。Flappy Octocat，这款以 GitHub 吉祥物章鱼猫为主角所打造的小游戏便是其中之一。 该游戏由电子科技大学的一名学生所研发，通过在 Chrome 上安装这款游戏，你便可以在 GitHub 上的 commit 强愉快的玩耍章鱼猫小游戏。可以说是非常有创意了。https://github.com/chxj1992/flappy-octocat 微信秒变云笔记在上班的时候，如果不好意思打开微信，跟网友吹水聊天怎么办？没关系，装上这款插件，就可以把你电脑上的网页微信伪装成云笔记，让你神不知鬼不觉地上微信了。 伪装到这地步，可以说真的很丧心病狂了。https://github.com/YGYOOO/WeChat-Shelter 一键将 Google 转为百度如果你会用 Google 进行科学上网，而其他人不会，那相信这个声音应该时常会在你耳边响起：“咦？你是怎么能上 Google 的？”时间久了，问得多了，答得烦了，难免耳朵长茧，嘴角生泡。这时，你只需要在你电脑上装上这款插件，扮成不懂科学上网的小白用户，便可以一劳永逸，远离尘世喧嚣了。 希望这款插件能救你于水深火热之中。https://greasyfork.org/zh-CN/scripts/372883 以上，即是本次分享。不多，但有趣。今后分享也是如此，内容贵精不贵多。觉得好玩、有意思的，不妨点个赞，支持一下。推荐阅读：GitHub 项目推荐：俄罗斯小游戏、Markdown 幻灯片、头像生成器、Logo 制作工具、坦克大战]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何以光速查看一行代码的提交记录]]></title>
    <url>%2F2019%2F06%2F18%2Fyuque%2F%E5%A6%82%E4%BD%95%E4%BB%A5%E5%85%89%E9%80%9F%E6%9F%A5%E7%9C%8B%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E7%9A%84%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[❓这行代码谁写的 ？在多人协作的项目中进行开发，总是会遇到这些问题：- 这行代码谁写的？明显是个坑，上线肯定是个故障。- 这行代码谁写的？相当优雅，得学习下。- 这行代码谁写的？看不懂，得咨询下。- 这行代码谁写的？不是我呀，得查一下。好，问题来了，这行代码谁写的？ 怎么查是谁写的？ 💢命令行工具 git blame例如，查询 request.js 第 99 行代码是谁提交的，命令为： 12$ git blame -L 99,99 request.js-&gt; dadd208596 lib/core/app/extend/request.js (fengmk2 2016-07-17 12:48:09 +0800 99) * @member &#123;String&#125; Request#ip 即使把这个命令设置为快捷方式，一行一行的查询也是非常耗费精力的，那么有没有一眼可以看到的方式呢？那就是直接在 GitHub 上查。 😑使用 GitHub 查询直接打开 GitHub 查询 request.js 提交记录，就可以看到了。然而，代码敲的好好的，能不能不切换窗口呢？那就是使用各大 IDE 的插件实现了。 🔥使用 VS Code 查询VS Code 在我的电脑上存在有两个原因：- 写 TypeScript- 使用 Git Blame 插件主要说一下 Git Blame 插件，迄今为止用过的最方便的查询代码提交记录的工具，来张截图感受下：光标在哪行，状态栏就显示该行代码的提交者。如果你使用 VS Code 用户，恭喜你，已经完美解决了本篇文章的问题。如果你喜欢轻量级编辑器，喜欢秒开，喜欢像特斯拉 P100D 一样百公里加速 2.5 秒的感觉，那就接着往下看吧。 🌟使用 Sublime Text 查询好好好，你要的，都给你。安装 Git Blame 插件后，需要在光标所在行启动命令框，输入：”Git Blame”，效果如下：重点到了，身为 VIM 用户，我们的插件呢？ 🚀在 VIM 中使用 git-blame.vim 快速查询我是一只小小鸟，想要飞呀却飞也飞不高我遨游在 GitHub 中，寻找着 VIM 适合的查询插件，tpope/vim-fugitive 太重，没有个轻量的插件么？git-blame.vim 横空出世！先看效果：怎么做到的？只需要同时按 ,s 即可。当然也支持自定义快捷键了。对实现感兴趣，请戳 git-blame.vim 代码仓库 🔧安装最直接的方式： 12cd ~/.vim/bundlegit clone git@github.com:zivyangll/git-blame.vim.git 如果你跟你一样用的是 Vundle： 1Plugin &apos;zivyangll/git-blame.vim&apos; 👏使用在 .vimrc 中设置快捷键“逗号+s“： 1nnoremap &lt;Leader&gt;s :&lt;C-u&gt;call gitblame#echo()&lt;CR&gt; 若未设置 Leader，建议设置为逗号： 12let mapleader = &quot;,&quot; &quot; map leader键设置let g:mapleader = &quot;,&quot; 如果你是 VIM 新手，一键上手没有用过 VIM 没关系，可以参考我的 vim 配置：zivim，一键安装： 1$ curl -k https://raw.githubusercontent.com/zivyll/zivim/master/install.sh 配置文件及其适合新手阅读和学习，截两张图 🔚结束语如果你觉得这个插件对你有帮助，不要吝啬你的 star：zivyangll/git-blame.vim，哈哈😄，也可以在 vim.org 投出你宝贵的一票。使用中有任何问题请提 issue。 转自：https://zhuanlan.zhihu.com/p/37599990]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端规范文档]]></title>
    <url>%2F2019%2F06%2F17%2Fyuque%2F%E5%89%8D%E7%AB%AF%E8%A7%84%E8%8C%83%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[百度：ecomfe/spec · GitHub 腾讯AlloyTeam：Code Guide by @AlloyTeam GitHub：Styleguide · GitHub Airbnb JavaScript 风格指南 项目规范 滴滴出行前端（FE）团队联盟文章集]]></content>
  </entry>
  <entry>
    <title><![CDATA[markdown]]></title>
    <url>%2F2019%2F06%2F14%2Fyuque%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[markdown API 欢迎使用 Cmd Markdown 编辑阅读器 学习网站：https://www.zybuluo.com/mdeditor、[https://markdown-here.com/](https://markdown-here.com/) 安装chrome插件：chrome-extension://elifhakcjgalahccnjkneoccemfahfoa/common/options.html可以编辑markdown我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown： 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持）除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载： Windows/Mac/Linux 全平台客户端 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 新文稿 或者使用快捷键 Ctrl+Alt+N。 什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 1. 制作一份待办事宜 Todo 列表 支持以 PDF 格式导出文稿 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 新增 Todo 列表功能 修复 LaTex 公式渲染问题 新增 LaTex 公式编号功能 2. 书写一个质能守恒公式[1]$$E=mc^2$$ 3. 高亮一段代码[2]123456@requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world' 4. 高效绘制 流程图 5. 高效绘制 序列图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 6. 高效绘制 甘特图12345678910111213title 项目开发流程 section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5d section 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5d section 发布验收 发布: 2d 验收: 3d 7. 绘制表格 项目 价格 数量 计算机 $1600 5 手机 $12 12 管线 $1 234 8. 更详细语法说明 想要查看更详细的语法说明，可以参考我们准备的 [Cmd Markdown 简明语法手册][1]，进阶用户可以参考 [Cmd Markdown 高阶语法手册][2] 了解更多高级功能。 总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。 什么是 Cmd Markdown您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 编辑/发布/阅读 Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。 1. 实时同步预览我们将 Cmd Markdown 的主界面一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！ 2. 编辑工具栏也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 编辑区 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。 3. 编辑模式完全心无旁骛的方式编辑文字：点击 编辑工具栏 最右侧的拉伸按钮或者按下 Ctrl + M，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！ 4. 实时的云端文稿为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 编辑工具栏 的最右侧提示 已保存 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。 5. 离线模式在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。 6. 管理工具栏为了便于管理您的文稿，在 预览区 的顶部放置了如下所示的 管理工具栏：通过管理工具栏可以：发布：将当前的文稿生成固定链接，在网络上发布，分享新建：开始撰写一篇新的文稿删除：删除当前的文稿导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地列表：所有新增和过往的文稿都可以在这里查看、操作模式：切换 普通/Vim/Emacs 编辑模式 7. 阅读工具栏通过 预览区 右上角的 阅读工具栏，可以查看当前文稿的目录并增强阅读体验。工具栏上的五个图标依次为：目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落视图：互换左边编辑区和右边预览区的位置主题：内置了黑白两种模式的主题，试试 黑色主题，超炫！阅读：心无旁骛的阅读模式提供超一流的阅读体验全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境 8. 阅读模式在 阅读工具栏 点击 或者按下 Ctrl+Alt+M 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。 9. 标签、分类和搜索在编辑区任意行首位置输入以下格式的文字可以标签当前文档：标签： 未分类标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示： 10. 文稿发布和分享 在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 (Ctrl+Alt+P) 发布这份文档给好友吧！再一次感谢您花费时间阅读这份欢迎稿，点击 (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！作者 [@ghosert][3]2016 年 07月 07日 123// All the code you will ever needvar hw = "Hello World!"alert(hw); My math is so rusty that I barely remember the quadratic equation:$-b \pm \sqrt{b^2 - 4ac} \over 2a$ 支持 LaTeX 编辑显示支持，例如：$\sum_{i=1}^n a_i=0$， 访问 [MathJax][4] 参考更多使用方法。 ↩︎ 代码高亮功能支持包括 Java, Python, JavaScript 在内的，四十一种主流编程语言。[1]: https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown[2]: https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#cmd-markdown-高阶语法手册[3]: http://weibo.com/ghosert[4]: http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference| Name | Lunch order | Spicy | Owes || —– | ———– | —— | —: || Joan | saag paneer | medium | $11 || Sally | vindaloo | mild | $14 || Erin | lamb madras | HOT | $5 |There are multiple syntax highlighting themes to choose from. Here’s one of them: ↩︎]]></content>
  </entry>
  <entry>
    <title><![CDATA[mermaidjs]]></title>
    <url>%2F2019%2F06%2F14%2Fyuque%2Fmermaidjs%2F</url>
    <content type="text"><![CDATA[mermaidjs]]></content>
  </entry>
  <entry>
    <title><![CDATA[markExample]]></title>
    <url>%2F2019%2F06%2F14%2Fyuque%2FmarkExample%2F</url>
    <content type="text"><![CDATA[https://segmentfault.com/markdown markdown例子Basic writing and formatting syntax 文本 Headers This is an tagThis is an tagThis is an tagInline-style: 12var s = "JavaScript syntax highlighting";alert(s); 12s = "Python syntax highlighting"print s 12No language indicated, so no syntax highlighting. But let&apos;s throw in a &lt;b&gt;tag&lt;/b&gt;. 表情包来自余：https://www.webfx.com/tools/emoji-cheat-sheet/ https://github.com/ikatyang/emoji-cheat-sheet/edit/master/README.md https://help.github.com/en/articles/basic-writing-and-formatting-syntax#using-emoji 1@octocat :+1: This PR looks great - it&apos;s ready to merge! :shipit: | top | :bowtie: | :bowtie: | | :smile: | emoji-cheat-sheetThis cheat sheet is automatically generated from GitHub Emoji API and Emoji Cheat Sheet. Table of Contents People Nature Objects Places Symbols Uncategorized]]></content>
  </entry>
  <entry>
    <title><![CDATA[在 VPS 上部署 Hexo]]></title>
    <url>%2F2019%2F06%2F14%2Fyuque%2F%E5%9C%A8%20VPS%20%E4%B8%8A%E9%83%A8%E7%BD%B2%20Hexo%2F</url>
    <content type="text"><![CDATA[Hexo博客架构 简单地说，在本地用 markdown 写好文章，用 hexo 生成静态的 html 文件并 push 到远程服务器（vps），vps 再通过 git-hooks 同步网站目录。其实这两个是可以合成一个的，不过每次写文章都要 ssh 登录到 vps，体验可能没那么好。 流程大纲 本地 – 环境搭建，安装 Hexo,包括 hexo-cli, Nodejs, git; 本地 – 写文章； 远程 VPS – 环境搭建，包括 Nodejs, git, Nginx 配置和创建 git 用户;使用 git 自动化部署发布博客 使用 Git 自动化部署发布博客 本地 Hexo 安装和配置首先要安装 Nodejs 和 git , mac 系统可用 brew 安装，其它系统自行摸索 1brew install nodejs git 安装 hexo-cli 1npm install -g hexo-cli 找个地方放 Hexo 程序 123mkdir -p ~/Documents/codecd ~/Documents/codehexo init blog 然后安装两个插件，分别是 git 自动部署插件 hexo-deployer-git 和简单的本地web服务器 hexo-server 123cd ~/Documents/code/blognpm install hexo-deployer-git --savenpm install hero-server --save 至此本地环境算搭建好了，下面是写文章 本地 Hexo 发表文章使用命令新建文章 12cd ~/Documents/codehexo new "hello Hexo" 该命令会成一个对应的 .md 文件放置在 sources/_posts 文件夹 1sources/_posts/hello-hexo.md 接下来用你喜欢的编辑器编辑 hello-hexo.md 文件，记得要用 markdown 语法。写好以后， 使用 hexo g 命令将 .md 文件渲染成静态文件 1hexo g 然后启动本地 web 服务器 hexo-server 1hexo server 该命令可简写为 hexo s, 现在可以用浏览器打开 http://localhost:4000 访问博客了。（注：以上本地环境搭建完成可以放在远程服务器 vps 上，当然写文章也得在 vps 上写，传统的做法是像架构图那样分离开。） 远程 VPS 环境搭建同样要安装 Nodejs 和 git，根据自己的系统自行摸索，此步略过Nginx 配置，我用宝塔 linux 面板一键安装，不用手动配置，如果要手动改，参考配置如下（抄来的，仅供参考）： 1234567891011121314151617181920212223242526272829server&#123; listen 80; #listen [::]:80; server_name www.xxb.me xxb.me; index index.html index.htm index.php default.html default.htm default.php; #这里要改成网站的根目录 root /path/to/www; include other.conf; #error_page 404 /404.html; location ~ .*\.(ico|gif|jpg|jpeg|png|bmp|swf)$ &#123; access_log off; expires 1d; &#125; location ~ .*\.(js|css|txt|xml)?$ &#123; access_log off; expires 12h; &#125; location / &#123; try_files $uri $uri/ =404; &#125; access_log /home/wwwlogs/blog.log access;&#125; 未完待续]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo 优化设置]]></title>
    <url>%2F2019%2F06%2F14%2Fyuque%2FHexo%20%E4%BC%98%E5%8C%96%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[hexo官网 修改博客标题简介语言等创建页面 编辑 _config.yml 12345678910# Sitetitle: Xxbsubtitle: Linux,crypto,miningdescription:keywords: Linux,crypto,miningauthor: xxb.melanguage: - zh-CN - zh-TW - en 修改网站 URL 和链接格式编辑 _config.yml 123456# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://www.xxb.meroot: /permalink: :category/:title/permalink_defaults: 创建分类页运行命令新建page页 1hexo new page categories 编辑页面123456789101112---title: 分类date: 2018-04-25 22:34:08type: "categories"------title: 标签date: 2018-04-25 22:34:08type: "tags"--- 实际使用1234567891011121314151617181920212223242526title: hexo 添加标签和分类date: 2018-04-27 23:00:34categories:- hexotags:- linux---layout: phototitle: My Gallerydate: 2019-06-19 15:54:13# tags: [photo, 照片]categories: - hexotags: - linux - React------title: post title with whitespacedate: 2019-06-19 15:39:18tags: [photo, 照片]--- 配置别名其中: 以前的是正式的名称，以后的是访问的路径 12345678910111213# Category &amp; Tagdefault_category: uncategorizedcategory_map: hexo:hexo ubuntu:ubuntu computer vision:computer-visiontag_map: linux:linux ubuntu:ubuntu vim:vim tmux:tmux hexo:hexo yolo:yolo opencv:opencv computer vision:computer-vision 部署生效一定要记得先clean在生成 123$ hexo clean$ hexo g$ hexo d 运行后提示 1INFO Created: ~/Documents/code/blog/source/categories/index.md 找到 index.md 这个文件，为其添加 type 属性 12345---title: tagsdate: 2019-01-30 17:37:12type: "categories"--- 修改主题 _config.yml 文件的menu段落，反注释掉tags那一行 123456789menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 创建标签页方法和创建分类页一样，只是把 categories 改为 tags 创建about页参考创建标签页 添加诗词插件今日诗词 API 根据不同地点、时间、节日、季节、天气、景观、城市、事件进行智能推荐，每次刷新都不同。官网： https://www.jinrishici.com/调用文档： https://www.jinrishici.com/doc/在想放置诗词的地方添加以下代码：（我放在_partials/header/brand.swig） 12&lt;div id="jinrishici-sentence" class="shici"&gt;&lt;/div&gt;&lt;script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"&gt;&lt;/script&gt; 自定义样式，修改主题样式文件source/css/_custom/custom.styl 1.shici &#123;font-size: 15px;text-align: center;font-weight: 300;color: #444;font-style: italic;&#125; 在线演示： www.xxb.me 主题：https://github.com/ppoffice/hexo-theme-icarus 未完待续 …]]></content>
  </entry>
  <entry>
    <title><![CDATA[UI组件库]]></title>
    <url>%2F2019%2F06%2F14%2Fyuque%2FUI%E7%BB%84%E4%BB%B6%E5%BA%93%2F</url>
    <content type="text"><![CDATA[经典模块化前端框架]]></content>
  </entry>
  <entry>
    <title><![CDATA[教程一]]></title>
    <url>%2F2019%2F06%2F14%2Fyuque%2F%E6%95%99%E7%A8%8B%E4%B8%80%2F</url>
    <content type="text"><![CDATA[手摸手教程手摸手，带你用合理的姿势使用 webpack4（上）手摸手，带你用合理的姿势使用 webpack4（下） url-loader vs file-loader 2018-08-13 很多人搞不清楚这两个 loader 是干嘛的？其实 url-loader 就是对 file-loader 的一个拓展。照你设置的文件大小 limit, 将其内联为 base64 或者单独作为文件引入。 将图片文件转换为 base64 编码并载入浏览器能够减少 http 请求数，但是增大了 js 或 html 文件的体积，如果图片在项目中的重用度较高，那么每处引用都会生成 base64 编码，造成了代码的冗余。所以是否需要内联自己需要权衡一下。 file-loader： 可以指定要复制和放置资源文件的位置，以及如何使用版本哈希命名以获得更好的缓存。此外，这意味着 你可以就近管理图片文件，可以使用相对路径而不用担心部署时 URL 的问题。使用正确的配置，webpack 将会在打包输出中自动重写文件路径为正确的 URL。 url-loader： 允许你有条件地将文件转换为内联的 base-64 URL (当文件小于给定的阈值)，这会减少小文件的 HTTP 请求数。如果文件大于该阈值，会自动的交给 file-loader 处理。]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue]]></title>
    <url>%2F2019%2F06%2F14%2Fyuque%2Fvue%2F</url>
    <content type="text"><![CDATA[##Router Linkrouter-link基本每一个人都会用，但有的时候我们需要在点击的时候做一些额外的操作，比如点击的时候先弹出一个确认框，问用户是否需跳转。但发现怎么也禁止不了它的默认时间。查阅文档之后发现它有一个 event参数，默认是click。我们只要将它设空，之后自己来处理跳转的逻辑就可以了。 1234&lt;router-link :to="&#123; name: 'my-favorites' &#125;" :event="''" @click.native.prevent="routeOrLogin(&#123; name: 'my-favorites' &#125;)"&gt; Favorites&lt;/router-link&gt; Dynamic Componentsvue 一个就是 它可以写愉快的写 template 一个类 html 的模板，大多数情况下都非常好用。但在一些复杂场景下，它就显得不太灵活了。 这里举一个例子来说： 12345678910&lt;a v-if="isExternalLink" :href="xxx"&gt; &lt;componentA /&gt; &lt;componentA /&gt; &lt;componentC /&gt;&lt;/a&gt;&lt;router-link v-else :to="xxx"&gt; &lt;componentA /&gt; &lt;componentA /&gt; &lt;componentC /&gt;&lt;/router-link&gt; 这里只是一个最简单一个例子，实际场景中，中间重复的内容可能更多，两者唯一的区别只是外链的时候使用a标签，内部链接使用router-link。但却要写一大串的 if..else很不爽。这里提供一个简单的方法解决这个问题。就是使用动态组件，我们将a标签和router-link分装成一个动态组件，根据传入的 url 是否是外部链接，动态的选择使用什么标签来渲染。 1234567891011121314151617181920212223242526272829303132&lt;!-- Link.vue --&gt;&lt;template&gt; &lt;component v-bind="linkProps(to)"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/component&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: &#123; to: &#123; type: String, required: true &#125; &#125;, methods: &#123; linkProps (url) &#123; if (url.match(/^(http(s)?|ftp):\/\//)) &#123; return &#123; is: 'a', href: url, target: '_blank', rel: 'noopener' &#125; &#125; return &#123; is: 'router-link', to: url &#125; &#125; &#125; &#125;&lt;/script&gt; 这样我们将代码的复杂度都封装在了Link.vue之中，我们在原来文件中只需这样使用： 12345&lt;link :to="xxx"&gt; &lt;componentA /&gt; &lt;componentA /&gt; &lt;componentC /&gt;&lt;/link&gt; 是不是一下子简单了许多，代码的可阅读性也直线上升了。 Fragmentreact 很早就有了 Fragment 但 vue 迟迟还没有支持。]]></content>
  </entry>
  <entry>
    <title><![CDATA[产品]]></title>
    <url>%2F2019%2F06%2F14%2Fyuque%2F%E4%BA%A7%E5%93%81%2F</url>
    <content type="text"><![CDATA[如何理解 DAU 和 MAU 这两个数据？DAU (Daily Active Users) 日活 单日活跃用户数，反应产品短期用户活跃度MAU (Monthly Active Users) 月活 单月活跃用户量，反应产品长期用户活跃度 DAU 的分析价值所在核心用户规模：DAU 指标直接反应了核心用户规模。可以结合其他指标一同分析。 生命周期分析的价值：产品不同阶段，DAU 的数据表现不一样。DAU趋势下滑，那么很可能是老用户流失，产品开始走下坡路。是否要投入运营预算，是否要产品重新战略部署等。 产品黏性：DAU 指标结合留存指标来分析产品的用户粘性。 渠道价值分析：DAU可以间接判断各大渠道对产品的贡献价值。在产品初期投放各大渠道之后，DAU 数据会逐步减少，后期可以有选择的保留用户基数大的渠道运营。 用户流失分析：运营活动结束之后，DAU 数据有大幅减少，则要进行用户流失分析。 DAU 的多维度分析趋势：通过判断 DAU 指标在某一时间段的变化来预测未来的数据表现，一般用趋势图表示。例如，未来一个月的收益表现，可以参考三个月的 DAU，去年同期的数据表现，可以综合评估分析。同比：是将本周期内的数据与历史相同时间点的数据进行比对。例如，今年 N 月与去年 N 月相比。环比：是将本期数据与前期数据进行对比，体现了数据连续性变化的趋势。例如，今年九月同八月、七月的数据进行比对。定基比：数据进行比对才有意义。该分析需要以某个时期为基数，其他各期数据都可以与之对比。基准线是产品发展的里程碑水平，可以反映产品的发展运营情况如何异常定位一般表现为：数据异常时间点的不同（如节假日，高考等），产品体验，近期是否发版，近期的运营活动，渠道投放，广告推广，产品相关的新闻事件，以及市场竞品的影响（如有新竞品进入市场，竞品最近搞运营活动）等。 比值DAU/MAU 代表的是，每天登录的玩家占月活跃的百分比。形象点就是说，你这些活跃玩家，是每天都在登录，还是隔了几天登录。假设，每天都在登录，粘性就高。你隔个四五天登录，粘性就低。一般这个值会在 0.03 到 1 之间。 如果低于10%，很可能已经处于衰退期；高于 20%的留存还不错。 交互席克定律它描述了根据已知选项做某项决定所花的时间——随着选项数量的增加，投入的时间也会呈对数增加。简单来讲，越少越快。 当用户出现恐慌或困惑时，唯一的选择反而给人一种「山有小口，仿佛若有光」的感觉。所以，如果「反应时间」很重要，那选项数量一定要控制在最少。这样也可以加快用户抉择的速度。 解决方案:分步选择, 均分总复杂度到每一个步骤限制选项数量, 保留基本的选项控制单个元素的复杂度, 使页面简单好理解]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端性能监控]]></title>
    <url>%2F2019%2F06%2F14%2Fyuque%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[前端性能优化原理与实践前端性能监控分为两种方式，一种叫做合成监控（Synthetic Monitoring，SYN），另一种是真实用户监控（Real User Monitoring，RUM）。 合成监控什么叫合成监控？就是在一个模拟场景里，去提交一个需要做性能审计的页面，通过一系列的工具、规则去运行你的页面，提取一些性能指标，得出一个审计报告。 常见的工具有 Google 的 Lighthouse，webpagetest，pagespeed 等。 当然其实业界对于 Lighthouse 也是评价有褒有贬，因为 Google 借助这个看似中立的性能评审工具也是在推行它的一些技术的方案。 比如你的页面如果没有支持 PWA 评分就不会很高。 合成监控的优缺点 优点 缺点 实现简单 无法还原全部真实场景 能采集到丰富的数据，如硬件指标或瀑布图 登录等场景需要额外解决 不影响真实用户的访问性能 单次数据不够稳定 可以提供页面加载幻灯片等可视化分析途径 数据量较小，无法发挥更大价值 真实用户监控所谓真实用户监控，就是用户在我们的页面访问之后就会产生各种各样的性能指标，之后会将这些性能指标上传的我们的日志服务器上，进行数据的提起清洗加工，最后在我们的监控平台上进行展示和分析的一个过程。 真实用户监控的优缺点 优点 缺点 无需配置模拟条件，完全还原真实场景 一定程度影响真实用户的访问性能及流量消耗 不存在登录等需要额外解决的场景 无法采集硬件相关指标 数据样本足够庞大，可以减少统计误差 受传输限制无法采集完整的资源加载瀑布图 新年数据可与其它数据关联，产生更大价值 无法可视化展示加载过程 对比 对比项 合成监控 真实用户监控 实现难度及成本 较低 较高 采集数据丰富度 丰富 基础 数据样本量 较小 大(视业务体量) 适合场景 团队自由业务，对性能做定性分析，或配合 CI 做小数据量的监控分析 作为中台产品支持前台业务，对性能做定量分析，结合业务数据进行深度挖掘 方案在真实用户性能数据采集时，要关注四个方面的东西： 使用标准的 API定义合适的指标采集正确的数据上报关联的维度使用标准的 API之前大家都使用一个叫 performance.timing，来做性能监控。但这个 API 已经“废弃”了。为什么会被废弃？因为 W3C 给我们提供了更全面、更强大的一个性能分析矩阵，比单一的 performance.timing更加强大，能帮助我们从各个方面分析前端页面性能。 采集性能数据时先抹平 Navigation Timing spec 差异，优先使用 PerformanceTimeline API(在复杂场景，亦可考虑优先使用 PerformanceObserver)。 定义合适的指标First Meaningful Paint，首次有效渲染时长，这个指标最早是由 Google 提出的，它的一个核心的想法是渲染并不一定代表着用户看到了主要内容，Load也不一定代表用户看到主要内容，那用户什么时候能够看到主要内容呢？我们假设当一个网页的 DOM 结构发生剧烈的变化的时候，就是这个网页主要内容出现的时候，那么在这样的一个时间点上，就是用户看到主要内容的一个时间点。 它的优点是相对校准的估算出内容渲染时间，贴近用户感知。但缺点是无原生 API 支持，算法推导时 DOM 节点不含权重。 怎样采集正确的数据？上报页⾯加载开始时间，以及后续各时间点相对增量，在数据端进行阶段清洗和异常处理。 上报关联的维度我们都知道在做前端的数据采集的时候，维度数据是非常重要的，除了我们刚才定义的各种度量，怎样采集到合适的相关维度，也能够极大地帮助我们分析页面性能的效果。 在分析页面性能的时候，有很多相对专业的维度是会被大家忽略掉的，比如说当前页面是否可见，这个页面加载方式是怎么样的，它是直接打开，还是刷新打开，还是前进后退打开等等。就是通过后面的数据分析，我们会发现，不同的页面操作，页面打开方式都会对我们页面加载的性能会有影响，以及一些更复杂的，比如说是否启用HTTP2、Service Worker 等等，这些数据我们都应该尽可能采集到，从而能够更好的去分析我们的页面性能。 原文本文为蚂蚁金服如何把前端性能监控做到极致? 的阅读笔记。 拓展阅读 我理解的前端性能 &amp; 优化]]></content>
  </entry>
  <entry>
    <title><![CDATA[uni-app]]></title>
    <url>%2F2019%2F06%2F14%2Fyuque%2Funi-app%2F</url>
    <content type="text"><![CDATA[官网git源码地址]]></content>
  </entry>
  <entry>
    <title><![CDATA[Javascript]]></title>
    <url>%2F2019%2F06%2F14%2Fyuque%2FJavascript%2F</url>
    <content type="text"><![CDATA[querySelectorAll getElementsBy 区别？浏览器兼容querySelectorAll 已被 IE 8+、FF 3.5+、Safari 3.1+、Chrome 和 Opera 10+ 良好支持 。getElementsBy 系列，以最迟添加到规范中的getElementsByClassName 为例，IE 9+、FF 3 +、Safari 3.1+、Chrome 和 Opera 9+ 都已经支持该方法了。 接收参数querySelectorAll 方法接收的参数是一个 CSS 选择符。而 getElementsBy 系列接收的参数只能是单一的 className、tagName 和 name。 123var c1 = document.querySelectorAll('.b1 .c')var c2 = document.getElementsByClassName('c')var c3 = document.getElementsByClassName('b2')[0].getElementsByClassName('c') 返回值大部分人都知道，querySelectorAll 返回的是一个 Static Node List，而 getElementsBy 系列的返回的是一个 Live Node List。 1234567891011121314151617181920212223&lt;ul&gt; &lt;li&gt;&lt;/ul&gt; &lt;li&gt;&lt;/ul&gt; &lt;li&gt;&lt;/ul&gt; &lt;li&gt;&lt;/ul&gt; &lt;li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;script&gt;// Demo 1var ul = document.querySelectorAll('ul')[0], lis = ul.querySelectorAll("li");for(var i = 0; i &lt; 5 ; i++)&#123; ul.appendChild(document.createElement("li"));&#125;console.log(lis) //5// Demo 2var ul = document.getElementsByTagName('ul')[0], lis = ul.getElementsByTagName("li");for(var i = 0; i &lt; 5 ; i++)&#123; ul.appendChild(document.createElement("li"));&#125;console.log(lis) //5+2&lt;/script&gt; Demo 1 中的 lis 是一个静态的 Node List，是一个 li 集合的快照，对文档的任何操作都不会对其产生影响。Demo 2 中的 lis 是一个动态的 Node List， 每一次调用 lis 都会重新对文档进行查询，导致无限循环的问题。但为什么要这样设计呢？ 其实，在 W3C 规范中对 querySelectorAll 方法有明确规定 The NodeList object returned by the querySelectorAll() method must be static ([DOM], section 8). 那什么是 NodeList 呢？ The NodeList interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented. NodeList objects in the DOM are live. 所以，NodeList 本质上是一个动态的 Node 集合，只是规范中对 querySelectorAll 有明确要求，规定其必须返回一个静态的 NodeList 对象。 12document.querySelectorAll('a').toString() // return "[object NodeList]"document.getElementsByTagName('a').toString() // return "[object HTMLCollection]" 这里又多了一个 HTMLCollection 对象出来，那 HTMLCollection 又是什么？ 实际上，HTMLCollection 和 NodeList 十分相似，都是一个动态的元素集合，每次访问都需要重新对文档进行查询。两者的本质上差别在于，HTMLCollection 是属于 Document Object Model HTML 规范，而 NodeList 属于 Document Object Model Core 规范。这样说有点难理解，看看下面的例子会比较好理解 12345var ul = document.getElementsByTagName('ul')[0], lis1 = ul.childNodes, lis2 = ul.childrenconsole.log(lis1.toString(), lis1.length) // "[object NodeList]" 11console.log(lis2.toString(), lis2.length) // "[object HTMLCollection]" 4 NodeList 对象会包含文档中的所有节点，如 Element、Text 和 Comment 等。HTMLCollection 对象只会包含文档中的 Element 节点。另外，HTMLCollection 对象比 NodeList 对象 多提供了一个 namedItem 方法。所以在现代浏览器中，querySelectorAll 的返回值是一个静态的 NodeList 对象，而 getElementsBy 系列的返回值实际上是一个 HTMLCollection 对象 。 参照文章 NodeList 和 HTMLCollection 之间的关系？历史上的 DOM 集合接口。主要不同在于 HTMLCollection是元素集合而 NodeList 是节点集合（即可以包含元素，也可以包含文本节点）。所以 node.childNodes 返回 NodeList，而 node.children 和 node.getElementsByXXX 返回 HTMLCollection 。唯一要注意的是 querySelectorAll 返回的虽然是 NodeList ，但是实际上是元素集合，并且是静态的（其他接口返回的 HTMLCollection 和 NodeList 都是 live 的）。Both interfaces are collections of DOM nodes. They differ in the methods they provide and in the type of nodes they can contain. While a NodeList can contain any node type, an HTMLCollection is supposed to only contain Element nodes. An HTMLCollection provides the same methods as a NodeList and additionally a method called namedItem.Collections are always used when access has to be provided to multiple nodes, e.g. most selector methods (such as getElementsByTagName) return multiple nodes or getting a reference to all children (element.childNodes). [“1”, “2”, “3”].map(parseInt) 坑第一反应都觉得结果会是 [1,2,3]但实际结果却是 [1, NaN, NaN]这是为什么呢？主要是 map 这个方法在调用 callback函数时，会给它传递三个参数: 当前正在遍历的元素 元素索引 原数组本身 也是就是说如上代码其实等同于 1['1', '2', '3'].map((i, index, array) =&gt; parseInt(i, index, array)) 这样就直观的解释了上面的答案是怎么产生得了。因为 parseInt 会接受两个参数：参数和进制数。 1234// 实际代码运算等于如下parseInt('1', 0) // 1parseInt('2', 1) // NaNparseInt('3', 2) // NaN 所以为了避免这个坑，平时写 map 还是不要偷懒了，完整的写法才更直观并且更容易维护。 1['1', '2', '3'].map(str =&gt; parseInt(str)) ## 省略参数引发的 bug省略参数是 es6 之后提供的一个很好用也非常常用的功能。但还是有一些细节值得注意，不然一不小心就会出现 bug。 12345678910function test(num = 1) &#123; console.log(num)&#125;test() // (num is set to 1)test(undefined) // (num is set to 1 too)test('') // (num is set to '')test(null) // (num is set to null)test(false) // (num is set to false) 如上面 demo 所示，只有参数没传或者是 undefined 是才会生效，其它情况默认参数并不会起作用。所以有的时候你传入了&#39;&#39;空字符串是不行的，还需要自己手动判断一下。str = str || defalutString 另外，一个容易忽略的地方是，参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。 123456789let x = 99function foo(p = x + 1) &#123; console.log(p)&#125;foo() // 100x = 100foo() // 101 上面代码中，参数 p 的默认值是 x + 1。这时，每次调用函数 foo，都会重新计算 x + 1，而不是默认 p 等于 100。 多余逗号引发的错误刚入前端的时候看错误日志，ie 的错误日志特别多，一直没找到原因，后来发现是 JSON 最后一组键值后多逗号。 1234567891011// 所有浏览器都正常var json_normal = &#123; id: 1, name: "John"&#125;;// ie 报错，其它游览器正常var json_error = &#123; id: 1, name: "John",&#125;; 好在现在有了 eslint 或者 preitter这种工具，这种错误很少会再发生了。 js 中的逗号123if (((a = 1), a++, a)) &#123; console.log(a)&#125; 很多人一下子可能会一脸懵逼。但看一下 MDN 文档 就很清楚了 逗号操作符 对它的每个操作数求值（从左到右），并返回最后一个操作数的值。 举个例子var a=(1+1,2+2,3+3); 结果就是 6。 3+3但在函数中，比如比 Math.max(x,y,z)。这里的逗号就是分隔函数参数。还有声明变量时，var a=1,b=2,c=3。这里的逗号也是起分隔的作用。再举一个例子大家应该就理解了 1234567alert(2 * 5, 2 * 4)//输出10而不是8 函数接收第一个参数,也说明逗号级别比较低console.log(2 * 5, 2 * 4) // 10,8alert((2 * 5, 2 * 4))// 输出8 ()是返回了,相当于隐藏了return 所以返回最右边操作数的值console.log((2 * 5, 2 * 4));//8 其实最常见的运用场景就是平时经常的for循坏 1for (var i = 0, j = 9; i &lt;= 9; i++, j--) &#123;console.log(i,j)&#125; document.documentElement 与 document.body 区别在前端开发中，我们经常需要获取网页中滚动条滚过的长度，获取该值的方式一般通过scrollTop属性，如：document.body.scrollTop，或者document.documentElement.scrollTop，这两者都是经常用来获取文档滚动条滚过长度值的方式，他们又有什么区别呢？ 之前一直没注意，只到有一天发现了一个 bug:document.body.scrollTop 拿到的值一直是 0。在这个之前我们先来了解一下 是干嘛的？为什么每个页面都需要加上这段声明。 doctype 声明不属于 HTML 标签，它是一条指令，告诉浏览器编写页面所用的标记的版本。 这个声明的目的是防止浏览器在渲染文档时，切换到我们称为“怪异模式(兼容模式)”的渲染模式。&lt;!DOCTYPE html&gt; 能确保浏览器按照最佳的相关规范进行渲染，而不是使用一个不符合规范的渲染模式。 document.documentElement 与 document.body document 代表的是整个文档(对于一个网页来说包括整个网页结构) document.documentElement 是整个文档节点树的根节点，在网页中即 html 标签 document.body 是整个文档 DOM 节点树里的 body 节点，网页中即为 body 标签元素 但在标准模式下document.body.scrollTop是无效的。 从 Chrome 61 开始，标准模式中 document.scrollingElement 已被修正为 document.documentElement。换句话说，这个版本开始标准模式中 document.body.scrollTop 始终都等于 0。 所以这里建议使用兼容写法： 12345const scrollTop = Math.max( window.pageYOffset, document.documentElement.scrollTop, document.body.scrollTop) 或者 12345function getBodyScrollTop() &#123; const el = document.documentElement || document.scrollingElement || document.body return el.scrollTop&#125; 每当这时候我就有一些怀念jQuery了。 sort123var array = [3, 7, 2, 8, 2, 782, 7, 29, 1, 3, 0, 34]array.sort()// =&gt; [0, 1, 2, 2, 29, 3, 3, 34, 7, 7, 782, 8] 默认情况下，sort是按照Unicode code points排序的，换而言之，先回比较首个字符的 code point，若相同的情况下依次位数比下去。 所以很多时候我们需要自定义 sort 的规则。最常见的操作： 123const array = [3, 7, 2, 8, 2, 782, 7, 29, 1, 3, 0, 34]array.sort((pre, next) =&gt; pre - next)// =&gt; [0, 1, 2, 2, 3, 3, 7, 7, 8, 29, 34, 782] 其实它的规则很简单，你想让 next 和 pre 换位子就返回一个&gt;0的值，其它情况位置不变，即返回&lt;=0的值。 codePointAt vs charCodeAtJavaScript 允许采用\uxxxx形式表示一个字符，其中xxxx表示字符的 Unicode 码点。但是，这种表示法只限于码点在\u0000~\uFFFF 之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。 12'\uD842\uDFB7'// "𠮷" JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为 2 个字节。对于那些需要 4 个字节储存的字符（Unicode 码点大于 0xFFFF 的字符），JavaScript 会认为它们是两个字符。 1234567var s = '𠮷's.length // 2s.charAt(0) // ''s.charAt(1) // ''s.charCodeAt(0) // 55362s.charCodeAt(1) // 57271 所以 ES6 提供了 codePointAt 方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。 1'𠮷'.codePointAt() //134071 总之，codePointAt 方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与 charCodeAt 方法相同。 switch 作用域其实我们经常会忽略一个点，switch case 是共用一个作用域的。比如如下代码就会抛出重复定义的错误： 12345678910switch (x) &#123; case 0: let foo break case 1: let foo // 重复定义引起TypeError break&#125;// Uncaught SyntaxError: Identifier 'foo' has already been declared 解决方案也很简单，我们给每一个 case 加上一个 bracket 就可以了： 1234567891011switch (x) &#123; case 0: &#123; let foo break &#125; case 1: &#123; let foo // 重复定义引起TypeError break &#125;&#125; div 如何监听 keydown 事件之前有一个人问我，为什么他监听了一个 div 的 keydown 事件，为什么没有用？ 我看了一下代码发现的确没有写错？但为什么就不触发呢？后来查阅了一下文档 Focused element processing the key event, root element if no suitable input element focused 发现只有能被 focus 的元素才能出发键盘事件，所以 div 也就不能触发 keydown 事件了。那怎么才能让 div 支持呢？答案是 tabindex mdn。它表示元素是可聚焦的，并且可以通过键盘导航来访问到该元素。这样一来我们就能愉快的使用keydown事件了. try catch 的 finally 坑try…catch 的 finally 可能很多人都没有使用过，它其实和 promise 中的 finally 很类似。 见MDN。它无论是否有异常它都会执行。 常见的操作就是 将关闭弹窗或者 loading 1234567891011121314var fn = function() &#123; try &#123; console.log('ok') return 'ok' &#125; catch &#123; console.log('error') return 'error' &#125; finally &#123; console.log('finally') return 'finally' &#125;&#125;fn()// ok finally "finally" 我们发现最终输出了finally。因为这个语句只会有一个 return，finally 中的 return 覆盖了之前的定义。而且 return 会被放在最后执行。详情见。 1234567891011var fn = function() &#123; var res='' try &#123; res='ok' &#125; catch &#123; res='error' &#125; finally &#123; return res &#125;&#125;fn() //"ok" 不过最好还是和 promise 中的 finally 一样，在里面做一些没有副作用的事情。免得发生一些 bug。 atob 方法解码中文字符由于一些网络通讯协议的限制,你必须使用 window.btoa() 方法对原数据进行编码后，才能进行发送。接收方使用相当于 window.atob() 的方法对接受到的 base64 数据进行解码,得到原数据。 12345window.btoa('foo')// "Zm9v"window.atob('Zm9v')// "foo" atob 这个方法名称乍一看，很奇怪，不知道这个单词什么意思。我们可以理解为 A to B，也就是从 A 到 B。atob 表示 Base64 字符 to 普通字符，也就是 Base64 解码。当你在 Chrome console 中执行 window.btoa(&#39;中文&#39;)会发下会报错。 Uncaught DOMException: Failed to execute &#39;btoa&#39; on &#39;Window&#39;: The string to be encoded contains characters outside of the Latin1 range. 这时候我们可以借助 encodeURIComponent 和 decodeURIComponent 转义非中文字符。 12345window.btoa(encodeURIComponent('中文'))// ('JUU0JUI4JUFEJUU2JTk2JTg3')decodeURIComponent(window.atob('JUU0JUI4JUFEJUU2JTk2JTg3'))// "中文" Safari 下 Date 的坑在 使用 Date 相关 api 的时候要牢记一个坑，就是 Safari 对一些时间格式是不支持的。比如： 123Date.parse('2018-10-16 12:00:00')// 1539662400000 -- 在Chrome 下// NaN -- 在Safari下 问题就出在 Safari 对于这个格式 YYYY-MM-DD HH:MM:SS 无法解析，Safari 要求 Date.parse()或 Date()转换日期的字符串需要满足 RFC2822 或 ISO 8601 定义的格式。不过我们可以将其转化为 YYYY/MM/DD HH:MM:SS 1Date.parse(new Date('2018-10-16 12:00:00'.replace(/-/g, '/'))) 相关stackoverflow new Date 在 safari 的坑new Date(&#39;2019-06-04 00:00:00&#39;)在除了 Safari 的浏览器都能正常运行。 问题就出在 Safari 对于这个格式 YYYY-MM-DD HH:MM:SS 无法解析，所以我们需要做的是将其转化为 YYYY/MM/DD HH:MM:SS 1+new Date('2019-06-04 00:00:00'.replace(/-/g, '/')) e.target 与 e.currentTarget 的区别有一次在面试的时候问了事件委托的题目，面试人说了一个 currentTarget，突然发现target和currentTarget的区别我好像有些忘记了，太多相似的 api 和属性了。 首先我们来看一下 MDN 上对它们的解释 target：一个触发事件的对象的引用， 当事件处理程序在事件的冒泡或捕获阶段被调用时。 currentTarget： 当事件遍历 DOM 时，标识事件的当前目标。它总是引用事件处理程序附加到的元素，而不是 event.target，event.target 标识事件发生的元素。 可能还是很抽象 ，这里提供一个在线demo。 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width"&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;li&gt;hello 1&lt;/li&gt; &lt;li&gt;hello 2&lt;/li&gt; &lt;li&gt;hello 3&lt;/li&gt; &lt;li&gt;hello 4&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;const ul = document.querySelectorAll('ul')[0]ul.addEventListener('click', function(e) &#123; let oLi1 = e.target let oLi2 = e.currentTarget console.log(oLi1.tagName); // 被点击的li console.log(oLi2.tagName); // ul console.log(oLi1 === oLi2); // false&#125;);&lt;/script&gt; 也就是说，currentTarget 始终是监听事件者，而 target 是事件的真正发出者。 函数变量必填校验这里分享一个平时写 ES6 的时候一个小技巧。如何简单的校验并强制在使用这个函数时必须传参数。 12345678910const isRequired = () =&gt; &#123; throw new Error('Missing parameter')&#125;const foo = (something = isRequired()) =&gt; &#123; console.log(something) return something&#125;foo(123)foo() // Error:Missing parameter 前端错误处理错误处理对于任何前端来说都是必不可少的。任何人写代码都避免不了会有 bug，而且很多 bug 也不是测试用例能完全覆盖的，如果我们没有一个完整的错误处理和错误收集的系统，我们都无法知道我们有 bug，不仅如此，很多 bug 也不一定是前端的问题，比如某个接口返回的数据格式不对了或者少字段了，亦或是在某个特定的浏览器型号上才有的问题等等。而且有了错误处理和收集，我们也才能更好的通过错误栈来还原这个问题。 有哪些错误需要处理 JS 语法错误、代码异常 请求错误 静态资源加载异常 Promise 异常 页面崩溃和卡顿Try Catchtry-catch 只能捕获到同步的运行时错误，对语法和异步错误却无能为力，捕获不到。 1.同步运行时错误： 同步错误 123456try &#123; let name = 'foo' console.log(nam)&#125; catch (e) &#123; console.log('捕获到异常：', e)&#125; 捕获到异常： ‘ReferenceError: nam is not defined at :3:15’ 语法错误 123456try &#123; let name = 'foo console.log(nam)&#125; catch (e) &#123; console.log('捕获到异常：', e)&#125; Uncaught SyntaxError: Unexpected identifier 异步错误 1234567try &#123; setTimeout(() =&gt; &#123; undefined.map(v =&gt; v) &#125;, 1000)&#125; catch (e) &#123; console.log('捕获到异常：', e)&#125; 每次的数都不一样，运行一次就加1Uncaught TypeError: Cannot read property ‘map’ of undefined window.onerror当 JS 运行时错误发生时，window 会触发一个 ErrorEvent 接口的 error 事件，并执行 window.onerror()。 12345678910/** * @param &#123;String&#125; message 错误信息 * @param &#123;String&#125; source 出错文件 * @param &#123;Number&#125; lineno 行号 * @param &#123;Number&#125; colno 列号 * @param &#123;Object&#125; error Error对象（对象） */window.onerror = function(message, source, lineno, colno, error) &#123; console.log('捕获到异常：', &#123; message, source, lineno, colno, error &#125;)&#125; 不同域名下的 js 报错不能被 全局的 window.onerror 监听到，我们需要给相关的 js 文件上加上 Access-Control-Allow-Origin:*的 response header，并且引用相关的 js 文件时加上 crossorigin 属性。相关文章 在实际的使用过程中，onerror 主要是来捕获预料之外的错误，而 try-catch 则是用来在可预见情况下监控特定的错误，两者结合使用更加高效。 window.addEventListener当一项资源（如图片或脚本）加载失败，加载资源的元素会触发一个 Event 接口的 error 事件，并执行该元素上的 onerror() 处理函数。这些 error 事件不会向上冒泡到 window ，不过（至少在 Firefox 中）能被单一的 window.addEventListener 捕获。 123456&lt;img src="./foo.png"&gt;&lt;scritp&gt;window.addEventListener('error', (error) =&gt; &#123; console.log('捕获到异常：', error);&#125;, true)&lt;/script&gt; Promise Catch没有写 catch 的 Promise 中抛出的错误无法被 onerror 或 try-catch 捕获到，所以我们务必要在 Promise 中不要忘记写 catch 处理抛出的异常。或者可以全局增加一个对 unhandledrejection 的监听，用来全局监听 Uncaught Promise Error。使用方式： 123window.addEventListener('unhandledrejection', function(e) &#123; console.log(e)&#125;) 当然你如果使用如 axios 这种库的话，错误处理完全可以放在它的请求实例里面做。更加的灵活。 VUE errorHandler123456Vue.config.errorHandler = (err, vm, info) =&gt; &#123; console.error('通过vue errorHandler捕获的错误') console.error(err) console.error(vm) console.error(info)&#125; React 异常捕获123componentDidCatch(error, info) &#123; console.log(error, info);&#125; 崩溃和卡顿相关文章 实践总结】优雅的处理 vue 项目异常 insertBefore 坑Node.insertBefore()很多人都用过， 它在参考节点之前插入一个节点作为一个指定父节点的子节点。 var insertedNode = parentNode.insertBefore(newNode, referenceNode); 但看文档还有一句补充说明： 如果 referenceElement 为 null 则 newElement 将被插入到子节点的末尾。如果 newElement 已经在 DOM 树中，newElement 首先会从 DOM 树中移除。 这就很坑了，如下面的例子： 12345678910&lt;div id="parentElement"&gt; &lt;span id="bar"&gt;bar&lt;/span&gt; &lt;span id='foo'&gt;foo&lt;/span&gt;&lt;/div&gt;&lt;script&gt;var foo = document.getElementById("foo")var bar = document.getElementById("bar")var parentDiv = document.getElementById("parentElement")parentDiv.insertBefore(foo, bar)&lt;/script&gt; 原本以为结果是 foo bar foo，但实际结果是foo bar。因为根据文档，当你 insertBefore 的是一个已存在的值时，会移动它而不是拷贝它重新插入。贼坑！！！如果使用 ES6 的话可以使用 before 123var foo = document.getElementById('foo')var bar = document.getElementById('bar')bar.before(foo) ## 为什么前端监控要用 GIF 打点目前主流的前端监控数据上报都是采用 GIF 的上报方式，(百度统计/友盟/谷歌统计）都是这样实现的。但为什么一定要使用 GIF 呢？不能发 post 请求或者通过 script 标签的形式么？当然你也可以使用一些黑科技的方式上报，用纯 css 来实现。但这种方案并没有什么特别的好处。 123.track-xx:active:after &#123; content: url(track.php?xxxx=foo);&#125; ### 主要原因 没有跨域问题 不会阻塞页面加载，影响用户体验 在所有图片中体积最小，相较 BMP/PNG，可以节约 41%/35%的网络资源 详情见 为什么前端监控要用 GIF 打点 使用方式但建议不要按如下方法使用 1new Image().src = 'https://foo.com/bar.gif?t=xxxx&amp;b=1' 这段代码的问题是这个 new Image()是一个没有引用的临时变量，随时可能被浏览器的垃圾回收机制回收。如果这个图片的 HTTP 请求尚未建立，那么在被回收时这个请求就会被取消，导致打点并没有真正发出。如果打点所在的页面比较复杂，浏览器垃圾回收机制可能会被频繁触发，那么这种方式打点的丢失率可能会高达 10%以上。 解决方法很简单，将这个图片赋值给一个全局变量即可，例如： 12345678910const img = new Image()const key = +new Date() //加一个时间戳，防止图片被浏览器缓存了，不再发送请求 "+"转换时间戳window[t] = imgimg.onload = img.onerror = img.onabort = function() &#123; // img标签加载完成、错误或终止时，解除事件绑定，销毁相关对象 img.onload = img.onerror = img.onabort = null window[key] = null img = null&#125;img.src = `$&#123;url&#125;?t=key` ### 其它方案Beacon API 在空闲的时候异步发送统计，不影响页面诸如 JS、CSS Animation 等执行 即使页面在 unload 状态下，也会异步发送统计，不影响页面过渡/跳转到下跳页 能够被客户端优化发送，尤其在 Mobile 环境下，可以将 Beacon 请求合并到其他请求上，一同处理 Object.create(null) vs {}查看 vue 的源码 或者一些开源项目的源码，发现不少地方都是使用 Object.create(null)来创建一个空对象的。当使用语句 const obj = {}; 创建对象时，它其实并不是一个真的空对象，它从 Object.prototype 上继承了一些方法： hasOwnProperty isPrototypeOf propertyIsEnumerable toString/toLocaleString valueOf 如果使用 Object.create(null) 创建的对象，在没有继承任何东西。 所以说是不是 Object.create(null) 是更好的创建一个空对象的方案呢？这就要看从 Object 上继承的那些方法我们是不是有用到了。 hasOwnProperty判断一个对象属性中是否具有指定的属性，返回 true or false。 valueOfvalueOf 很少直接使用。在隐式转换类型时，JavaScript 引擎会调用 valueOf 方法，强制把对象转换成原始值 toString、isPrototypeOf 和 propertyIsEnumerable这几个方法直接使用的情况较少，但自己的代码中不用并不表示别人写的代码不会调用。比如，有些框架可能会调用 toString 方法来判断结果是否为 [object Object]。 结论因此，我们可以得出结论：当创建的对象只在当前执行环境中使用并且不会用到任何从 Object.prototype 上继承来的方法，也不会将该对象作为其他对象的原型的时候，那么可以使用 Object.create(null)。比如，构造一个字典对象的时候。不过相对而言 const obj={}在浏览器中的执行速度是会比Object.create(null)快的，具体可点击链接test。不过你一般代码中这些性能差距完全是可以忽略不计的。 async/await with forEach()之前在工作中遇到了一个需求，实现一个简单的请求队列，大概意思就是这个页面有一个 list，我需要按 list 顺序依次发请求，多数据做一些操作，每次等前一个请求成功之后，再执行下一个，全部执行完毕之后，显示已完成。这不就是用 async/await就可以实现了。于是写了如下代码： 123456const waitFor = ms =&gt; new Promise(r =&gt; setTimeout(r, ms));[1, 2, 3].forEach(async num =&gt; &#123; await waitFor(1000) console.log(num)&#125;)console.log('Done') What？为什么await没有生效，直接就输出了1,2,3？谷歌搜索了一下，发现原来是forEach的锅。 我们简单来看一下 forEach的实现原理： 1234567Array.prototype.forEach = function(callback) &#123; // this represents our array for (let index = 0; index &lt; this.length; index++) &#123; // We call the callback for each entry callback(this[index], index, this) &#125;&#125; 我们可以看到它只是 for 循环的一个简单封装，而且在内部它只是简单做了一个回调，根本就不会wait。其实一些其它的数组方式比如map、reduce等等也是不支持的，因为 Array 的迭代方法就支持不支持参数函数返回 promise 的异步用法，有兴趣的可以自行了解。那我们直接用 for循环不就好了 1234567async function test() &#123; for (let index = 0; index &lt; [1, 2, 3].length; index++) &#123; await waitFor(1000) console.log(index) &#125; console.log('done')&#125; 或者 for-of更为简单 1234567async function test() &#123; for (let i of [1, 2, 3]) &#123; await waitFor(1000) console.log(i) &#125; console.log('done')&#125; 获取元素宽度说真的，我觉得前端麻烦的地方就是 API 太多了，我只是想获取一个元素的宽度居然有getBoundingClientRect().width 我使用 Async/Await 而不使用 Promises 的六个理由本文主要来自于 6 Reasons Why JavaScript’s Async/Await Blows Promises Away，在 medium 上，需要翻墙阅读。之前我很长一段时间内都是使用 promise 的，但遇到一些复杂业务的时候，发现还是写起来会很不爽，代码阅读性也有所欠缺。 简洁 对比 Promise，我们不需要书写.then，不需要新建一个匿名函数处理响应，也不需要再把数据赋值给一个我们其实并不需要的变量 a 但 Async/Await 也不是没有缺点的，很多人经常会错用它。比如我一个组件创建的的时候会异步向服务器发送三个请求，a、b、c。 很多人会这么写 123456async function mount() &#123; const resultA = await fetch('A') const resultB = await fetch('B') const resultC = await fetch('C') render(resultA, resultB, resultC)&#125; 虽然上面的这段写法相对于 promise 简洁了不少，但效率来说是不合格的。因为这个请求是异步的，毫无联系的，所有没必要顺序请求，他们三个明显可以异步并发的去请求。要想实现真正的异步，还是需要依赖 Promise.all 封装一层： 12345678async function mount() &#123; const result = await Promise.all( fetch('a.json'), fetch('b.json'), fetch('c.json') ) render(...result)&#125; 未完待续…]]></content>
  </entry>
  <entry>
    <title><![CDATA[Virtual DOM 性能好？]]></title>
    <url>%2F2019%2F06%2F14%2Fyuque%2FVirtual%20DOM%20%E6%80%A7%E8%83%BD%E5%A5%BD%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[每次面试，面试人一谈到 react 就必然会谈到 Virtual DOM，一谈到 Virtual DOM 就会说它比原生操作 DOM 性能哪里哪里好。 但任何一个 v-dom 框架都不会说自己的性能快过 DOM 操作。就拿 react 为例子，它的目标是：“每次数据变化都以最小的代价来更新真实 DOM”。引入 v-dom，在内存中比较虚拟节点，然后找出不同，之后执行更新。 就能更改页面上一个元素的内容，直接操作 DOM 的反应速度绝对会比你 diff 一次之后再更新来的快。但这时你可能会觉得当程序到达一定的复杂度之后，v-dom 性能上的优势才能体现出来。但是，无论你代价再少也好，v-dom 都是有消耗的，光从你要生成整个页面的 v-dom 就会比单单生成原生 dom 要多消耗一大截内存，更别说其中的复杂递归，比对，然后再变换。但是！它依然是纯 js 层面的计算，比起后面的 DOM 操作来说，依然便宜了太多。 所以 v-dom 真正的价值是什么？ 框架给你的保证是，你在不需要手动优化的情况下，我依然可以给你提供过得去的性能。 我认为是带来了跨屏能力，以及代码的可维护性， 同时为函数式的 UI 编程方式打开了大门。]]></content>
  </entry>
  <entry>
    <title><![CDATA[垃圾回收]]></title>
    <url>%2F2019%2F06%2F14%2Fyuque%2F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%2F</url>
    <content type="text"><![CDATA[作为编写程序的人，是可以做出“这个对象已经不再需要了”这样的判断，但计算机是做不到的。因此，如果程序（通过某个变量等等）可能会直接或间接地引用一个对象，那么这个对象就被视为“存活”；与之相反，已经引用不到的对象被视为“死亡”。将这些“死亡”对象找出来，然后作为垃圾进行回收，这就是 GC 的本质。 三大基础 GC 算法 引用计数法 它的基本原理是，在每个对象中保存该对象的引用计数，当引用发生增减时对计数进行更新。引用计数的增减，一般发生在变量赋值、对象内容更新、函数结束（局部变量不再被引用）等时间点。当一个对象的引用计数变为 0 时，则说明它将来不会再被引用，因此可以释放相应的内存空间。 引用计数最大的缺点，就是无法释放循环引用的对象。 标记清除法/标记压缩法这个算法假定设置一个叫做根（root）的对象（在 Javascript 里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象从 2012 年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对 JavaScript 垃圾回收算法的改进都是基于标记-清除算法的改进，并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义。标记清除算法有一个缺点，就是在分配了大量对象，并且其中只有一小部分存活的情况下，所消耗的时间会大大超过必要的值，这是因为在清除阶段还需要对大量死亡对象进行扫描。 复制收集算法在这种算法中，会将从根开始被引用的对象复制到另外的空间中，然后，再将复制的对象所能够引用的对象用递归的方式不断复制下去。但是，和标记相比，将对象复制一份所需要的开销则比较大，因此在“存活”对象比例较高的情况下，反而会比较不利。这种算法的另一个好处是它具有局部性（Lo-cality）。在复制收集过程中，会按照对象被引用的顺序将对象复制到新空间中。于是，关系较近的对象被放在距离较近的内存空间中的可能性会提高，这被称为局部性。局部性高的情况下，内存缓存会更容易有效运作，程序的运行性能也能够得到提高。 分代回收V8 引擎将保存对象的 堆 (heap) 进行了分代: 对象最初会被分在 新生区(New Space) (1~8M)，新生区的内存分配只需要保有一个指向内存区的指针，不断根据内存大小进行递增，当指针达到新生区的末尾，会有一次垃圾回收清理(小周期)，清理掉新生区中不再活跃的死对象。 对于超过 2 个小周期的对象，则需要将其移动至 老生区(Old Space)。老生区在 标记-清除 或 标记-紧缩 的过程(大周期) 中进行回收。 大周期进行的并不频繁。一次大周期通常是在移动足够多的对象至老生区后才会发生参考： JavaScript 垃圾回收机制 GC 的三大基础算法]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue面试题]]></title>
    <url>%2F2019%2F06%2F13%2Fyuque%2Fvue%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[很多人面试会问啥 vue 实现原理，但我觉得这略过分，有多少人会老老实实看过它的源码。但我觉得面者这也只是知道 vue 双向绑定的原理吧。 发布者-订阅者模式（backbone.js） 一般通过 sub, pub 的方式实现数据和视图的绑定监听，更新数据方式通常做法是 vm.set(‘property’, value)，这种方式现在毕竟太 low 了，我们更希望通过 vm.property = value 这种方式更新数据，同时自动更新视图，于是有了下面两种方式 脏值检查（angular.js） angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然 Google 不会这么 low，angular 只有在指定的事件触发时进入脏值检测，大致如下： DOM 事件，譬如用户输入文本，点击按钮等( ng-click ) XHR 响应事件 ( $http ) 浏览器 Location 变更事件 ( $location ) Timer 事件( $timeout , $interval ) 执行 $digest() 或 $apply() 数据劫持（vue.js） vue.js[2.0] 则是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 vue.js[3.0]采取了 proxy 的方式]]></content>
  </entry>
  <entry>
    <title><![CDATA[React面试题]]></title>
    <url>%2F2019%2F06%2F13%2Fyuque%2FReact%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[React面试题&amp;回答 React在使用 react 的过程中，我们绕不开渲染性能优化问题，因为默认情况下 react 组件的 shouldComponentUpdate 函数会一直返回 true，这回导致所有的组件都会进行耗时的虚拟 DOM 比较。在使用 redux 作为 react 的逻辑层框架时，我们可以使用经典的 PureComponent+ShallowCompare 的方式进行渲染性能优化https://foio.github.io/mobx-react/ MobX作为一个数据层框架，mobx 基于一个最简单的原则： 当应用状态更新时，所有依赖于这些应用状态的监听者（包括 UI、服务端数据同步函数等），都应该自动得到细粒度地更新。 在使用 mobx 作为 react 的 store 时，我们该如何进行渲染性能优化呢？ 通过分析源代码发现，在使用@observer 将 react 组件转换成一个监听者(Reactions)后，mobx 会为 react 组件提供一个精确的、细粒度的 shouldComponentUpdate 函数: 123456789shouldComponentUpdate: function(nextProps, nextState) &#123; ...... // update on any state changes (as is the default) if (this.state !== nextState) &#123; return true; &#125; // update if props are shallowly not equal return isObjectShallowModified(this.props, nextProps);&#125; 借助于 mobx 框架对 Observable 变量引用的跟踪和依赖收集，mobx 能够精确地得到 react 组件对 Observable 变量的依赖图谱，然后再用经典的 ShallowCompare 实现细粒度的 shouldComponentUpdate 函数，以达到 100%无浪费 render。这一切都是自动完成地，fantastic！使用 mobx 后，我们再也无需手动写 shouldComponentUpdate 函数了。 React Native 优势 跨平台 （只有 0.2% 的平台特定代码） 统一的设计语言，同时还能为不同平台提供不同设计 React 的 scale 很好。组件化，简单的生命周期,声明式 迭代速度快（主要是 hot reloading 很快） 大量基础设施的投入值得（网络、国际化、复杂动画、设备信息、用户信息等等都是通过一- 个桥把原生 api 暴露给 RN 的。） 同时他们在这里也指出：他们并不相信在一个已有 app 上集成 RN 是一件简单事儿，必须- 要大量且持续地投入基础设施才行（说好的「满意的地方」呢） 性能 （尽管大家都担心但是其实基本没有问题） 不过首次渲染比较慢，导致不适合用作启动屏、deeplink，也增加了可交互时间（TTI），另外掉帧不好 debug（说好的「满意的地方」呢） Redux（好用，虽然废话太多） 背后是原生，一些曾经不确定能不能做的功能（Shared element transitions、动画库 Lottie、网络层、核心基础设施）发现都能做 静态分析（eslint，prettier，一些性能检测） 动画 JS/React 的开源生态 Flexbox 有时候可以加上 Web 跨三端 劣势 论成熟度，稳定性，RN 比 不上 iOS 和 Android 原生。 由于 RN 的 Bug，有时我们必须维护自己的一个 RN 分支。 JS 缺少类型系统，Flow 太严格，TS 集成到已有项目也还有问题。 不好重构（JS 没有类型无法静态分析，重构引起的错误不能在编译时被捕捉到） JavaScriptCore 不一致性，更糟糕的是，现在都 8102 年了，RN （Android）带的还是不支持 ES 6 的 JSC RN 开源库质量参差不齐。比如在 iOS 上正常的库在 Android 上可能有意想不到的错误（因为为作者也许只熟悉 iOS 和 RN,并不熟悉 Android） 有时不得不白手起家，因为很多的基础框架中的库还没有 的 RN 封装。 崩溃监控库在 RN 上表现不是特别特定业。内没方案，只能自己搞。 Native Bridge 的由于 JS 的弱类型造成 Native 与 JS 通信 中类型的不匹配，容易造成错误。 启动时间，RN 框架初始化需要几秒，即使是在高端机器上。 新开页面的渲染时间，0.4 秒左右页面第一次渲染费时。 APP 大小。至少增加 12M。 直到目前都无法在 Android 上支持 64 位。 手势，iOS 和 Android 的手势 API 差距很大，不过喜闻 react-native-gesture-handler 发布了 1.0 版本。 长列表，虽然 RN 团队很努力了，但是由于 RN 的异步通信机制，长列表的流畅渲染，目前依然无解。 React Native 升级是个坑。 RN 中的 Accessibility 就是个大坑。 还有一些奇怪的 Bug，暂没有修复。 SavedInstanceState 在 Android 上跨进程的坑。 不是技术问题的问题 要用好 RN 你必须同时熟悉 iOS 和 Android ，当然还有 RN 本身，这就对我们工程师提出了更多挑战。 团队的管理，责任的划分。 RN 文档及相关资源不如 iOS 和 Android 的丰富。 面试题reactjs-interview-questions]]></content>
  </entry>
  <entry>
    <title><![CDATA[网络面试题]]></title>
    <url>%2F2019%2F06%2F13%2Fyuque%2F%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[WebSocket WebSocket 与 HTTP 什么关系呢？简单来说，WebSocket 是一种协议，是一种与 HTTP 同等的网络协议，两者都是应用层协议，都基于 TCP 协议。但是 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。 WebSocket 与 Socket网络应用中，两个应用程序同时需要向对方发送消息的能力（即全双工通信），所利用到的技术就是 socket，其能够提供端对端的通信。对于程序员而言，其需要在 A 端创建一个 socket 实例，并为这个实例提供其所要连接的 B 端的 IP 地址和端口号，而在 B 端创建另一个 socket 实例，并且绑定本地端口号来进行监听。当 A 和 B 建立连接后，双方就建立了一个端对端的 TCP 连接，从而可以进行双向通信。WebSocekt 是 HTML5 规范中的一部分，其借鉴了 socket 的思想，为 client 和 server 之间提供了类似的双向通信机制。同时，WebSocket 又是一种新的应用层协议，包含一套标准的 API；而 socket 并不是一个协议，而是一组接口，其主要方便大家直接使用更底层的协议（比如 TCP 或 UDP） 什么是 Socket.IOSocket.IO 是一个封装了 Websocket、基于 Node 的 JavaScript 框架，包含 client 的 JavaScript 和 server 的 Node。其屏蔽了所有底层细节，让顶层调用非常简单。另外，Socket.IO 还有一个非常重要的好处。其不仅支持 WebSocket，还支持许多种轮询机制以及其他实时通信方式，并封装了通用的接口。这些方式包含 Adobe Flash Socket、Ajax 长轮询、Ajax multipart streaming 、持久 Iframe、JSONP 轮询等。换句话说，当 Socket.IO 检测到当前环境不支持 WebSocket 时，能够自动地选择最佳的方式来实现网络的实时通信。 WebSocket VS SSE(Server-Sent Events)Server-sent Events 其实很多人都不知道这东西，但其实肯定用过的，webpack-hot-middleware就是运用该原理进行热更新的，当然webpack-dev-server使用的是 WebSocket。SSE 与 WebSocket 作用相似，都是建立浏览器与服务器之间的通信渠道，然后服务器向浏览器推送信息。总体来说，WebSocket 更强大和灵活。因为它是全双工通道，可以双向通信；SSE 是单向通道，只能服务器向浏览器发送，因为流信息本质上就是下载。如果浏览器向服务器发送信息，就变成了另一次 HTTP 请求。但是，SSE 也有自己的优点。 SSE 使用 HTTP 协议，现有的服务器软件都支持。WebSocket 是一个独立协议。 SSE 属于轻量级，使用简单；WebSocket 协议相对复杂。 SSE 默认支持断线重连，WebSocket 需要自己实现。 SSE 一般只用来传送文本，二进制数据需要编码后传送，WebSocket 默认支持传送二进制数据。 SSE 支持自定义发送的消息类型。 相关补充文章 Server-Sent Events-阮一峰 WebSockets vs. Server-Sent events/EventSourceWebSocket 推荐阅读文章WebSocket 是什么原理？TCP VS UDPTCP UDP 这两个东西已经是老生常谈了，基本每个面试都会问一下，还不了解的赶快去补习一下。但发现一个问题，大家都只是知道这两者的区别是什么，完全不知道他们各自的应用场景是什么？UDP 场景： 实时音视频是可以而且应该用 UDP 的，一方面因为它常常涉及到网络穿透，另外一方面它不需要重传。——我需要实时的看到你的图像跟声音，至于中间丢一帧什么的完全不重要。而为了重传往往会造成延迟与不同步，考虑一下，某一帧因为重传，导致 0.5 秒以后才到，那么整个音视频就延迟了 0.5 秒。考虑一下接收方看视频，如果使用 TCP 导致视频的中间延迟了 0.5 秒，只要我不按「快进」键，那么后续的视频全都会比发送方延迟 0.5 秒。这种延迟是累加的，随着持续丢帧，延迟会越来越大，达到数秒，甚至分钟级，这会严重影响实时音视频的用户体验。因此「实时音视频聊天」功能通常都会使用 UDP 实现。 网络真的非常非常可靠，以至于你完全不需要考虑 UDP 丢包问题的情况。典型的例子应该是专门为有线局域网设计的协议。 另外一个问题是 TCP 是纯粹的流式数据，所以制定传输协议的时候，接受方需要自行判定一个包的开始和结束，因为你完全可能接受到半个包或者两个包。——如果数据报的起止判定对你具体的程序会成为大问题，也可以考虑 UDP。 采用 UDP 有 3 个关键点： 网络带宽需求较小，而实时性要求高 大部分应用无需维持连接 需要低功耗]]></content>
  </entry>
  <entry>
    <title><![CDATA[常规面试题]]></title>
    <url>%2F2019%2F06%2F13%2Fyuque%2F%E5%B8%B8%E8%A7%84%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[事件委托应该是前端最经常问的一个问题。 但其实里面有非常非常多的知识点可以考察。 css last-of-type last-child 事件委托的好处 addEventListener 第三个参数 实现 index 类数组 =&gt; 数组 querySelectorAll 方法相比 getElementsBy 系列方法有什么区别 HTMLCollection NodeList 区别 https://www.zhihu.com/question/24702250 12345678const ul = window.document.getElementsByTagName('ul')[0]ul.addEventListener('click', e =&gt; &#123; const children = [...ul.getElementsByTagName('li')] //htmlCollection =&gt; array if (e.target &amp;&amp; e.target.nodeName.toLowerCase() === 'li') &#123; const index = children.indexOf(e.target) console.log(index) &#125;&#125;) 一道有意思的面试题 100*100 的 canvas 占多少内存？ 你有必要知道的几个 JavaScript 面试题 1. 使用 typeof bar === “object” 判断 bar 是不是一个对象有神马潜在的弊端？如何避免这种弊端？大部分情况下 typeof 是可信的，但 js 就是这样不靠谱，总是有一些边缘 case。 1234567typeof &#123;&#125; //'object'typeof [] //'object'typeof null //'object'typeof new String() //'object'typeof NaN //'number'const var reg = /pop/gtypeof reg //'object' 这时候你可以说使用 instanceof。但 instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型。 简而言之就是 123'' instanceof String //falsenew String() instanceof String //truenew String() instanceof Object //true 只有使用构造函数创建的基本类型可以正确显示。所以到底有没有靠谱的校验类型方法？答案是有的 详情见玉伯的分享 12345678910111213var toString = Object.prototype.toStringfunction isObject(obj) &#123; return toString.call(obj) === '[object Object]'&#125;function isString(obj) &#123; return toString.call(obj) === '[object String]'&#125;function isArray(obj) &#123; return toString.call(obj) === '[object Array]'&#125;function isFunction(obj) &#123; return toString.call(obj) === '[object Function]'&#125; 附加问题： 我们知道 typeof new String(“xxx”) 返回 “object”，请问 typeof String(“xxx”) 返回什么？为什么？ 返回”string”，因为直接调用 String 返回的是一个字符串，而 new String 返回的是一个 String 对象。2. 下面的代码会在 console 输出神马？为什么？12345;(function() &#123; var a = (b = 3)&#125;)()console.log(typeof a)console.log(b) 12console.log(typeof a) //undefinedconsole.log(b) //3 这题是以前比较常见的变量提升的问题 它实际执行步骤是这样子的 12b = 3var a = b 并且 b 变成一个全局变量，而 a 还是一个局部变量，所以你在外部 console 是会报错的。 3. 下面的代码会在 console 输出神马？为什么？12345678910111213var myObject = &#123; foo: 'bar', func: function() &#123; var self = this console.log('outer func: this.foo = ' + this.foo) console.log('outer func: self.foo = ' + self.foo) ;(function() &#123; console.log('inner func: this.foo = ' + this.foo) console.log('inner func: self.foo = ' + self.foo) &#125;)() &#125;&#125;myObject.func() 这题是最简单的作用域问题，没啥好讨论的了。 4. 将 JavaScript 代码包含在一个函数块中有神马意思呢？为什么要这么做？换句话说，为什么要用立即执行函数表达式（Immediately-Invoked Function Expression）。IIFE 有两个比较经典的使用场景，一是类似于在循环中定时输出数据项，二是类似于 JQuery/Node 的插件和模块开发。 12345for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(i) &#125;, 1000)&#125; 上面的输出并不是你以为的 0，1，2，3，4，但输出的全部是 5，这时 IIFE 就能有用了： 1234567for (var i = 0; i &lt; 5; i++) &#123; ;(function(i) &#123; setTimeout(function() &#123; console.log(i) &#125;, 1000) &#125;)(i)&#125; ES6 的话，可以用 let 12345for (let i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(i) &#125;, 1000)&#125; 而在 JQuery/Node 的插件和模块开发中，为避免变量污染，也是一个大大的 IIFE： 123;(function($) &#123; //代码&#125;)(jQuery) 5. 在严格模式(‘use strict’)下进行 JavaScript 开发有神马好处？ 消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的 Javascript 做好铺垫。6. 下面两个函数的返回值是一样的吗？为什么？1234567891011function foo1() &#123; return &#123; bar: 'hello' &#125;&#125;function foo2() &#123; return &#123; bar: 'hello' &#125;&#125; 对于 return 、break、continue 等语句，如果后面紧跟换行，解析器一定会自动在后面填充分号(😉，所以上面的第二个函数就直接被 return了。所以第二个函数是返回 undefined。 7. 神马是 NaN，它的类型是神马？怎么测试一个值是否等于 NaN?NaN 是 Not a Number 的缩写，JavaScript 的一种特殊数值，其类型是 Number，可以通过 isNaN(param) 来判断一个值是否是 NaN： 12345678910console.log(isNaN(NaN)) //trueconsole.log(isNaN(23)) //falseconsole.log(isNaN('23')) //false 因为执行的时候先回转化为数字 所以 '23'=&gt; 23console.log(isNaN('ds')) //trueconsole.log(isNaN('32131sdasd')) //true 先回 Number("123ABC") 结果是 NaNconsole.log(NaN === NaN) //falseconsole.log(NaN === undefined) //falseconsole.log(undefined === undefined) //falseconsole.log(typeof NaN) //numberconsole.log(Object.prototype.toString.call(NaN)) //[object Number] ES6 中，isNaN() 成为了 Number 的静态方法：Number.isNaN().它的 polyfill 实现起来也很简单–利用了 NaN 自身永不相等于自身这一特征 1234const isNaN = function(value) &#123; const n = Number(value) return n !== n&#125; 8. 解释一下下面代码的输出12console.log(0.1 + 0.2) //0.30000000000000004console.log(0.1 + 0.2 == 0.3) //false 另一道非常经典的面试题，js 精度问题 JavaScript 浮点数陷阱及解法JavaScript 存储任何数字都是遵循 IEEE-754 标准，使用 64 位固定长度来表示，也就是标准的 double 双精度浮点数。所以为什 0.1+0.2=0.30000000000000004？ 计算步骤为： 12345// 0.1 和 0.2 都转化成二进制后再进行运算0.00011001100110011001100110011001100110011001100110011010 +0.0011001100110011001100110011001100110011001100110011010 =0.0100110011001100110011001100110011001100110011001100111// 转成十进制正好是 0.30000000000000004 解决方案 你可以使用一些成熟的库如：big.js，bignumber.js。 或者对精度要求不高的情况下 直接 toFixed就可以了。不过注意它得到的值可能是不准确的。如：1.005.toFixed(2) 返回的是 1.00 而不是 1.01。原因： 1.005 实际对应的数字是 1.00499999999999989，在四舍五入时全部被舍去！ 9. 实现函数 isInteger(x) 来判断 x 是否是整数可以将 x 转换成 10 进制，判断和本身是不是相等即可： 123function isInteger(x) &#123; return parseInt(x, 10) === x&#125; 10. 在下面的代码中，数字 1-4 会以什么顺序输出？为什么会这样输出？12345678910;(function() &#123; console.log(1) setTimeout(function() &#123; console.log(2) &#125;, 1000) setTimeout(function() &#123; console.log(3) &#125;, 0) console.log(4)&#125;)() 最简单的运行提了，如果这都不会的话，真应该好好补习补习基础了。 11. 判断一个字符串是不是回文字符串12345678910function isPalindrome(str) &#123; str = str.replace(/\W/g, '').toLowerCase() return ( str == str .split('') .reverse() .join('') )&#125; 12. 写一个按照下面方式调用都能正常工作的 sum 方法12console.log(sum(2, 3)) // Outputs 5console.log(sum(2)(3)) // Outputs 5 13. 据下面的代码片段回答后面的问题12345678for (var i = 0; i &lt; 5; i++) &#123; var btn = document.createElement('button') btn.appendChild(document.createTextNode('Button ' + i)) btn.addEventListener('click', function() &#123; console.log(i) &#125;) document.body.appendChild(btn)&#125; 没啥难度，不说了 15. 下面的代码会输出什么？为什么？123456console.log(1 + '2' + '2')console.log(1 + +'2' + '2')console.log(1 + -'1' + '2')console.log(+'1' + '1' + '2')console.log('A' - 'B' + '2')console.log('A' - 'B' + 2) 这个主要考察的隐式转换，规则太多太复杂了，我也记不住，如果真有面试官问你这个的话，随缘吧。 16. 解释下列代码的输出1234console.log('0 || 1 = ' + (0 || 1))console.log('1 || 2 = ' + (1 || 2))console.log('0 &amp;&amp; 1 = ' + (0 &amp;&amp; 1))console.log('1 &amp;&amp; 2 = ' + (1 &amp;&amp; 2)) 运算符优先级的问题，这题同上，遇到就随缘吧，我反正搞不清也记不住。 17. 解释下面代码的输出12console.log(false == '0')console.log(false === '0') ==和===的区别，太基础略。 18.移动端问题 1. 你怎么提高一个长列表在手机端滑动的流畅度这里主要考察的是否知道 passive这个属性首先解释一下为什么会卡顿： 当你触摸滑动页面时，页面应该跟随手指一起滚动。而此时你绑定了一个 touchstart 事件，你的事件大概执行 200 毫秒。这时浏览器就犯迷糊了：如果你在事件绑定函数中调用了 preventDefault，那么页面就不应该滚动，如果你没有调用 preventDefault，页面就需要滚动。但是你到底调用了还是没有调用，浏览器不知道。只能先执行你的函数，等 200 毫秒后，绑定事件执行完了，浏览器才知道，“哦，原来你没有阻止默认行为，好的，我马上滚”。此时，页面开始滚。 题外话，这里也可以考察你对addEventListenerapi 的熟练度，很多人其实不知道addEventListener其实第三个参数除了可以传true or false，还可以传一个对象。 12345&#123; capture: Boolean, // 表示`listener`会在该类型的事件捕获阶段传播到该`EventTarget`时触发 once: Boolean, // 表示`listener`在添加之后最多只调用一次。如果是`true`，`listener`会在其被调用之后自动移除 passive: Boolean, // 表示`listener`永远不会调用`preventDefault()`。如果`listener`仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告&#125; 拓展：will-change 、pointer-events 19.用 setTimeout 实现 setIntervalrender props 和 HOC 的区别 purecomponent 柯里化 高阶函数 尾调用 vue 3.0 proxy Object.defineProperty 原因 线上版本回退 发布流程 开发生产环境区分 调试 dokder 持续集成 babel-polyfil babel-plugin-transform-runtime babel-preset-env htttp2 有哪些优势，对于前端来说会有什么影响？ 设计一个登录系统 es6 私有方法 WeakMap 顺序存储结构与链式存储结构的比较（也可以说的顺序表与链表的比较） HOC(高阶组件)和 Decorator(装饰器)的区别是什么？ 如何使用一个 Decorator 来修饰一个函数? https://github.com/sunyongjian/blog/issues/32 iOS 下 input 无法自动聚焦的问题 手写实现以下事件委托函数 function delegate(parent, selector, handle) {} 手写实现 inherit 函数 手写实现 throttle 函数 请解释 XSS 与 CSRF 分别是什么，两者有什么联系？如何防御？ 手写代码实现一下 Array.prototype.trim 这个函数，并写个测试用例跑给我看下 面向切面编程和函数式编程听说过吗 图灵完备理论知道吗？关于图灵的其他知识知道吗？ 如果一系列操作数据的规则（如指令集、编程语言、细胞自动机）可以用来模拟单带图灵机，那么它是图灵完备的。图灵机由以下几个部分组成： 一条无限长的纸带 TAPE。 一个读写头 HEAD。 一套控制规则 TABLE。 一个状态寄存器。 图片懒加载的两种实现形式 如何实现图片懒加载； 如何提高图片懒加载的效率； PWA 的原理； 如何写一个 PWA； getBoundingClientRect 方法的弊端； 前端性能优化有哪些； 静态资源加载和更新的策略； CDN 服务器的了解和使用；缓存静态资源的注意事项； history 路由和 hash 路由的区别, 在浏览器有什么影响； http 1.1 与 http 2 的区别； 遇到过什么 Webpack 上的坑； 什么是虚拟 DOM； 为什么虚拟 DOM 的操作比 DOM 更快； 谈一下你对 MVVM 的认识； 谈一下你对 Vue 的认识，以及 Vue 底层实现的机制； 写一个自定义事件系统，实现 on、off、emit API，要求可以同时触发多个事件，也可同时取消多个事件 使用 requestAnimationFrame 实现类似 setInterval 的计时器 实现一个类似百度的搜索框，就是一边输入内容，一边在一个下拉列表显示搜索结果，需要考虑哪些问题？ file-loader 和 url-loader 区别 淘宝 P6 前端要求，比较泛的能力描述，供参考： 掌握程序设计的一般性原则，能正确应用设计模式 提炼可复用组件，为类库贡献高质量代码；至少掌握一门后端语言，并有相关的开发使用经验 理解程序内部原理，能快速定位解决疑难杂症；通过开发、使用、推广效率工具让自己与团队的效率得到提高 有效跟进，能独立计划实施复杂项目，过程监控，有预案，保证结果 有效传达思想观念信息，把握别人的意图立场，快速与别人达成共识 积极的学习，并学以致用，甚至突破经验与常规思维方式，引入新的方法，流程等 精通各种前端技术（包括 HTML/CSS/JavaScript 等），熟悉 ES6 语法，具备跨终端（Mobile+PC）的前端开发能力，熟悉网络协议（HTTP/SSL），熟悉常见安全问题和对策； 熟悉前端工程化与模块化开发，并有实践经验（如 gulp/webpack、VueJS/React 等）； 熟悉 NodeJS，并有实践经验；熟悉一门非前端的语言（如 Java/C/C++ 等），加分； 有桌面客户端相关开发经验（如 Electron/VSCode Plugin 等），加分； 熟悉 TypeScript，并有较大项目实践经验，加分； 有独立的开源项目或者参与知名开源项目经验，加分； 百度阿里网易大疆等大小厂前端校招面筋 如何轻松拿到淘宝前端 offer]]></content>
  </entry>
  <entry>
    <title><![CDATA[面试题]]></title>
    <url>%2F2019%2F06%2F13%2Fyuque%2F%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[TIP你的简历是自己工作的答卷，项目经历是你给面试官出的考纲。所以，我的面试一定是与我的简历、工作经历相关的，一些面试题并不一定适用于任何人，但是你可以从中了解他们考察的点，以及侧重点。基础知识可以查漏补缺。 前端工程师手册30-seconds-of-interviewsfront-end-interview-handbook33-js-concepts33-js-concepts 中国国情版Git 飞行规则 看了这个常规的 git 应该没什么问题了node-interviewNode.js-Troubleshooting-Guide Node.js 应用线上/线下故障、压测问题和性能调优指南手册2018 大厂高级前端面试题汇总Daily-Interview-Question 每天一道前端大厂面试题https://github.com/forthealllight/blog/issues想成为一个好的前端工程师，光有强大的编程能力是远远不够的，还有很多软知识需要知道。学会与人沟通。前端是一个承上启下的工作，在实际业务之中你除了要面对代码之外还需要对接 UI、产品、后端和其它前端有时候经常也会和运营啊广告销售打交道。因此怎么与其他角色很好的沟通也是一个非常重要的能力，代码写的再好，但不满足需求也是白搭。需求明确再动手；发现问题尽快解决；意见分歧不要拒绝沟通；学会换位思考，不要总站在自己的角度想当然； 华尔街见闻面试题请先 fork 本项目，之后按照题目规则，完成功能之后，请不要依赖任何外部框架。 页面中有一个 ul列表，里面有 20 个 li，和若干个其它元素：div，需要实现一个功能，点击任何一个 li都会 alert hello world，点击其它元素没反应 在线demo 注意：请在在线 demo 的基础上进行修改， 在第一题的基础上进行修改，现在点击任何 li需要 alert 它的位置，即 它的 index，第一个 li alert(1)，第二个 alert(2)，以此类推 需要实现一个功能，每过 1s，往列表的末端添加新的5 个li元素，并且li的内容是它的位置，并且当页面的 li 个数超过 50 个时，停止添加。 请根据设计稿，写成相应的静态页面，并且有如下要求 根据 api 拉取列表数据 可以使用 Vue、React 或者任何框架还原页面 需要自适应 适配 PC 和 Mobile 最后一个 item 不需要下划线 点击任何一个 item alert 它的 title title 超过两个需要省略超出部分 对 Node.js 的看法 算法 OSI 七层协议？ http 和 https 有什么区别？ https 使用上有什么注意点？ https 和 http 性能有什么区别？ 常见的排序方法，你都熟悉那些？ 说下希尔排序的过程？ 希尔排序的时间复杂度和空间复杂度多少？（ 希尔排序的时间复杂度是：O（nlogn）～ O（n2），平均时间复杂度大致是 O(n√n)） 时间复杂度怎么推测的？ 数据结构你对那些比较熟悉？ 二叉树是什么啊？ 平衡二叉树（AVL）有什么特点？ 平衡二叉树（AVL）有什么好处？ 平衡二叉树（AVL）和红黑树的区别？ 平衡树的插入和删除的时间复杂度？ 怎么实现 短链？ 设计模式https://juejin.im/post/5c2e10a76fb9a049c0432697设计模式定义：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。通俗一点来讲就是在某种特定场合下对某个问题的一种解决方案。所有的设计模式的实现都遵循一条原则，‘找出程序变化的地方，并将变化封装起来’。 设计原则设计本身是为了提高代码可利用性，增加可维护性，符合以下的原则： 单一原则：永远不应该有多于一个原因来改变某个类。当我们做系统设计时，如果发现有一个类拥有了两种的职责，那就问自己一个问题：可以将这个类分成两个类吗？如果真的有必要，那就分吧。千万不要让一个类干的事情太多！ 开放封闭原则：软件实体，如：类、模块与函数，对于扩展应该是开放的，但对于修改应该是封闭的。当需求有改动，要修改代码了，此时您要做的是，尽量用继承或组合的方式来扩展类的功能，而不是直接修改类的代码。当然，如果能够确保对整体架构不会产生任何影响，那么也没必要搞得那么复杂了，直接改这个类吧。 最少知识原则（迪米特原则）：尽量减少对象之间的交互，从而减小类之间的耦合。简言之，一定要做到：低耦合，高内聚。 里氏转换原则：在使用基类的的地方可以任意使用其子类，能保证子类完美替换基类。 接口隔离原则：一个类与另一个类之间的依赖性，应该依赖于尽可能小的接口。不要对外暴露没有实际意义的接口 依赖倒转原则：引用一个对象，如果这个对象有底层对象，直接引用底层对象，比如可以直接用小桶打水，就没必要引用大桶向大桶灌水再用大桶。单例模式应用场景：全局唯一模态框，登录注册。 延伸：单例懒加载 定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。策略模式应用场景：计算不同绩效的工资，表单验证 将计算逻辑或者验证逻辑的算法单独封装。 定义：一系列的算法，将它们一个个封装起来，并且使它们可以相互替代。代理模式应用场景：图片懒加载(proxyImage),代理缓存，代理合并请求 定义：一个对象提供一个代用品或占位符，以便控制对它的访问。迭代器模式定义：提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。发布-订阅模式应用场景：DOM 事件系统(addEventListener)，网站登录系统 定义：又叫观察者模式，它定义了对象间的一种一对多的依赖关系。当一个对象的状态发生变化时，所有依赖它的对象都将受到通知。 延伸：订阅不同事件，订阅离线缓存命令模式组合模式模板模式延伸：好莱坞原则享元模式定义：核心是运用共享技术来有效的支持大量颗粒度的对象，常用于性能优化。 延伸：对象池职责链模式定义：避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，知道有一个对象处理它为止。 例子：手机商城-是否有 500 打折券-&gt;200 打折券 -&gt;有库存…，aop，上传组件适配 html5=&gt;flash=&gt;xxx中介者模式定义：作用是解除对象与对象之间的紧耦合关系，所有的相关对象都通过中介者对象来通信装饰者模式状态模式适配器模式定义：作用是解决两个软件实体间的接口不兼容问题。常规面试题 网络面试题 React面试题 VUE面试题]]></content>
  </entry>
  <entry>
    <title><![CDATA[文章收集]]></title>
    <url>%2F2019%2F06%2F13%2Fyuque%2F%E6%96%87%E7%AB%A0%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[说明主要是用来收集汇总平时看过得一些不错的文章，方便日后查找 Vue手摸手，带你用 vue 撸后台 系列一(基础篇)手摸手，带你用 vue 撸后台 系列二(登录权限篇)手摸手，带你用 vue 撸后台 系列三 (实战篇)手摸手，带你用 vue 撸后台 系列四(vueAdmin 一个极简的后台基础模板)手摸手，带你封装一个 vue component手摸手，带你优雅的使用 icon 前端Press Enter to Submit 背后的那些事Webnovel 国际化实践Things I Don’t Know as of 2018The TypeScript Tax: A Cost vs Benefit Analysis 主要讲 ts 收益，具有一定可读性TypeScript 解决了什么痛点？ 比较中肯的一个答案，做技术不要盲目跟风 GraphQLGraphQL 核心概念RPC vs REST vs GraphQLWhy use GraphQL, good and bad reasons 职业发展一个程序员的成长之路 张云龙大佬的文章，强推！！值得反复阅读。开发者如何在「技术+管理」的路上越走越宽？蔡志忠：努力是没有用的 视频计算机科学速成课 计算机科学基础的系列视频，很不错，浅显易懂，看完这四十节课能多计算机世界有一个大概的整体认知。 其它前端人工智能？TensorFlow.js 学会游戏通关谈谈 WebSocket https://zhuanlan.zhihu.com/p/37171897 小程序只需两步获取任何微信小程序源码 挺有意思的一篇文章 node基于 node.js 的脚手架工具开发经历 How to build a CLI with Node.js 网络什么是 RPC 框架？前端技术清单关于 JavaScript 单线程的一些事从零开始开发一款属于你的 Visual Studio Code 插件 AST平庸前端码农之蜕变 — AST]]></content>
  </entry>
  <entry>
    <title><![CDATA[网站]]></title>
    <url>%2F2019%2F06%2F13%2Fyuque%2F%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[常看的网站 awesome-f2e-libs sorrycc 整理的个人关注使用的前端库 overreacted react Dan 的个人博客，更新频率很高 DailyJS codeburst Github github 短域名服务 shields Github README 里面的装逼小图标 Emoji 方便平时写查找 emoji emoji.muan 同上 而且更全 git-awards github ranking 没事可以查着玩玩 http://githubrank.com/ github 按照 followers 排名 github-rank同上，githubrank 基本算挂了已经，只能用这个新的 star-history 展示一个项目 Stars 增长规矩曲线 probot 基于 github 做一个小机器人。可以做很多 workflow 的事情 开发 can i use 前端常用网站了 查看不同属性和方法的兼容性 Squoosh 谷歌出品在线免费图片压缩工具 神器 codesandbox-client - 在线 web 开发容器 astexplorer - 一个在线 ast 生成器 30 seconds of code 收集了许多有用的代码小片段 zeplin 前端和设计师神器，有标注、Style Guide、版本管理、简单的团队协作，重点是前端不用写 css 了，复制就可以了。 iconfont 阿里出的图标库，非常实用，支持 svg、font、png 多种格式，基本现在所有图标都在上面找。 cssicon 所有的 icon 都是纯 css 画的 缺点：icon 不够多 智图 腾讯出品 在线图片压缩 支持转成 webP 处理静态图片时候很好用 picdiet 另一个图片压缩网站 CSS triangle generator 帮你快速用 css 做出三角形 cssarrowplease 帮你做对话框三角的 clippy 在线帮你使用 css clip-path 做出各种形状的图形 Regular Expressions 在线正则网站 jex 正则可视化网站，配合上面的 Regular Expressions，写正则方便很多 jsfiddle 在线运行代码网站 很不错，可惜要翻墙 codepan 在线运行代码网站 不用翻墙，可以自己部署 fiddle.md 一个方便的在线共享 markdown 在线笔试题一般都用这个 jsdelivr cdn 服务 unpkg cdn 服务 coderpad 远程面试的神器，可以让面试者远程写代码 不过需要翻墙 icode 有赞团队出品的 coderpad 可以互补，它不需要翻墙 codeadvice 又一个让面试者远程写代码的网址 snipper 一个代码协同的网站。你新建一个代码片段，然后把网址分享给其他人，就可以看到他们的实时编辑。 codesandbox 一个可以在线编辑且提供在线 demo 的网站 支持 vue react angular 多种框架 神器 codrops 上面的交互都非常酷炫 bgremover 在线图片去底工具 photopea 一个网页端 Photoshop 很变态 bestofjs 查看一个项目增长经历，Star 数变化的网站，辅助你判断这个库的质量 stackblitz 一款在线 IDE,主要面向 Web 开发者,移植了很多 VS Code 的特性与功能 programmingfonts.org 一个专门介绍编程字体的网站 早报 一个个人开发者的前端开发的分享日报 emoji-search 帮你快速找到能表达你情感的 emoji gitmoji 通过 emoji 表达 git 的操作内容 starcharts 可以把你一个项目的 stars 增长轨迹当做 svg 放在 readme 中 mockapi 一个还不错的在线 mock 服务（可在线可视化编辑），可以满足大部分简单需求了 coder 在线版 VS Code browserstack 远程调整各种版本浏览器 兼容性问题 carbon 根据源码生成图片 主要作用是让你打代表片段分享的时候更好看一点 clipboard2markdown 将你所有复制进去的内容都转化为 markdown grammarly 英语写作检查工具 quickchart 通过 URL 生成图表的开源服务 hipdf 一站式在线 PDF 解决方案 whimsical 画路程图 Lorem Picsum 提供免费的占位图 sm.ms 免费图床 设计 https://www.photopea.com/ Photopea,高级图片编辑器 uimovement 能从这个网站找到不少动画交互的灵感 awwwards是一个一个专门为设计精美的网站以及富有创意的网站颁奖的网站 dribbble 经常能在上面找到很多有创意好看的 gif 或者图片，基本上我所有的图都是上面招的 Bēhance dribbble 是设计师的微博，Bēhance 是设计师的博客 Logojoy 使用 ai 做 logo 的网站，做出来的 logo 质量还不错。 brandmark 另一个在线制作 logo 网站 instant 又一个 logo 制作网站 logo-maker 又一个 logo 制作网站 这个更简单点 就是选模板之后微调 coolors 帮你在线配色的网站 你能找到不少配色灵感 colorhunt 另一个配色网站 uigradients 渐变色网站 designcap 在线海报设计 Flat UI 色表 Flat UI 色表 0to255 颜色梯度 Ikonate 提供免费的图标 icons remixicon 又一个提供免费图标 icons feather 免费的 icons nord 北欧性冷淡风主题配色 Unsplash 提供免费的高清图片 colorkitty 从你的图片中提取配色 有趣 帮你百度一下 可以 点我测试一下- 国际版 同帮我百度一下-点我测试一下- wallhaven 壁纸网站- URL 地址播放 Emojis 动画 在地址栏里面播放 emoji Can’t Unsee 强烈建议前端、客户端、UI 开发的同学玩下，检查一下自己对设计稿的敏感度怎么样 ggtalk 平时一直在听的一个技术博客 awesome-comment 里面收集了很多有趣的代码注释 text-img 都将图片转化为 ascii 用来写注释 weird-fonts 将普通字母转化为 特殊 unicode snake 在地址栏里面玩贪吃蛇 交互 微交互 里面收集了市面上很多很好的微交互例子 值得学习 Little Big Details 同上，一个国外微交互汇集网站 cruip 登录页的各种页面设计，可以免费下载模板 Comixify 一个波兰团队做了非常好玩的工具，可以把视频自动转成漫画，上图是他们提供的 demo，效果很棒。 taiko-web 太鼓达人网页版 只能说很 6 Csscss-tricks 一个学习 css 不错的网站 有很多有意思的 demo 教程 npx 教你怎么合理的使用 npx hacksplaining 网络安全学习网站 产品 产品大牛 什么有很多完整的产品原型可以借鉴 磨刀 快速出 ui 原型 实用 typeform 一个国外的在线调查问卷网站 Talk peerigon-talks 收集了不少有意思的 talks 算法 leetcode 用 js 刷 leetcode ### PC UI https://baidu.github.io/amis/一种基于特定 JSON 格式生成 MIS 页面的工具 http://fis.baidu.com/ 简单页面制作 https://github.com/fex-team/fis fis git 源码 UmiJS 可插拔的企业级 react 应用框架。]]></content>
  </entry>
  <entry>
    <title><![CDATA[推荐库]]></title>
    <url>%2F2019%2F06%2F13%2Fyuque%2F%E6%8E%A8%E8%8D%90%E5%BA%93%2F</url>
    <content type="text"><![CDATA[太常用的一些库，比如 lodash、axios、echarts、normalize.css等就不再下面推荐了。这里主要推荐一下自己平时常用，提高效率的，但大家可能又不知道的一些库。 前端常用 sweetalert2 一个自适应，且自定义性强的弹出框（零依赖） tippy.js 最著名的 tooltip/popover library text-mask 可以让 input 按照规则输入(如电话,email,日期,信用卡等)，特殊格式 input dinero.js 用来创建、计算和格式化货币价值的不可变的框架，支持国际化 lerna 大项目版本控制工具，项目中可以有多个 package.json 文件 img-2 一个提高图片加载性能和体验的库，懒加载使用 web worker 模糊预览 fingerprintjs 是一个快速的浏览器指纹库，通浏览环境的一系列配置生成 id ajv 一个 json schema 验证的库 dayjs 一个轻量级类 moment.js API 时间库 primjs 让页面支持代码高亮 ReLaXed 一个将 document html 转成 PDF 的工具 uppy 一个很好看的也很好用的 前端上传库 Filepond 一个小巧的文件上传库 tui-calendar 功能全面的日程安排日历控件，还支持拖拽 tui.editor markdown 所见即所得编辑器 tabler - 基于 Bootstrap 4 的 Dashboard UI Kit 和美观 高颜值 ui 模板 pulltorefresh.js - 下个下拉刷新插件 lulu - 腾讯阅文基于 jQuery，针对 PC 网站 IE8+（peak 主题）的前端 UI 框架 chancejs - 生成随机数据的库 spritejs - 360 奇舞团出的跨平台绘图对象模型 workbox - 让你的网站更方便的变成 pwa tui.image-editor - 一个功能齐全的在线图片编辑，基于 canvas nanoid - 前端轻量 unique string ID 生成库 rxdb - 一款开源的快速、灵活的客户端数据库，支持各种浏览器以及 NodeJS，Electron、React 等等，是 PouthDB 之上的一个封装库 percollate - 命令行工具 能将网页转换成 pdf rawact - 一个 babel 插件，把 react 组件转为原生 dom irondb - 是一个浏览器 key-value 储存的封装库，把 Cookies、IndexedDB、LocalStorage、SessionStorage 统一成一个接口。它的最大特色就是数据冗余机制，即使某种底层储存机制失效，它可以从其他机制恢复数据。 big.js 解决 js 浮点数问题。 主要就是 Big Number 或者小数点温柔 bignumber.js - 同上 stickybits - CSS 的 position: sticky 是一个很有用的设置，但是老的浏览器不支持。这个 JS 库是该功能的垫片库。 react-jsonschema-form - Mozilla service 开源了一个通过 JSON 直接生成表单的 React 组件 cleave.js - 用于在输入时格式化输入内容（信用卡格式、日期等） shiny - 在手机设备上模拟光的反射效果。 支持 DeviceMotion 事件 cloudquery - Turn any website to serverless API A-Programmers-Guide-to-English - 专为程序员编写的英语学习指南。 rrweb - 一个可以记录你页面中所有操作的库 nodeppt - markdown 写 ppt flexsearch - 能让你更加高效和快速的检索文本内容 public-apis - 汇集了市面上一些对外免费开放的 api，做一些自己练手 app 的时候很好用。 scroll-hint 用于提示用户页面可以左右滑动的一个提示库 fuse.js 轻量级前端模糊查询库 非常的好用 FileSaver.js 文件下载插件 很多时候下载会有兼容性问题，它能帮你解决这些问题 instant.page 一个判断用户行为 预测提前加载页面的库 screenfull.js 浏览器全屏插件 解决了不少兼容性问题 VuePress 本网站就是基于它实现的，简单方便的静态网站生成器 selection 可视化选择页面元素的库 scroll-out 滚动效果（滚动视差）的框架，框架大小不到 1KB,使用回调的方式将相关动画元素的属性进行实时分配 gpu.js 通过将 js 转为特定的 language，利用 GPU 来执行，大大提高了执行性能和速度 pressure 前端实现 3D Touch hammer 移动端手势库 AlloyFinger 腾讯出的手势库 lowdb LowDB 是一个本地 JSON 数据库，基于 Lodash 开发的 JSON-server 可以配合 LowDB 使用 快速搭建一个 REST API lunr.js 是个用于浏览器的轻量级 JavaScript 全文搜索引擎,对于一些小型的博客、开发者文档或 Wiki 网站来说,完全可以通过它实现站内离线搜索 he 一个前端 encoder/decoder 库 grade 一个可以根据你的 图片 调整底色的插件 pretty-bytes 将字节转换成可以读的字符串，比如 1337 个字节，会显示成 1.34 KB Css &amp;&amp; 动画 animate.css 最有名的动画效果库 magic.css css 动画效果库 类似 animate.css popmotion 一个函数式声明前端动画库 NES.css 任天堂主题风格 css 库 particles.js 前端实现颗粒粒子的动画效果库，比较炫酷，但相对的也比较吃性能 PaperCSS 手绘风格感觉 css 库 rough 基于 Canvas 的手绘风格图形库 wired-elements 基于 rough.js 分装 button input radio 等组件。它的底层是 Web components matter-js web 物理引擎 micron 通过在元素上绑定属性从而实现动画效果的库 direction-reveal 根据鼠标进入位置，展现从不同方向 展现 hover 效果 laxxx 滚动特效库 轻量级 压缩完 2kb cssfx 优雅的 CSS 动画效果，开箱即用 zdog 3D engine 引擎 Vue vue-multiselect select 组件 目前 vue 里面用过最好用的 Vue.Draggable DnD 拖拽组件 基于 Sortable.js 的 vue 版本 vue-sauce 一个可以展示 vue 源码的指令 vue-smooth-dnd Vue wrappers components for smooth-dnd vuegg 一个 vue 可视化拖拽界面生成器 vee-validate 基于 vue 的验证，能验证的内容比较全 vuesax 一个很漂亮的基于 vue 的 ui 框架 vue-analytics 基于 vue 的 谷歌统计封装 vue-virtual-scroller 基于 vue 的虚拟列表无限滚动 vue-content-placeholders 页面龙骨 skeleton 实践库 Jasonette 一个用 json 来构建 hybrid App 的框架 crate 一个 react 全栈练习(pc,mobile,rn,api) demo，适合入门拿来练手 react-in-patterns 一本开源教你如何写 react 的书 hocs react 相关 hoc 收集库 工具库 live-server 可以快速启一个本地 dev 服务 并且支持自动刷新的 http server serve - 快速起本地静态服务 picojs js 人脸识别库 es-checker 检查当前环境对 ES6 支持的情况。支持浏览器和 node.js merge-images 图片合成，利用canvas能将几张图片合成一张 fabric.js 基于 canvas 创建交互式的图片编辑界面非常适合用来做图片合成类工作。 phaser 这是一个为桌面和移动浏览器开发 HTML5 游戏的快速开源框架。 你可以为 iOS、 Android 和不同的本地应用程序创建游戏。 purifycss 移除没使用到的 css dropcss 同上 fast-cli 命令行测试下载上传速度 @pika/web 让你不需要在本地 webpack 中 import，直接在游览器里面运行 npm 包 pinyin 汉字拼音转换工具 JavaScript Obfuscator Tool js 代码混淆工具 tesseract 图像识别，它能识别图片中的文字，支持中文 gka 一款高效、高性能的帧动画生成工具。只需一行命令，快速图片优化、生成动画文件，支持效果预览。 recast 前端 ast 库 jscodeshift 将 js 内容解析成 AST 语法树，然后提供一些便利的操作接口，方便我们对各个节点进行更改 stats.js 前端性能监控 如 FPS、内存使用情况等 PapaParse 解析 csv excel Node consola 优雅的命令行 console vuepress 也使用了它 cheerio - 用类 jQuery 语法处理 HTML chokidar - node 监听文件变化的库 fs-extra - fs-extra 模块是系统 fs 模块的扩展，提供了更多便利的 API，并继承了 fs 模块的 API rimraf - 删除文件 globby - 用于模式匹配目录文件 glob - 文件查找 tiny-glob - 文件查找 node-semver - node 版本验证库 npm-run-all - 一个 CLI 工具可以并行或者串行执行 script live-server - 一个简单的 http server 带有 reload 功能 node-portfinder - 一个端口嗅探工具 update-notifier - Update notifications for your CLI app. cli 升级提醒工具 y18n - yargs 基于 i18n 的一个包 signale - Hackable console logger 一个 Node 的日志格式库，自带 16 个级别，可以定制颜色和 Emoji execa - A better child_process listr - Terminal task commander.js - 自动的解析命令和参数，合并多选项，处理短参，等等，功能强大，上手简单 Inquirer.js - A collection of common interactive command line user interfaces. 命令行询问库 enquirer - 命令行 prompt 询问库，写 cli 的时候很有用 Qoa 同上 ora - Elegant terminal spinner 命令行 loading chalk - 命令行着色美化库 hygen - 快速方便的创建代码 可以命令行创建预设的 template ndb - node 调试 got - http 请求库 如果你觉得 request 太多的话 这是一个不错的选择 dumper.js - 能让你的 node console 更加的规整，方便调试 node-in-debugging - node.js 调试指南 node-best-practices - node 最佳实践 fastscan - node 敏感词库 fx - 命令行优化 JSON 输出 dataloader - 解决 Graphql 中的 N+1 查询问题 progress-estimator - 命令行 progress bar 进度条模拟库 Node.js 最佳实践 grpc-web - 前端直连 gRPC 服务 node-fetch - node 环境下轻量级 fetch 请求库 ink 是一个 React 的命令行渲染器，命令行界面可以像写页面那么写了 strapi 开源的解决方案来创建、部署和管理自己的 API listr Terminal task list dotenv 通过.env 设置环境部变量 vue-cli 也依赖它 GraphQL prisma - 让前端也能快速的写出 Apollo GraphQL - 是基于 GraphQL 的全栈解决方案集合。从后端到前端提供了对应的 lib 使得开发使用 GraphQL 更加的方便 有趣 the-bread-code - 使用程序员的思维制作面包 ，比如制作中使用 A/B test, 来比较那种做法更好。 build-your-own-x - 教你用各种语言实现 Bot Database Neural Network javascript-algorithms - 教你用前端知识认识各种算法 not-paid - 如果你给人做网站，交过去以后对方没有付款，那么这个 JS 会把网站的透明度一天调低一点，直到看不见 nsfwjs - 前端图片鉴黄，基于 Tensorflow elevator.js 我很喜欢的一个库，让一个 back-to-top 的效果有了一种坐复古电梯的感觉 app-ideas 很多年轻人苦于缺少练手的项目，这个项目收集了不少点子，每个点子都有明确的目标和复杂资源。 WebGL-Fluid-Simulation 很酷的 WebGL 交互 工具 high-speed-downloader - 百度网盘不限速下载 支持 Windows 和 Mac hyper - 前端命令行 yapi - 是一个可本地部署的、打通前后端及 QA 的、可视化的接口管理平台 sway - 一个微软自己出的在线 ppt 很强大 bigjpg - 放大图片的神器 通过神经网络可以放大图片并能降噪 Ascii Art Generator - 在线生成 Ascii 图案 Winds - 开源 RSS JSUI - 一个用来控制管理前端项目的客户端 docz - 让你能快速写文档的一个库 hiper - 性能统计分析工具 verdaccio - 私有 npm git-guide - git 入门指南 git-tips - git 进阶 bit - 实现了项目之间的代码共享 可以自建私有 simpread - 简悦 ( SimpRead ) 让你瞬间进入沉浸式阅读的扩展 mkcert - 一键命令 让本地也支持 https termtosvg - 录制 命令操作转成 svg 基于 python gh-polls - 可以在 github issue 中添加投票 eruda - 移动端调试工具 vConsole - 也是一个移动端调试工具 腾讯出品 terminalizer - 命令行录制工具 基于 node badgen - 快速构建和 shields 一样的 svg badge 但速度更快 readability - 移除页面非正文部分 基于 jsdom WeChatPlugin-MacOS - 一款功能强大的 macOS 版微信小助手 puppeteer-recorder - 一个 chrome 插件 能够根据你的操作 自动生成 puppeteer 相关代码 mdx-deck - 用 markdown 编写演示文稿 code-surfer - 基于 mdx-deck 的一个插件 让你更好的在文稿中展示 code Progressive Tooling - 前端性能优化工具集合 https://github.com/artf/grapesjs - 可视化建站工具 不需要写代码就能写一个页面，前端再次再次要下岗了 image-charts - 该服务通过 URL 接受参数，然后生成图表，以图片形式返回 eagle.js - 一个用 vue 来制作 PPT 的库 Optimizely - A/B Test appadhoc - 一个国内的 A/B Test 服务 glorious-demo - 通过编写代码的方式构建一个命令行的演示例子 nginxconfig - 可视化配置 nginx 提供了多个基础模板 bundlephobia - 一个可以查看某个库的大小，并且分析它的依赖 jsperf - 一个提供在线 test case 的网站，主要用来比较性能。可以比较如： forEach vs for 的性能 perflink 与 jsperf 类似的一个比较 js 性能的网站 algorithm-visualizer - 算法代码可视化 An-English-Guide-for-Programmers - 专为程序员编写的英语学习指南 Webhint - 用于检查代码的可访问性、性能和安全的开源检查（Linting）工具 airtap - 测试浏览器兼容性，可覆盖 800 多种浏览器 jsonstore - 供免费，安全且基于 JSON 的云数据存储，自己玩的小项目神器 git-history - 可视化查看一个文件的历史变化 x-spreadsheet 一个基于 Canvas 的 JS 电子表格库 excel imgcook 阿里出品，一键通过设计稿生成代码 majestic jest 可视化 leon 你开源项目的 ai 个人助手 js-code-to-svg-flowchart 将代码逻辑用流程图的方式展现出来 Webpack webpackbar webpack 打包进度可视化 jarvis webpack dashboard webpack-chain 通过 chain 风格 api 的方式修改 webpack 配置 speed-measure-webpack-plugin 探测 webpack 各阶段的耗时 obsolete-webpack-plugin 基于 browserslist 做浏览器升级提示 mini-css-extract-plugin 提取 CSS 为单独文件 copy-webpack-plugin 复制额外的文件到输出目录 duplicate-package-checker-webpack-plugin 检查是否存在重复依赖 Mac get-plain-text - 能清除剪贴板里的格式 很实用 IINA - mac 平台感觉免费最好的播放器 强推 magnet - 分屏管理 Xnip - 方便好用的截图工具-支持截长图 Spectacle - 窗口管理工具 vanilla - 顶栏图标管理工具 Dozer - 一个开源的顶栏管理 腾讯电脑管家 - 反正我用下来好觉得蛮好用的 mos - 鼠标平滑滚动软件，很好用。免费开源 sequel pro - mysql 客户端 好用 Microsoft Remote Desktop Beta - Mac 远程登录 Windows 调试神器 pap.er - 专为 Mac 设计的壁纸应用 The Unarchive - Mac 目前感觉最好用的免费解压软件 Tickeys - 让你用 Mac 键盘也能打出机械键盘的感觉 Beaker Browser - P2P 开源浏览器 支持点对点发布文件，成为了文件传输工具，支持 DAT 对等协议 Gifski - 视频转 gif 工具 more - 更多优秀的 mac app 介绍 Motrix - 支持 HTTP、FTP、BT、磁力链、百度网盘的下载工具 Chrome 拓展 Tampermonkey 油猴 神器 扩展管理器 轻松管理扩展，就不用担心安装太多扩展了 visbug 它可以帮助你改变 css，移动元素等等一系类强大的功能,页面调试神器。当然有些时候还是 DevTools 更好用 refined-github 优化 github 默认功能和样式的 chrome 插件 ADB chrome 真机调试安卓神器 Adblock Plus 免费广告拦截程序 这个应该不用说了，装机必备 Axure RP Extension 看原型必备 JSON Formatter JSON 格式化 程序员必备 Lighthouse 谷歌出品，检查网页综合性能评分，分析不足 二维码(QR 码)生成器 手机扫码神器 Octotree github 上看代码必备神器 OctoLinker 能在 github 上看代码的时候 快速链接跳转到依赖的库 The Great Suspender chrome 太吃内存了，当页面开的很多时候会很卡，它就完美的解决了这个问题。它将几分钟没浏览过的页面都挂载了，当你想看是再重新加载 WEB 前端助手 支持 JSON 格式化、二维码生成与解码、代码压缩、Markdown 与 HTML 互转、网页滚动截屏、正则表达式、时间转换工具、JSON 比对工具等 掘金 目前我默认新开 tab 的默认页，可以刷刷新的文章或者项目，还不错。 沙拉查词 划词翻译插件 npmhub在 README 下方显示 npm 依赖信息 #VS Code Import Cost 查看你引入的依赖模块大小 Auto Close Tag 自动补全 html 标签，如输入将自动补全 Auto Rename Tag 自动重命名 html 标签，如修改为，将自动修改结尾标签为 polacode 生产代码图片快照插件 vscode-leetcode - 一个能让你在 vscode 中刷 LeetCode 的插件 算一个划水神器吧 vscode-icons VS Code 必备吧，为文件添加炫图标 工程 lerna - monorepo 管理。 lerna-changelog - 为 lerna 项目自动生成 changelog。 eslint - JS 风格约束。 eslint-config-airbnb xo - 封装自 eslint。 prettier - 更主观的风格自动修改。 yeoman-generator - 脚手架工具。 serve - 本地静态服务器。 np - npm publish 辅助，自动 push、打 tag、升版本等。 lint-staged - eslint 提速，只 lint 提交的代码。 coveralls - 覆盖率。 husky - 添加 git hooks。 cross-env - 跨平台的环境变量声明。 projj - 本地 git 项目管理，支持 github 和 gitlab。 nvm - 管理 node 版本。 concurrently -在 npm scripts 里并行执行命令。 @zeit/ncc - 打包为 npm 包为一个文件。 npm-check - 检测依赖升级情况，我会和 yarn upgrade-interactive 配合着用，主要用来检测冗余依赖。 cpx - 复制，支持 glob，并且可以 watch。 onchange - 监听文件变动然后做一些事。 常看的网站]]></content>
  </entry>
  <entry>
    <title><![CDATA[素材网站收集]]></title>
    <url>%2F2019%2F06%2F13%2Fyuque%2F%E7%B4%A0%E6%9D%90%E7%BD%91%E7%AB%99%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[干货01—PPT素材全搜罗]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSS]]></title>
    <url>%2F2019%2F06%2F13%2Fyuque%2FCSS%2F</url>
    <content type="text"><![CDATA[占位图 Css&amp;&amp;动画 animate.css 最有名的动画效果库 magic.css css 动画效果库 类似 animate.css popmotion 一个函数式声明前端动画库 NES.css 任天堂主题风格 css 库 particles.js 前端实现颗粒粒子的动画效果库，比较炫酷，但相对的也比较吃性能 PaperCSS 手绘风格感觉 css 库 rough 基于 Canvas 的手绘风格图形库 wired-elements 基于 rough.js 分装 button input radio 等组件。它的底层是 Web components matter-js web 物理引擎 micron 通过在元素上绑定属性从而实现动画效果的库 direction-reveal 根据鼠标进入位置，展现从不同方向 展现 hover 效果 laxxx 滚动特效库 轻量级 压缩完 2kb cssfx 优雅的 CSS 动画效果，开箱即用 zdog 3D engine 引擎 KulerKuler是在线色彩工具的典范。有数千个出色的预置色彩模板可供选择，你也可以利用这款既先进又好用的工具来生成自己的模板。kuler from adobe - Color:https://color.adobe.com/zh/create PiknikPiknik是地球上最基本的色彩工具之一，绝对是我的至爱之一。只需轻轻移动鼠标去改变颜色，滚动一下改变亮度，然后点击复制数值到粘贴板上，大功告成矣。做网站的时候，我每天都用它来为颜色选用找感觉，包括它看起来会如何、如果覆盖整个屏幕效果会怎样、做幻灯片用哪个颜色好等等。 0to2550to255也是我的至爱之一，是寻找颜色变化的一款非常震撼的工具。这让它在设计网站的边界和悬浮（hover）效果时表现出色，但你同样可以用它来为PPT的排版或其他要素寻找重点色。]]></content>
  </entry>
  <entry>
    <title><![CDATA[ppt制作]]></title>
    <url>%2F2019%2F06%2F13%2Fyuque%2Fppt%E5%88%B6%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[PPT排版https://www.zhihu.com/question/29386330/answer/79692944 PPT像电影一样流畅？这5招带你入门MG动画 色彩灵感来源https://zhuanlan.zhihu.com/p/41077780在前面的 里提到过一个网站pictogram2.com提供各种人形素材，而这些素材均有矢量文件下载，因此可以随下随用在Behance.net上看到过大神Rutger PauJusse的每日C4D练习，立刻就被这种风格吸引了～虽然整体只采用一种搭配，却显得十分和谐自然。 精选15个PPT制作网站，收藏好，别丢了 pptfans.cn 不仅有海量的模板，还有各种级别的视频教程。很适合初学者来丰富自己的素材库。 *NO.1 officeplus *微软官方在线模板网站，模板比较丰富，内容花样多，可以来学习一波。 **叮当设计 **全网站总共1037的模板，全部免费下载。 **present **这是一个全球的网站，内容比较丰富，设计水平比较高端，缺点就是需要付费够买。一些对内容要求比较高的可以看一下。 *演界网 *yanj.cn 国内原创ppt模板网站，有大量的免费图表分享给大家使用。有一部分需要付费，免费的就可以满足我们的普通需求啦。 *逼格 *tretars.com 这是一个个人博客网站，逼格高，在发模板的同时还有一些ppt小技巧教程，图文结合，写的挺不错。 *优品 *ypppt.com 这个网站内容分类比较清晰，直接搜索自己所需要的模板内容就能找到。内容质量都挺高，免费。 *雷锋 *lfppt.com 有着海量的ppt，分类比较明确。需要哪个点哪个就完事。 *扑奔 *pooban.com 内容极其丰富，图表免费的居多，但是有些优质模板都需要200个积分才可以下载。 *无忧ppt *网站如其名字，搜集了很多的ppt模板，完全免费，内容质量也不错，就是网站广告有点多。 ppt宝藏** **pptbz.com 内容比较丰富，但是质量参差不齐，有缺点，网站分类不太明确，不能够想要什么点什么，适合上网浏览，收集模板，免费。 **500丁 **内容都是优质的，质量也比较高，有一些简历模板，都是收费的，适合大佬使用。 **变色龙 **和500丁一样，质量也都挺高。内容更是不得了，不仅分类明确，而且全面。同样全部收费，适合大佬使用。 ppt之家 **压轴**的来啦，内容全面，质量高。文章、教程、图表、背景、素材、应有尽有。重点是免费下载，只需要关注一下人家的公众号就可以了。 http://yanshuo.io/演说 NO.2 slidemodel 国外的PPT模板网站，网站绝大部分的PPT都是图标或者图形类型的，而且还添加了地图类型的ppt模板，虽然这些都是需要付费订阅，但网站每周会提供150个免费的ppt模板，注册后均可下载。 NO.3 presentationmagazine 网站模板内容非常齐全，大部分的模板都可以免费使用，还免费提供一些制作 PPT 时所用到背景元素，如果你在PPT的制作过程中遇到什么困难，可以在网站的官方论坛上提出来， NO.4 slidehunter 4000个完全免费ppt模板网站，不管你做什么工作，都能在网站中找到相应的 PPT 模板，有趣的是网站还提供3D类型的 PPT，感兴趣的朋友可以去了解一下。 NO.5 AllPPT 网站设计简洁大方，种类也比较齐全，并且还有4；3的模板下载，如果你不会 PPT，他们还提供了 PPT 学习网站，以及免版权的图片使用网站，该网站每周会更新30个精美的ppt模板提供下载。 PPT审美训练营 ： https://www.zhihu.com/question/39233528/answer/390237175 PPT遥控器：http://ppt.baidu.com/ PPT 插件： iSlide iSlide 是一款基于 PowerPoint 的插件工具，即便您不懂设计，也能简单、高效地创建各类专业PPT演示文档。拥有近数十万 PPT 模板，而且还会持续更新。你可以快速检索、一键插入PPT 。另外，使用 iSlide 智能图表可以让数据变得直观易懂！目前 ，iSlide 已经全面支持微软 Office 以及金山 WPS。 口袋动画 口袋动画分为盒子版和专业版。盒子版是 PPT 小白专属工具；专业版是 PPT 进阶级变身，无论使用哪个版本，都能让你快速制作出媲美 AE 特效水准的 PPT 动画。同时它还拥有一键美化功能，覆盖片头、片尾、图表等多场景动画，还有各种组合、单一动画。仅需一键下载，既可替换元素，生成酷炫动画展示页。目前这款插件同时支持微软 Office 和金山 WPS 。 OneKeyTools OneKeyTools 简称 “OK插件” 或 “OK” ，是一款免费开源的 PPT 设计辅助插件。功能覆盖形状、图片、调色、表格、图表、音频、辅助等领域。目前支持微软 Office 2013 及以上版本。 PPT 美化大师 PPT 美化大师拥有海量在线模板素材。专业模板、精美图示、创意画册、实用形状等，细致分类，内容也会持续更新。最大的特点是支持一键全自动智能美化，让精美的 PPT变得简单起来。同时，它还支持将 PPT 一键生成不能复制、修改的只读格式。目前，PPT 美化大师都支持微软 Office 和金山 WPS 。 ispring suite 作为教师或者课程开发者，我们可能会有制作在线课程的需要，而这款名为 ispring suite 的 PPT 插件可以帮你把普通的 PPT 演示文档转换为适合在 Windows、Mac、iPad、iPhone、Android 等多种平台独立使用的在线课程。你可以将 PPT 生成为 H5 或者 Flash ，也可以集成为 exe 格式的软件或者 MP4 视频。目前这款插件并不支持 WPS ，适配微软的 Office 2007 及以上版本。 查看这里：https://topbook.cc/overview 1、Note &amp; Point Note &amp; Point2、Stock XCHNG stock.xchng - the leading free stock photography site3、Lauren Tucker Wheat Field In Newton-St-Loe4、色彩理论 Basic color schemes: Color Theory Introduction5、三个工具：KulerPiknikOto255 PPT动画基于软件工具开发3D素材网站：free3d.com画图神器：Paint 3D 寻找模型（Paint3D+Remix3D）：在较新的win10版本，系统里已经自带了Paint3D这项APP，通过可以直接进行建模。如果没有找到，可以至MS Store下载：画图 3D - Microsoft Store3D模型逆天新功能全剧透： https://zhuanlan.zhihu.com/p/30860481PPT-3D使用教程：这一招，带你的PPT突破天际！C4d入门：零基础自学C4D？不妨从这里开始Focusky动画：Focusky动画演示大师：https://zhuanlan.zhihu.com/p/37336987 动画背景网站：1.videos.pexels.com2.Free HD Stock Video &amp; HD Video Clips3.Mazwai 好的动画网站或APPPPT中最酷的效果—3D模型全解 一懒再懒—好用到爆的PPT插件来自：有哪些让你相见恨晚的 PPT 制作技术或知识？https://www.zhihu.com/question/30018273/answer/3657817581_._全能选手-iSlide（原Nordri tools）2.动画爱好者福音—PA口袋动画3.排版/图片神器-OneKeyTools js/css 怎么制作动画版PPT，基于js Slides Revealjs http://hakim.se 可给ppt增加模版组件 一般需求用 http://slides.com 的服务应该能满足大部分场景。但如果需要内嵌脚本之类的，可能就不太够用了。可以手写 HTML/Markdown 然后用 reveal.js 来展示。 用Markdown写一个极客范儿的PPThttps://www.jianshu.com/p/e063303317cb这个需要一定的程序基础才可以进入 前端大神都用什么做PPT？ yanshuo.io nodeppt slides.com 声响 impress.js http://demo.orbitale.io/easy_impress/ http://parhumm.github.io/presentation-learning-to-design/ http://pkoperek.github.io/bytecode-presentation/#/title reveal.js - The HTML Presentation Framework 此外reveal.js还提供了可视化编辑的功能，不会写代码也能带你装逼带你飞哦 prezi.com]]></content>
  </entry>
  <entry>
    <title><![CDATA[vim]]></title>
    <url>%2F2019%2F06%2F13%2Fyuque%2Fvim%2F</url>
    <content type="text"><![CDATA[Vim 有什么奇技淫巧？ Vim实用插件推荐 笨方法学Vimscript面向那些想学会如何自定义Vim编辑器的用户。 Mac开发配置手册 安装macvimmac预装了vim，但官方的 vim 在 Mac 上只有一个很不完善的，长期没人维护的 Carbon 图形用户界面。macvim 主要是在此基础上添加了一个完整的 Cocoa 用户界面，其核心部分和 vim 同步。MacVim 采用了分离进程的方式，一个 MacVim 程序可以启动多个 vim 进程，每个显示在一个 MacVim 窗口中，这是官方的 vim 和其他平台下的 gvim 所不支持的。MacVim 还支持很多 Mac OS X 原生的界面特性，比如工具栏、滚动条、全屏显示、Mac 菜单快捷键的绑定等。 12345# 查看预装vim版本vim --version# 查看预装vim路径where vim 安装有两种方式来安装macvim: Github上下载macvim.dmg安装包进行安装 使用Homebrew安装 https://aaaaaashu.gitbooks.io/mac-dev-setup/content/Homebrew/index.html 这也是我们所采用的方式： 1brew install macvim 建立软链接(这步可以不走)无论使用哪种方式进行安装，可以在MacVim.app包文件中找到mvim和vim的可执行文件，要在shell中方便的执行这些命令，可以： 将可执行文件所在路径添加到环境变量$PATH中 将可执行文件复制到环境变量$PATH中的某一个路径下； 在$PATH中的某一个路径下创建该可执行文件的软/硬链接； 为可执行文件设置别名，并添加到配置文件中（/.bash_profile或/.zshrc）； 这里推荐在/usr/local/bin目录下为mvim软链接的方式。同时，mac预装vim版本过低，推荐使用MacVim.app包中的vim将其替代,如果想同时保留原来预装的/usr/bin/vim中的vim，可以通过创建别名来将其“覆盖”掉。 12345678910111213# 将可执行文件所在路径添加到环境变量`$PATH`中，单引号内的字符会原样输出echo 'export PATH=/usr/local/Cellar/macvim/8.0-133/MacVim.app/Contents/bin:$PATH' &gt;&gt; ~/.zshrc# 或将可执行文件mvim复制到/usr/local/bin/路径下cp /usr/local/Cellar/macvim/8.0-133/MacVim.app/Contents/bin/mvim /usr/local/bin/mvim# 或者在/usr/local/bin/路径中为mvim建立软链接ln -s /usr/local/Cellar/macvim/8.0-133/MacVim.app/Contents/bin/mvim /usr/local/bin/mvim# 为macvim中的vim创建别名，将其添加至~/.zshrc配置文件echo 'alias vim="/usr/local/Cellar/macvim/8.0-133/MacVim.app/Contents/MacOS/vim"' &gt;&gt; ~/.zshrc# 重新加载.zshrc以使修改生效 source ~/.zshrc 安装验证终端输入vim，终端vim显示如下:终端输入mvim，弹出GUIvim如下： 配置文件在vim启动过程中，首先将查找配置文件并执行其中的命令，而这些初始化文件一般有vimrc、gvimrc和exrc三种。通过:version命令可以查看vim的配置文件信息： 配置文件的位置vim的配置文件有全局和用户两种版本，分别存放于$VIM和$HOME目录中，用户配置文件默认是没有的，必要时由用户自己在$HOME目录下创建。可以使用:echo命令查看他们的路径，使用:e命令进入目录： 12345:echo $VIM/usr/local/Cellar/macvim/8.0-133/MacVim.app/Contents/Resources/vim:echo $HOME/Users/fangcao vimrc是vim最常用的配置文件 gvim是Gvim的配置文件 exrc仅用于向后兼容olvi/ex；除非你使用vi-compatible模式，否则不需要关注exrc配置文件 配置文件的加载顺序(这步也可以不用)可以通过:scriptname查看各脚本的加载顺序: 12345678910111213141: /usr/local/Cellar/macvim/8.0-133/MacVim.app/Contents/Resources/vim/vimrc 2: ~/.vimrc 3: /usr/local/Cellar/macvim/8.0-133/MacVim.app/Contents/Resources/vim/runtime/syntax/syntax.vim 4: /usr/local/Cellar/macvim/8.0-133/MacVim.app/Contents/Resources/vim/runtime/syntax/synload.vim 5: /usr/local/Cellar/macvim/8.0-133/MacVim.app/Contents/Resources/vim/runtime/syntax/syncolor.vim 6: /usr/local/Cellar/macvim/8.0-133/MacVim.app/Contents/Resources/vim/runtime/filetype.vim 7: /usr/local/Cellar/macvim/8.0-133/MacVim.app/Contents/Resources/vim/runtime/menu.vim 8: /usr/local/Cellar/macvim/8.0-133/MacVim.app/Contents/Resources/vim/runtime/autoload/paste.vim 9: /usr/local/Cellar/macvim/8.0-133/MacVim.app/Contents/Resources/vim/runtime/ftoff.vim 10: ~/.vim/bundle/Vundle.vim/autoload/vundle.vim ...... 85: /usr/local/Cellar/macvim/8.0-133/MacVim.app/Contents/Resources/vim/gvimrc 86: ~/.gvimrc ...... 可以看到：macvim在启动时会依次加载全局vimrc&gt;&gt;用户.vimrc&gt;&gt;全局gvimrc&gt;&gt;用户.gvimrc，而终端vim在启动既不加载gvimrc也不加载.gvimrc也就是说： 用户配置文件中的配置会覆盖全局配置文件的配置；因此，我们可以通过创建~/.vimrc来修改vim的默认配置。 对GUIvim，gvimrc会覆盖vimrc中的配置；因此，我们可以通过创建~/.vimrc使终端vim和GUIvim拥有不同的配置。此外，GUIvim支持更多扩展，有些功能在终端vim中无法使用。创建用户配置文件 1234# 切换至用户目录cd ~# 使用mvim创建并打开.vimrcmvim .vimrc 编辑配置文件1234可以使用以下命令，新建缓冲区来编辑配置文件：:edit $MYVIMRC也可以使用以下命令，新建标签页来编辑配置文件：:tabedit $MYVIMRC 当然也可以使用任何其他文本编辑器打开配置文件进行编辑。 应用配置文件修改配置文件后，需要重新启动Vim，或使用:source命令来应用新的设置： 1:source $MYVIMRC 我们可以在配置文件中增加以下命令，在保存后自动应用配置： 1autocmd bufwritepost .vimrc source $MYVIMRC 配置文件基本配置 显示中文帮助 下载vimdoc 将文件解压到~/.vim/doc，若路径不存在则自己创建 打开vim执行:helptags ~/.vim/doc 在~/.vimrc中进行配置： 12345set helplang=cn if version &gt;= 603 set helplang=cn set encoding=utf-8endif 没有完毕转自：https://www.jianshu.com/p/923aec861af3]]></content>
  </entry>
  <entry>
    <title><![CDATA[JsBridge]]></title>
    <url>%2F2019%2F06%2F12%2Fyuque%2FJsBridge%2F</url>
    <content type="text"><![CDATA[整个流程就是Native和Js两端各准备一个bridge，Native的bridge提供modules，js的bridge注册Native提供的modules。这就是bridge存在的意义–提供一个桥梁，让两边通信。 简单来说，只需要两步，第一简历桥连接，第二注册方法： 123456789101112131415161718192021222324252627function setupWebViewJavascriptBridge(callback) &#123; if (window.WebViewJavascriptBridge) &#123; return callback(WebViewJavascriptBridge); &#125; if (window.WVJBCallbacks) &#123; return window.WVJBCallbacks.push(callback); &#125; window.WVJBCallbacks = [callback]; var WVJBIframe = document.createElement('iframe'); WVJBIframe.style.display = 'none'; WVJBIframe.src = 'wvjbscheme://__BRIDGE_LOADED__'; document.documentElement.appendChild(WVJBIframe); setTimeout(function () &#123; document.documentElement.removeChild(WVJBIframe) &#125;, 100)&#125;function connectWebViewJavascriptBridge(callback) &#123; if (window.WebViewJavascriptBridge) &#123; callback(WebViewJavascriptBridge) &#125; else &#123; document.addEventListener( 'WebViewJavascriptBridgeReady' , function () &#123; callback(WebViewJavascriptBridge) &#125;, false); &#125;&#125; 兼容安卓ios 12345678910111213141516171819if (navigator.userAgent.match(/(iPhone|iPod|iPad);?/i)) &#123; //ios setupWebViewJavascriptBridge(function (bridge) &#123; bridge.callHandler(funcName, data,callback ); &#125;);&#125; else if (navigator.userAgent.match(/android/i)) &#123; connectWebViewJavascriptBridge(function(bridge) &#123; if(window.WebViewJavascriptBridge)&#123; window.WebViewJavascriptBridge.callHandler( funcName , data, callback ); &#125;else&#123; bridge.callHandler(funcName, data, callback); &#125; &#125;);&#125; else &#123;&#125; Android 初次加载是需要初始化 1bridge.init(function(message, responseCallback) &#123;responseCallback(data)&#125;); h5调用nativeiOS在setupWebViewJavascriptBridge里注册android在connectWebViewJavascriptBridge里注册 1bridge.callHandler(funcName, data, callback); native调用js 12bridge.registerHandler(funcName, function(responseData, responseCallback) &#123;&#125;); 概念1、H5，即是html5，超文本标记语言，用于描述网页内容结构的语言，网页编程中由它有负责描述页面数据和信息2、JS，即是JavaScript，广泛用于web应用开发中的脚本语言，负责响应用户的操作，为网页添加动态功能3、native APP，即传统的原生APP开发模式，Android基于Java语言，底层调用Google的 API；iOS基于Objective-C或者Swift语言，底层调用App官方提供的API4、Hybrid App，即原生和web的混合开发模式，由原生提供统一的API给js调用，实现跨平台的效果 交互方式 第一种为H5与native的基本通讯方式 说是基本通讯方式是因为由native自身的组件进行通讯的，这里需要区分为android和iOS，两端的组件实现有差异 基本通讯方式汇总 iOS通过官方提供的库文件JaveScriptCore来实现交互，可以脱离webview直接运行js android是通过addJavascriptInterface开放统一的api给js调用，实现交互，但具有安全性问题，版本4.2之前addJavascriptInterface接口引起安全漏洞，可被反编译获取Native注册的js对象，在页面通过反射Java的内置静态类，获取一些敏感的信息和破坏。 第二种H5与native交互方式为JSBridge原理 JSBridge是H5代码与native代码之间的一个通讯桥梁，是广为流行的交互理念。目前的统一实现流程是：H5触发url scheme–&gt;native捕获url scheme–&gt;原生分析并执行–&gt;原生调用H5，如下图： URL scheme，是一个URL最初始的位置，即://之前的那段字符，如baidu.com的scheme为http；根据我们上面对URL scheme的使用，我们可以理解，H5通过某种方式如iframe触发scheme，然后Native用某种方法捕获对应的url触发事件，根据定义好的协议，分析当前触发了哪种方法，然后根据定义来执行。比如短信，就是sms：，比如微信，就是weixin所以JSBridge交互本质就是通过webview的代理拦截url scheme，然后注入相应的JS，从而实现交互，目前我们公司使用的是第三方开源库WebViewJavascriptBridge，下面我们来讲讲这个通讯桥梁。 实现流程 首先在H5代码注入js代码块 1234567891011121314151617181920212223242526272829303132333435function setupFH5JsBridge(callback) &#123; var ua = navigator.userAgent.toLowerCase(), isiOS = ua.match(/(iphone|ipod|ipad);?/i), isAndroid = ua.match("android"); if (isAndroid) &#123; if (window.FH5JsBridge) &#123; window.FH5JsBridge.initBridge(callback); &#125; else &#123; document.addEventListener( "FH5JsBridgeReady", function() &#123; window.FH5JsBridge.initBridge(callback); &#125;, false ); &#125; window.WebViewJavascriptBridge = window.FH5JsBridge; &#125; else if (isiOS) &#123; if (window.WebViewJavascriptBridge) &#123; return callback(WebViewJavascriptBridge); &#125; if (window.WVJBCallbacks) &#123; return window.WVJBCallbacks.push(callback); &#125; window.WVJBCallbacks = [callback]; var WVJBIframe = document.createElement("iframe"); WVJBIframe.style.display = "none"; WVJBIframe.src = "wvjbscheme://__BRIDGE_LOADED__"; document.documentElement.appendChild(WVJBIframe); setTimeout(function() &#123; document.documentElement.removeChild(WVJBIframe); &#125;, 0); &#125;&#125;setupFH5JsBridge(function(bridge) &#123;&#125;); or我们项目里是这样： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153function nativeApp() &#123; var App = &#123; callbacks: &#123;&#125; &#125;, slice = Array.prototype.slice; /** * 常量定义 */ var ua = navigator.userAgent.toUpperCase(); // 当前环境是否为Android平台 App.IS_ANDROID = ua.indexOf("ANDROID") != -1; // 当前环境是否为IOS平台 App.IS_IOS = ua.indexOf("IPHONE OS") != -1; // 当前环境是否为WP平台 App.IS_WP = ua.indexOf("WINDOWS") != -1 &amp;&amp; ua.indexOf("PHONE") != -1; App.IS_YZT = /One Account (IOS|Android)/gi.test(ua); App.callbacks.__leftAction__ = function() &#123; var haveLeftAction = typeof App.callbacks.leftAction === "function", args = slice.call(arguments); if (haveLeftAction) &#123; setTimeout(function() &#123; App.callbacks.leftAction.apply(App.callbacks, args); &#125;, 0); if (App.IS_ANDROID) &#123; App.call(["called"]); &#125; else if (App.IS_IOS) &#123; return true; &#125; &#125; &#125;; //=======================Native 相关================================ var callindex = 0, isFunc = function(name) &#123; return typeof name === "function"; &#125;, isObj = function(name) &#123; return typeof name === "object"; &#125;; /** * 调用一个Native方法 * @param &#123;String&#125; name 方法名称 */ App.call = function(name) &#123; // 获取传递给Native方法的参数 var args = slice.call(arguments, 1); var successCallback = "", errorCallback = "", item = null, returnArg; var methodName = name[name.length - 1]; if (App.IS_YZT) &#123; if (App.IS_ANDROID) &#123; if (window.HostApp) &#123; var newArguments = []; for (var i = 0; i &lt; args.length; i++) &#123; if (isFunc(args[i])) &#123; var callbackName = methodName + "Callback" + callindex; window[callbackName] = args[i]; newArguments.push(callbackName); callindex++; &#125; else if (isObj(args[i])) &#123; newArguments.push(JSON.stringify(args[i])); &#125; else &#123; newArguments.push(args[i]); &#125; &#125; // 之所以要重新调用，是因为Android 初始化HostApp可能晚于JS调用。 try &#123; HostApp[methodName].apply(window.HostApp, newArguments); &#125; catch (e) &#123; // TODO 这里应该走Mock functions var params = slice.call(arguments, 0); setTimeout(function() &#123; App["call"].apply(window.App, params); &#125;, 300); &#125; &#125; else &#123; var params = slice.call(arguments, 0); setTimeout(function() &#123; App["call"].apply(window.App, params); &#125;, 1000); &#125; &#125; else if (App.IS_IOS) &#123; var tempArgument = []; for (var i = 0; i &lt; args.length; i++) &#123; if (isFunc(args[i])) &#123; var callbackName = methodName + "Callback" + callindex; window[callbackName] = args[i]; tempArgument.push(callbackName); callindex++; &#125; else &#123; args[i] &amp;&amp; tempArgument.push(args[i]); &#125; &#125; callindex++; var iframe = document.createElement("iframe"); var _src = "callnative://" + methodName + "/" + (tempArgument &amp;&amp; tempArgument.length ? encodeURIComponent(JSON.stringify(tempArgument)) + "/" + callindex : ""); console.log(_src); iframe.src = _src; iframe.style.display = "none"; document.body.appendChild(iframe); iframe.parentNode.removeChild(iframe); iframe = null; &#125; else &#123; // WP 用户不支持。 Mock functions, 模拟H5 容器 console.warn("Tips: No available environment WP"); // Mock functions, 模拟H5 容器 for (var i = 0; i &lt; args.length; i++) &#123; if (isFunc(args[i])) &#123; args[i](&#123;&#125;); return; &#125; &#125; &#125; &#125; else &#123; console.warn("Tips: No available environment, NO YZT"); // Mock functions, 模拟H5 容器 for (var i = 0; i &lt; args.length; i++) &#123; if (isFunc(args[i])) &#123; args[i](&#123;&#125;); return; &#125; &#125; &#125; &#125;;&#125;window.AppAPI = nativeApp();AppAPI.call(["onGetShareData"], data);AppAPI.call( ["checkLoginStatus"], function(data) &#123; callback &amp;&amp; callback(SUCCESS, formatJSON(data)); &#125;, function(err) &#123; //do nothing callback &amp;&amp; callback(ERROR, err); &#125;, &#123;&#125;); JS端使用方式 native端需要进行注册对应的方法，H5才可以调用 Android注册方式如下: 1FH5JsBridge.registerHandler(bridgeWebView, handlerName, bridgeHandler); iOS端注册方式如下 12345678910111213/*** @param registerHandler 要注册的事件名称@param handel 回调block函数 当后台触发这个事件的时候会执行block里面的代码 ***/ [_bridgeregisterHandler:@"loginFunc" handler:^(id data, PAFFWVJBResponseCallbackresponseCallback) &#123; // data 后台传过来的参数,例如用户名、密码等 NSLog(@"testObjcCallback called:%@", data); //具体的登录事件的实现,这里的login代表实现登录功能的一个OC函数。 [self login]; // responseCallback 给后台的回复 responseCallback(res);&#125;]; H5调用方式如下 12FH5JsBridge.callHandler(methodName, 方法名options,对象 callback) 调用 Native API其中callback 统一接受一个参数json对象 H5常见的调用方法 打开native 页面，从H5页面跳转到某个原生页面 1void openAppPage(data,callback) --data 为&#123;pageName:''&#125; 获取会话token，H5登录区内的操作需获取原生的登录态 1void getSSOTicket(data,callback) 刷新会话，在一定的时间内刷新会话 1void refreshSession(data,callback) 打开原生App的安全键盘 1void openSafeKeyboard(data,callback) 打开分享，微信QQ等分享 1void share(data,callback) 设置临时存储数据，H5需要存储native的数据作为临时数据，退出APP后，临时数据清空 12void setData(data, callback)data 格式为&#123;key:"key", value: string &#125; 获取临时存储数据，获取临时存储的数据进行使用 12void getData(data, callback)data 格式为&#123;key:"key"&#125; 删除临时存储数据 12void removeData(data, callback)data格式为&#123;key:"key"&#125; 加载过程加载和互相调用]]></content>
  </entry>
  <entry>
    <title><![CDATA[学习的UP主收集]]></title>
    <url>%2F2019%2F06%2F12%2Fyuque%2F%E5%AD%A6%E4%B9%A0%E7%9A%84UP%E4%B8%BB%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[关注这些牛人，你可以丰富多彩 3Blue1Brown 对不少理工科学生来说，数学都是噩梦一般的存在。从线代到离散，从高数到数分，每一科都要耗费大量的时间和精力，让人想怒摔课本。为了人类的未来发展，3Blue1Brown 决心用动画讲述数学专业知识，其视频涵盖了线性代数、微积分、拓扑学等领域，每门课都配有直观生动的动画演示，帮助观众加深对数学概念定理的理解。3Blue1Brown 原作者毕业于斯坦福大学数学系，并在 Khan Academy 担任过数学讲师，专业性有所保障。如果你上网方式比较科学，也可以关注其 YouTube 账号，第一时间掌握其动态。 李永乐老师官方 如果你还是高中生，不妨关注李永乐老师官方这个 B 站账号。他任职于人大附中，取得了北京大学双学士学位，在物理和数学两大学科领域都颇有造诣。除了高中数学讲座外，他还会结合时事热点，推出《流浪地球》科普、金庸武侠的科学解释等视频，幽默风趣，寓教于乐。 田浅浅 田浅浅是一位人大本科生，高考排名全省前百，她的学习经验对文科生来说大有裨益。在她的个人投稿中，你可以找到文综答题技巧、练字方法、高效笔记术、期末复习技巧等，凝聚了一枚学霸的心血。 蜡笔和小勋 蜡笔和小勋 是一对浙大毕业的情侣，他俩上传的视频，除了狂撒狗粮外，就是自己学习的经验之谈了，例如提高记忆效率、自律和自制力、对付拖延症等。如果你想提高自己的成绩排名，看他们的视频准没错。 潘子Jane 潘子Jane 是一位清华大学在读研究生，她的 B 站账号为我们分享了诸多生活技巧和个人感悟，如学生党如何月入过万、快速背单词方法、考研历程分享等，都是过来人的经验之谈。此外，你也可以借她的视频窥见清华学生的日常生活，激励自己进取前行。 FanfaniShare FanfaniShare 是一位在美国高校教英文的中国女孩，她 TESOL 硕士全 A 毕业，在国内教过雅思口语和新概念课程，水平与母语者不相上下。你可以借助她的投稿视频练习英式口语、雅思写作、单词记忆等，并纠正错误的发音习惯，面对歪果仁也不怯场。 小圆脸Paprika 读书破万卷，下笔如有神，这句诗人人皆知，却非人人都能做到。如果你正面临不知看何书、又如何看书的困境，小圆脸Paprika 就可以帮到你。她会为我们定期分享最近出版的好书、个人读书的感触等，伴你一路前行。 oeasy 如果你想涉足设计领域，关注oeasy可以避免走许多弯路。作为中国传媒大学的计算机教师，他可谓是这一领域的全才，出品了 Photoshop、Illustrator、Office、视频编辑、动画制作乃至编程入门等教程，内容翔实易懂，广受好评，带你从零开始，成为大神。 doyoudo doyoudo 同样是一位设计教程分享 UP 主，不过其更侧重于技术在具体生活场景中的应用，如用 C4D 制作猫爪杯模型、用 Photoshop 制作表情包、用 Audition 制作鬼畜音频等，选题十分有趣，小白也能轻松跟上节奏。 影视飓风 随着智能手机的普及和人们对生活追求的提高，Vlog 这一表现形式受到了越来越多人的欢迎。如果你想拍摄属于自己的 Vlog，又不知从何下手，影视飓风 或许能帮上忙。它的视频涵盖了 Vlog 制作的方方面面，从拍摄前期的准备工作到拍摄过程中的布光技巧，乃至后期剪辑等专业知识，深入浅出。 左手plus 拍照人人都会，手机一举，快门咔嚓，就大功告成了。但想拍出一张好照片，却并不那么简单，如果你内心深处有一个摄影梦，关注 左手plus 准没错。你可以从他的视频中学到鲜为人知的摄影技巧、摄影器材选购知识、照片后期处理流程等，再也不怕给妹子拍照后被踹了。 Free从容 如果你想学一门乐器，吉他可以说是性价比最高的选择之一：价格实惠、易于上手、在聚会上小露一手还能收获喝彩无数。如果你的公司年会在即，不妨关注 Free从容 的 B 站账号，突击学习吉他的弹奏方法，成为全公司最靓的仔。 少数派sspai 少数派sspai 是国际知名科技媒体我派本派（本句收费五毛）的 B 站官方账号，专注于提高你的数字生活效率。在目前投稿的视频中，你可以了解 Windows 美化技巧、捷径使用指南、隐私保护秘笈、新鲜科技产品评测等，推荐大家关注。]]></content>
  </entry>
  <entry>
    <title><![CDATA[名人博客收集]]></title>
    <url>%2F2019%2F06%2F12%2Fyuque%2F%E5%90%8D%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[看过的博客收集地址 语雀AlloyTeam 腾讯全端 AlloyTeam 团队 Blog学习的 UP 主收集京程一灯程墨 Morgan我的兜兜有糖PanjiaChen云龙 http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1530517140411/Codelife.pdf小Z博客360准备的平台，众诚翻译—这个可以翻译文章发表博客https://www.smashingmagazine.com/https://overreacted.io/how-are-function-components-different-from-classes/ GMTC 2019 全球大前端技术大会]]></content>
  </entry>
  <entry>
    <title><![CDATA[GitHub Pages 建立个人网站详细教程]]></title>
    <url>%2F2019%2F06%2F12%2Fyuque%2FGitHub%20Pages%20%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[GitHub Pages是免费的静态站点，三个特点： 免费托管、 自带主题、 支持自制页面和Jekyll。 为什么使用github pages 搭建简单而且免费； 支持静态脚本； 可以绑定你的域名； DIY自由发挥，动手实践一些有意思的东西git,markdown,bootstrap,jekyll； 理想写博环境，git+github+markdown+jekyll； 创建github pages 安装git工具 http://windows.github.com/http://mac.github.com/ 2.两种pages模式 使用自己的用户名，每个用户名下面只能建立一个； 资源命名必须符合这样的规则username/http://username.github.com； 主干上内容被用来构建和发布页面 gh-pages分支用于构建和发布； 如果user/org pages使用了独立域名，那么托管在账户下的所有project pages将使用相同的域名进行重定向，除非project pages使用了自己的独立域名； 如果没有使用独立域名，project pages将通过子路径的形式提供服务http://username.github.com/projectname； 自定义404页面只能在独立域名下使用，否则会使用User Pages 404； 创建项目站点步骤： 123456$ git clone https://github.com/USERNAME/PROJECT.git PROJECT$ git checkout --orphan gh-pages$ git rm -rf .$ git add .$ git commit -a -m "First pages commit"$ git push origin gh-pages 可以通过User/Organization Pages建立主站，而通过Project Pages挂载二级应用页面。 创建步骤第一步：创建个人站点第二步：设置站点主题 常用命令123456789$ git clone git@github.com:username/username.github.com.git //本地如果无远程代码，先做这步，不然就忽略$ cd .ssh/username.github.com //定位到你blog的目录下$ git pull origin master //先同步远程文件，后面的参数会自动连接你远程的文件$ git status //查看本地自己修改了多少文件$ git add . //添加远程不存在的git文件$ git commit * -m "what I want told to someone"$ git push origin master //更新到远程服务器上 使用Jekyll搭建博客 1 什么是jekyllJekyll是一种简单的、适用于博客的、静态网站生成引擎。它使用一个模板目录作为网站布局的基础框架，支持Markdown、Textile等标记语言的解析，提供了模板、变量、插件等功能，最终生成一个完整的静态Web站点。说白了就是，只要安装Jekyll的规范和结构，不用写html，就可以生成网站。[jekyll介绍][jekyll on github][jekyllbootstrap]。Jekyll使用Liquid模板语言，表示文章标题， GitHub Pages是免费的静态站点，三个特点： 免费托管、 自带主题、 支持自制页面和Jekyll。 为什么使用github pages 搭建简单而且免费； 支持静态脚本； 可以绑定你的域名； DIY自由发挥，动手实践一些有意思的东西git,markdown,bootstrap,jekyll； 理想写博环境，git+github+markdown+jekyll； 创建github pages 安装git工具 http://windows.github.com/http://mac.github.com/ 2.两种pages模式 使用自己的用户名，每个用户名下面只能建立一个； 资源命名必须符合这样的规则username/http://username.github.com； 主干上内容被用来构建和发布页面 gh-pages分支用于构建和发布； 如果user/org pages使用了独立域名，那么托管在账户下的所有project pages将使用相同的域名进行重定向，除非project pages使用了自己的独立域名； 如果没有使用独立域名，project pages将通过子路径的形式提供服务http://username.github.com/projectname； 自定义404页面只能在独立域名下使用，否则会使用User Pages 404； 创建项目站点步骤： 123456$ git clone https://github.com/USERNAME/PROJECT.git PROJECT$ git checkout --orphan gh-pages$ git rm -rf .$ git add .$ git commit -a -m "First pages commit"$ git push origin gh-pages 可以通过User/Organization Pages建立主站，而通过Project Pages挂载二级应用页面。 创建步骤第一步：创建个人站点第二步：设置站点主题 常用命令123456789$ git clone git@github.com:username/username.github.com.git //本地如果无远程代码，先做这步，不然就忽略$ cd .ssh/username.github.com //定位到你blog的目录下$ git pull origin master //先同步远程文件，后面的参数会自动连接你远程的文件$ git status //查看本地自己修改了多少文件$ git add . //添加远程不存在的git文件$ git commit * -m "what I want told to someone"$ git push origin master //更新到远程服务器上 使用Jekyll搭建博客 1 什么是jekyllJekyll是一种简单的、适用于博客的、静态网站生成引擎。它使用一个模板目录作为网站布局的基础框架，支持Markdown、Textile等标记语言的解析，提供了模板、变量、插件等功能，最终生成一个完整的静态Web站点。说白了就是，只要安装Jekyll的规范和结构，不用写html，就可以生成网站。[jekyll介绍][jekyll on github][jekyllbootstrap]。Jekyll使用Liquid模板语言，{{page.title}}表示文章标题，{{content}}表示文章内容。我们可以用两种Liquid标记语言：输出标记（output markup）和标签标记 (tag markup)。输出标记会输出文本（如果被引用的变量存在），而标签标记不会。输出标记是用双花括号分隔，而标签标记是用花括号-百分号对分隔。[Liquid模板语言] [Liquid模板变量参考]。jekyll与github的关系：GitHub Pages一个由 GitHub 提供的用于托管项目主页或博客的服务，jekyll是后台所运行的引擎。 2 jekyll本地环境搭建1.下载最新的RubyInstaller并安装(我下载的是rubyinstaller-1.9.3-p194.exe)，设置环境变量，path中配置C:Ruby193bin目录，然后在命令行终端下输入gem update –system来升级gem；2.下载最新的DevKit，DevKit是windows平台下编译和使用本地C/C++扩展包的工具。它就是用来模拟Linux平台下的make,gcc,sh来进行编译。但是这个方法目前仅支持通过RubyInstaller安装的Ruby，并双击运行解压到C:DevKit。然后打开终端cmd，输入命令进行安装。3.完成上面的准备就可以安装Jekyll了,因为Jekyll是用Ruby编写的,最好的安装方式是通过RubyGems(gem): 1gem install Jekyll 并使用命令检验是否安装成功 1jekyll --version 4.安装Rdiscount，这个用来解析Markdown标记的包，使用如下命令： 1gem install rdiscount 5.运行本地工程：cd 到工程目录，启动服务： 1jekyll --server 3 jekyll目录结构 _posts：_posts中的数据文档，通过注入_layouts定义的模板，通过jekyll –server最终生成的静态页面在_sites目录。目录是用来存放你的文章的，一般以日期的形式书写标题。 _layouts：_layouts中的模板一般指向了_includes/themes中的模板。目录是用来存放模板的，在这里你可以定义页面中不同的头部和底部。 _includes： _includes/JB中有一些常用的工具，用于列表显示、评论等； _includes/themes中可参看主题的相关html文档。 _includes/themes中的主题一般包含default.html、post.html和page.html三个文档。default.html定义了网站的最上层框架（模板），post.html和page.html是其子框架（模板）。 生成好的html子页面通过default.html的{{ content }}变量调用，生成整个页面。assets渲染页面的CSS和JS文档在assets/themes中_config.yml站点生成需要用到_config.yml配置文件，站点的全局变量在_config.yml中定义，用site.访问；页面的变量在YAML Front Matter中定义，用page.访问，更多的模板变量可参考模板数据。index.html你的页面首页。Jekyll-Bootstrap创建博客 1.创建个人站点，即创建一个新资源，格式为http://username.github.com；2.安装Jekyll-Bootstrap： 1234$ git clone https://github.com/plusjade/jekyll-bootstrap.git USERNAME.github.com$ cd USERNAME.github.com$ git remote set-url origin git@github.com:USERNAME/USERNAME.github.com.git$ git push origin master 3.访问创建好的个人站点： http://username.github.com4.在本地测试查看效果： 1cd USERNAME.github.comjekyll --server 详细的教程看：http://jekyllcn.com/https://www.zhihu.com/question/30018945?sort=created 表示文章内容。我们可以用两种Liquid标记语言：输出标记（output markup）和标签标记 (tag markup)。输出标记会输出文本（如果被引用的变量存在），而标签标记不会。输出标记是用双花括号分隔，而标签标记是用花括号-百分号对分隔。[Liquid模板语言] [Liquid模板变量参考]。jekyll与github的关系：GitHub Pages一个由 GitHub 提供的用于托管项目主页或博客的服务，jekyll是后台所运行的引擎。 2 jekyll本地环境搭建1.下载最新的RubyInstaller并安装(我下载的是rubyinstaller-1.9.3-p194.exe)，设置环境变量，path中配置C:Ruby193bin目录，然后在命令行终端下输入gem update –system来升级gem；2.下载最新的DevKit，DevKit是windows平台下编译和使用本地C/C++扩展包的工具。它就是用来模拟Linux平台下的make,gcc,sh来进行编译。但是这个方法目前仅支持通过RubyInstaller安装的Ruby，并双击运行解压到C:DevKit。然后打开终端cmd，输入命令进行安装。3.完成上面的准备就可以安装Jekyll了,因为Jekyll是用Ruby编写的,最好的安装方式是通过RubyGems(gem): 1gem install Jekyll 并使用命令检验是否安装成功 1jekyll --version 4.安装Rdiscount，这个用来解析Markdown标记的包，使用如下命令： 1gem install rdiscount 5.运行本地工程：cd 到工程目录，启动服务： 1jekyll --server 3 jekyll目录结构 _posts：_posts中的数据文档，通过注入_layouts定义的模板，通过jekyll –server最终生成的静态页面在_sites目录。目录是用来存放你的文章的，一般以日期的形式书写标题。 _layouts：_layouts中的模板一般指向了_includes/themes中的模板。目录是用来存放模板的，在这里你可以定义页面中不同的头部和底部。 _includes： _includes/JB中有一些常用的工具，用于列表显示、评论等； _includes/themes中可参看主题的相关html文档。 _includes/themes中的主题一般包含default.html、post.html和page.html三个文档。default.html定义了网站的最上层框架（模板），post.html和page.html是其子框架（模板）。 生成好的html子页面通过default.html的 GitHub Pages是免费的静态站点，三个特点： 免费托管、 自带主题、 支持自制页面和Jekyll。 为什么使用github pages 搭建简单而且免费； 支持静态脚本； 可以绑定你的域名； DIY自由发挥，动手实践一些有意思的东西git,markdown,bootstrap,jekyll； 理想写博环境，git+github+markdown+jekyll； 创建github pages 安装git工具 http://windows.github.com/http://mac.github.com/ 2.两种pages模式 使用自己的用户名，每个用户名下面只能建立一个； 资源命名必须符合这样的规则username/http://username.github.com； 主干上内容被用来构建和发布页面 gh-pages分支用于构建和发布； 如果user/org pages使用了独立域名，那么托管在账户下的所有project pages将使用相同的域名进行重定向，除非project pages使用了自己的独立域名； 如果没有使用独立域名，project pages将通过子路径的形式提供服务http://username.github.com/projectname； 自定义404页面只能在独立域名下使用，否则会使用User Pages 404； 创建项目站点步骤： 123456$ git clone https://github.com/USERNAME/PROJECT.git PROJECT$ git checkout --orphan gh-pages$ git rm -rf .$ git add .$ git commit -a -m "First pages commit"$ git push origin gh-pages 可以通过User/Organization Pages建立主站，而通过Project Pages挂载二级应用页面。 创建步骤第一步：创建个人站点第二步：设置站点主题 常用命令123456789$ git clone git@github.com:username/username.github.com.git //本地如果无远程代码，先做这步，不然就忽略$ cd .ssh/username.github.com //定位到你blog的目录下$ git pull origin master //先同步远程文件，后面的参数会自动连接你远程的文件$ git status //查看本地自己修改了多少文件$ git add . //添加远程不存在的git文件$ git commit * -m "what I want told to someone"$ git push origin master //更新到远程服务器上 使用Jekyll搭建博客 1 什么是jekyllJekyll是一种简单的、适用于博客的、静态网站生成引擎。它使用一个模板目录作为网站布局的基础框架，支持Markdown、Textile等标记语言的解析，提供了模板、变量、插件等功能，最终生成一个完整的静态Web站点。说白了就是，只要安装Jekyll的规范和结构，不用写html，就可以生成网站。[jekyll介绍][jekyll on github][jekyllbootstrap]。Jekyll使用Liquid模板语言，{{page.title}}表示文章标题，{{content}}表示文章内容。我们可以用两种Liquid标记语言：输出标记（output markup）和标签标记 (tag markup)。输出标记会输出文本（如果被引用的变量存在），而标签标记不会。输出标记是用双花括号分隔，而标签标记是用花括号-百分号对分隔。[Liquid模板语言] [Liquid模板变量参考]。jekyll与github的关系：GitHub Pages一个由 GitHub 提供的用于托管项目主页或博客的服务，jekyll是后台所运行的引擎。 2 jekyll本地环境搭建1.下载最新的RubyInstaller并安装(我下载的是rubyinstaller-1.9.3-p194.exe)，设置环境变量，path中配置C:Ruby193bin目录，然后在命令行终端下输入gem update –system来升级gem；2.下载最新的DevKit，DevKit是windows平台下编译和使用本地C/C++扩展包的工具。它就是用来模拟Linux平台下的make,gcc,sh来进行编译。但是这个方法目前仅支持通过RubyInstaller安装的Ruby，并双击运行解压到C:DevKit。然后打开终端cmd，输入命令进行安装。3.完成上面的准备就可以安装Jekyll了,因为Jekyll是用Ruby编写的,最好的安装方式是通过RubyGems(gem): 1gem install Jekyll 并使用命令检验是否安装成功 1jekyll --version 4.安装Rdiscount，这个用来解析Markdown标记的包，使用如下命令： 1gem install rdiscount 5.运行本地工程：cd 到工程目录，启动服务： 1jekyll --server 3 jekyll目录结构 _posts：_posts中的数据文档，通过注入_layouts定义的模板，通过jekyll –server最终生成的静态页面在_sites目录。目录是用来存放你的文章的，一般以日期的形式书写标题。 _layouts：_layouts中的模板一般指向了_includes/themes中的模板。目录是用来存放模板的，在这里你可以定义页面中不同的头部和底部。 _includes： _includes/JB中有一些常用的工具，用于列表显示、评论等； _includes/themes中可参看主题的相关html文档。 _includes/themes中的主题一般包含default.html、post.html和page.html三个文档。default.html定义了网站的最上层框架（模板），post.html和page.html是其子框架（模板）。 生成好的html子页面通过default.html的{{ content }}变量调用，生成整个页面。assets渲染页面的CSS和JS文档在assets/themes中_config.yml站点生成需要用到_config.yml配置文件，站点的全局变量在_config.yml中定义，用site.访问；页面的变量在YAML Front Matter中定义，用page.访问，更多的模板变量可参考模板数据。index.html你的页面首页。Jekyll-Bootstrap创建博客 1.创建个人站点，即创建一个新资源，格式为http://username.github.com；2.安装Jekyll-Bootstrap： 1234$ git clone https://github.com/plusjade/jekyll-bootstrap.git USERNAME.github.com$ cd USERNAME.github.com$ git remote set-url origin git@github.com:USERNAME/USERNAME.github.com.git$ git push origin master 3.访问创建好的个人站点： http://username.github.com4.在本地测试查看效果： 1cd USERNAME.github.comjekyll --server 详细的教程看：http://jekyllcn.com/https://www.zhihu.com/question/30018945?sort=created 变量调用，生成整个页面。assets渲染页面的CSS和JS文档在assets/themes中_config.yml站点生成需要用到_config.yml配置文件，站点的全局变量在_config.yml中定义，用site.访问；页面的变量在YAML Front Matter中定义，用page.访问，更多的模板变量可参考模板数据。index.html你的页面首页。Jekyll-Bootstrap创建博客 1.创建个人站点，即创建一个新资源，格式为http://username.github.com；2.安装Jekyll-Bootstrap： 1234$ git clone https://github.com/plusjade/jekyll-bootstrap.git USERNAME.github.com$ cd USERNAME.github.com$ git remote set-url origin git@github.com:USERNAME/USERNAME.github.com.git$ git push origin master 3.访问创建好的个人站点： http://username.github.com4.在本地测试查看效果： 1cd USERNAME.github.comjekyll --server 详细的教程看：http://jekyllcn.com/https://www.zhihu.com/question/30018945?sort=created]]></content>
  </entry>
  <entry>
    <title><![CDATA[flutter]]></title>
    <url>%2F2019%2F06%2F12%2Fyuque%2Fflutter%2F</url>
    <content type="text"><![CDATA[一门跨全平台移动应用开发（这里主要是以Mac电脑来安装和开发） API:https://flutterchina.club/web-analogs/ 知乎flutter:https://zhuanlan.zhihu.com/p/65033883 安装过程：1.下载Flutter2.新建目录：/Users/fangcao/Documents/flutter_code3.将flutter安装程序放在flutter_code 12cd ~/flutter_codeunzip ~/Downloads/flutter_macos_v0.5.1-beta.zip 将flutter_macos_v0.5.1-beta.zip解压到flutter_code里面4.在～/.bash_profile目录里面加入：export PATH=pwd/flutter/bin:$PATH5.如果你的终端用了zshrc,就得：vim ~/.zshrc 最后添加 source ~/.bash_profile 这样全局的环境变量PATH安装成功 注意：google出的东西都需要翻墙下载，不过，这次google给我们提供了一个临时镜像，此镜像为临时镜像，并不能保证一直可用，读者可以参考详情请参考 Using Flutter in China 以获得有关镜像服务器的最新动态。 12export PUB_HOSTED_URL=https://pub.flutter-io.cn //国内用户需要设置export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn //国内用户需要设置 接着运行1flutter doctor 检查安装哪些依赖,该命令检查您的环境并在终端窗口中显示报告缺少的功能或者模块，它会给你提示，按照指示安装即可（一般ios和android软件安装配置完成即可，下面会讲解ios和android软件的安装和配置）。 该flutter工具使用Google Analytics匿名报告功能使用情况统计信息和基本崩溃报告。 这些数据用于帮助改进Flutter工具。Analytics不是一运行或在运行涉及flutter config的任何命令时就发送， 因此您可以在发送任何数据之前退出分析。要禁用报告，请执行flutter config –no-analytics并显示当前设置，然后执行flutter config。 请参阅Google的隐私政策。 在vscode里面的终端：发现没有flutter,就运行一下source ~/.bash_profile最后检查下echo $PATH 看看 是否已经添加到环境变量中 安装flutter插件安装后，flutter doctor检查一下。 发现要进行如下安装： 123456brew updatebrew install --HEAD usbmuxd brew link usbmuxd brew install --HEAD libimobiledevice brew install ideviceinstaller ios-deploy cocoapods pod setup 前端：vscode安装flutter，还要安装Dart sdk安卓：IOS:Xcode 详细步骤：Flutter macOS 开发环境搭建笔记 开始HelloWorld这里以最新的Dart2为主 1.安装dart:https://dart.dev/tutorials/web/get-started 12brew tap dart-lang/dartbrew install dart --devel 如果你需要开发 web 应用，则还需要安装 Dartium 和 Content Shell： 12$ brew tap dart-lang/dart$ brew install dart --with-content-shell --with-dartium 2.看看flutterSDK是不是最新的，如果不是，就升级FlutterSDK 1flutter upgrade 3.开启手机应用IOS： 1open -a Simulator Flutter 配置在 Android StudioAndroid Studio添加Flutter开发 如果发现报错了：1.flutter错误解决–Error running Gradle 错误 2.flutter\packages\flutter_tools\gradle打开文件进行修改，修改代码如下（其实也是换成阿里的路径就可以了）。这一步有两种情况1，flutter.gradle文件中repositories中是google() 和 jcenter()，repositories{google()gcenter()}把google() 和 jcenter()这两行去掉。改为阿里的链接。maven { url ‘https://maven.aliyun.com/repository/google&#39; }maven { url ‘https://maven.aliyun.com/repository/jcenter&#39; }maven { url ‘http://maven.aliyun.com/nexus/content/groups/public&#39; } 4.创建flutter程序 1234flutter create my_appcd my_appflutter runflutter -h 5.VScode中常用的快捷键R键：点击后热加载，直接查看预览效果P键：在虚拟机中显示网格，工作中经常使用O键：切换Android和IOS的预览模式Q键：推出调试预览模式 APP开启Xcode 9 —进阶的 iOS Simulator查询设备 选择运行在哪个模拟器上运行在安卓上运行在IOS上运行在所有设备上 开始组件讲解https://www.imooc.com/video/18530 123456789101112131415161718192021222324252627282930import 'package:flutter/material.dart';void main() =&gt; runApp(new MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Welcome to Flutter', home: Scaffold( appBar: AppBar( title: Text('Hello World'), ), body: Center( child: Text( 'Hello World,触发事件，在触发n秒后才执行，如果在触发时间的n秒内再次触发事件，那就以新的时间为准，n秒后才执行。总之，需要你在触发事件的n秒内不再触发新事件，我才执行。', textAlign: TextAlign.left, // maxLines: 2, // overflow: TextOverflow.fade, style: TextStyle( fontSize: 25.0, color: Color.fromARGB(120, 255, 0, 0), decoration: TextDecoration.underline, decorationStyle: TextDecorationStyle.solid), ), ), ), ); &#125;&#125; Flutter webhttps://dart.dev/web 如何评价 Flutter for Web？针对 Web 的 Flutter 框架的技术预览版：https://flutter.dev/webGithub 仓库：https://https://github.com/flutter/flutter_webter_web示例程序：https://https://flutter.github.io/samples/ Flutter for Web架构图https://dart.dev/tutorials/web/get-started 1.安装 Dart12$ pub global activate webdev$ pub global activate stagehand 2.安装 webdev 和 stagehand:Stagehand- A Dart project generator 12$ pub global activate webdev$ pub global activate stagehand 3.创建一个wep app1234mkdir quickstartcd quickstartstagehand web-simplepub get 获取包 4.运行app12webdev servewebdev serve --auto restart 加入了热重新加载 如果觉得webdev serve –auto restart 太麻烦，可以尝试 flutter pub global run webdev serve –auto restart 5.打包发布1webdev build flutter项目和flutter web项目的不同 s/ 文件配置说明 pubspec.yaml包管理资源管理在Flutter中添加资源和图片 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#name很重要，如果修改了name所有的dart的文件的import前引用的本地的文件啊的包名都需要修改name: flutterdemo #包名description: A new Flutter application. dependencies: flutter: sdk: flutter #添加依赖packages ^表示适配和当前大版本一致的版本，~表示适配和当前小版本一致的版本 cupertino_icons: ^0.1.2 english_words: ^3.1.0 # image_picker: ^0.4.8 dev_dependencies: flutter_test: sdk: flutter #启用国际化1 flutter_localizations: sdk: flutter #定义常量 #数组server: - aaaaaa - bbbbbb - dddddd#常量age: 22 # intboolitem: true #定义一个boolean值name: 'hello' #定义一个string flutter: # The following line ensures that the Material Icons font is # included with your application, so that you can use the icons in # the material Icons class. uses-material-design: true #启用国际化2 # To add assets to your application, add an assets section, like this: #添加资源，不单单是图片，images是个和pubspec.yaml配置文件同级的目录，如果不同级，需要添加.. assets: - images/park.jpg - images/lake.jpg - images/touxiang.jpg # - images/a_dot_burr.jpeg # - images/a_dot_ham.jpeg #字体设置 fonts: - family: Schyler fonts: - asset: fonts/Schyler-Regular.ttf - asset: fonts/Schyler-Italic.ttf style: italic - family: Trajan Pro fonts: - asset: fonts/TrajanPro.ttf - asset: fonts/TrajanPro_Bold.ttf weight: 700 name:包名 引入图片资源1234#不同尺寸图片资源写法：…/my_icon.png…/2.0x/my_icon.png…/3.0x/my_icon.png 读取文本12345import 'package:flutter/services.dart' show rootBundle;Future&lt;String&gt; loadAsset() async &#123;//读取文件是的路径，就是assets下配置的 return await rootBundle.loadString('assets/config.json');&#125; 使用图片12//图片路径的配置new AssetImage('graphics/background.png'), 加载依赖包中图片12//配置name的作用，需要读取其他外部package下的资源时new AssetImage('icons/heart.png', package: 'my_icons') 支持字体的设置，可以使用自定义字体1style: new TextStyle( fontFamily: 'Schyler', fontSize: 24.0, ), 基本控件flutter提供了一套完备的基本控件，最常用的有如下几个： Text ：Text提供了一个用来显示文本的一次性控件（即无状态）。 Row, Column：这两个控件用来显示水平或垂直方向上的多个组件，并且是可伸缩的。 Stack：可以将多个组件以一定的顺序排列，可以使用Positioned控件来指定组件在Stack中的顺序。 Container: 是一个可视化的矩形控件，它可以使用BoxDecoration来进行外观装饰，装饰内容可以是背景，边框和阴影等。Container也有外边距，内边距等属性，也可以约束自身的大小，另外值得一提的是Container还可以利用矩阵在三维控件内做转换。 下面结合一些基本的控件来自定义我们的组件并构建应用： 开发Packages和插件 Package 介绍 Package 类型 Developing Dart packages Step 1: 开发Dart包 Step 2: 实现package 开发插件包 Step 1: 创建 package Step 2: 实现包 package Step 2a: 定义包API（.dart） Step 2b: 添加Android平台代码（.java / .kt） Step 2c: 添加iOS平台代码 (.h+.m/.swift) Step 2d: 连接API和平台代码 添加文档 API documentation 发布 packages 处理包的相互依赖 Android iOS 解决冲突 Flutter应用代码讲解 &lt;a name=&quot;EpZQi&quot;&gt;&lt;/a&gt; # 原生App项目集成flutter混合开发详细指南 参考：&lt;br /&gt;[Flutter视频学习](https://www.imooc.com/video/18527)&lt;br /&gt;[Flutter实战](https://book.flutterchina.club/chapter1/dart.html)&lt;br /&gt;[Flutter中文网](https://flutterchina.club/)&lt;br /&gt;[Dart官网](https://dart.dev/) 以前的名字叫https://www.dartlang.org&lt;br /&gt;[Dart](http://dart.goodev.org/) [http://dart.goodev.org/](http://dart.goodev.org/)&lt;br /&gt;[Dartpad](https://dartpad.dartlang.org/)&lt;br /&gt;[跨平台的应用程序](https://www.yuque.com/fangcao/api/zq2og4)]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何优雅地使用 macOS]]></title>
    <url>%2F2019%2F06%2F12%2Fyuque%2F%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8%20macOS%2F</url>
    <content type="text"><![CDATA[来自：https://www.zhihu.com/question/20873070 终端配置 (iTerm2 + zsh + oh-my-zsh + tmux) 和一些好用的小插件 oh-my-zsh theme: 自带主题已经很多了, 想折腾的, 可以自己定制一套主题 wting/autojump: 终端中一键直达目录, 命令行中切换目录是最常用的操作, 只要正常 cd 过目录, 下次只要记住目录名字, 就可以直接进去, 支持模糊匹配, 用过一次, 无法离开 zsh-users/zsh-autosuggestions: 终端历史操作记录自动补全 vim-mode: 喜欢 vim 键位的可以配合oh-my-zsh开启 vim mode, 当然终端中默认使用的是emacs jeffkaufman/icdiff: diff 的 升级美化版, 高亮文件差异对比工具 jakubroztocil/httpie: curl 的升级美化版,高亮效果和返回结果格式化效果 ack: 更强大的文件内容检索, grep 的升级版本 Taskwarrior: 这个是装逼的, 终端 todo list dbcli/mycli: 这个是装逼的, 终端操作数据库的时候, 自动提示 guarinogabriel/Mac-CLI: 这个是 mac 终端工具一个集合包, 暂时还没用过 生产力工具, 介绍几个常用的插件 有道翻译: 翻译结果回车可到剪贴板 音量控制: 直接输入音量大小, 控制音量 terminal finder: terminal 的目录在 finder 中打开, finder 当前目录在 terminal 中打开 source tree: 直接进入到指定 show desktop: 隐藏所有窗口, 显示桌面 jetBrains: 直接进入到 idea 指定项目的编辑窗口 Search tabs in Safari and Chrome: 搜索到 chrome 或者 safari 中 tab 等等 日常 网易邮箱大师 网易云音乐 chrome 微信 印象笔记 QQ iPic ，图床神器，搭配个人站上传图片使用 百度网盘 Microsoft 365 MacDown，Atom上有MD撰写的插件，不过感觉没这个好用 typora, 评论好多同学分享的另外一款MD的阅读编辑器，简单大方～ 网易有道词典 Xmind，思维导图 OmniGraffle，Visio替代品 番茄土豆，番茄工作法，让你知道其实你一天的工作效率其实低的可怜 OneDrive，微软云的桌面版，可以把仓库克隆到Finder里面实现本地无缝云同步 (2018-10-08 更新） Folx，BT下载工具，告别迅雷 iina，播放工具，开源软件，完全免费,作者还是校友，厉害厉害（相关：作者知乎) 1password，密码管理软件，多终端密码管理 CAJ云阅读，mac版的caj阅读器，妈妈再也不用担心我下载的论文读不了了～ (2019-01-17 更新） duet, 如果你同时拥有一个ipad的话，你一定会需要它。屏幕扩展，让你的ipad成为你的第二个屏幕～ Things3, to-do软件，个人强推，比上面提到的番茄要好的多哈哈哈，我现在已经把番茄卸载了～ 开发工具 Dash，离线api文档，搭配aflred食用体验更佳（后文有aflred） Postman，接口测试工具 iTerm2，替换原生终端 Oh My zsh，zsh扩展，留坑待补充 brew，mac的包管理工具，类似于apt-get一套，开发环境配置不用太简单 tmux，shell多窗口管理，终端断开延续，终端历史共享等（Oh My Tmux!，tmux配套插件，酌情选择使用） Xcode，特别说明，mac的一些系统扩展需要xcode支持，必须下载xcode才能使用 Docker，容器盒子 Atom，GitHub官方IDE，对git有很好的支持，感觉都不会使用sourceTree了 VS Code,另外一款IDE，微软旗下，速度性能很优秀，不输Atom，可以两个都下，同时品味，然后选择最喜欢的一款～ SourceTree，对，就是这个软件，Git的GUI管理软件 Navicat，数据库管理GUI 奇技淫巧（系统增强） Aflred，WorkFlow神器，谁用谁知道 TotalFinder，Finder增强，多标签页管理Finder Dr.Cleaner，内存监控，系统优化 Proxifier ，网络代理软件，支持对单一软件的强制代理 Bartender，菜单栏管理软件，给你一个简洁优雅的菜单栏 Moom，窗口大小管理，谁用谁知道 iStat Menus，菜单栏系统监控（内存，网速，磁盘，电池…..) PopClip，划词增强工具，包括但不限于（上百个官方扩展）：复制，粘贴，翻译，定制搜索（淘宝，知乎，google…） ProxyeeDown，底层 HTTP 高速下载器，支持百度云不限速下载 Disk Drill，数据恢复，磁盘数据安全 Mounty，NTFS格式U盘的完全读写 Qbserve，时间监控，记录你在电脑上花费的时间 Scroll Reveser，鼠标（触摸板）控制滚动翻转，让mac上鼠标滚轮方向不再反人类 cDock，Dock栏增强，几乎你能想到的它都有，不过目前版本1.13部分功能在macOS 10.14中失效了 AppCleaner，超级小，超级好用的app删除工具 Tips（效率提升） 关于双系统： 目前我接触到的最完美的解决办法是Parallels Desktop+bootcamp。 日常使用可以使用pd做虚拟机，需要更强性能和稳定性的时候使用bootcamp。PD真的很强大。。。 关于更加详细的双系统教程，戳这里官方解释（有时间我自己做一个教程～） 通过 Parallels Desktop 使用 Boot Camp 大写键和control键交换一下。contorl键绑定了很多的快捷键，交换了之后可以打开快捷键世界的大门。 屏幕触发角设置，提高鼠标党和单手党的工作效率。 2.如果你是程序员，最好学会使用Alfred，如果你只是普通的用户那也应该学会用Spotlight。Alfred有各种好用的workflow强烈推荐！具体请看：https://github.com/zenorocha/alfred-workflows喜欢这个workflow，不用再跑到terminal里面找pid了… 借助 Alfred 的 Workflows 功能可以做哪些好玩的事情？ 3.Dash + alfred 很好用，程序员必备 这是纯 Dash，加上了 alfred 以后就变成了下面这样： 觉得这几个软件可以提高我们使用的流畅度, 便捷度高,能用快捷键尽量不要用触摸板, 能用触摸板尽量不要用鼠标,来回移动右手, 真的好累!!!!]]></content>
  </entry>
  <entry>
    <title><![CDATA[Github+Hexo搭建个人网站]]></title>
    <url>%2F2019%2F06%2F12%2Fyuque%2FGithub%2BHexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2F2019%2F06%2F12%2Fyuque%2FGit%2F</url>
    <content type="text"><![CDATA[git查看命令地址github接口文档：https://developer.github.com/v3/repos/ 不了解GitHub,可以看 https://github.com/xirong/my-git/blob/master/how-to-use-github.md 作为一名开发者，GitHub上面有很多东西值得关注学习，可是刚刚接触GitHub，怎样一步步学习使用GitHub？怎样更高效的利用GitHub？ 在这里搜集整理网络上面的资料，汇总成这么一篇repo 《GitHub使用指南》，供大家一起学习。 GitHub 入门使用教程-图文并茂 很简洁的说明如何使用，看图即可明白。 GitHub help Sometimes you just need a little help. 中文翻译版在此GitHub 帮助文档。 GitHub 之 fork 简介指南 帮你理解清楚什么是fork，fork 的工作流有哪些。 GitHub-cheat-sheet 关于使用 git 和 GitHub 的一些技巧汇总，中文版在此GitHub秘籍 The GitHub Blog GitHub 官方博客，关注最新动态。 How to Build a GitHub GitHub一名早期员工介绍GitHub的历史，5年108名员工无人离职。 阳志平：如何高效利用GitHub 介绍的挺全，以及一些用法，如怎样利用GitHub来学习、演讲找工作等。 GitHub 支持的 emoji表情 emoji-cheat-sheet ✌️ 👏 感觉不好找到需要的表情？试试Emoji Searcher GitHub guides 从Contributing to Open Source on GitHub、Hello World、Forking Projects、Be Social、Making Your Code Citable、Mastering Issues、Mastering Markdown、Mastering Wikis、Getting Started with GitHub Pages 等9个方面图文详细讲解每一步如何使用，以及能做哪些功能。 fork-me-on-GitHub 个人博客、技术博客等如果需要添加GitHub 的彩带，可以使用此方法。 蒋鑫-GotGitHub 《Git权威指南》的作者，对GitHub有很深的了解。（由于首页打开太慢，放到了本文目录中，下面的文章既是） GitHub Skills Using Git blame to trace changes in a file 如果你想看某一个文件中每一行是谁修改的，为什么修改？那么尽情的使用 blame 按钮，发现文件的历史。 GitHub 搜索技巧 Closing issues via commit messages - 通过提交信息关闭Issues Update your forked code from original repository - 如何更新自己 Fork 的代码 更多关于 GitHub 的内容请查看：GitHubHelp 查找需要的信息。 原文地址：http://www.worldhello.net/gotgithub/index.html git - Retrieve the commit log for a specific line in a file? - Stack Overflow Git - git-blame Documentation Git Book 中文版 - 查找问题的利器 - Git Blame 每一行代码都有记录—如何用git一步步探索项目的历史 - Alexia(minmin) - 博客园Git &amp; Gitlab 使用指南 一、Git 有什么奇技淫巧？ 如何以光速查看一行代码的提交记录 在保存所有的文件的情况下，删除所有的commit记录： 检出 1git checkout --orphan latest_branch 添加所有文件夹 1git add -A 评论消息改动 1git commit -am "just come and commit" 删除分支 1git branch -D master 将现有分支设置为master 1git branch -m master push 1git push -f origin master 在尝试过所有命令都不能把你从深渊里挽救出来的时候, git reflog 也许能起作用。 比如撤销一次 rebase（rebase 可是会直接修改历史的，一定要了解原理后再使用） Undoing a git rebase 每次 merge 完总是出现很多 .orig 文件，使用 git clean -f 干掉所有 untracked files rebase 一个 diverged 分支一直要解决冲突很痛苦，可以尝试在自己的分支先 squash 一下，git rebase -i，然后再 rebase 主干，解决一次冲突就 ok 了 本地有很多其实早就被删除的远程分支，可以用 git remote prune origin 全部清除掉，这样再 checkout 别的分支时就清晰多了. 1git bisect 有没有过写了一天的代码，checkin无数，结果突然发现之前没注意的地方break的时候？这个时候要在茫茫commits里寻找那个错误的commit是多么的痛苦啊。git-bisect就是大救星！git-bisect本质上就是一个二分法，用起来也很简单： 123git bisect start #startgit bisect bad #current branch is badgit bisect good &lt;SHA-1&gt; #some old commit that is good 然后只要不停的告诉git当前commit是不是好的， 1git bisect good or 1git bisect bad 就能找到罪魁祸首了！ 二、Git log常见用法 三、git checkout 命令详解 四、git重要的三个命令stash, checkout, reset的一些总结 正常的情形，修改工作区的文件然后add，commit，我使用git一般的流程是：git status ——&gt; git stash save “message…”——&gt; git pull –&gt; git stash pop ——&gt; git add . 或 git add filename ——&gt; git commit -m ‘message…’ ——&gt; git push 其中 . 表示所有的文件。 只需要撤销工作区的文件修改，即用暂存区的文件覆盖工作区中的文件 git checkout – filename 当修改的文件已经add到暂存区，需要撤销这次添加，即撤销上一次git add filename 操作： git reset – filename / git reset HEAD filename 撤销暂存区内所有的文件改动:git reset / git reset HEAD 当对上次提交不满意，可以让HEAD指针回退，而暂存区和工作区可以不用动 git reset –soft HEAD^ 如果让工作区不改变，而暂存区和引用（HEAD指针）回退一次 git reset –mixed HEAD^ 当需要彻底撤销最近的提交，HEAD指针、暂存区、工作区都回到上次的提交状态，自上一次以来的提交全部丢失 git reset –hard HEAD^ git stash 用于保存和恢复工作进度。 git stash 保存当前的工作进度。会分别对暂存区和工作区的状态进行保存。 git stash list 显示进度列表。此命令显然暗示了git stash 可以多次保存工作进度，并用在恢复时候选择。 git stash drop [] 删除一个存储的进度。默认删除最新的进度。 git stash clear 删除所有存储的进度。 git stash pop [–index] [] –index 参数：不仅恢复工作区，还恢复暂存区 指定恢复某一个具体进度。如果没有这个参数，默认恢复最新进度 如：以下命令恢复编号为0的进度的工作区和暂存区 1# git stash pop --index stash@&#123;0&#125; 如果不使用任何参数，会恢复最新保存的工作进度，并将恢复的工作进度从存储的工作进度列表中清除。 如果提供参数（来自git stash list显示的列表），则从该中恢复。恢复完毕也将从进度列表中删除。 选项–index除了恢复工作区的文件外，还尝试恢复暂存区。这也就是为什么恢复进度的时候显示的状态和保存进度前的略有不同。 git stash [save [–patch] [-k|–[no]keep-index] [-q|–quiet] []] 这条命令实际上是git stash命令的完整版。 save，即如果需要在保存工作进度的时候使 用指定的说明，必须使用如下格式： git stash save “message…” 使用参数–patch会显示工作区和HEAD的差异，通过对差异文件的编辑决定在进度中 最终要保存的工作区的内容，通过编辑差异文件可以在进度中排除无关内容。 使用-k或者–keep-index参数，在保存进度后不会将暂存区重置。默认会将暂存区和工 作区强制重置。 git stash apply [–index] [] 除了不删除恢复的进度之外，其余和git stash pop 命令一样。 检出命令git checkout是git最常用的命令之一，同时也是一个很危险的命令，因为这条命令会重写工作区。 检出命令的用法如下：用法一：git checkout [-q] [] [–] …用法二：git checkout []用法三：git checkout [-m] [[-b]–orphan] ] [] 注：&lt;1&gt; 为了避免路径和引用（或者提交ID）同名而发生冲突，可以在前用两个连续的短线（短号）–作为分隔。&lt;2&gt; 在用法一中， 省略commit：用暂存区的文件覆盖工作区的文件。 加上commit：用指定提交中的文件覆盖暂存区和工作区中的文件。 &lt;3&gt;在用法二中，会改变HEAD头指针 加上：因为只有HEAD切换到一个分支才可以对提交进行跟踪，否则仍然会进入“分离头指针”的状态。在“分离头指针”状态下的提交不能被引用关联到，从而可能丢失。 所以用法二（加上）最主要的作用就是切换到某分支。(2）省略：则相当于对工作区进行状态检查。&lt;4&gt;在用法三中，主要是创建和切换到新的分支（），新的分支从指定的提交开始创建。新分支和我们熟悉的master分支没有什么实质的不同，都是在refs/heads命名空间下的引用。 下图所示的版本库模型图描述了git checkout实际完成的操作。使用： git checkout branch 检出branch分支。要完成图中的三个步骤，更新HEAD以指向branch分支，以及用branch 指向的树更新暂存区和工作区。 git checkout / git checkout HEAD 汇总显示工作区、暂存区与HEAD的差异。 git checkout – filename 用暂存区中filename文件来覆盖工作区中的filename文件。相当于撤销自上次执行git add filename以来（如果执行过）的本地修改。 git checkout – . / git checkout . 这条命令最危险！会撤销所有本地的修改（相对于暂存区）。相当于用暂存区的所有文件直接覆盖本地文件，不给用户任何确认的机会！ git reset是Git最常用的命令之一，也是最危险最容易误用的命令。用法一：git reset [-q] [] [–] …用法二：git reset [–soft –mixed | –hard | –merge | –keep] [-q] []注：（1）第一种用法（包含了路径的用法）不会重置引用，更不会改变工作区，而是用指定提交状态()下的文件()替换掉暂存区中的文件。例如：git reset HEAD 相当于取消之前执行的git add 命令时改变的暂存区。（2）第二种用法（不使用路径的用法）则会重置引用。根据不同的选项，可以对暂存区或工作区进行重置。参照下面的版本库模型图，可以看不同的参数对第二种重置语法的影响。命令格式：git reset [–soft | –mixed | –hard] []（1）使用参数–soft，如 git reset –soft 会执行上图中的操作①。即只更改引用的指向，不改变暂存区和工作区。（2）使用参数–mixed或者不使用参数（默认为–mixed），如 git reset 会执行上图中的操作①和②。即更改引用的指向及重置暂存区，但是不改变工作区。（3）使用参数–hard，如git reset –hard 会执行上图中的全部动作①、②、③，（理解为此时工作区、暂存区、commit都相同）即： ①替换引用的指向。引用指向新的提交ID。 ②替换暂存区。替换后，暂存区的内容和引用指向的目录树一致。 ③替换工作区。替换后，工作区的内容变得和暂存区一致，也和HEAD所指向的目录树内容相同。注： 引用即HEAD指针 使用：git reset / git reset HEAD仅用HEAD指向的目录树重置暂存区，工作区不会受到影响，相当于将之前用git add命令更新到暂存区的内容撤出暂存区。引用也未改变，因为引用重置到HEAD相当于没有重置。git reset – filename / git reset HEAD filename仅将文件filename 的改动撤出暂存区，暂存区中其他文件不改变。相当于命令git add filename 的反射操作。git reset –soft HEAD^工作区和暂存区不改变，但是引用向前回退一次。当对最新的提交说明或者提交的更改不满意时，撤销最新的提交以便重新提交。之前提到过修补提交命令git commit –amend，用于对最新的提交进行重新提交以修补错误的提交说明或者错误的提交文件。修补提交命令实际上相当于执行了下面两条命令。（注：文件.git/COMMIT_EDITMSG保存了上次的提交日志） git reset –soft HEAD^ git commit -e -F .git/COMMIT_EDITMSGgit reset HEAD^ / git reset –mixed HEAD^工作区不改变，但是暂存区会回退到上一次提交之前，引用也会回退一次。git reset –hard HEAD^彻底撤销最近的提交。引用回退到前一次，而且工作区和暂存区都会回退到上一次提交的状态。自上一次以来的提交全部丢失。 五、如何以光速查看一行代码的提交记录怎么查是谁写的，命令行工具git blame 1git blame -L 99,99 package.json 即使把这个命令设置为快捷方式，一行一行的查询也是非常耗费精力的，那么有没有一眼可以看到的方式呢？那就是直接在 GitHub 上查。]]></content>
  </entry>
  <entry>
    <title><![CDATA[vscode]]></title>
    <url>%2F2019%2F06%2F12%2Fyuque%2Fvscode%2F</url>
    <content type="text"><![CDATA[VSCode 拓展推荐 使用说明 相似功能的插件，不推荐全都装上，请挑选一个使用 本列表所有插件均已测试使用过，但不代表不存在问题 任何插件本身的问题，请到对于代码仓库提交 issue 插件 名称 简述 Auto Close Tag 自动闭合 HTML 标签 Auto Import import 提示 Auto Rename Tag 修改 HTML 标签时，自动修改匹配的标签 Babel JavaScript babel 插件，语法高亮 Babelrc .babelrc 文件高亮提示 Beautify css/sass/scss/less css/sass/less 格式化 Better Align 对齐赋值符号和注释 Better Comments 编写更加人性化的注释 Bookmarks 添加行书签 Bracket Pair Colorizer 用不同颜色高亮显示匹配的括号 Can I Use HTML5、CSS3、SVG 的浏览器兼容性检查 Code Outline 展示代码结构树 Code Runner 运行选中代码段（支持多数语言） Code Spell checker 单词拼写检查 CodeBing 快速打开 Bing 并搜索，可配置搜索引擎 Color Highlight 颜色值在代码中高亮显示 Color Info 小窗口显示颜色值，rgb,hsl,cmyk,hex 等等 Color Picker 拾色器 CSS-in-JS CSS-in-JS 高亮提示和转换 Dash 集成 Dash Debugger for Chrome 调试 Chrome Document This 注释文档生成 DotENV .env 文件高亮 EditorConfig for VS Code EditorConfig 插件 Emoji 在代码中输入 emoji endy 将输入光标跳转到当前行最后面 ESLint ESLint 插件，高亮提示 File Peek 根据路径字符串，快速定位到文件 filesize 状态栏显示当前文件大小 Find-Jump 快速跳转到指定单词位置 Font-awesome codes for html FontAwesome 提示代码段 ftp-sync 同步文件到 ftp Git Blame 在状态栏显示当前行的 Git 信息 Git History(git log) 查看 git log gitignore .gitignore 文件语法 GitLens (Git 增强)显示文件最近的 commit 和作者，显示当前行 commit 信息 GraphQL for VSCode graphql 高亮和提示 Guides 高亮缩进基准线 Gulp Snippets Gulp 代码段 HTML CSS Class Completion CSS class 提示 HTML CSS Support css 提示（支持 vue） HTMLHint HTML 格式提示 htmltagwrap 快捷包裹 html 标签 htmltagwrap 包裹 HTML Import Beautify import 分组、排序、格式化 Import Cost 行内显示导入（import/require）的包的大小 Indenticator 缩进高亮 IntelliSense for css class names css class 输入提示 JavaScript (ES6) code snippets ES6 语法代码段 JavaScript Standard Style Standard 风格 JS Refactor 代码重构工具，提取函数、变量重命名等等 JSON to TS JSON 结构转化为 typescript 的 interface JSON Tools 格式化和压缩 JSON jumpy 快速跳转到指定单词位置 language-stylus Stylus 语法高亮和提示 Less IntelliSense less 变量与混合提示 Lodash Lodash 代码段 Log Wrapper 生产打印选中变量的代码 markdownlint Markdown 格式提示 MochaSnippets Mocha 代码段 Node modules resolve 快速导航到 Node 模块 npm 运行 npm 命令 npm Intellisense 导入模块时，提示已安装模块名称 Output Colorizer 彩色输出信息 Partial Diff 对比两段代码或文件 Path Autocomplete 路径完成提示 Path Intellisense 另一个路径完成提示 Polacode 将代码生成图片 PostCss Sorting css 排序 Prettier - Code formatter prettier 官方插件 Prettify JSON 格式化 JSON Project Manager 快速切换项目 Quokka.js 不需要手动运行，行内显示变量结果 React Native Storybooks storybook 预览插件，支持 react React Playground 为编辑器提供一个 react 组件运行环境，方便调试 React Standard Style code snippets react standar 风格代码块 REST Client 发送 REST 风格的 HTTP 请求 Sass sass 插件 Settings Sync VSCode 设置同步到 Gist Sort lines 排序选中行 Sort Typescript Imports typescript 的 import 排序 String Manipulation 字符串转换处理（驼峰、大写开头、下划线等等） stylelint css/sass/less 代码风格 SVG Viewer SVG 查看器 Syncing vscode 设置同步到 gist Test Spec Generator 测试用例生成（支持 chai、should、jasmine） TODO Parser Todo 管理 TS/JS postfix completion ts/js 后缀提示 TSLint TypeScript 语法检查 Types auto installer 自动安装@types 声明依赖 TypeScript Hero TypeScript 辅助插件，管理 import、outline 等等 TypeScript Import TS 自动 import TypeScript Import Sorter import 整理排序 Typescript React code snippets React Typescript 代码段 TypeSearch TS 声明文件搜索 Version Lens package.json 文件显示模块当前版本和最新版本 vetur 目前比较好的 Vue 语法高亮 View Node Package 快速打开选中模块的主页和代码仓库 VS Live Share 实时多人协助 VSCode Great Icons 文件图标拓展 vscode-database 操作数据库，支持 mysql 和 postgres vscode-icons 文件图标，方便定位文件 vscode-random 随机字符串生成器 vscode-spotify 集成 spotify，播放音乐 vscode-styled-components styled-components 高亮支持 vscode-styled-jsx styled-jsx 高亮支持 Vue TypeScript Snippets Vue Typescript 代码段 VueHelper Vue2 代码段（包括 Vue2 api、vue-router2、vuex2） Wallaby.js 实时测试插件 12345678910111213141516171819202122232425262728293031323334353637&#123; "breadcrumbs.enabled": true, "editor.tabSize": 2, "editor.renderWhitespace": "boundary", "editor.cursorBlinking": "smooth", "editor.minimap.renderCharacters": false, "editor.fontFamily": "'Fira Code', 'Droid Sans Mono', 'Courier New', monospace, 'Droid Sans Fallback'", "editor.fontLigatures": true, "explorer.confirmDragAndDrop": false, "extensions.autoUpdate": false, "files.insertFinalNewline": true, "git.autofetch": true, "git.path": "F:\\Program Files\\Git\\cmd\\git.exe", "search.exclude": &#123; "**/node_modules": true, "**/dist": true &#125;, "typescript.locale": "en", "window.titleBarStyle": "custom", "window.title": "$&#123;dirty&#125;$&#123;activeEditorMedium&#125;$&#123;separator&#125;$&#123;rootName&#125;", "window.zoomLevel": 1, "workbench.activityBar.visible": true, "workbench.colorTheme": "Plastic - deprioritised punctuation", "workbench.iconTheme": "vscode-great-icons", "workbench.startupEditor": "newUntitledFile", "eslint.autoFixOnSave": true, "eslint.validate": ["javascript", "javascriptreact", "vue"], "vsicons.projectDetection.autoReload": true, "vsicons.dontShowNewVersionMessage": true, "tslint.autoFixOnSave": true, "debugwrapper.wrappers": &#123; "default": "console.log('$eSEL', $SEL)" &#125;, "prettier.tslintIntegration": true, "cSpell.userWords": ["Unmount"], "jest.autoEnable": false&#125; Visual Studio Code 最好的功能、插件和设置 让 create-react-app 支持 do 表达式 1.先安装@babel/plugin-proposal-do-expressions2.在.babelrc里配置： 1"plugins": ["@babel/plugin-proposal-do-expressions"] 3.vsCode 不支持 ES6 do{}表达式，这样设置即可： 全局安装：npm install -g eslint 安装 babel-eslint: npm install –save-dev babel-eslint 安装 eslint-plugin-react(如果你用 react 的话): npm install –save-dev eslint-plugin-react 创建’.eslintrc’文件 12345678910111213141516171819202122232425262728293031323334353637383940414243&#123; "env": &#123; "browser": true, "node": true, "es6": true, "jest": true, "jquery": true &#125;, "parser": "babel-eslint", "parserOptions": &#123; "ecmaVersion": 6, "sourceType": "module", "ecmaFeatures": &#123; "arrowFunctions": true, "binaryLiterals": true, "blockBindings": true, "classes": true, "defaultParams": true, "destructuring": true, "forOf": true, "generators": true, "modules": true, "objectLiteralComputedProperties": true, "objectLiteralDuplicateProperties": true, "objectLiteralShorthandMethods": true, "objectLiteralShorthandProperties": true, "octalLiterals": true, "regexUFlag": true, "regexYFlag": true, "spread": true, "superInFunctions": true, "templateStrings": true, "unicodeCodePointEscapes": true, "globalReturn": true, "jsx": true, "experimentalObjectRestSpread": true &#125; &#125;, "plugins": ["react"], "rules": &#123; "strict": 0 &#125;&#125; 关闭 vscode 的语法验证:”javascript.validate.enable” : false vscode 主题背景设置]]></content>
  </entry>
  <entry>
    <title><![CDATA[Theme]]></title>
    <url>%2F2019%2F06%2F11%2Fyuque%2FTheme%2F</url>
    <content type="text"><![CDATA[根据Hexo博客的自动发布体系，想要完整的主题，也有主题收集 hexo主题：https://hexo.io/themes/ next主题：https://theme-next.iissnan.com/]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo同步语雀文章一]]></title>
    <url>%2F2019%2F06%2F11%2Fyuque%2FHexo%E5%90%8C%E6%AD%A5%E8%AF%AD%E9%9B%80%E6%96%87%E7%AB%A0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[创建 Hexo 博客已经有 Hexo 博客的可以跳过。如果你是 Jekyll ，也可以跳过。 安装 Node.js 安装 Hexo 脚手架 12345npm install -g hexo-clihexo init blogcd blognpm install or yarn installhexo server Hexo建站参考Hexo官方文档：https://hexo.io/zh-cn/docs/ 安装语雀文章下载插件yuque-hexo 是一个 Node.js 环境下的语雀下载器，使用 npm 安装 安装 yuque-hexo 注册语雀，创建知识库，获得你的个人路径和知识库的名字，比如我的博客的知识库是 :https://www.yuque.com/fangcao/api 在 Hexo 博客的目录下面的 package.json 中，进行下面的配置 123456789101112131415161718192021222324252627282930313233343536373839&#123; "name": "hexo-site", "version": "0.0.0", "private": true, "hexo": &#123; "version": "3.8.0" &#125;, "dependencies": &#123; "hexo": "^3.8.0", "hexo-generator-archive": "^0.1.5", "hexo-generator-category": "^0.1.3", "hexo-generator-index": "^0.2.1", "hexo-generator-tag": "^0.2.0", "hexo-renderer-ejs": "^0.3.1", "hexo-renderer-marked": "^1.0.1", "hexo-renderer-stylus": "^0.3.3", "hexo-server": "^0.3.3" &#125;, "yuqueConfig": &#123; "baseUrl": "https://www.yuque.com/api/v2", "login": "fangcao", "repo": "api", "mdNameFormat": "title", "postPath": "source/_posts/yuque", "token": "放上自己的语雀token" &#125;, "scripts": &#123; "clean": "hexo clean", "clean:yuque": "DEBUG=yuque-hexo.* yuque-hexo clean", "deploy": "hexo deploy", "publish": "npm run clean &amp;&amp; npm run deploy", "dev": "hexo s", "sync": "DEBUG=yuque-hexo.* yuque-hexo sync", "reset": "npm run clean:yuque &amp;&amp; npm run sync" &#125;, "devDependencies": &#123; "yuque-hexo": "^1.6.1" &#125;&#125; 参数名 含义 默认值 postPath 文档同步后生成的路径 source/_posts/yuque cachePath 文档下载缓存文件 yuque.json mdNameFormat 文件名命名方式 (title / slug) title adapter 文档生成格式 (hexo/markdown) hexo concurrency 下载文章并发数 5 baseUrl 语雀 API 地址 - login 语雀 login (group) - repo 语雀仓库短名称 - onlyPublished 只展示已经发布的文章 如果不是 Hexo 博客，则需要按照上面的文件保存一个 package.json 到博客目录，并且配置 postPath 为正确的文章目录 同步文章 1yuque-hexo sync 语雀同步过来的文章会生成两部分文件； yuque.json: 从语雀 API 拉取的数据 source/_posts/yuque/*.md: 生成的 md 文件 支持配置 front-matter, 语雀编辑器编写示例如下: 语雀编辑器示例，可参考hexo的终极玩法 配置GitHub pages首先需要一个GitHub账号然后可以具体可参照官方教程 改变主题这是官方的主题网站将主题clone到你的theme，在配置文件中将theme改变为你下载的主题名称然后编译，运行，发布。 使用next主题的可以参考官方网址 配置Travis CI之前也有不少文章用不同的方法解决上述的问题，例如利用 Dropbox 同步或者利用 Github 的 Webhooks 进行自动部署。这些方法需要付出一定的成本，因为都需要利用到一台 VPS 去完成。而今有一个更加简单而且免费的方法去完成 hexo 的自动部署，就是利用 Travis CI。 重点来了，详细步骤可参考用 Travis CI 自动部署 hexo，手把手教你Travis CI,作者已经说的比较详细。需要注意的一点是：在package.json中增加depoly的命令行语句，防止travis在自动执行到npm run deploy这一步的时候报找不到该script的错。 123&quot;scripts&quot;: &#123; &quot;deploy&quot;: &quot;hexo clean &amp;&amp; hexo g -d&quot;&#125;, 上述代码加在dependencies同级即可。 查看TravisCi https://travis-ci.org/fangcao7618/fangcao7618.github.io 主题： 主题选择：next 主题主题二：https://hexo.io/themes/ https://theme-next.org/ 例子：https://www.jinrishici.com/]]></content>
  </entry>
  <entry>
    <title><![CDATA[通过 ngrok 实现 ssh 内网穿透]]></title>
    <url>%2F2019%2F06%2F11%2Fyuque%2F%E9%80%9A%E8%BF%87%20ngrok%20%E5%AE%9E%E7%8E%B0%20ssh%20%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%2F</url>
    <content type="text"><![CDATA[ngrok用 ssh 访问一台主机，如果和主机在一个局域网中或者主机拥有公网 IP，就可以使用 ssh 命令直接连接主机的 IP 地址，但是大部分公司和家庭内部都是局域网，并不能给局域网内的每一台主机都分配一个公网 IP，这时候就需要进行内网穿透，才能从外部连接到局域网内的主机。ngrok 是一个反向代理工具，可以实现将内网的端口暴露到公网，通过 ngrok，也能将 ssh 使用的端口暴露出去，以此实现 ssh 的内网穿透。 注册并下载 ngrok访问 https://ngrok.com/ 注册 ngrok 账号并下载 ngrok 客户端。 查看 ngrok 的 token访问 https://dashboard.ngrok.com/auth 查看 token并复制。 在内网机器上启动 ngrok连接 ngrok 账号 1ngrok authtoken 5TqUhMnum6ntDE8Z5HkNb_49F9ffzzcV9V7pKLVdDYc 启动 ngrok 并打开 22 端口转发 1ngrok tcp 22 --log=stdout &gt; &quot;$HOME/ngrok.log&quot; --region ap &amp; 其中 region 的 ap 代表 ngrok 新加坡节点，访问速度相比美国节点会快一些。访问 https://ngrok.com/docs#config-options 可以查看支持的所有区域。访问 http://127.0.0.1:4040。可以看到一个tcp开头的地址，通过访问这个地址，就可以转发到本机的 22 端口上。 通过 ssh 访问内网机器查看到转发地址后，就可以在外网通过 ssh 命令访问内网机器来。以上图为例，ssh 访问的命令是： 1ssh -p 10502 username@0.tcp.ap.ngrok.io 需要注意的问题由于所有流量都要经过 ngrok 服务器，而 ngrok 的服务节点又只有美国、新加坡等地，所以速度上还是比较慢的。另外，如果 ngrok 的服务节点存在安全隐患的话，存在敏感内容的泄漏的可能性。]]></content>
  </entry>
  <entry>
    <title><![CDATA[语雀 + netlify 自动部署静态博客]]></title>
    <url>%2F2019%2F06%2F11%2Fyuque%2F%E8%AF%AD%E9%9B%80%20%2B%20netlify%20%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[语雀 + netlify 1. netlify 配置1一、使用github或者gitlab登陆netlify首先，打开netlify网站(https://app.netlify.com/)然后使用github或者gitlab账号登录。二、根据github/gitlab仓库创建网站点击New site from Git按钮： 根据你的仓库所在平台选择，以下三选一：选择你需要部署的仓库：设置部署选项，包括三点： 部署分支（对应下图中 Branch to deploy）:顾名思义就是你的git仓库的分支，默认选择为master分支 打包命令（对应下图中 Build command）：就是你的打包命令，诸如 npm run build，gulp build 之类；如果本身已是静态文件，不需打包编译，这一栏则不填 打包后目录（对应下图中 Publish directory）：即执行完打包命令之后静态文件所在目录，诸如 dist，_site 之类；如果本身已是静态文件，这一栏则不填 完成之后点击途中 deploy site 按钮 三、设置域名，绑定域名进行完第二步，我们可以看到自动化部署已经开始运行了，而且过不多久，我们的网站就已经可以利用netlify域名就行访问了，如下图：可以看到netlify为我们随机生成了一个netlify下的域名，这里我们可以更改其前缀，并绑定到我们自己的域名下：&gt;&gt; 更改netlify域名前缀：首先，点击上图中 Site settings 按钮，然后在下方点击 Change site name 按钮，然后在弹出框中输入自己需要更改的前缀名，点击保存即可，如下图所示：&gt;&gt; 绑定到自己的域名下：首先，点击上上图中 Domain settings 按钮，然后在下方点击 Add custom domain 按钮，然后在弹出框中输入自己需要绑定的完整域名，点击保存，如下图所示：这个时候会显示 ！Check DNS configuration，因为我们还没有设置域名解析到netlify服务器，所以这个时候需要到你自己域名的相应服务商网站登录之后在需要绑定的域名下添加一条CNAME解析，解析的主机记录即对应的netlify域名值（这里即 codernie.netlify.com）ok，过一会儿就可以使用自己的域名访问自己的网站啦 四、生成HTTPS证书，实现HTTPS访问第四部中的Domain settings 中往下拉，可以看到 HTTPS 几个大字母：点击 Verify DNS configuration 按钮，待它变成下方绿色按钮之后，再点击：然后在弹出框中点击确认，过一会儿之后就可以使用https访问你的小站啦：看到自己的小站前面可以有绿色的安全字样，是不是很酷炫，而且很放心，再也不用担心运营商在自己的网站上挂广告啦，哈哈哈。。。等等，是不是还差了点什么：对啊，还没有强制跳转https，OK，继续 五、强制HTTP跳转HTTPS访问在第四步 Domain settings 再往下翻一点，可以看到 Force HTTPS，只需点击 Force HTTPS 即可实现，是不是很方便，如下图： 六、设置redirect利用netlify实现自动化部署和HTTPS就写到这里了。 https://app.netlify.com/sites/stoic-murdock-f3d33b/settings/general 2. netlify 配置2前往 Settings -&gt; Build &amp; Deploy 找到 Build hooks，添加一个 build hook 3. 语雀配置URL 填入刚刚从 netlify 生成的 hook 链接 所有更新触发：该知识库下的任何一篇文档的更新都会触发 WebHook 仅主动推送更新触发：只在文档发布或更新的时候勾选了「文档有较大更新，推送给关注人」才会触发 WebHook 同步语雀文章Gatsby -&gt; https://github.com/Raincal/gatsby-source-yuqueVuePress -&gt; https://github.com/ulivz/vuepress-plugin-yuqueHexo -&gt; https://github.com/x-cold/yuque-hexo完成上面三步后，就可以尝试发布新文章啦！参考文章Hexo 博客终极玩法：云端写作，自动部署]]></content>
  </entry>
  <entry>
    <title><![CDATA[gatsbyjs]]></title>
    <url>%2F2019%2F06%2F10%2Fyuque%2Fgatsbyjs%2F</url>
    <content type="text"><![CDATA[gatsbyjs]]></content>
  </entry>
  <entry>
    <title><![CDATA[前言]]></title>
    <url>%2F2019%2F06%2F10%2Fyuque%2F%E5%89%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[H5，即是html5，超文本标记语言，用于描述网页内容结构的语言，网页编程中由它有负责描述页面数据和信息 JS，即是JavaScript，广泛用于web应用开发中的脚本语言，负责响应用户的操作，为网页添加动态功能 native APP，即传统的原生APP开发模式，Android基于Java语言，底层调用Google的 API；iOS基于Objective-C或者Swift语言，底层调用App官方提供的API Hybrid App，即原生和web的混合开发模式，由原生提供统一的API给js调用，实现跨平台的效果 很久以前，这是hexo制作出的博客，是长这样的，当时，觉得好玩，记录了一下，后面就忘记了… 现在又重新捡起来，对过去的一些回忆吧，重点是有时候看过的东西，再回过去找很难找，要么文章都不在了，记录也是一种存储吧。]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript语言基础知识点总结]]></title>
    <url>%2F2019%2F06%2F10%2Fyuque%2FJavaScript%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[写给Node.js新手的7个小技巧]]></title>
    <url>%2F2019%2F06%2F10%2Fyuque%2F%E5%86%99%E7%BB%99Node.js%E6%96%B0%E6%89%8B%E7%9A%847%E4%B8%AA%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[一些我更愿意在开始就知道东西利用 Node.js 开发是一个非常有趣，和令人满足的过程， 他有3万多个模块可以选择使用，并且所有的模块可以非常容易的集成入现有的应用之中。 无论如何，对于一些刚开始使用Node.js 开发的的人来说，很容易碰壁，在这个文章中，我会提到在你学习过程中遇到的问题。 贴士 1: 在开发环境使用 nodemon, 在生产环境使用pm2当你第一次开发Node.js应用的时候，其中一件事情就是一次又一次的运行[file].js 就和揭伤疤一样。 当我第一次开发的node app时候，这个让我感到异常挫败和痛苦， 尤其是每当我修改很小东西的时候需要control+c 幸运的是我发现了一个非常棒的工具Nodemon. 你可以利用以下的命令来安装。 npm install -g nodemonNodemon 是一个令人惊叹的工具， 当你全局安装他以后，可以通过 nodemon [file].js 来启动你的node.js scripts，它会告诉nodemon来监视你的script和scripts的所有变化，这样的Node.js开发方式非常震撼以及让大大提高开发速度。 那么，生产环境又如何，除非你用了heroku，Nodejitsu或者其他一些好的 Node.js 平台(也许他们有类似的功能)，但是碰巧你用了EC2 或者一些其他的云平台来运行你的Node.js app，你如何能然保证这是一个始终运行的Node.js app？ 案就是PM2, PM2 是一个类似于Nodemon的工具，不同之处在于它用于生产环境，和Nodemon相似的地方在于他会监控你的app的任何修改或者重新部署，但是有更好的一面， PM2 在遭遇到崩溃的时候，他会正确重启你的app. PM2的优胜之处在于当你要将app需要多核处理的时候，PM2内部集成的负载均衡可以让你很容易的去指定运行多少个实例。 pm2 start app.js -i max-i参数目的是指定运行多少个实例，在这个例子中 PM2 使用了一个常量max来扩展你的app运转到你最大的核数，不要忘记Node 平时只会运行在单核！ 贴士 2: Async 或者 Q当你专注于写了更多的node.js apps的时候，你肯定领略了什么是回调地狱。如果你还不知道,这里有一个例子： function register(name, password, cb){ checkIfNameExists(name, function(err, result){ if(err){ return cb(“error”); } checkIfPasswordGood(password, function(err, result){ if(err){ return cb(“error”); } createAccount(name,password, function(err,result){&lt;br /&gt; if(err){&lt;br /&gt; return cb(“error”);&lt;br /&gt; }&lt;br /&gt; createBlog(name, function(err, result){&lt;br /&gt; sendEmail(name, function(err, result){&lt;br /&gt; callback(result);&lt;br /&gt; });&lt;br /&gt; });&lt;br /&gt; });&lt;br /&gt; });&lt;br /&gt; });&lt;br /&gt; }&lt;br /&gt;这显然不是一个有用或者令人折服的代码， 反而进入一种回调地狱般两难的境地，是你的话将如何避免？一个简单的办法是使用events， 但是我个人不建议这么做，因为使用events来调用只有一个用途的私有方法，足以令人受挫。所以你该怎么做? 这里有两个编译好的模块async.js和Q, 他们两个都可以防止落入回调地狱。 Async.js或者 ‘async’ 让你可以容易的执行一些连续或者平行的任务，在不依赖一个又一个的嵌套循环前提下. 下面是一些来自Async的readme，写明了他支持的模式，如需获取全部的支持方式请去他们的github主页查看。 async.map([‘file1’,’file2’,’file3’], fs.stat, function(err, results){ // results is now an array of stats for each file }); async.filter([‘file1’,’file2’,’file3’], fs.exists, function(results){ // results now equals an array of the existing files}); async.parallel([ function(){ … }, function(){ … } ], callback); async.series([ function(){ … }, function(){ … } ]); async.waterfall([ function(callback){ callback(null, ‘one’, ‘two’); }, function(arg1, arg2, callback){ callback(null, ‘three’); }, function(arg1, callback){ // arg1 now equals ‘three’ callback(null, ‘done’); } ], function (err, result) { // result now equals ‘done’ });如果我们用async的waterfall来修改之前的例子,结果将更加容易阅读, 再也不用让你的代码看起来像一个死亡金字塔. 另一个重要的库叫做Q. 这个库是一个暴漏promises的概念，Promise 是一个含有’promise’方法的返回对象，他提供了一个最终的返回值，非常优雅的将javascripts的异步和node.js紧密联系在一起。 promiseMeSomething() .then(function (value) { }, function (reason) { });这个 promise me 方法正确返回了一个对象，对象将在传入value的时候调用这个方法当，并且他提供了一个额外的callback来处理失败后的返回值。 这是一个非常有条理的方式来避免回调地狱，如果你重写我们之前的那个例子，你可以非常容易的让这些函数正确被调用并执行。 就和我之前说的一样，我很不愿创建只有一个用途的一堆功能，相反的在’then’之后传入一个方法名，仅仅创建了一个匿名的内部功能和传递,当然了选择权始终在你手里。 总的来说，当你落入回调地狱的时候，是时候去看看 async.js或者Q吧。 我的选择? 当然是 Q贴士 3: 轻松调试 Node.js apps如果你从一个IDE重度集成的语言比如java 或者C# 转来调试Node.js,，你一定会感到很困扰，大部分新加入node的开发者采用了’flow’的调试模式，从这一刻开始你最好的朋友就是console.log 但是依然有更常见的调试方式来代替， Node.js 内置了一个调试器你可以称为 node debug，不过我更喜欢的 node-inspector 他们的github说 “Node Inspector 是一个使用Blink Developer Tools (以前称为WebKit Web Inspector)node.js调试器的界面,” 简而言之，node-inspector 可以让你用任何你想用的编辑器和chrome web tools来调试你的应用,这是多么的性感。 Node-inspector 可以让你做一些非常酷的事情,比如实时修改,单步调试,注入以及一堆其他非常酷的东西。 让我们来根据指示一步一步安装。 https://github.com/node-inspector/node-inspector 贴士 4: Nodefly一旦你有你的应用程序正常运行，你可能会问自己，你怎么可以监视它的性能和配置文件，以确保您的应用程序运行在最佳的速度。最简单的答案是一个伟大的服务，我称为Nodefly。 用简单的一行代码Nodefly开始监视你的应用程序内存泄漏，测量redis用了多久，mongo查询和一堆其他很酷的东西。 http://www.nodefly.com 贴士 5: 利用NPM进行模块管理Node做最常见的事情之一是通过NPM安装软件包。Node有一个惊人的包管理器安装所有指定在你的package.json的manifest文件中的模块。然而，所有初学者都会碰上保持的package.json文件中您所使用的所有的模块都是最新版。 这似乎是一个痛苦的过程,总是打开的package.json来更新新模块的依赖，但许多人不知道的是npm会为你做这个！ 非常简单运行 npm install - save module_name 然后 npm将自动更新你的package.json 包含正确的模块和版本。 npm install - save module_name贴士 6: 不要检查node_modules 文件夹虽然我们的话题一直是modules和npm，但是并不是不是很多人都知道，你不应该提交node_modules文件夹。这背后最大的原因是，没有必要提交这个文件夹。只要有人下载你的代码，他们可通过运行NPM来安装和下载所有需要的模块。 您可能会说，它是不是一个大问题，如果检查node_modules，但是，如果下载代码的人使用了和你编译modules不一样的操作系统的来安装通过NPM？你的应用程序将会崩溃，下载代码的人将不知道为什么会如此！ 举个例子bcrypt以及sentimental如果当在您安装在主机系统上编译他们，因为他们用了本地C语言组件来编译。 避免检查node_modules文件夹的方式是加入.gitignore // .gitignore node_modules/*贴士 7: 别忘记返回初学者经常犯一个很常识的错误,就是忘记callback后的返回值,虽然有些时候，这没有影响，有很多时候，你会遇到奇怪的问题，因为你的回调被调用两次。 让我们看一个简单的例子 function do(err,result, callback){ if(err){ callback(“error”); } callback(“good”); }乍一看，这个片段是有道理的。如果有错误，在回调中发送“错误。如果不发送return，调用callaback后这个函数不会停下来。它只是将移动到调用回callback(“good”)。 这样做在长期和复杂的代码行里面会节省几个小时的调试。]]></content>
  </entry>
  <entry>
    <title><![CDATA[学习Git]]></title>
    <url>%2F2019%2F06%2F10%2Fyuque%2F%E5%AD%A6%E4%B9%A0Git%2F</url>
    <content type="text"><![CDATA[Git是一个免费开源的分布式版本控制系统，用于以高效、迅速的方式处理从很小到非常大的项目。Github是程序员的名片。代码，是程序员沟通的最直接的手段。 使用Git应该是每一位程序员的必备技能（钟情于SVN的亲们勿喷），Git被很多IT公司使用并在开源届和圈内有着巨大的声誉，之前团队做项目经常使用的也都是SVN现在接触了Github后，学习掌握Git也成了顺理成章的事情。希望这篇短文可以帮助到Git的初学者，我们共同学习。 Git入门Git本身非常容易掌握，同样学习Git也很容易，通过下面几个网站你就可以轻松掌握Git。 Git的官方网站提供了Git的所有文档。墙内用户可以参考Git Reference。 书籍：《Pro Git》提供在线的中文版和英文版。 Github与Code School联合提供了一个在线互动教程：Try Git，除此之外Git Immersion也是个不错的选择。各种英文看不懂？来看看Git 简易指南 。 进阶篇：Git图解，Git Magic，Think like a Git。 Github入门Github是一群有趣的人在做的有趣的事，Github不仅仅简单的是Git服务器，更是发展成了Social Coding，在Github你可以得到的绝对超出你的想象。 Github提供了官方的帮助信息和他们的博客。 《Git权威指南》一书的作者编写的GotGitHub是一份非常好的学习资料。 好文两篇：如何高效利用Github，Gthub初级运用。 最好的学习当然是Learning by doing！]]></content>
  </entry>
  <entry>
    <title><![CDATA[gongsi]]></title>
    <url>%2F2019%2F06%2F10%2Fyuque%2Fgongsi%2F</url>
    <content type="text"><![CDATA[$$ 表示整行公式：$$ \sum_{i=1}^n a_i=0$$$$ f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$$$ \sum^{j-1}{k=0}{\widehat{\gamma}{kj} z_k}$$ 这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如：Here is an example of AppleScript: 123tell application "Foo" beepend tell]]></content>
  </entry>
  <entry>
    <title><![CDATA[兼容所有浏览器的菱形]]></title>
    <url>%2F2019%2F06%2F10%2Fyuque%2F%E5%85%BC%E5%AE%B9%E6%89%80%E6%9C%89%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%8F%B1%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;菱形裁剪&lt;/title&gt; &lt;script type="text/javascript" charset="utf-8" src="js/raph.js"&gt;&lt;/script&gt; &lt;style type="text/css" charset="utf-8"&gt; #canvas &#123; background-color: #F4F4F4; left: 0; position: absolute; top: 0; &#125; #paper &#123; left: 0; position: relative; top: 0; &#125; h2 &#123; text-align: center; &#125; #vic1, #vic2, #vic3 &#123; position:absolute; left:0; top:0; &#125; shape, span &#123; font-size: 16px; font-family:'Microsoft YaHei'; color: #ffffff; font-style: oblique; display:block; height:100%; width:100%; text-align:center; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="canvas"&gt; &lt;div id="paper"&gt; &lt;div id="vic1"&gt;&lt;/div&gt; &lt;div id="vic2"&gt;&lt;/div&gt; &lt;div id="vic3"&gt;&lt;/div&gt; &lt;div id="vic4"&gt;&lt;/div&gt; &lt;div id="vic5"&gt;&lt;/div&gt; &lt;div id="vic6"&gt;&lt;/div&gt; &lt;div id="vic7"&gt;&lt;/div&gt; &lt;div id="vic8"&gt;&lt;/div&gt; &lt;div id="vic9"&gt;&lt;/div&gt; &lt;div id="vic10"&gt;&lt;/div&gt; &lt;div id="vic11"&gt;&lt;/div&gt; &lt;div id="vic12"&gt;&lt;/div&gt; &lt;div id="vic13"&gt;&lt;/div&gt; &lt;div id="vic14"&gt;&lt;/div&gt; &lt;div id="vic15"&gt;&lt;/div&gt; &lt;div id="vic16"&gt;&lt;/div&gt; &lt;div id="vic17"&gt;&lt;/div&gt; &lt;div id="vic18"&gt;&lt;/div&gt; &lt;div id="vic19"&gt;&lt;/div&gt; &lt;div id="vic20"&gt;&lt;/div&gt; &lt;div id="vic21"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; (function(Raphael,wh) &#123; var attr = &#123; fill: "#fff", stroke: "#BCBCBC", "stroke-width": 1 &#125;, attr2 = &#123; fill: "#F8F8F8", stroke: "#BBBBBB", "stroke-width": 1 &#125;, attr3 = &#123; fill: "#795755", stroke: "#BBBBBB", "stroke-width": 1, "opacity": "0", "cursor": "pointer" &#125;, attr4 = &#123; fill: "#fff", font: "40px Georgia", "opacity": "0", 'text-anchor': 'start' &#125;, x = 30/146*wh, //距离横坐标点 这里也可以根据角度而计算 y = 30/146*wh, //距离竖坐标点 这里也可以根据角度而计算 width = wh, height = wh, xiejiao = parseInt(width * Math.sqrt(2)), //对角线 plength = document.getElementById("paper").getElementsByTagName("div").length, //总个数 itemCount = 9, //每行显示的个数 row = plength % itemCount == 0 ? plength / itemCount : parseInt(plength / itemCount) + 1, //行数 R = Raphael("paper", xiejiao * (itemCount / 2 + 0.5), xiejiao * (row + 0.5)), //绘制画布宽度 aus = &#123;&#125;, //声明数组 pstrs = attr, temp, H1 = 0, L1 = "", key = "", imagesL1 = 0, imagesH1 = 0, _index = 0; for (var i = 0; i &lt; row; i++) &#123; //console.log("第" + i + "行"); for (var j = 1; j &lt;= itemCount; j++) &#123; _index = j + i * itemCount; if (_index &gt; plength) &#123; break; &#125; //console.log(j); if (j % 2 != 0) &#123; pstrs = attr; L1 = i * xiejiao + "r45t-0"; H1 = j == 1 ? 0 : (j - 1) / 2 * xiejiao; imagesH1 = (xiejiao - 40) / 2 + xiejiao * i; imagesL1 = H1 + 30; //console.log("奇数:" + j + ":" + H1 + " " + L1 + "图:" +imagesL1+ ":"+ imagesH1); &#125; else &#123; pstrs = attr2; L1 = (i * xiejiao + xiejiao) + "r45t-" + width; H1 = j / 2 * xiejiao; imagesH1 = (0.5 * xiejiao + 30 - 40) * 2 + xiejiao * i; imagesL1 = (j / 2 - 0.5) * xiejiao + 35; //console.log("偶数:" + j + ":" + H1 + " " + L1+ "图:" +imagesL1+ ":"+ imagesH1); &#125; //绘制最底层的形状 R.path(Raphael.format("M&#123;0&#125;,&#123;1&#125;h&#123;2&#125;v&#123;3&#125;h&#123;4&#125;z", x, y, width, height, -width)).transform("t" + H1 + "," + L1 + ",0s1").attr(pstrs); //绘制内容图片 R.image("images/big_1.jpg", imagesL1, imagesH1, 133, 40); //图片的位置及大小 //绘制遮罩层 temp = R.path(Raphael.format("M&#123;0&#125;,&#123;1&#125;h&#123;2&#125;v&#123;3&#125;h&#123;4&#125;z", x, y, width, height, -width)).transform("t" + H1 + "," + L1 + ",0s1").attr(attr3); //绘制遮罩层上面的说明文字 R.text(imagesL1 + 20, imagesH1 + 20, "60." + _index+"a").attr(attr4).data("i", _index+"a"); key = "vic" + _index; aus[key] = temp; &#125; &#125; for (var state in aus) &#123; aus[state].color = Raphael.getColor(); (function(st, state) &#123; st[0].style.cursor = "pointer"; //console.log(st.next[0].childNodes[0].innerHTML.length*parseInt(st.next[0].style.fontSize)/2); st.next[0].onmouseover = function() &#123; st.animate(&#123; "opacity": ".5" &#125;); st.next.animate(&#123; "opacity": "1.0" &#125;); &#125;; st.next[0].onmouseout = function() &#123; st.animate(&#123; "opacity": "0" &#125;); st.next.animate(&#123; "opacity": "0" &#125;); &#125;; st[0].onmouseover = function() &#123; st.animate(&#123; "opacity": ".5" &#125;); st.next.animate(&#123; "opacity": "1.0" &#125;); &#125;; st[0].onmouseout = function() &#123; st.animate(&#123; "opacity": "0" &#125;); st.next.animate(&#123; "opacity": "0" &#125;); &#125;; &#125;)(aus[state], state); &#125;; &#125;)(Raphael,146); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[babel笔记]]></title>
    <url>%2F2019%2F06%2F10%2Fyuque%2Fbabel%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[bable bable 官网英文版本: https://babeljs.io/docs/en/ bable 官网中文版本: https://www.babeljs.cn/docs/git源码地址：&gt; https://github.com/babel/website]]></content>
  </entry>
  <entry>
    <title><![CDATA[vuepress]]></title>
    <url>%2F2019%2F06%2F06%2Fyuque%2FVuePress%2F</url>
    <content type="text"><![CDATA[介绍VuePress 由两部分组成：第一部分是一个极简静态网站生成器，它包含由 Vue 驱动的主题系统和插件 API，另一个部分是为书写技术文档而优化的默认主题，它的诞生初衷是为了支持 Vue 及其子项目的文档需求。 1234567891011# 安装yarn global add vuepress@next # 或者：npm install -g vuepress@next# 新建一个 markdown 文件echo '# Hello VuePress!' &gt; README.md# 开始写作vuepress dev .# 开始写作vuepress dev .]]></content>
  </entry>
  <entry>
    <title><![CDATA[web前端学习资料收集]]></title>
    <url>%2F2019%2F06%2F06%2Fyuque%2Fweb%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[读谷歌开发指南专业高效的在线翻译管理平台其实谷歌除了一个分很好的学习指南，但很多人都不知道。DOM(Document Object Mode) 前端开发者手册2019 面向亿万用户级的移动端Web解决方案https://github.com/AlloyTeam/Mars 代码结构规范 前端跨框架跨平台框架 http://omijs.org 字体设置最佳实践 模拟原生效果实践 工具类方法汇总 iOS 与 Android 平台上问题列表 高性能 Mobile Web 开发 特效制作解决方案 - css3transform 触摸运动解决方案 - AlloyTouch Mobile 手势解决方案 - AlloyFinger Mobile 裁剪解决方案 - AlloyCrop Mobile 级联选择器 1kb代码搞定移动 Web 开发调试发布错误监控上报用户问题定位 - AlloyLever 小程序、小游戏以及 Web 通用 Canvas 渲染引擎 - Cax 前端学习地址和查询地址 各种开发文档大全 —–https://devdocs.io/ 开发者手册–腾讯云 多看 JavaScript指南 知乎 掘金 WordPress - 百度百科 全球最大中文百科全书 语雀–https://cn.wordpress.org/–http://www.wordpress.org.cn/ 前端免费学习网 segmentfault 学习技能，解决难题 Topics 浏览 Github 上最常用的主题 GitHub Explore Mozilla 开发者网络，简称 MDN w3schools.com https://developer.mozilla.org MDN 源于开发者，服务开发者 慕课网 懒人图库 力扣 Mac开发配置手册 FEX 技术峰会 推荐的经典的前端书籍 《JavaScript 忍者秘籍》 《JavaScript 高级程序设计》 《编写可维护的 JavaScript》 《Javascript 语言精粹》 《锋利的 jQuery》 《JavaScript DOM 编程艺术（第二版）》 《学习 JavaScript 数据结构与算法》 《JavaScript 权威指南》 《JavaScript 忍者秘籍》 《高性能 JavaScript》 《ECMAScript 6 标准入门》 《Build Your Own AngularJS》 《Effective JavaScript:编写高质量 JavaScript 代码的 68 个有效方法》 《你不知道的 JavaScript（上）》 《单页 Web 应用：JavaScript 从前端到后端》 《HTML5 与 CSS3 基础教程（第八版）》 《深入浅出 HTML 与 CSS》 《CSS 揭秘》 《HTML5 权威指南》 《CSS 权威指南》 《精通正则表达式》 深入理解 JavaScript 特性 Java Web 应用开发 Web全栈工程师学习大纲 推荐库 网站 文章收集 JavaScript面试题 vue面试题 ## 前端性能监控 产品 前端开发全面知识库]]></content>
  </entry>
</search>
