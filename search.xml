<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[你需掌握的CSS知识都在这]]></title>
    <url>%2F2019%2F12%2F09%2Fyuque%2F%E4%BD%A0%E9%9C%80%E6%8E%8C%E6%8F%A1%E7%9A%84CSS%E7%9F%A5%E8%AF%86%E9%83%BD%E5%9C%A8%E8%BF%99%2F</url>
    <content type="text"><![CDATA[1.CSS盒模型，在不同浏览器的差异css 标准盒子模型css盒子模型 又称为框模型（Box Model），包含了元素内容（content）、内边距（padding）、边框（border）、外边距（margin）几个要素。如下图： 图中的内层是content依次是padding border margin。通常我们设置背景时就是内容、内边距、边框这三部分，如果border设置颜色的时候会显示boder颜色当boder颜色是透明时会显示background-color的颜色。而该元素的子元素的是从content开始的。而外边距是透明的，不会遮挡其他元素。 元素框的总宽度=width+padding-left+padding-right+border-left+border-right+margin-left+margin-right; 元素框的总高度=height+padding-top+padding-bottom+border-top+border-bottom+margin-top+margin-bottom; IE盒子模型IE盒子模型如下图： 图中的内层是content依次是content padding border。通常我们设置背景时就是内容、内边距、边框这三部分。而外边距是透明的，不会遮挡其他元素。 元素框的总宽度=width（padding-left+padding-right+border-left+border-right)； 元素框的总高度=height（padding-top+padding-bottom+border-top+border-bottom）;两个模型宽度和高度的计算（是不一样的） w3c中的盒子模型的宽:包括margin+border+padding+width; width:margin*2+border*2+padding*2+width; height:margin*2+border*2+padding*2+height; &lt;br /&gt;iE中的盒子模型的width:包括border+padding+width; &lt;br /&gt;上面的两个宽度相加的属性是一样的。因此我们应该选择标准盒子模型，在网页的顶部加上 DOCTYPE 声明。 2.CSS所有选择器及其优先级、使用场景，哪些可以继承，如何运用at规则css选择器种类有：通用选择器：*id选择器：#header{}class选择器：.header{}元素选择器：div{}子选择器：ul &gt; li{}后代选择器：div p{}伪类选择器：:hover、::selection、.action、:first-child、:last-child、:first-of-type、:last-of-type、:nth-of-type(n)、:nth-of-last-type(n)等,例如a:hover{}伪元素选择器: :after、:before等,例如：li:after属性选择器: input[type=”text”]组合选择器：E,F/E F（后代选择器）/E&gt;F（子元素选择器）/E+F（直接相邻元素选择器—-匹配之后的相邻同级元素）/EF（普通相邻元素选择器—-匹配之后的同级元素）层次选择器：pul 选择前面有p元素的每个ul元素css选择器优先级： 选择器优先级由高到低分别为：!important &gt; 作为style属性写在元素标签上的内联样式 &gt;id选择器&gt;类选择器&gt;伪类选择器&gt;属性选择器&gt;标签选择器&gt; 通配符选择器（* 应少用）&gt;浏览器自定义； 当比较多个相同级别的CSS选择器优先级时，它们定义的位置将决定一切。下面从位置上将CSS优先级由高到低分为六级：1、位于标签里的中所定义的CSS拥有最高级的优先权。2、第二级的优先属性由位于 标签中的 @import 引入样式表所定义。3、第三级的优先属性由标签所引入的样式表定义。4、第四级的优先属性由标签所引入的样式表内的 @import 导入样式表定义。5、第五级优先的样式有用户设定。6、最低级的优先权由浏览器默认。 使用场景： class使用场景：需要某些特定样式的标签则放在同一个class中，需要此样式的标签可再添加此类。（class不可被javascript中的GetElementByID函数所调用） id使用场景：1、根据提供的唯一id号快速获取标签对象，如：document.getElementById(id) ；2、用于充当label标签for属性的值：示例：用户名：，表示单击此label标签时，id为userid的标签获得焦点 *CSS哪些属性可以继承？ *css继承特性主要是指文本方面的继承(比如字体、颜色、字体大小等)，盒模型相关的属性基本没有继承特性。不可继承的：display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、top、bottom、left、right、z-index、float、clear、 table-layout、vertical-align、page-break-after、page-bread-before和unicode-bidi。所有元素可继承的：visibility和cursor终极块级元素可继承的：text-indent和text-align内联元素可继承的：letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction列表元素可继承的：list-style、list-style-type、list-style-position、list-style-image 常用at规则及使用示例： @charset @import @namespace @document @font-face @keyframes @media @page @supports12345678910/*定义字符集*/@charset &quot;utf-8&quot; /*导入css文件*/ @import &quot;base.css&quot;/*自定义字体*/@font-face &#123;&#125;/*声明CSS3 animation动画关键帧*/@keyframes fadeIn &#123;&#125;/*媒体查询*/@media&#123;&#125;复制代码 3.CSS伪类和伪元素有哪些，它们的区别和实际应用伪类的例子有：:hover:active:first-child:visited等。伪元素的例子有：:first-line:first-letter:after:before伪类和伪元素的根本区别在于：它们是否创造了新的元素(抽象)。从我们模仿其意义的角度来看，如果需要添加新元素加以标识的，就是伪元素，反之，如果只需要在既有元素上添加类别的，就是伪类。伪元素在一个选择器里只能出现一次，并且只能出现在末尾;伪类则是像真正的类一样发挥着类的作用，没有数量上的限制，只要不是相互排斥的伪类，也可以同时使用在相同的元素上。实际使用：伪类用一个冒号表示 :first-child伪元素则使用两个冒号表示 ::first-line 4.CSS几种定位的规则、定位参照物、对文档流的影响，如何选择最好的定位方式，雪碧图实现原理1）、static定位(普通流定位) ————– 默认定位2）、float定位(浮动定位) 例：float:left;有两个取值：left(左浮动)和right(右浮动)。浮动元素会在没有浮动元素的上方，效果上看是遮挡住了没有浮动的元素，有float样式规则的元素是脱离文档流的，它的父元素的高度并不能有它撑开。3）、relative定位(相对定位) position:relative;相对本元素的左上角进行定位，top,left,bottom,right都可以有值。虽然经过定位后，位置可能会移动，但是本元素并没有脱离文档流，还占有原来的页面空间。可以设置z-index。使本元素相对于文档流中的元素，或者脱离文档流但是z-index的值比本元素的值要小的元素更加靠近用户的视线。相对定位最大的作用是为了实现某个元素相对于本元素的左上角绝对定位，本元素需要设置position为relative。4）、absolute定位(绝对定位) position:absolute;相对于祖代中有relative(相对定位)并且离本元素层级关系上是最近的元素的左上角进行定位，如果在祖代元素中没有有relative定位的，就默认相对于body进行定位。绝对定位是脱离文档流的，与浮动定位是一样的效果，会压在非定位元素的上方。可以设置z-index属性。雪碧图实现原理：CSS雪碧的基本原理是把你的网站上用到的一些图片整合到一张单独的图片中，从而减少你的网站的HTTP请求数量。该图片使用CSS background和background-position属性渲染，这也就意味着你的标签变得更加复杂了，图片是在CSS中定义，而非标签。 5.写出尽可能多的水平垂直居中的方案并对比它们的优缺点行内元素水平居中：首先看它的父元素是不是块级元素，如果是，则直接给父元素设置 text-align: center; **如果不是，则先将其父元素设置为块级元素，再给父元素设置 **text-align: center;块级元素水平居中(定宽度)：1）需要谁居中，给其设置 margin: 0 auto; （作用：使盒子自己居中）2) 首先设置父元素为相对定位，再设置子元素为绝对定位，设置子元素的left:50%，即让子元素的左上角水平居中；设置绝对子元素的 margin-left: -元素宽度的一半px;** 或者设置transform: translateX(-50%);块级元素水平居中(不宽度)：1) 默认子元素的宽度和父元素一样，这时需要设置子元素为display: inline-block; 或 display: inline;即将其转换成行内块级/行内元素，给父元素设置 text-align: center;2) 首先设置父元素为相对定位，再设置子元素为绝对定位，设置子元素的left:50%，即让子元素的左上角水平居中； 利用css3新增属性transform: translateX(-50%);使用flexbox布局实现水平居中（宽度定不定都可以）:使用flexbox布局，只需要给待处理的块状元素的父元素添加属性 display: flex; justify-content: center; 单行的行内元素垂直居中:只需要设置单行行内元素的”行高等于盒子的高”即可；多行的行内元素垂直居中:使用给父元素设置display:table-cell;和vertical-align: middle;属即可；块级元素垂直居中方法一：使用定位首先设置父元素为相对定位，再设置子元素为绝对定位，设置子元素的top: 50%**，即让子元素的左上角垂直居中； 定高度：设置绝对子元素的** margin-top: -元素高度的一半px;** 或者设置transform: translateY(-50%);不定高度：利用css3新增属性transform: translateY(-50%);块级元素垂直居中方法二：使用flexbox布局实现（高度定不定都可以）** 使用flexbox布局，只需要给待处理的块状元素的父元素添加属性 display: flex; align-items: center;水平垂直居中-已知高度和宽度的元素：方法一：设置父元素为相对定位，给子元素设置绝对定位，top: 0; right: 0; bottom: 0; left: 0; margin: auto;方法二：设置父元素为相对定位，给子元素设置绝对定位，left: 50%; top: 50%; margin-left: –元素宽度的一半px; margin-top: –元素高度的一半px;水平垂直居中-未知高度和宽度的元素：方法一：使用定位属性 设置父元素为相对定位，给子元素设置绝对定位，left: 50%; top: 50%; transform: translateX(-50%) translateY(-50%);方案二：使用flex布局实现设置父元素为flex定位，justify-content: center; align-items: center; 6.BFC的布局规则，实现原理，可以解决的问题BFC直译为块级格式化上下文，它是一个独立的渲染区域，只有Block-level box参与，它规定了内部的Block-level Box如何布局，并且与外部毫不相干。注意：可以把BFC理解为一个大的盒子，其内部是由Block-level box组成的 BFC布局规则： 内部的Box会在垂直方向，一个接一个地放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动元素也参与计算BFC的作用及原理：1. 自适应两栏布局2. 清除内部浮动3. 防止垂直 margin 重叠BFC内部的元素和外部的元素绝对不会互相影响，因此， 当BFC外部存在浮动时，它不应该影响BFC内部Box的布局，BFC会通过变窄，而不与浮动有重叠。同样的，当BFC内部有浮动时，为了不影响外部元素的布局，BFC计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理。 7.CSS函数有哪些？根据w3cplus中可以划分为以下几类： 属性函数：attr()； 背景图片函数：linear-gradient()、radial-gradient()、conic-gradient()、repeating-linear-gradient()、repeating-radial-gradient()、repeating-conic-gradient()、image-set()、image()、url()、element()； 颜色函数：rgb()、rgba()、hsl()、hsla()、hwb()、color-mod()； 图形函数：circle()、ellipse()、inset()、polygon()、path() 滤镜函数：blur()、brightness()、contrast()、drop-shadow()、grayscale()、hue-rotate()、invert()、opacity()、saturate()、sepia()； 转换函数：matrix()、matrix3d()、perspective()、rotate()、rotate3d()、rotateX()、rotateY()、rotateZ()、scale()、scale3d()、scaleX()、scaleY()、scaleZ()、skew()、skewX()、skewY()、translate()、translateX()、translateY()、translateZ()、translate3d()； 数学函数：calc()、min()、max()、mixmax()、repeat()； 缓动函数：cubic-bezier()、steps()； 其他函数：counter()、counters()、toggle()、var()、 symbols()。 8.PostCSS、Sass、Less的异同，以及使用配置，至少掌握一种 ● 编译环境不一样，Sass的安装需要Ruby环境，是在服务端处理的，而Less是需要引入less.js来处理Less代码输出css到浏览器，也可以在开发环节使用Less，然后编译成css文件，直接放到项目中； ● 变量符号不一样，Less是@，而Scss是$； ● 输出设置，Less没有输出设置，Sass提供4中输出选项：nested, compact, compressed 和 expanded； ● 处理条件语句，Sass支持条件语句，可以使用if{}else{},for{}循环等等。 LESS的条件语句使用有些另类，他不是我们常见的关键词if和else if之类，而其实现方式是利用关键词“when”； ● 引用外部文件，文件名如果以下划线_开头的话，Sass会认为该文件是一个引用文件，不会将其编译为css文件，ess引用外部文件和css中的@import没什么差异； ● 工具库的不同，Sass有工具库Compass, 简单说，Sass和Compass的关系有点像Javascript和jQuery的关系,Compass在Sass的基础上，封装了一系列有用的模块和模板，补充强化了Sass的功能。Less有UI组件库Bootstrap,Bootstrap是web前端开发中一个比较有名的前端UI组件库，Bootstrap的样式文件部分源码就是采用Less语法编写。 ● PostCSS介绍：PostCSS 的主要功能只有两个：第一个就是前面提到的把 CSS 解析成 JavaScript 可以操作的 AST，第二个就是调用插件来处理 AST 并得到结果。因此，不能简单的把 PostCSS 归类成 CSS 预处理或后处理工具。PostCSS 所能执行的任务非常多，同时涵盖了传统意义上的预处理和后处理。 ● PostCSS使用PostCSS 一般不单独使用，而是与已有的构建工具进行集成。PostCSS 与主流的构建工具，如 Webpack、Grunt 和 Gulp 都可以进行集成。完成集成之后，选择满足功能需求的 PostCSS 插件并进行配置。现在经常用到的是基于PostCSS的Autoprefixer插件，使用方式可以在官网的插件库进行查询。下面是官网地址：PostCSS官网地址 9.CSS模块化方案有哪些？ css的模块化方案可能和js的一样多，下面简单介绍几种主要的模块方案。 oocss面对对象的规则，主要的原则是两种：分离结构和外观，分离容器和内容。 名词解释分离结构和外观：增加可重复的设计单元，同时去推进产品和ui对这方面的思考，比如下面的css使用时对象模式的命名和模块化规则。分离容器和内容：指的是样式的使用不以元素位置唯一匹配，在任何位置你都可以使用这个样式，如果你不适用这个样式，会保持默认的样式。 实例1// dom结构&lt;div class=&quot;toogle simple&quot;&gt; &lt;div class=&quot;toogle-control open&quot;&gt; &lt;div class=&quot;toogle-tittle&quot;&gt;标题&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;toogle-details &quot;&gt;&lt;/div&gt;&lt;/div&gt;复制代码 1// 模块的标记 唯一标识.toggle&#123;&#125;// 皮肤样式的写法，如果基本结构是一样的，你可以用complex的一个辅助样式.toggle.simple&#123;&#125;// 是否做嵌套写法 相信很多预处理器的部分会支持嵌套 然后很多人会这样写,不被推荐的.toogle&#123; .toogle-control&#123; &#125; .toogle-details&#123; &#125;&#125;// 其实你会这样组织么 不是很建议 这样会降低查询效率 如果能确认唯一性的时候 其实直接写子即可.toogle&#123;&#125;.toogle-control&#123;&#125;.toogle-details&#123;&#125;复制代码 smacsssma和oocss有很多类似之处，但区分的地方有很多，主要是对样式的分类。分别是：基础、布局、模块、状态、主题 基础可以适用于任何位置，我也称全局样式 布局主要是用来实现不同的特色布局，提高布局的复用率， 模块设计中的模块化，可重复使用的一个单元，一般是dom+css的耦合绑定。 状态描述在特定状态下的布局或者模块的特殊化表现，这里我觉得要推荐下《css禅意花园》，在dom结构不变的情况下，可以通过css的皮肤化实现样式的改版。 主题与状态相比更加定制的是，我们会针对有些特殊的模块，进行主题的设置，包括一系列的颜色、尺寸、交互等进行重度设计，参数化设计。 案例1// dom结构&lt;div class=&quot;toogle toogle-simple&quot;&gt; &lt;div class=&quot;toogle-control is-active&quot;&gt; &lt;div class=&quot;toogle-tittle&quot;&gt;标题&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;toogle-details &quot;&gt;&lt;/div&gt;&lt;/div&gt;复制代码 与oocss相比，其实大部分设计思路是一样的，以一个类作为css的作用域（作用域就是两个限制，1 不符合场景时限制禁止使用 2 符合场景时要正确的使用），另外的区别就是针对皮肤和状态的不同书写规则。 bembem就是块、元素、修饰符的思维去写样式。它不涉及具体的css结构，只是建议你如何命名css. 案例1// dom结构&lt;div class=&quot;toogle toogle--simple&quot;&gt; &lt;div class=&quot;toogle_control toogle_control--active&quot;&gt; &lt;div class=&quot;toogle_tittle&quot;&gt;标题&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;toogle_details &quot;&gt;&lt;/div&gt;&lt;/div&gt;复制代码 解释 块级：所属组件的名称 元素：元素在组件里的名称 修饰符：任何与元素修饰相关的类 style-components **彻底抛弃 CSS，用 JavaScript 写 CSS 规则,点击style-components进入github的主页。**CSS Modules 使用JS编译原生的CSS文件，使其具备模块化的能力，点击CSS Modules进入github主页。这些模块化方案都是各有优缺点，如命名约定：命名复杂、缺乏扩展、 CSS Modules当然也有一些缺点(你得先学会它再去谈优劣)。在众多解决方案中，没有绝对的优劣。还是要结合自己的场景来决定。 10.CSS如何配置按需加载** ● **使用require.js按需加载CSS 123456789101112131415161718//模块test.jsdefine([&apos;css!../css/test.css&apos;], function() &#123; //先加载依赖样式 var test = &#123;&#125;; return test;&#125;);//配置require.config(&#123; map: &#123; //map告诉RequireJS在任何模块之前，都先载入这个模块 &apos;*&apos;: &#123; css: &apos;lib/css&apos; &#125; &#125;, paths: &#123; test: &apos;lib/test&apos;, &#125;&#125;);//调用require([&apos;test&apos;])复制代码 ● webpack配置CSS的按需加载这里以ant desgin css 为例： 1234567891011121314151617181920212223242526&#123; test: /\.(js|mjs|jsx|ts|tsx)$/, include: paths.appSrc, loader: require.resolve(&apos;babel-loader&apos;), options: &#123; customize: require.resolve( &apos;babel-preset-react-app/webpack-overrides&apos; ), plugins: [ [&quot;import&quot;,&#123;libraryName: &quot;antd&quot;, style: &apos;css&apos;&#125;], //只需加一行，手动划重点antd按需加载 [ require.resolve(&apos;babel-plugin-named-asset-import&apos;), &#123; loaderMap: &#123; svg: &#123; ReactComponent: &apos;@svgr/webpack?-svgo,+ref![path]&apos;, &#125;, &#125;, &#125;, ], ], cacheDirectory: true, cacheCompression: isEnvProduction, compact: isEnvProduction, &#125;,&#125;复制代码 11. 如何防止CSS阻塞渲染 默认情况下，CSS 被视为阻塞渲染的资源，这意味着浏览器将不会渲染任何已处理的内容，直至 CSSOM 构建完毕。请务必精简您的 CSS，并利用媒体类型和查询来解除对渲染的阻塞。我们可以通过 CSS“媒体类型”和“媒体查询”来解决这类用例： 123&lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;link href=&quot;print.css&quot; rel=&quot;stylesheet&quot; media=&quot;print&quot;&gt; &lt;link href=&quot;other.css&quot; rel=&quot;stylesheet&quot; media=&quot;(min-width: 40em)&quot;&gt;复制代码 媒体查询由媒体类型以及零个或多个检查特定媒体特征状况的表达式组成。例如，上面的第一个样式表声明未提供任何媒体类型或查询，因此它适用于所有情况，也就是说，它始终会阻塞渲染。第二个样式表则不然，它只在打印内容时适用—或许您想重新安排布局、更改字体等等，因此在网页首次加载时，该样式表不需要阻塞渲染。最后，最后一个样式表声明提供由浏览器执行的“媒体查询”：符合条件时，浏览器将阻塞渲染，直至样式表下载并处理完毕。 12.熟练使用CSS(3)实现常见动画，如渐变、移动、旋转、缩放等等我把一些常用的CSS动画效果代码上传到github了，有需要的同学可以点击下载，CSS常用动画；另外还有一些CSS动画库，比如：animate.css、magic.css、Hover.css、 13.CSS浏览器兼容性写法 浏览器CSS样式初始化由于每个浏览器的css默认样式不尽相同，所以最简单有效的方式就是对其进行初始化，相信很多朋友都写过这样的代码，在所有CSS开始前，先把marin和padding都设为0，以防不同浏览器的显示效果不一样。1234*&#123; margin: 0; padding: 0; &#125;复制代码 关于浏览器CSS样式初始化，经验不丰富的话，可能也不知道该初始化什么，这里给大家推荐一个库，Normalize.css，github star数量接近3.4万，选取展示其中几个样式设置，如下： 12345678910111213141516html &#123; line-height: 1.15; /* Correct the line height in all browsers */ -webkit-text-size-adjust: 100%; /* Prevent adjustments of font size after orientation changes in iOS. */ &#125; body &#123; margin: 0; &#125; a &#123; background-color: transparent; /* Remove the gray background on active links in IE 10. */ &#125; img &#123; border-style: none; /* Remove the border on images inside links in IE 10. */ &#125;复制代码 通过CSS样式初始化，相信能解决不少常规的兼容性问题，接下来再看看浏览器的私有属性。2. 浏览器私有属性我们经常会在某个CSS的属性前添加一些前缀，比如-webkit-，-moz- ，-ms-，这些就是浏览器的私有属性。为什么会出现私有属性呢？这是因为制定HTML和CSS标准的组织W3C动作是很慢的。通常，有W3C组织成员提出一个新属性，比如说圆角border-radius，大家都觉得好，但W3C制定标准，要走很复杂的程序，审查等。而浏览器商市场推广时间紧，如果一个属性已经够成熟了，就会在浏览器中加入支持。但是为避免日后W3C公布标准时有所变更，会加入一个私有前缀，比如-webkit-border-radius，通过这种方式来提前支持新属性。等到日后W3C公布了标准，border-radius的标准写法确立之后，再让新版的浏览器支持border-radius这种写法。常用的前缀有： -moz代表firefox浏览器私有属性 -ms代表IE浏览器私有属性 -webkit代表chrome、safari私有属性 -o代表opera私有属性 对于私有属性的顺序要注意，把标准写法放到最后，兼容性写法放到前面 12345-webkit-transform:rotate(-3deg); /*为Chrome/Safari*/ -moz-transform:rotate(-3deg); /*为Firefox*/ -ms-transform:rotate(-3deg); /*为IE*/ -o-transform:rotate(-3deg); /*为Opera*/ transform:rotate(-3deg);复制代码 每个CSS属性写这么一堆兼容性代码，无疑是对生命最大的浪费，后面我们会讲一下通过自动化插件来处理这块。3. CSS hack有时我们需要针对不同的浏览器或不同版本写特定的CSS样式，这种针对不同的浏览器/不同版本写相应的CSS code的过程，叫做CSS hack!CSS hack的写法大致归纳为3种：条件hack、属性级hack、选择符级hack。 各游览器常用兼容标记一览表: 标记 IE6 IE7 IE8 FF Opera Sarari [*+&gt;&lt;] √ √ X X X X _ √ X X X X X \9 √ √ √ X X X \0 X X √ X √ X @media screen and (-webkit-min-device-pixel-ratio:0){.bb {}} X X X X X √ .bb , x:-moz-any-link, x:default X √ X √(ff3.5及以下) X X @-moz-document url-prefix(){.bb{}} X X X √ X X @media all and (min-width: 0px){.bb {}} X X X √ √ √ * +html .bb {} X √ X X X X 游览器内核 Trident Trident Trident Gecko Presto WebKit （以上 .bb 可更换为其它样式名） 4.自动化插件Autoprefixer是一款自动管理浏览器前缀的插件，它可以解析CSS文件并且添加浏览器前缀到CSS内容里，使用Can I Use（caniuse网站）的数据来决定哪些前缀是需要的。把Autoprefixer添加到资源构建工具（例如Grunt）后，可以完全忘记有关CSS前缀的东西，只需按照最新的W3C规范来正常书写CSS即可。如果项目需要支持旧版浏览器，可修改browsers参数设置 。 12345678910111213//我们编写的代码 div &#123; transform: rotate(30deg); &#125; // 自动补全的代码，具体补全哪些由要兼容的浏览器版本决定，可以自行设置 div &#123; -ms-transform: rotate(30deg); -webkit-transform: rotate(30deg); -o-transform: rotate(30deg); -moz-transform: rotate(30deg); transform: rotate(30deg); &#125;复制代码 目前webpack、gulp、grunt都有相应的插件，如果还没有使用，那就赶紧应用到我们的项目中吧，别再让CSS兼容性浪费你的时间！ 14.掌握一套完整的响应式布局方案比较常用的布局方式有float,position,display,table,flex,grid等。 全屏布局相关方案的兼容性、性能和自适应一览表：实际项目使用中一般是根据具体场景去选择相应的布局方式。附两张CSS知识图谱(建议收藏)： 注：部分内容来源于网络，仅供参考与学习，有遗漏或者错误的地方欢迎指出或者讨论！ 最后 欢迎加我微信(RHB_1223),拉你进web全栈学习打卡群，每天一道题，补齐自己的知识盲区，进阶高级资深前端！每日一题github主页：每日一题 欢迎关注「深圳湾码农】，做持续学习的技术人！ 作者：深圳湾码农链接：https://juejin.im/post/5d8336d2f265da03df5f4a06来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
  </entry>
  <entry>
    <title><![CDATA[常用的 59 个类（项目需要的基础函数）]]></title>
    <url>%2F2019%2F12%2F09%2Fyuque%2F%E5%B8%B8%E7%94%A8%E7%9A%84%2059%20%E4%B8%AA%E7%B1%BB%EF%BC%88%E9%A1%B9%E7%9B%AE%E9%9C%80%E8%A6%81%E7%9A%84%E5%9F%BA%E7%A1%80%E5%87%BD%E6%95%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[https://juejin.im/post/5de5be53f265da05c33fcbb4 git源码地址：https://github.com/lanzhsh/react-vue-koa/tree/master/utils-lan 前言前端开发有时会处理一部分后台返回的数据,或者根据数据判断做一些处理;这个时候就非常有必要将一些常用的工具类封装起来;本文根据常用的一些工具类封装了 59 个方法,当然还有很多用的较少前期没有录入,后期持续跟新;源码地址,utils-lan 源码地址,欢迎 star! 使用1.方法一 1234npm i -S utils-lan import utils from 'utils-lan' console.log(utils.arrJudge(['1','2']))复制代码 2.方法二git clone utils-lan 源码地址下来导入项目;3.关于类名是根据字面量来命名的,方法首个驼峰表示所属类型,后面是方法作用;如 arrAndSet 一看就是数组的方法,是处理交集的;如果实在难以忍受,可以采用方法 2,导入本地对项目进行更改. arr 1.arrAndSet并集 123456789/** * 数组并集,只支持一维数组 * @param &#123;Array&#125; arrOne * @param &#123;Array&#125; arrTwo */export const arrAndSet = (arrOne, arrTwo) =&gt; &#123; return arrOne.concat(arrTwo.filter(v =&gt; !arrOne.includes(v)))&#125;复制代码 2.arrIntersection交集 123456789/** * 数组交集,只支持一维数组 * @param &#123;Array&#125; arrOne * @param &#123;Array&#125; arrTwo */export const arrIntersection = (arrOne, arrTwo) =&gt; &#123; return arrOne.filter(v =&gt; arrTwo.includes(v))&#125;复制代码 3.arrDifference差集 12345678910/** * 数组差集,只支持一维数组 * @param &#123;Array&#125; arrOne * @param &#123;Array&#125; arrTwo * eg: [1, 2, 3] [2, 4, 5] 差集为[1,3,4,5] */export const arrDifference = (arrOne, arrTwo) =&gt; &#123; return arrOne.concat(arrTwo).filter(v =&gt; !arrOne.includes(v) || !arrTwo.includes(v))&#125;复制代码 4.arrTwoToArrObj两个数组合并成一个数组对象 1234567891011121314151617/** * 两个数组合并成一个对象数组,考虑到复杂度,所以目前支持两个一维数组 * @param &#123;Array&#125; arrOne * @param &#123;Array&#125; arrTwo * @param &#123;oneKey&#125; oneKey 选填,如果两个都未传,直接以 arrOne 的值作为 key,arrTwo 作为 value * @param &#123;twoKey&#125; twoKey */export const arrTwoToArrObj = (arrOne, arrTwo, oneKey, twoKey) =&gt; &#123; if(!oneKey&amp;&amp;!twoKey)&#123; return arrOne.map((oneKey, i) =&gt; (&#123; [oneKey]:arrTwo[i] &#125;)) // 或者 // return Object.assign(&#123;&#125;, arrOne, arrTwo) &#125;else&#123; return arrOne.map((oneKey, i) =&gt; (&#123; oneKey, twoKey: arrTwo[i] &#125;)) &#125;&#125;复制代码 5.arrObjSum数组对象求和 123456789/** * 数组对象求和 * @param &#123;Object&#125; arrObj 数组对象 * @param &#123;String&#125; key 数组对应的 key 值 */export const arrObjSum = (obj, key) =&gt; &#123; return arrObj.reduce((prev, cur) =&gt; prev + cur.key, 0)&#125;复制代码 6.arrConcat数组合并 123456789/** * 数组合并,目前合并一维 * @param &#123;Array&#125; arrOne 数组 * @param &#123;Array&#125; arrTwo 数组 */export const arrConcat = (arrOne, arrTwo) =&gt; &#123; return [...arrOne, ...arrTwo]&#125;复制代码 7.arrSum数组求和 12345678910/** * 数组求和 * @param &#123;Array&#125; arr 数组 */export const arrSum = arr =&gt; &#123; return arr.reduce((prev, cur)=&gt; &#123; return prev + cur &#125;, 0)&#125;复制代码 8.arrIncludeValue数组是否包含某值 123456789/** * 数组是否包含某值 * @param &#123;Array&#125; arr 数组 * @param &#123;&#125; value 值,目前只支持 String,Number,Boolean */export const arrIncludeValue = (arr, value) =&gt; &#123; return arr.includes( value)&#125;复制代码 9.arrMax数组最大值 12345678/** * 数组最大值 * @param &#123;Array&#125; arr 数组 */export const arrMax = arr =&gt; &#123; return Math.max(...arr)&#125;复制代码 10.arrRemoveRepeat数组去重 12345678/** * 数组去重 * @param &#123;Array&#125; arr 数组 */export const arrRemoveRepeat = arr =&gt; &#123; return Array.from(new Set(arr))&#125;复制代码 11.arrOrderAscend数组排序 1234567891011/** * 数组排序 * @param &#123;Array&#125; arr 数组 * @param &#123;Boolean&#125; ascendFlag 升序,默认为 true */export const arrOrderAscend = (arr, ascendFlag=true) =&gt; &#123; return arr.sort((a, b) =&gt; &#123; return ascendFlag ? a - b : b - a &#125;)&#125;复制代码 12.arrJudge判断是否是数组 123456/** * 判断是否是数组 * @param &#123;Array&#125;&#125; arr 数组 */export const arrJudge = arr =&gt; Array.isArray(arr)复制代码 check 13.checkNum判断是否是数字 123456/** * 判断是否是数字 * @param &#123;Number&#125; data */export const checkNum = data =&gt; /^\d&#123;1,&#125;$/g.test(data)复制代码 14.checkLetter判断是否是字母 123456/** * 判断是否是字母 * @param &#123;Number&#125; data */export const checkLetter = data =&gt; /^[a-zA-Z]+$/g.test(data)复制代码 15.checkLowercaseLetter判断是否全部是小写字母 123456/** * 判断是否全部是小写字母 * @param &#123;Number&#125; data */export const checkLowercaseLetter = data =&gt; /^[a-z]+$/g.test(data)复制代码 16.checkCapitalLetter判断是否是大写字母 123456/** * 判断是否是大写字母 * @param &#123;Number&#125; data */export const checkCapitalLetter = data =&gt; /^[A-Z]+$/g.test(data)复制代码 17.checkNumOrLetter判断是否是字母或数字 123456/** * 判断是否是字母或数字 * @param &#123;Number || String&#125; data 字符或数字 */export const checkNumOrLetter = data =&gt; /^[0-9a-zA-Z]*$/g.test(data)复制代码 18.checkChinese判断是否是中文 123456/** * 判断是否是中文 * @param &#123;String&#125; data 中文 */export const checkChinese = data =&gt; /^[\u4E00-\u9FA5]+$/g.test(data)复制代码 19.checkChineseNumberLettter判断是否是中文，数字或字母 12export const checkChineseNumberLettter = data =&gt; /^[a-zA-Z0-9\u4e00-\u9fa5]+$/g.test(data)复制代码 20.checkEmail判断是否是邮箱地址 123456789/** * 判断是否是邮箱地址 * @param &#123;String&#125; data */export const checkEmail = data =&gt; &#123; const reg = /^[a-zA-Z0-9.!#$%&amp;&apos;*+\/=?^_`&#123;|&#125;~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]&#123;0,61&#125;[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]&#123;0,61&#125;[a-zA-Z0-9])?)*$/g if (reg.test(data)) return true&#125;复制代码 21.checkTelphone判断是否是手机号 123456789/** * 判断是否是手机号，只要是13,14,15,16,17,18,19开头即可 * @param &#123;String&#125; data */export const checkTelphone = data =&gt; &#123; const reg = /^((\+|00)86)?1[3-9]\d&#123;9&#125;$/g if (reg.test(data)) return true&#125;复制代码 22.checkUrl判断是否是正确的网址 123456789101112131415/** * 判断是否是正确的网址 * @param &#123;String&#125; url 网址 */export const checkUrl = url =&gt; &#123; const a = document.createElement(&apos;a&apos;) a.href = url return [ /^(http|https):$/.test(a.protocol), a.host, a.pathname !== url, a.pathname !== `/$&#123;url&#125;` ].find(x =&gt; !x) === undefined&#125;复制代码 client 23.checkBrowser1234567891011121314/** * 判断是浏览器内核 */export const checkBrowser = () =&gt; &#123; const u = navigator.userAgent; const obj = &#123; trident: u.indexOf(&quot;Trident&quot;) &gt; -1, //IE内核 presto: u.indexOf(&quot;Presto&quot;) &gt; -1, //opera内核 webKit: u.indexOf(&quot;AppleWebKit&quot;) &gt; -1, //苹果、谷歌内核 gecko: u.indexOf(&quot;Gecko&quot;) &gt; -1 &amp;&amp; u.indexOf(&quot;KHTML&quot;) == -1, //火狐内核 &#125; return Object.keys(obj)[Object.values(obj).indexOf(true)]&#125;;复制代码 24.checkIosAndroidIpad判断是终端类型,值有ios,android,iPad 12345678910111213/** * 判断是终端类型,值有ios,android,iPad */export const checkIosAndroidIpad = () =&gt; &#123; const u = navigator.userAgent; const obj = &#123; ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端 android: u.indexOf(&quot;Android&quot;) &gt; -1 || u.indexOf(&quot;Linux&quot;) &gt; -1, //android终端或者uc浏览器 iPad: u.indexOf(&quot;iPad&quot;) &gt; -1, //是否iPad &#125; return Object.keys(obj)[Object.values(obj).indexOf(true)]&#125;;复制代码 25.checkWeixinQqUc判断是否是微信,qq 或 uc 1234567891011121314/** * 判断是否是微信,qq 或 uc */export const checkWeixinQqUc = () =&gt; &#123; const u = navigator.userAgent; const obj = &#123; weixin: u.indexOf(&quot;MicroMessenger&quot;) &gt; -1, //是否微信 qq: u.match(/QQ/i) == &quot;qq&quot;&amp;&amp;!u.indexOf(&apos;MQQBrowser&apos;) &gt; -1, //是否QQ uc: u.indexOf(&apos;UCBrowser&apos;) &gt; -1 &#125; return Object.keys(obj)[Object.values(obj).indexOf(true)]&#125;;复制代码 26.checkIsIphoneX检查是否是 IphoneX 1234567891011/** * 检查是否是 IphoneX */export const checkIsIphoneX = () =&gt; &#123; const u = navigator.userAgent; const isIOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/); if (isIOS &amp;&amp; screen.height &gt;= 812) &#123; return true; &#125;&#125;;复制代码 file 27.fileFormatSize格式化文件单位 12345678910111213/** * 格式化文件单位 * @param &#123;String || Number&#125; size 文件大小(kb) */export const fileFormatSize = size =&gt; &#123; var i var unit = [&apos;B&apos;, &apos;KB&apos;, &apos;MB&apos;, &apos;GB&apos;, &apos;TB&apos;, &apos;PB&apos;] for (i = 0; i &lt; unit.length &amp;&amp; size &gt;= 1024; i++) &#123; size /= 1024 &#125; return (Math.round(size * 100) / 100 || 0) + unit[i]&#125;复制代码 obj 28.objIsEqual判断两个对象是否相等,目前只支持对象值为简单数据类型的判断 12345678910111213141516171819202122/** * 判断两个对象是否相等,目前只支持对象值为简单数据类型的判断 * @param &#123;Object&#125; oneObj 对象 * @param &#123;Object&#125; twoObj 对象 */export const objIsEqual = (oneObj, twoObj) =&gt; &#123; const aProps = Object.getOwnPropertyNames(oneObj); const bProps = Object.getOwnPropertyNames(twoObj); if (aProps.length != bProps.length) &#123; return false; &#125; for (let i = 0; i &lt; aProps.length; i++) &#123; let propName = aProps[i]; let propA = oneObj[propName]; let propB = twoObj[propName]; if ( propA !== propB) &#123; return false; &#125; &#125; return true;&#125;复制代码 29.objDeepClone对象深度克隆;1.JSON.stringify深度克隆对象;2.无法对函数 、RegExp等特殊对象的克隆;3.会抛弃对象的constructor,所有的构造函数会指向Object;4.对象有循环引用,会报错 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * 对象深度克隆, * JSON.stringify深度克隆对象 * 无法对函数 、RegExp等特殊对象的克隆, * 会抛弃对象的constructor,所有的构造函数会指向Object * 对象有循环引用,会报错 * @param &#123;Object&#125; obj 克隆的对象 */export const objDeepClone = obj =&gt; &#123; return clone(obj)&#125;const isType = (obj, type) =&gt; &#123; if (typeof obj !== &apos;object&apos;) return false; // 判断数据类型的经典方法： const typeString = Object.prototype.toString.call(obj); let flag; switch (type) &#123; case &apos;Array&apos;: flag = typeString === &apos;[object Array]&apos;; break; case &apos;Date&apos;: flag = typeString === &apos;[object Date]&apos;; break; case &apos;RegExp&apos;: flag = typeString === &apos;[object RegExp]&apos;; break; default: flag = false; &#125; return flag;&#125;;/*** deep clone* @param &#123;[type]&#125; parent object 需要进行克隆的对象* @return &#123;[type]&#125; 深克隆后的对象*/const clone = parent =&gt; &#123; // 维护两个储存循环引用的数组 const parents = [] const children = [] const _clone = parent =&gt; &#123; if (parent === null) return null if (typeof parent !== &apos;object&apos;) return parent let child, proto if (isType(parent, &apos;Array&apos;)) &#123; // 对数组做特殊处理 child = [] &#125; else if (isType(parent, &apos;RegExp&apos;)) &#123; // 对正则对象做特殊处理 child = new RegExp(parent.source, getRegExp(parent)) if (parent.lastIndex) child.lastIndex = parent.lastIndex &#125; else if (isType(parent, &apos;Date&apos;)) &#123; // 对Date对象做特殊处理 child = new Date(parent.getTime()) &#125; else &#123; // 处理对象原型 proto = Object.getPrototypeOf(parent) // 利用Object.create切断原型链 child = Object.create(proto) &#125; // 处理循环引用 const index = parents.indexOf(parent) if (index !== -1) &#123; // 如果父数组存在本对象,说明之前已经被引用过,直接返回此对象 return children[index] &#125; parents.push(parent) children.push(child) for (const i in parent) &#123; // 递归 child[i] = _clone(parent[i]) &#125; return child &#125; return _clone(parent)&#125;复制代码 storage 30.localStorageSetlocalStorage 存贮目前对象值如果是函数 、RegExp等特殊对象存贮会被忽略 1234567891011/** * localStorage 存贮 * 目前对象值如果是函数 、RegExp等特殊对象存贮会被忽略 * @param &#123;String&#125; key 属性 * @param &#123;Object&#125; value 值 */export const localStorageSet = (key, value) =&gt; &#123; if (typeof (value) === &apos;object&apos;) value = JSON.stringify(value) localStorage.setItem(key, value)&#125;复制代码 31.localStorageGetlocalStorage 获取 12345678/** * localStorage 获取 * @param &#123;String&#125; key 属性 */export const localStorageGet = (key) =&gt; &#123; return JSON.parse(localStorage.getItem(key))&#125;复制代码 32.localStorageRemovelocalStorage 移除 12345678/** * localStorage 移除 * @param &#123;String&#125; key 属性 */export const localStorageRemove = (key) =&gt; &#123; localStorage.removeItem(key)&#125;复制代码 33.localStorageSetExpirelocalStorage 存贮某一段时间失效 1234567891011121314/** * localStorage 存贮某一段时间失效 * @param &#123;String&#125; key 属性 * @param &#123;*&#125; value 存贮值 * @param &#123;String&#125; expire 过期时间,毫秒数 */export const localStorageSetExpire = (key, value, expire) =&gt; &#123; if (typeof (value) === &apos;object&apos;) value = JSON.stringify(value) localStorage.setItem(key, value) setTimeout(() =&gt; &#123; localStorage.removeItem(key) &#125;, expire)&#125;复制代码 34.sessionStorageSetsessionStorage 存贮 12345678910/** * sessionStorage 存贮 * @param &#123;String&#125; key 属性 * @param &#123;*&#125; value 值 */export const sessionStorageSet = (key, value) =&gt; &#123; if (typeof (value) === &apos;object&apos;) value = JSON.stringify(value) sessionStorage.setItem(key, value)&#125;复制代码 35.sessionStorageGetsessionStorage 获取 12345678/** * sessionStorage 获取 * @param &#123;String&#125; key 属性 */export const sessionStorageGet = (key) =&gt; &#123; return JSON.parse(sessionStorage.getItem(key))&#125;复制代码 36.sessionStorageRemovesessionStorage 删除 12345678/** * sessionStorage 删除 * @param &#123;String&#125; key 属性 */export const sessionStorageRemove = (key, value) =&gt; &#123; sessionStorage.removeItem(key, value)&#125;复制代码 37.sessionStorageSetExpiresessionStorage 存贮某一段时间失效 1234567891011121314/** * sessionStorage 存贮某一段时间失效 * @param &#123;String&#125; key 属性 * @param &#123;*&#125; value 存贮值 * @param &#123;String&#125; expire 过期时间,毫秒数 */export const sessionStorageSetExpire = (key, value, expire) =&gt; &#123; if (typeof (value) === &apos;object&apos;) value = JSON.stringify(value) sessionStorage.setItem(key, value) setTimeout(() =&gt; &#123; sessionStorage.removeItem(key) &#125;, expire)&#125;复制代码 38.cookieSetcookie 存贮 123456789101112/** * cookie 存贮 * @param &#123;String&#125; key 属性 * @param &#123;*&#125; value 值 * @param String expire 过期时间,单位天 */export const cookieSet = (key, value, expire) =&gt; &#123; const d = new Date() d.setDate(d.getDate() + expire) document.cookie = `$&#123;key&#125;=$&#123;value&#125;;expires=$&#123;d.toGMTString()&#125;`&#125;复制代码 39.cookieGetcookie 获取 123456789101112131415161718/** * cookie 获取 * @param &#123;String&#125; key 属性 */export const cookieGet = (key) =&gt; &#123; const cookieStr = unescape(document.cookie) const arr = cookieStr.split(&apos;; &apos;) let cookieValue = &apos;&apos; for (var i = 0; i &lt; arr.length; i++) &#123; const temp = arr[i].split(&apos;=&apos;) if (temp[0] === key) &#123; cookieValue = temp[1] break &#125; &#125; return cookieValue&#125;复制代码 40.cookieRemovecookie 删除 12345678/** * cookie 删除 * @param &#123;String&#125; key 属性 */export const cookieRemove = (key) =&gt; &#123; document.cookie = `$&#123;encodeURIComponent(key)&#125;=;expires=$&#123;new Date()&#125;`&#125;复制代码 str 41.strTrimLeftOrRight去掉字符左右空格 12345678/** * 去掉字符左右空格 * @param &#123;String&#125; str 字符 */export const strTrimLeftOrRight = str =&gt; &#123; return str.replace(/(^\s*)|(\s*$)/g, &quot;&quot;)&#125;复制代码 42.strInclude判断字符是否包含某值 123456789/** * 判断字符是否包含某值 * @param &#123;String&#125; str 字符 * @param &#123;String&#125; value 字符 */export const strInclude = (str, value) =&gt; &#123; return str.includes(value)&#125;复制代码 43.strBeginWith判断字符是否以某个字符开头 123456789/** * 判断字符是否以某个字符开头 * @param &#123;String&#125; str 字符 * @param &#123;String&#125; value 字符 */export const strBeginWith = (str, value) =&gt; &#123; return str.indexOf(value) === 0&#125;复制代码 44.strReplace全局替换某个字符为另一个字符 12345678910/** * 全局替换某个字符为另一个字符 * @param &#123;String&#125; str 字符 * @param &#123;String&#125; valueOne 包含的字符 * @param &#123;String&#125; valueTwo 要替换的字符,选填 */export const strReplace = (str, valueOne, valueTwo) =&gt; &#123; return str.replace(new RegExp(valueOne,&apos;g&apos;), valueTwo)&#125;复制代码 45.strToCapital将字母全部转化成大写 12345678/** * 将字母全部转化成大写 * @param &#123;String&#125; str 字符 */export const strToCapital = (str) =&gt; &#123; return str.toUpperCase()&#125;复制代码 46.strToLowercase将字母全部转化成小写 12345678/** * 将字母全部转化成小写 * @param &#123;String&#125; str 字符 */export const strToLowercase = (str) =&gt; &#123; return str.toLowerCase()&#125;复制代码 47.strToCapitalLetter将字母全部转化成以大写开头 123456789/** * 将字母全部转化成以大写开头 * @param &#123;String&#125; str 字符 */export const strToCapitalLetter = (str) =&gt; &#123; const strOne = str.toLowerCase() return strOne.charAt(0).toUpperCase() + strOne.slice(1)&#125;复制代码 thrDeb 48.throttle节流 123456789101112131415161718/** * 节流 * @param &#123;*&#125; func 执行函数 * @param &#123;*&#125; delay 节流时间,毫秒 */export const throttle = function(func, delay) &#123; let timer = null return function() &#123; if (!timer) &#123; timer = setTimeout(() =&gt; &#123; func.apply(this, arguments) // 或者直接 func() timer = null &#125;, delay) &#125; &#125;&#125;复制代码 49.debounce防抖 1234567891011121314151617/** * 防抖 * @param &#123;*&#125; fn 执行函数 * @param &#123;*&#125; wait 防抖时间,毫秒 */export const debounce = function(fn, wait) &#123; let timeout = null return function() &#123; if (timeout !== null) clearTimeout(timeout)// 如果多次触发将上次记录延迟清除掉 timeout = setTimeout(() =&gt; &#123; fn.apply(this, arguments) // 或者直接 fn() timeout = null &#125;, wait) &#125;&#125;复制代码 time 50.getYear获取年份 1234567/** * 获取年份 */export const getYear = () =&gt; &#123; return new Date().getFullYear()&#125;复制代码 51.getMonth获取月份 1234567891011/** * 获取当前月份 * @param &#123;Boolean&#125; fillFlag 布尔值,是否补 0,默认为 true */export const getMonth = (fillFlag=true) =&gt; &#123; const mon = new Date().getMonth() + 1 const monRe = mon if (fillFlag) mon &lt; 10 ? `0$&#123;mon&#125;` : mon return monRe&#125;复制代码 52.getDay获取日 1234567891011/** * 获取日 * @param &#123;Boolean&#125; fillFlag 布尔值,是否补 0 */export const getDay = (fillFlag=true) =&gt; &#123; const day = new Date().getDate() const dayRe = day if (fillFlag) day &lt; 10 ? `0$&#123;day&#125;` : day return dayRe&#125;复制代码 53.getWhatDay星期几 1234567/** * 获取星期几 */export const getWhatDay = () =&gt; &#123; return new Date().getDay() ? new Date().getDay() : 7&#125;复制代码 54.getMonthNum获取当前月天数 12345678910/** * 获取当前月天数 * @param &#123;String&#125; year 年份 * @param &#123;String&#125; month 月份 */export const getMonthNum = (year, month) =&gt; &#123; var d = new Date(year, month, 0) return d.getDate()&#125;复制代码 55.getYyMmDdHhMmSs获取当前时间 yyyy-mm-dd,hh:mm:ss 123456789101112131415161718192021222324252627282930/** * 获取当前时间 yyyy-mm-dd,hh:mm:ss */export const getYyMmDdHhMmSs = () =&gt; &#123; const date = new Date() const year = date.getFullYear() const month = date.getMonth() + 1 const day = date.getDate() const hours = date.getHours() const minu = date.getMinutes() const second = date.getSeconds() const arr = [month, day, hours, minu, second] arr.forEach(item =&gt; &#123; item &lt; 10 ? &apos;0&apos; + item : item &#125;) return ( year + &apos;-&apos; + arr[0] + &apos;-&apos; + arr[1] + &apos; &apos; + arr[2] + &apos;:&apos; + arr[3] + &apos;:&apos; + arr[4] )&#125;复制代码 56.timesToYyMmDd时间戳转化为年月日 12345678910111213141516171819202122232425262728293031323334353637383940/** * 时间戳转化为年月日 * @param times 时间戳 * @param ymd 格式类型(yyyy-mm-dd,yyyy/mm/dd) * @param hms 可选,格式类型(hh,hh:mm,hh:mm:ss) * @returns &#123;年月日&#125; */export const timesToYyMmDd = (times, ymd, hms) =&gt; &#123; const oDate = new Date(times) const oYear = oDate.getFullYear() const oMonth = oDate.getMonth() + 1 const oDay = oDate.getDate() const oHour = oDate.getHours() const oMin = oDate.getMinutes() const oSec = oDate.getSeconds() let oTime // 最后拼接时间 // 年月日格式 switch (ymd) &#123; case &apos;yyyy-mm-dd&apos;: oTime = oYear + &apos;-&apos; + getzf(oMonth) + &apos;-&apos; + getzf(oDay) break case &apos;yyyy/mm/dd&apos;: oTime = oYear + &apos;/&apos; + getzf(oMonth) + &apos;/&apos; + getzf(oDay) break &#125; // 时分秒格式 switch (hms) &#123; case &apos;hh&apos;: oTime = &apos; &apos;+oTime + getzf(oHour) break case &apos;hh:mm&apos;: oTime = oTime + getzf(oHour) + &apos;:&apos; + getzf(oMin) break case &apos;hh:mm:ss&apos;: oTime = oTime + getzf(oHour) + &apos;:&apos; + getzf(oMin) + &apos;:&apos; + getzf(oSec) break &#125; return oTime&#125;复制代码 57.YyMmDdToTimes将年月日转化成时间戳 12345678/** * 将年月日转化成时间戳 * @param &#123;String&#125; time yyyy/mm/dd 或yyyy-mm-dd 或yyyy-mm-dd hh:mm 或yyyy-mm-dd hh:mm:ss */export const YyMmDdToTimes = (time) =&gt; &#123; return new Date(time.replace(/-/g, &apos;/&apos;)).getTime()&#125;复制代码 58.compareTimeOneLessTwo12345678910/** * 比较时间 1 小于时间 2 * @param &#123;String&#125; timeOne 时间 1 * @param &#123;String&#125; timeTwo 时间 2 */export const compareTimeOneLessTwo = (timeOne, timeTwo) =&gt; &#123; // 判断 timeOne 和 timeTwo 是否 return new Date(timeOne.replace(/-/g, &apos;/&apos;)).getTime()&lt;new Date(timeTwo.replace(/-/g, &apos;/&apos;)).getTime()&#125;复制代码 url 59.getQueryString获取 url 后面通过?传参的参数~ 12345678910111213/** * 获取 url 后面通过?传参的参数 * @param &#123;String&#125; name */export function getQueryString(name) &#123; const reg = new RegExp(&apos;(^|&amp;)&apos; + name + &apos;=([^&amp;]*)(&amp;|$)&apos;, &apos;i&apos;) const url = window.location.href const search = url.substring(url.lastIndexOf(&apos;?&apos;) + 1) const r = search.match(reg) if (r != null) return unescape(r[2]) return null&#125;复制代码 总结码字不易,持续更新中,欢迎 start! 作者：火狼1链接：https://juejin.im/post/5de5be53f265da05c33fcbb4来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
  </entry>
  <entry>
    <title><![CDATA[推荐 3 个超赞的图表工具，让你0基础做出大神级可视化图表]]></title>
    <url>%2F2019%2F12%2F01%2Fyuque%2F%E6%8E%A8%E8%8D%90%203%20%E4%B8%AA%E8%B6%85%E8%B5%9E%E7%9A%84%E5%9B%BE%E8%A1%A8%E5%B7%A5%E5%85%B7%EF%BC%8C%E8%AE%A9%E4%BD%A00%E5%9F%BA%E7%A1%80%E5%81%9A%E5%87%BA%E5%A4%A7%E7%A5%9E%E7%BA%A7%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9B%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[文不如表，表不如图。我们在工作中经常进行会借助一些表格或者可视化的图表来展示信息。清晰美观的图表不但有利于数据内容的呈现，还能使人印象深刻。 比如，像一些大神的数据可视化表格是这样的： 还有这样的： 不但数据呈现清晰，而且特别美观，逼格非常高。 但你的数据可视化图表是这样的： 事实上，想要做出高大上的数据可视化效果并不难，今天给各位推荐3个数据可视化工具，即使你是小白，也能够在10分钟内制作出高逼格的数据可视化图表。 1.文图网站：&gt; https://www.wentu.io/ 文图是一个「模板式」的在线可视化工具。你可以用它快速制做出专业级可视化数据报告。 它的用法太简单了。你只需要 选择模板 → 导入数据/编辑内容 → 导出/分享 就可以轻松搞定。 操作方面的内容我就不多赘述了，它最吸引我的地方是在于： 01.模板类型主题化它的模板数量不多，但每一个报告模板都有自己的主题。整体风格统一，简洁美观。选中模板，所有的内容都会根据模板自动统一颜色： 整体逼格很高，非常适合用来做工作型的数据分析和汇报。 02.图表类型多样化作为数据可视化报告，它支持自由增添的图表类型非常多。除了常见的折线图、柱形图，还有显示效果非常赞的「文字云」类型： 专业级别的「散点/气泡图」： 甚至还有 省 / 全国 / 世界的地图： 双击图表就可以直接编辑，填充数据后就可以成精美的图表： 除此之外。你可以自由的增添文字、形状甚至视频。完善整个数据报告 所有的图表制作完成后都是动态效果的，可视化效果非常赞。 03.便捷分享/演示制作完数据报告后，你可以根据具体需求，选择不同的方式分享或者展示它。 比如你可以直接点击「下载」保存为 PDF 或者 PNG 格式： 把它当做素材直接插入PPT也会非常赞！ 或者是点击「分享」生成链接或者二维码： 这样在手机上查看效果会更好： 如果你需要公开演示的你报告，我推荐你制作的时候可以选择「演示文档」类型的模板：这样点击「播放」，你的报告就可以跟PPT一样直接演示： 还保留了动态效果，演示效果简直爆炸： 总而言之，有了文图，小白也可以快速制作专业级的数据报告。 2.图表秀网站：&gt; https://www.tubiaoxiu.com/ 图表秀是在线图表制作网站，它可以帮你快速制作各种传统图表和高级可视化图表。整体的操作和文图差不多，都可以通过修改模板来完成可视化图表。但图表秀最大的优势在于，模板更实用，可视化效果更酷炫：根据不同的行业，图表秀基于实际需求内置了许多类型不同的模板。比如 公众号分析数据模板、财务总结模板、竞品分析数据模板…… 除了可以直接套用，你还可以参考模板内容来确定和优化你的数据内容。 什么意思呢？比如说，老板想让我出一份微信运营数据分析，我应该收集哪些内容呢？ 选择公众号运营分析的模板，你就会明白可以从用户行为分析、用户画像、公众号总体指标分析……角度入手。 即使不套用模板，它也可以帮你更好的进行数据分析，是不是非常实用呢？ 除了模板实用之外，图表秀的可视化效果也非常酷炫。 它采用了「资源框」来分割页面。可以让一个页面中同时展示多个图表或者文字元素 你可以自由的添加「资源框」，新建 图表 / 文字 / 图片信息。你也可以通过「布局」快速确定不同内容的分布。 当然，它的图表样式非常多，全部都是动态效果。可视化的效果非常赞： 最赞的一点是，图表数据的导入和分享非常便捷。你可以直接上传 EXCEL 或者 CSV 格式的数据文件，图表就可以自动生成： 这样，任意的EXCEL数据表格都可以快速导入进行美化，实现可视化。 总的来说，图表秀操作简单，效果强大。可以帮你快速制作一份酷炫的数据可视化图表。 3.创客贴网站：&gt; https://www.chuangkit.com/ 创客贴其实是一个在线平面设计网站。你可以利用它来制作各种精致的图片：当然，它也是「模板式」操作，只要选择喜欢的模板就可以直接编辑了： 但是，如果你在模板库中搜索「数据」，你就会发现： 它包含了非常多超赞的数据可视化长图，显示效果简直堪比「经济学人」中的图表。 选中模板就可以开始更改，非常方便。 严格上来说创客贴不属于数据可视化工具，它不具备数据处理的能力，无法精确的导入数据。但它胜在效果强大，不需要任何设计基础，也不需要 PS AI 这样的专业图片软件，就能够做出非常惊艳的可视化效果。 非常适合于数据汇报总结，会让人眼前一亮。 最后今天给各位推荐了 3 个数据可视化工具。它们都是「模板式」操作、「在线式」工具，操作简单，功能强大。如果你想要快速美化图表，完成可视化效果，又觉得学习代码技术太困难。那这些工具非常适合你。]]></content>
  </entry>
  <entry>
    <title><![CDATA[3D可视化]]></title>
    <url>%2F2019%2F11%2F30%2Fyuque%2F3D%E5%8F%AF%E8%A7%86%E5%8C%96%2F</url>
    <content type="text"><![CDATA[d9faa237-3ef13fc3f-f4b1-77e6af384494 本文中的图可视化由 G6 提供支持。G6 —— 专业的图可视化引擎。让关系数据变得简单透明，让用户获得 Insight。G6 官网：antv.alipay.com/zh-cn/g…。欢迎关注。GitHub：github.com/antvis/g6。欢迎 Star。G6 是一个图可视化引擎。它提供了图的绘制、布局、分析、交互、动画等图可视化的基础能力。旨在让关系变得透明，简单。让用户获得关系数据的 Insight。 https://github.com/antvis/G6/blob/master/README-zh_CN.md https://zhuanlan.zhihu.com/p/94155959 使用webgl(three.js)搭建一个3D智慧园区、3D建筑，3D消防模拟，web版3D,bim管理系统——第四课（炫酷版一）) 使用webgl(three.js)创建3D机房，3D机房微模块详细介绍(升级版二)如何用webgl(three.js)搭建一个3D库房-第一课如何用webgl(three.js)搭建一个3D库房,3D密集架,3D档案室,-第二课使用webgl(three.js)搭建一个3D建筑，3D消防模拟——第三课使用webgl(three.js)搭建一个3D智慧园区、3D建筑，3D消防模拟，web版3D,bim管理系统——第四课如何用webgl(three.js)搭建不规则建筑模型，客流量热力图模拟 使用webgl(three.js)搭建一个3D智慧园区、3D建筑，3D消防模拟，web版3D,bim管理系统——第四课（炫酷版一） TensorSpace 是一个基于 TensorFlow.js 、Three.js 和 Tween.js 开发，用于对神经网络进行 3D 可视化呈现的库。通过使用 TensorSpace，不仅能展示神经网络的结构，还可以呈现网络的内部特征提取、中间层的数据交互以及最终的结果预测等一系列过程。通过使用 TensorSpace，可以更直观地观察并理解基于 TensorFlow、Keras 以及 TensorFlow.js 开发的神经网络模型。 从工业开发的角度来看，TensorSpace 降低了前端深度学习可视化相关应用的开发门槛。总的来说，TensorSpace 具有以下特性： 交互 – 使用类 Keras 的 API，在浏览器中构建可交互的 3D 可视化模型。 直观 – 观察并展示模型中间层预测数据，直观演示模型推测过程。 集成 – 支持使用 TensorFlow、Keras 以及 TensorFlow.js 训练的模型。 基于HTML5和WebGL的三维可视立体动态流程图 基于 HTML5 的工业互联网 3D 可视化应用 three.js / docs Three.js 入门指南 three.js右手坐标系， 显示和线条有哪些值得推荐的前端3D库或其他可视化库？D3.js D3.js - Data-Driven Documents基于D3.js的three.js three.js - Javascript 3D library基于three.js 的 *ThingJS *three.js - Javascript 3D library这个ThingJS看起来真的很强大，@香布拉喷 的回答有详细介绍。在线编程，调用ThingJS的API，几百行代码就能写出非常复杂的3D模型，基本能替代简单的Autodesk 3ds Max的操作。ThingJS - 物联网3D可视化PaaS平台这里面宣称一个ThingJS开发者一天就能做出以下效果的模型 echart.jsg2.jsd3.jsthree.js G6 —— 专业的图可视化引擎。让关系数据变得简单透明，让用户获得 Insight。 ECharts,G2,F2,G6,D3.js,highchartthree.jsdeck.gl，kepler.gl uber出的三维地理信息可视化库 像threeJS 、babylonJS等通用前端库应该是众所周知了，其他还有比如OSG.js、Openscenegraph、x3Dom等都可以看看。不过，上面基本都是比较通用的3D库，当然门槛也还是有一些，如果只是想实现在web端的3D模型展示（尤其是对于如3D打印、制造业模型等场景），这里也推荐另外一个API开发包:EverAPIhttps://evercraft.co/api/docs/evercraft/ EverAPI主要针对制造类模型的展示，比如结构树、剖切图等，支持常用的制造格式：stl、stp等。很适合普通开发者或者网站外包团队，因为最少只需要四五条代码就可以实现完整的功能。（像3D协作平台EverCraft,也是基于EverAPI开发的）。 https://evercraft.co/zh/ThingJS - 物联网3D可视化PaaS平台tensorspace.jshttps://tensorspace.org/index_zh.html http://www.thingjs.com/guide/ 3D 可视化系统的小 demo**网址：https://www.alwxkxk.xyz/github 源码：https://github.com/alwxkxk/iot-visualization-examples怕大家不会操作，所以还录了个小小的操作视频：操作视频网址 http://www.hightopo.com/ http://www.thingjs.com/guide/?m=sample&amp;g=1]]></content>
  </entry>
  <entry>
    <title><![CDATA[Remax(React渲染器)]]></title>
    <url>%2F2019%2F11%2F18%2Fyuque%2FRemax(React%E6%B8%B2%E6%9F%93%E5%99%A8)%2F</url>
    <content type="text"><![CDATA[上个月蚂蚁金服前端发布了一个新的框架 Remax, 口号是使用真正的、完整的 React 来开发小程序.对于原本的 React 开发者来说 ‘Learn once, write anywhere’ , 和 ReactNative 开发体验差不多，而对于小程序来说则是全新的开发体验。Taro号称是‘类React’的开发方案，但是它是使用静态编译的方式实现，边柳 在它的 《Remax - 使用真正的 React 构建小程序》文章中也提到了这一点:所谓静态编译，就是使用工具把代码语法分析一遍，把其中的 JSX 部分和逻辑部分抽取出来，分别生成小程序的模板和 Page 定义。这种方案实现起来比较复杂，且运行时并没有 React 存在。 相比而言，Remax 的解决方案就简单很多，它不过就是新的React渲染器. 因为 Remax 刚发布不久，核心代码比较简单，感兴趣的可以去 github 观摩贡献可以通过 CodeSandbox 游乐场试玩自定义Renderer: Edit react-custom-renderer文章看起来比较长，好戏在后头，一步一步来 🦖 文章大纲 关于React的一些基本概念 自定义React渲染器 HostConfig 渲染器适配 宿主组件 镜像树的构建和操作 节点更新 副作用提交 HostConfig执行流程总结 同步到渲染进程 总结 扩展阅读 关于React的一些基本概念创建一个 React 自定义渲染器，你需要对React渲染的基本原理有一定的了解。所以在深入阅读本文之前，先要确保你能够理解以下几个基本概念:1. Element我们可以通过 JSX 或者 React.createElement 来创建 Element，用来描述我们要创建的视图节点。比如: 123456&lt;button class='button button-blue'&gt; &lt;b&gt; OK! &lt;/b&gt;&lt;/button&gt;复制代码 JSX 会被转义译为: 123456React.createElement( "button", &#123; class: 'button button-blue' &#125;, React.createElement("b", null, "OK!"))复制代码 React.createElement 最终构建出类似这样的对象: 12345678910111213&#123; type: 'button', props: &#123; className: 'button button-blue', children: &#123; type: 'b', props: &#123; children: 'OK!' &#125; &#125; &#125;&#125;复制代码 也就是说 Element 就是一个普通的对象，描述用户创建的节点类型、props 以及 children。这些 Elements 组合成树，描述用户视图 2. Component可以认为是 Element 的类型，它有两种类型： Host Component: 宿主组件，这是由渲染的平台提供的‘内置’组件，例如ReactDOM 平台下面的 DOM 节点，如 div、span… 这些组件类型为字符串 Composite Component: 复合组件，这是一种用户自定义的组件封装单位。通常包含自定义的逻辑、状态以及输出 Element 树。复合类型可以为类或函数12345678const DeleteAccount = () =&gt; ( &lt;div&gt; &lt;p&gt;Are you sure?&lt;/p&gt; &lt;DangerButton&gt;Yep&lt;/DangerButton&gt; &lt;Button color='blue'&gt;Cancel&lt;/Button&gt; &lt;/div&gt;);复制代码 3. Instance当 React 开始渲染一个 Element 时，会根据组件类型为它创建一个‘实例’，例如类组件，会调用new操作符实例化。这个实例会一直引用，直到 Element 从 Element Tree 中被移除。首次渲染: React 会实例化一个 MyButton 实例，调用挂载相关的生命周期方法，并执行 render 方法，递归渲染下级 12render(&lt;MyButton&gt;foo&lt;/MyButton&gt;, container)复制代码 更新: 因为组件类型没有变化，React 不会再实例化，这个属于‘节点更新’，React 会执行更新相关的生命周期方法，如shouldComponentUpdate。如果需要更新则再次执行render方法 12render(&lt;MyButton&gt;bar&lt;/MyButton&gt;, container)复制代码 卸载: 组件类型不一样了, 原有的 MyButton 被替换. MyButton 的实例将要被销毁，React 会执行卸载相关的生命周期方法，如componentWillUnmount 12render(&lt;button&gt;bar&lt;/button&gt;, container)复制代码 4. Reconciler &amp; RendererReconciler 和 Renderer 的关系可以通过下图缕清楚.Reconciler 的职责是维护 VirtualDOM 树，内部实现了 Diff/Fiber 算法，决定什么时候更新、以及要更新什么而 Renderer 负责具体平台的渲染工作，它会提供宿主组件、处理事件等等。例如ReactDOM就是一个渲染器，负责DOM节点的渲染和DOM事件处理。 5. Fiber 的两个阶段React 使用了 Fiber 架构之后，更新过程被分为两个阶段(Phase) 协调阶段(Reconciliation Phase) 这个阶段 React 会找出需要更新的节点。这个阶段是可以被打断的，比如有优先级更高的事件要处理时。 提交阶段(Commit Phase) 将上一个阶段计算出来的需要处理的副作用(Effects)一次性执行了。这个阶段必须同步执行，不能被打断 如果按照render为界，可以将生命周期函数按照两个阶段进行划分： 协调阶段 constructor componentWillMount 废弃 componentWillReceiveProps 废弃 static getDerivedStateFromProps shouldComponentUpdate componentWillUpdate 废弃 render getSnapshotBeforeUpdate() 提交阶段 componentDidMount componentDidUpdate componentWillUnmount 没理解？那么下文读起来对你可能比较吃力，建议阅读一些关于React基本原理的相关文章。 就目前而言，React 大部分核心的工作已经在 Reconciler 中完成，好在 React 的架构和模块划分还比较清晰，React官方也暴露了一些库，这极大简化了我们开发 Renderer 的难度。开始吧！ 自定义React渲染器React官方暴露了一些库供开发者来扩展自定义渲染器： react-reconciler - 这就是 React 的协调器, React 的核心所在。我们主要通过它来开发渲染器。 scheduler - 合作调度器的一些 API 。本文不会用到 需要注意的是，这些包还是实验性的，API可能不太稳定。另外，没有详细的文档，你需要查看源代码或者其他渲染器实现；本文以及扩展阅读中的文章也是很好的学习资料。 创建一个自定义渲染器只需两步:第一步: 实现宿主配置，这是react-reconciler要求宿主提供的一些适配器方法和配置项。这些配置项定义了如何创建节点实例、构建节点树、提交和更新等操作。下文会详细介绍这些配置项 12345const Reconciler = require('react-reconciler');const HostConfig = &#123; // ... 实现适配器方法和配置项&#125;;复制代码 第二步：实现渲染函数，类似于ReactDOM.render() 方法 123456789101112131415// 创建Reconciler实例, 并将HostConfig传递给Reconcilerconst MyRenderer = Reconciler(HostConfig);/** * 假设和ReactDOM一样，接收三个参数 * render(&lt;MyComponent /&gt;, container, () =&gt; console.log('rendered')) */export function render(element, container, callback) &#123; // 创建根容器 if (!container._rootContainer) &#123; container._rootContainer = ReactReconcilerInst.createContainer(container, false); &#125; // 更新根容器 return ReactReconcilerInst.updateContainer(element, container._rootContainer, null, callback);&#125;复制代码 容器既是 React 组件树挂载的目标(例如 ReactDOM 我们通常会挂载到 #root 元素，#root 就是一个容器)、也是组件树的 根Fiber节点(FiberRoot)。根节点是整个组件树的入口，它将会被 Reconciler 用来保存一些信息，以及管理所有节点的更新和渲染。关于 Fiber 架构的一些细节可以看这些文章: 《译 深入React fiber架构及源码》 《React Fiber》 有能力的同学，可以直接看Lin Clark的演讲 HostConfig 渲染器适配HostConfig 支持非常多的参数，完整列表可以看这里. 下面是一些自定义渲染器必须提供的参数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798interface HostConfig &#123; /** * 用于分享一些上下文信息 */ // 获取根容器的上下文信息, 只在根节点调用一次 getRootHostContext(rootContainerInstance: Container): HostContext; // 获取子节点的上下文信息, 每遍历一个节点都会调用一次 getChildHostContext(parentHostContext: HostContext, type: Type, rootContainerInstance: Container): HostContext; /** * 节点实例的创建 */ // 普通节点实例创建，例如DOM的Element类型 createInstance(type: Type, props: Props, rootContainerInstance: Container, hostContext: HostContext, internalInstanceHandle: OpaqueHandle,): Instance; // 文本节点的创建，例如DOM的Text类型 createTextInstance(text: string, rootContainerInstance: Container, hostContext: HostContext, internalInstanceHandle: OpaqueHandle): TextInstance; // 决定是否要处理子节点/子文本节点. 如果不想创建则返回true. 例如ReactDOM中使用dangerouslySetInnerHTML, 这时候子节点会被忽略 shouldSetTextContent(type: Type, props: Props): boolean; /** * 节点树构建 */ // 如果节点在*未挂载*状态下，会调用这个来添加子节点 appendInitialChild(parentInstance: Instance, child: Instance | TextInstance): void; // **下面都是副作用(Effect)，在’提交‘阶段被执行** // 添加子节点 appendChild?(parentInstance: Instance, child: Instance | TextInstance): void; // 添加子节点到容器节点(根节点) appendChildToContainer?(container: Container, child: Instance | TextInstance): void; // 插入子节点 insertBefore?(parentInstance: Instance, child: Instance | TextInstance, beforeChild: Instance | TextInstance): void; // 插入子节点到容器节点(根节点) insertInContainerBefore?(container: Container, child: Instance | TextInstance, beforeChild: Instance | TextInstance,): void; // 删除子节点 removeChild?(parentInstance: Instance, child: Instance | TextInstance): void; // 从容器节点(根节点)中移除子节点 removeChildFromContainer?(container: Container, child: Instance | TextInstance): void; /** * 节点挂载 */ // 在完成所有子节点初始化时(所有子节点都appendInitialChild完毕)时被调用, 如果返回true，则commitMount将会被触发 // ReactDOM通过这个属性和commitMount配置实现表单元素的autofocus功能 finalizeInitialChildren(parentInstance: Instance, type: Type, props: Props, rootContainerInstance: Container, hostContext: HostContext): boolean; // 和finalizeInitialChildren配合使用，commitRoot会在’提交‘完成后(resetAfterCommit)执行, 也就是说组件树渲染完毕后执行 commitMount?(instance: Instance, type: Type, newProps: Props, internalInstanceHandle: OpaqueHandle): void; /** * 节点更新 */ // 准备节点更新. 如果返回空则表示不更新，这时候commitUpdate则不会被调用 prepareUpdate(instance: Instance, type: Type, oldProps: Props, newProps: Props, rootContainerInstance: Container, hostContext: HostContext,): null | UpdatePayload; // **下面都是副作用(Effect)，在’提交‘阶段被执行** // 文本节点提交 commitTextUpdate?(textInstance: TextInstance, oldText: string, newText: string): void; // 普通节点提交 commitUpdate?(instance: Instance, updatePayload: UpdatePayload, type: Type, oldProps: Props, newProps: Props, internalInstanceHandle: OpaqueHandle): void; // 重置普通节点文本内容, 这个需要和shouldSetTextContent(返回true时)配合使用， resetTextContent?(instance: Instance): void; /** * 提交 */ // 开始’提交‘之前被调用，比如这里可以保存一些状态，在’提交‘完成后恢复状态。比如ReactDOM会保存当前元素的焦点状态，在提交后恢复 // 执行完prepareForCommit，就会开始执行Effects(节点更新) prepareForCommit(containerInfo: Container): void; // 和prepareForCommit对应，在提交完成后被执行 resetAfterCommit(containerInfo: Container): void; /** * 调度 */ // 这个函数将被Reconciler用来计算当前时间, 比如计算任务剩余时间 // ReactDOM中会优先使用Performance.now, 普通场景用Date.now即可 now(): number; // 自定义计时器 setTimeout(handler: (...args: any[]) =&gt; void, timeout: number): TimeoutHandle | NoTimeout; // 取消计时器 clearTimeout(handle: TimeoutHandle | NoTimeout): void; // 表示一个空的计时器，见👆clearTimeout的签名 noTimeout: NoTimeout; // ? 功能未知 shouldDeprioritizeSubtree(type: Type, props: Props): boolean; // 废弃 scheduleDeferredCallback(callback: () =&gt; any, options?: &#123; timeout: number &#125;): any; // 废弃 cancelDeferredCallback(callbackID: any): void; /** * 功能开启 */ // 开启节点修改，一般渲染器都会开启，不然无法更新节点 supportsMutation: boolean; // 开启持久化 ? supportsPersistence: boolean; // 开启hydrate，一般用于服务端渲染 supportsHydration: boolean; /** * 杂项 */ // 获取可公开的节点实例，即你愿意暴露给用户的节点信息，用户通过ref可以获取到这个对象。一般自定义渲染器原样返回即可, 除非你想有选择地给用户暴露信息 getPublicInstance(instance: Instance | TextInstance): PublicInstance; // ... 还有很多参数，由于一般渲染器不会用到，暂时不讲了&#125;复制代码 如果按照Fiber的两个阶段来划分的话，接口分类是这样的: 协调阶段 开始提交 提交阶段 提交完成 createInstance prepareCommit appendChild resetAfterCommit createTextInstance appendChildToContainer commitMount shouldSetTextContent insertBefore appendInitialChild insertInContainerBefore finalizeInitialChildren removeChild prepareUpdate removeChildFromContainer commitTextUpdate commitUpdate resetTextContent 通过上面接口定义可以知道 HostConfig 配置比较丰富，涉及节点操作、挂载、更新、调度、以及各种生命周期钩子, 可以控制渲染器的各种行为.看得有点蒙圈？没关系, 你暂时没有必要了解所有的参数，下面会一点一点展开解释这些功能。你可以最后再回来看这里。 宿主组件React中有两种组件类型，一种是宿主组件(Host Component), 另一种是复合组件(CompositeComponent). 宿主组件是平台提供的，例如 ReactDOM 平台提供了 div、span、h1… 等组件. 这些组件通常是字符串类型，直接渲染为平台下面的视图节点。而复合组件，也称为自定义组件，用于组合其他复合组件和宿主组件，通常是类或函数。渲染器不需要关心复合组件的处理, Reconciler 交给渲染器的是一颗宿主组件树。当然在 Remax 中，也定义了很多小程序特定的宿主组件，比如我们可以这样子使用它们: 1234function MyComp() &#123; return &lt;view&gt;&lt;text&gt;hello world&lt;/text&gt;&lt;/view&gt;&#125;复制代码 Reconciler 会调用 HostConfig 的 createInstance 和createTextInstance 来创建宿主组件的实例，所以自定义渲染器必须实现这两个方法. 看看 Remax 是怎么做的： 12345678910111213141516171819202122232425262728293031323334const HostConfig = &#123; // 创建宿主组件实例 createInstance(type: string, newProps: any, container: Container) &#123; const id = generate(); // 预处理props, remax会对事件类型Props进行一些特殊处理 const props = processProps(newProps, container, id); return new VNode(&#123; id, type, props, container, &#125;); &#125;, // 创建宿主组件文本节点实例 createTextInstance(text: string, container: Container) &#123; const id = generate(); const node = new VNode(&#123; id, type: TYPE_TEXT, props: null, container, &#125;); node.text = text; return node; &#125;, // 判断是否需要处理子节点。如果返回true则不创建，整个下级组件树都会被忽略。 // 有一些场景是不需要创建文本节点的，而是由父节点内部消化。 // 举个例子，在ReactDOM中，如果某个节点设置了dangerouslySetInnerHTML，那么它的children应该被忽略， // 这时候 shouldSetTextContent则应该返回true shouldSetTextContent(type, nextProps) &#123; return false &#125;&#125;复制代码 在 ReactDOM 中上面两个方法分别会通过 document.createElement 和 document.createTextNode 来创建宿主组件(即DOM节点)。 上面是微信小程序的架构图(图片来源: 一起脱去小程序的外套 - 微信小程序架构解析)。因为小程序隔离了渲染进程和逻辑进程。Remax 是跑在逻辑进程上的，在逻辑进程中无法进行实际的渲染, 只能通过setData方式将更新指令传递给渲染进程后，再进行解析渲染。所以Remax选择在逻辑进程中先构成一颗镜像树(Mirror Tree), 然后再同步到渲染进程中，如下图: 上面的 VNode 就是镜像树中的虚拟节点，主要用于保存一些节点信息，不做任何特殊处理, 它的结构如下: 123456789101112131415161718export default class VNode &#123; id: number; // 唯一的节点id container: Container; children: VNode[]; // 子节点 mounted = false; // 节点是否已经挂载 type: string | symbol; // 节点的类型 props?: any; // 节点的props parent: VNode | null = null; // 父节点引用 text?: string; // 如果是文本节点，这里保存文本内容 path(): Path // 节点的路径. 同步到渲染进程后，通过path恢复到树中 // 子节点操作 appendChild(node: VNode, immediately: boolean) removeChild(node: VNode, immediately: boolean) insertBefore(newNode: VNode, referenceNode: VNode, immediately: boolean) update() // 触发同步到渲染进程 toJSON(): string&#125;复制代码 VNode 的完整代码可以看这里 镜像树的构建和操作要构建出完整的节点树需要实现HostConfig 的 appendChild、insertBefore、removeChild 等方法, 如下， 这些方法都比较容易理解，所以不需要过多解释。 12345678910111213141516171819202122232425262728293031323334353637const HostConfig = &#123; // ... // 支持节点修改 // 有些静态渲染的场景，例如渲染为pdf文档，这时候可以关闭 // 当关闭时，只需要实现appendInitiaChild supportsMutation: true, // 用于初始化(首次)时添加子节点 appendInitialChild: (parent: VNode, child: VNode) =&gt; &#123; parent.appendChild(child, false); &#125;, // 添加子节点 appendChild(parent: VNode, child: VNode) &#123; parent.appendChild(child, false); &#125;, // 插入子节点 insertBefore(parent: VNode, child: VNode, beforeChild: VNode) &#123; parent.insertBefore(child, beforeChild, false); &#125;, // 删除节点 removeChild(parent: VNode, child: VNode) &#123; parent.removeChild(child, false); &#125;, // 添加节点到容器节点，一般情况我们不需要和appendChild特殊区分 appendChildToContainer(container: any, child: VNode) &#123; container.appendChild(child); child.mounted = true; &#125;, // 插入节点到容器节点 insertInContainerBefore(container: any, child: VNode, beforeChild: VNode) &#123; container.insertBefore(child, beforeChild); &#125;, // 从容器节点移除节点 removeChildFromContainer(container: any, child: VNode) &#123; container.removeChild(child); &#125;,&#125;复制代码 节点更新上一节讲的是树结构层面的更新，当节点属性变动或者文本内容变动时，也需要进行更新。我们可以通过下列 HostConfig 配置来处理这类更新: 1234567891011121314151617181920212223242526272829303132333435const HostConfig = &#123; /** * 更新相关 */ // 可以在这里比对props，如果props没有变化则不进行更新，这和React组件的shouldComponentUpdate差不多 // **返回’空‘则表示不更新该节点, 这时候commitUpdate则不会被调用** prepareUpdate(node: VNode, type: string, oldProps: any, newProps: any) &#123; oldProps = processProps(oldProps, node.container, node.id); newProps = processProps(newProps, node.container, node.id); if (!shallowequal(newProps, oldProps)) &#123; return true; &#125; return null; &#125;, // 进行节点更新 commitUpdate( node: VNode, updatePayload: any, type: string, oldProps: any, newProps: any ) &#123; node.props = processProps(newProps, node.container, node.id); node.update(); &#125;, // 进行文本节点更新 commitTextUpdate(node: VNode, oldText: string, newText: string) &#123; if (oldText !== newText) &#123; node.text = newText; // 更新节点 node.update(); &#125; &#125;,&#125;复制代码 Ok, 这个也比较好理解。对于普通节点更新，Reconciler 会先调用 prepareUpdate, 确定是否要更新，如果返回非空数据，Reconciler 就会将节点放入 Effects 链中，在提交阶段调用 commitUpdate 来执行更新。文本节点更新则直接调用 commitTextUpdate，不在话下. 副作用提交React 的更新的两个阶段这个概念非常重要，这个也体现在HostConfig上: 123456789101112131415const HostConfig = &#123; // Reconciler说，我要开始提交了，你提交前要做什么，就在这做吧 // 比如ReactDOM会在这里保存当前DOM文档的选中状态和焦点状态, 以及禁用事件处理。因为DOM更新可能会破坏这些状态 prepareForCommit: () =&gt; &#123;&#125;, // Reconciler说，我已经提交完了 // ReactDOM会在这里恢复提交前的DOM文档的选中状态和焦点状态 resetAfterCommit: () =&gt; &#123;&#125;, // 在协调阶段，当一个节点完成'创建'后调用。如果有子节点，则在所有子节点appendInitialChild完成后调用 // 返回一个boolean值表示’完成提交‘后是否要调用commitMount. 通俗讲就是告诉Reconciler，当前节点完成’挂载‘后要执行某些东西 // ReactDOM会使用这个钩子来处理带有autofoucs属性的节点，在commitMount中实现自动获取焦点 finalizeInitialChildren: () =&gt; false, // 和finalizeInitialChildren配合使用，如果前者返回true，在Reconciler完成提交后，对应节点的commitMount会被执行 commitMount: () =&gt; &#123;&#125;,&#125;复制代码 将上文讲到的所有钩子都聚合起来，按照更新的阶段和应用的目标(target)进行划分，它们的分布是这样的： 那么对于 Remax 来说, 什么时候应该将’更新’提交到渲染进程呢？答案是上图所有在提交阶段的方法被调用时。提交阶段原意就是用于执行各种副作用的，例如视图更新、远程方法请求、订阅… 所以 Remax 也会在这个阶段收集更新指令，在下一个循环推送给渲染进程。 HostConfig执行流程总结回顾一下自定义渲染器各种方法调用的流程, 首先看一下挂载的流程:假设我们的组件结构如下: 12345678910111213141516171819const container = new Container()const MyComp = () =&gt; &#123; return ( &lt;div&gt; &lt;span&gt;hello world&lt;/span&gt; &lt;/div&gt; )&#125;render( &lt;div className="root"&gt; &lt;MyComp /&gt; &lt;span&gt;--custom renderer&lt;/span&gt; &lt;/div&gt;, container, () =&gt; &#123; console.log("rendered") &#125;,)复制代码 React 组件树的结构如下(左图)，但对于渲染器来说，树结构是右图。自定义组件是React 层级的东西，渲染器只需要关心最终需要渲染的视图结构, 换句话说渲染器只关心宿主组件: 挂载会经历以下流程: 通过上面的流程图，可以很清晰看到每个钩子的调用时机。 同理，我们再来看一下节点更新时的流程. 我们稍微改造一下上面的程序，让它定时触发更新: 123456789101112131415161718const MyComp = () =&gt; &#123; const [count, setCount] = useState(1) const isEven = count % 2 === 0 useEffect(() =&gt; &#123; const timer = setInterval(() =&gt; &#123; // 递增计数器 setCount(c =&gt; c + 1) &#125;, 10000) return () =&gt; clearInterval(timer) &#125;, []) return ( &lt;div className="mycomp" style=&#123;&#123; color: isEven ? "red" : "blue" &#125;&#125;&gt; &#123;isEven ? &lt;div&gt;even&lt;/div&gt; : null&#125; &lt;span className="foo"&gt;hello world &#123;count&#125;&lt;/span&gt; &lt;/div&gt; )&#125;复制代码 下面是更新的流程: 当MyComp的 count 由1变为2时，MyComp 会被重新渲染，这时候新增了一个div 节点(红色虚框), 另外 hello world 1 也变成了 hello world 2。新增的 div 节点创建流程和挂载时一样，只不过它不会立即插入到父节点中，而是先放到Effect链表中，在提交阶段统一执行。同理hello world {count}文本节点的更新、以及其他节点的 Props 更新都是放到Effect链表中，最后时刻才更新提交. 如上图的 insertBefore、commitTextUpdate、commitUpdate.另外一个比较重要的是 prepareUpdate 钩子，你可以在这里告诉 Reconciler，节点是否需要更新，如果需要更新则返回非空值，这样 commitUpdate 才会被触发。 同步到渲染进程React 自定义渲染器差不多就这样了，接下来就是平台相关的事情了。Remax 目前的做法是在触发更新后，通过小程序 Page 对象的 setData 方法将更新指令传递给渲染进程;渲染进程侧再通过 WXS 机制，将更新指令恢复到树中； 最后再通过模板机制，将树递归渲染出来。整体的架构如下: 先来看看逻辑进程侧是如何推送更新指令的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 在根容器上管理更新export default class Container &#123; // ... // 触发更新 requestUpdate( path: Path, start: number, deleteCount: number, immediately: boolean, ...items: RawNode[] ) &#123; const update: SpliceUpdate = &#123; path, // 更新节点的树路径 start, // 更新节点在children中的索引 deleteCount, items, // 当前节点的信息 &#125;; if (immediately) &#123; this.updateQueue.push(update); this.applyUpdate(); &#125; else &#123; // 放入更新队列，延时收集更新指令 if (this.updateQueue.length === 0) &#123; setTimeout(() =&gt; this.applyUpdate()); &#125; this.updateQueue.push(update); &#125; &#125; applyUpdate() &#123; const action = &#123; type: 'splice', payload: this.updateQueue.map(update =&gt; (&#123; path: stringPath(update.path), start: update.start, deleteCount: update.deleteCount, item: update.items[0], &#125;)), &#125;; // 通过setData通知渲染进程 this.context.setData(&#123; action &#125;); this.updateQueue = []; &#125;&#125;复制代码 逻辑还是比较清楚的，即将需要更新的节点(包含节点路径、节点信息)推入更新队列，然后触发 setData 通知到渲染进程。 渲染进程侧，则需要通过 WXS 机制，相对应地将更新指令恢复到渲染树中： 1234567891011121314151617181920212223242526272829// 渲染树var tree = &#123; root: &#123; children: [], &#125;,&#125;;// 将指令应用到渲染树function reduce(action) &#123; switch (action.type) &#123; case 'splice': for (var i = 0; i &lt; action.payload.length; i += 1) &#123; var value = get(tree, action.payload[i].path); if (action.payload[i].item) &#123; value.splice( action.payload[i].start, action.payload[i].deleteCount, action.payload[i].item ); &#125; else &#123; value.splice(action.payload[i].start, action.payload[i].deleteCount); &#125; set(tree, action.payload[i].path, value); &#125; return tree; default: return tree; &#125;&#125;复制代码 OK, 接着开始渲染, Remax 采用了模板的形式进行渲染: 1234&lt;wxs src="../../helper.wxs" module="helper" /&gt;&lt;import src="../../base.wxml"/&gt;&lt;template is="REMAX_TPL" data="&#123;&#123;tree: helper.reduce(action)&#125;&#125;" /&gt;复制代码 Remax 为每个组件类型都生成了一个template，动态’递归’渲染整颗树: 1234567891011121314151617181920212223242526272829&lt;template name="REMAX_TPL"&gt; &lt;block wx:for="&#123;&#123;tree.root.children&#125;&#125;" wx:key="&#123;&#123;id&#125;&#125;"&gt; &lt;template is="REMAX_TPL_1_CONTAINER" data="&#123;&#123;i: item&#125;&#125;" /&gt; &lt;/block&gt;&lt;/template&gt;&lt;wxs module="_h"&gt; module.exports = &#123; v: function(value) &#123; return value !== undefined ? value : ''; &#125; &#125;;&lt;/wxs&gt;&lt;% for (var i = 1; i &lt;= depth; i++) &#123; %&gt;&lt;%var id = i; %&gt;&lt;% for (let component of components) &#123; %&gt;&lt;%- include('./component.ejs', &#123; props: component.props, id: component.id, templateId: id, &#125;) %&gt;&lt;% &#125; %&gt;&lt;template name="REMAX_TPL_&lt;%=id%&gt;_plain-text" data="&#123;&#123;i: i&#125;&#125;"&gt; &lt;block&gt;&#123;&#123;i.text&#125;&#125;&lt;/block&gt;&lt;/template&gt;&lt;template name="REMAX_TPL_&lt;%=id%&gt;_CONTAINER" data="&#123;&#123;i: i&#125;&#125;"&gt; &lt;template is="&#123;&#123;'REMAX_TPL_&lt;%=id%&gt;_' + i.type&#125;&#125;" data="&#123;&#123;i: i&#125;&#125;" /&gt;&lt;/template&gt;&lt;% &#125; %&gt;复制代码 限于小程序的渲染机制，以下因素可能会影响渲染的性能: 进程IPC。更新指令通过IPC通知到渲染进程，频繁更新可能会影响性能. ReactNative 中涉及到 Native 和 JS引擎之间的通信，也是存在这个问题的。所以小程序才有了 WXS 这类方案，用来处理复杂的视图交互问题，比如动画。未来 Remax 也需要考虑这个问题 Reconciler这一层已经进行了 Diff，到渲染进程可能需要重复再做一遍？ 基于模板的方案，局部更新是否会导致页面级别重新渲染？和小程序原生的自定义组件相比性能如何？ 总结本文以 Remax 为例，科普一个 React 自定义渲染器是如何运作的。对于 Remax，目前还处于开发阶段，很多功能还不完善。至于性能如何，笔者还不好做评论，可以看官方给出的初步基准测试。有能力的同学，可以参与代码贡献或者 Issue 讨论。最后谢谢边柳对本文审校和建议。 扩展阅读 Remax - 使用真正的 React 构建小程序 React Fiber是什么 深入React fiber架构及源码 Hello World Custom React Renderer - Shailesh - Medium ⚛️👆 Part 1/3 - Beginners guide to Custom React Renderers. How to build your own renderer from scratch? 这系列文章很棒 谜之wxs，uni-app如何用它大幅提升性能 全新重构，uni-app实现微信端性能翻倍 浅谈小程序运行机制 作者：荒山链接：https://juejin.im/post/5d8395646fb9a06ad16faa57来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
  </entry>
  <entry>
    <title><![CDATA[程序员必备的8款高效工具]]></title>
    <url>%2F2019%2F11%2F15%2Fyuque%2F%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87%E7%9A%848%E6%AC%BE%E9%AB%98%E6%95%88%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[码个蛋第336次推文Alfredhttps://www.alfredapp.com/效率神器，搜索和快速启动的功能，以及工使用自定义插件的工作流功能。让你的效率提升N的档次。http://alfredworkflow.com/这里有400+个workflows。举个栗子：豆瓣的搜索如果还是不满足，那就自己写随便用下面任意一种语言都可以bash, zsh, PHP, Ruby, Python, Perl, Apple Script。Dashhttps://kapeli.com/dashDash提供150+文档下载，让你可以在离线的状态下查看常用的各种技术文档。第三方工具集成：与各个工具及编辑器 、IDE无缝集成，还有 jetBrain 家族、Xcode、Alfred 等等，你用的都在里面。自定义数据来源：已经包含 Google、Stack Overflow，你还可以自定义来自诸如 Medium、Quora 等任何你需要的网站。注释功能：方便快速的注释、标记功能。iTerm2https://www.iterm2.com/OS X 下开源免费的的终端工具，基本用它替代了原生的 Terminal。简化了很多基本功能，拥有文本复制、及时回放、标记跳转、Tab 窗口面板管理、智能补全等功能。组合oh-my-zsh(https://ohmyz.sh/)效果更佳！Sublime-Text-3一款具有代码高亮、语法提示、自动完成且反应快速的编辑器软件，不仅具有华丽的界面，还支持插件扩展机制。优点：功能强大，占用内存小，插件丰富，界面友好。HomeBrewhttps://brew.sh/OSX下好用的包管理工具，Ruby 社区的作品，功能类似 Ubuntu下的apt-get。使用 Homebrew 可以非常容易的安装OS X中没有包含的 Unix工具包和语言包，比如 wget，node，lua，nginx 等。操作简单，一键安装，避免了繁琐的安装，升级，卸载等配置工作。SourceTreehttps://www.sourcetreeapp.com/SourceTree 是 Windows 和Mac OS X 下免费的 Git 和 Hg 客户端，拥有可视化界面，容易上手操作。同时它也是Mercurial和Subversion版本控制系统工具。支持创建、提交、clone、push、pull 和merge等操作。目前用过的最好用的免费的Git代码管理的图形化工具。beyond-compare智能的比较工具只需用简单而强大的操作命令，即可开启最优质的对比体验，找出你感兴趣的差异，合并变化，然后同步文件，并生成报告。随时随地访问数据用户可以从Windows、Mac OSX和Linux工作站直接访问FTP网站、媒体设备、WebDAV资源，SVN存储库和云存储。多种文件格式对比Beyond Compare包含多种数据类型的内置比较浏览器，除了文本之外，还可以进行表格、图片、二进制文件、注册表的比较。Mwebhttps://zh.mweb.im/通常写文章我就用它，支持 Markdown 语法。可以同步到 Evernote 。除此之外还可以发布Wordrpess 博客、支持 Metaweblog API 的博客服务、Wordpress、Blogger、Medium、Tumblr。]]></content>
  </entry>
  <entry>
    <title><![CDATA[react UI库]]></title>
    <url>%2F2019%2F11%2F15%2Fyuque%2Freact%20UI%E5%BA%93%2F</url>
    <content type="text"><![CDATA[Material.io Semantic UI Reacthttps://semantic-ui.com/elements/label.html https://react.semantic-ui.com/elements/input/#states-loading-without-iconhttps://react.semantic-ui.com/ Material-UI Onsen UIhttps://onsen.io/https://onsen.io/v2/guide/theming.html#theme-customizationhttps://onsen.io/v2/guide/react/ Grommet用于企业应用最先进的 UX 框架 Draft.js react-md Fabric Blueprint rebassjs React UWP]]></content>
  </entry>
  <entry>
    <title><![CDATA[2018 前端性能优化清单]]></title>
    <url>%2F2019%2F11%2F14%2Fyuque%2F2018%20%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%B8%85%E5%8D%95%2F</url>
    <content type="text"><![CDATA[前言：这篇文章我在掘金翻译计划中跟着一起翻译的文章（感谢掘金翻译），我翻译了第三部分，然后校对了第二部分，这篇文章对于前端性能优化的技术还是比较新颖和全面的，所以决定自己阅读一遍英文原文，然后又用思维导图整理了下重点，英文原文还是挺长的，所以 如果想要粗略的了解本文内容的可以直接查看我总结的思维导图 如果看完思维导图觉得本文对你有所帮助的，可以查看我自己翻译并根据其他人翻译整理后的文章 如果你英文阅读没有障碍，并且觉得我翻译不好的，可以直接阅读 英文原文 推荐大家时间充裕的话可以自己阅读英文原文，此文是根据掘金翻译的四篇文章 + 其他的翻译文章 + 自己翻译修改得出的。因为翻译大家懂得，会有一些错误的地方，欢迎大家指出，本人不保证翻译没有错误，但已经尽力去翻译了，所以欢迎大家直接阅读英文原文！！欢迎大家直接阅读英文原文！！欢迎大家直接阅读英文原文！！我们都知道性能很重要，但是，我们是否真的一直都知道我们性能优化的瓶颈在哪？是代价昂贵的 JavaScript？是 web 字体很慢？还是比较大的图片？或者是渲染速度过于迟缓？tree-shaking（无用代码移除）、scope hoisting（作用域提升）、code-splitting（按需加载）、 intersection observer 以及 clients hints、CSS containment、HTTP/2 和 service workers 这些技术都是有利于性能优化的。并且，最重要的是，我们要从哪里开始提升我们的性能呢？并且要怎么建立长久有效的性能机制。 译者注： tree-shaking：tree-shaking 是 Webpack 2 引入的新功能，tree-shaking 是无用代码移除（DCE, dead code elimination）的一个方法，但和传统的方法不太一样。tree-shaking 找到需要的代码，灌入最终的结果；传统 DCE 找到执行不到的代码，从 AST 里清除。—— 如何评价 Webpack 2 新引入的 Tree-shaking 代码优化技术？ scope hoisting：scope hoisting 是 Webpack 3 的新功能，又译作“作用域提升”。Webpack 将所有模块都用函数包裹起来，然后自己实现了一套模块加载、执行与缓存的功能，使用这样的结构是为了更容易实现 Code Splitting（包括按需加载）、模块热替换等功能。—— Webpack 3 的新功能：Scope Hoisting code-splitting：对于大型的 web 应用而言，把所有的代码放到一个文件的做法效率很差，特别是在加载了一些只有在特定环境下才会使用到的阻塞的代码的时候。Webpack有个功能会把你的代码分离成Chunk，后者可以按需加载。这个功能就是code-splitting。—— 在Webpack中使用Code Splitting实现按需加载 intersection observer：可以自动”观察”元素是否可见，由于可见（visible）的本质是，目标元素与视口产生一个交叉区，所以这个 API 叫做”交叉观察器”。—— IntersectionObserver API 使用教程 clients hints：自动响应式图片 —— Automatic responsive images with Client Hints CSS containment：新的 CSS 属性 Containment 允许开发者限制浏览器样式、布局和 paint 工作的范围。—— CSS Containment in Chrome 52 service workers：实现离线页面 ——Service worker concepts and usage 在以前，性能优化经常是在项目完成才去考虑的，经常被推迟到项目的末期，这样优化的范围就会缩小，优化的内容通常是优化静态文件和调整一些服务器配置文件。但是现在，性能优化发生了很大的改变，这些是远远不够的。性能不仅仅是一个技术问题：重要的是，当将它放入工作流中的时候，做出的设计决策必须受性能的提示。性能必须被测量、监测和完善，而网络日益增长的复杂性也使得跟踪性能的度量原来越难，因为度量会根据设备、浏览器、协议、网络类型和延迟而显着变化（CDN，ISP，缓存，代理，防火墙，负载均衡器和服务器都在性能上发挥作用）。所以，我们就必须时刻记住性能优化 —— 从项目开始的时候直到网站最后发布。所以我们就创建了一个性能优化列表。（希望是公正的和客观的）2018 前端性能检查表 —— 可以帮助你解决你网站的优化问题，例如，响应时间如何更快，流畅的用户交互和不会流失用户的带宽。（你也可以仅下载 2018 前端性能优化清单 的 PDF 版本（0.129 MB）或者下载 Apple Pages 版本（0.236 MB）） 准备就绪：计划和度量微小的优化对于保持性能也是十分重要的，但是时刻记着我们必须要有一个明确的目标，可度量的目标将影响整个过程中的任何决策。这里有几种不同的模式，并且下面的方法都是从自身角度出发，所以你要尽早确认你自己优化的优先级。 树立性能优化意识 在很多团队中，前端开发者确切的知道常见的潜在问题是什么，应该用什么样的加载模块来修复。然而，只要开发或者设计那边有一方跟市场的意见不合，性能就不会长时间持续下去。所以，研究用户常见的抱怨的地方，看看提高性能如何帮助解决这些常见问题。无论是在移动设备上还是在桌面上都需要运行性能实验并测量结果。 它会建立一个用真实数据为你们公司量身定制的案例研究。此外，要善于使用 WPO Stats 上发布的案例研究和实验中的数据，可以帮助提高你对性能和业务之前潜在关系的认识，以及性能对用户体验和业务度量的影响。仅仅说明绩效是不够的 - 你还需要建立一些可衡量和可追踪的目标来观察性能。 目标：至少要比你最快的竞争对手还快 20% 根据 心理学研究，如果你想要用户感觉你的网站比你竞争者的网站快，那么你至少需要比它们快 20%。研究你的主要竞争者，收集他们在手机和桌面上的性能，并且设置一个你能超过他们的临界值。要获取准确的结果和目标，首先要研究你的分析结果，看看你的用户都在做什么。你可以模拟第百分之九十的用户经验进行测试，收集数据，然后建立一个 表格，然后再减去 20% 就是你的目标（即 性能预算）。现在你在测试之前就有了一些可度量的数据。如果你比较在意预算并尝试去用最小的脚本来获得最快的交互时间，那么你就开始了你的“前端优化之旅”。Lara Hogan 关于如何使用性能预算来处理设计的 指南 可以为设计人员提供有用的指引，而 性能预算计算器 和 Browser Calories 里都可以帮助创建预算（感谢 Karolina Szczur 提供）。除了性能外，还要考虑对你业务最有利的客户的行为。 设置和讨论关键行动的可接受时间阈值，并设置一个整个团队已经达成一致的 “UX ready”用户时间标记。 大部分情况下，用户的行为涉及许多不同部门，因此，按照设置的可接受的时间安排会避免很多问题。确保额外的资源和功能的额外成本其他成员都是可见和知晓的。此外，正如 Patrick Meenan 所建议的那样，最好在设计的过程中设置一个加载队列并且要知道这些顺序会存在哪些利弊。你需要优先处理更重要的优先级，并且定义一个它们优先级的顺序，你也应该清楚哪些是可以推迟的。理想的情况，该队列也应该反映出 JS 和 CSS 的加载顺序，只要设计好了，那么在构建过程中处理它们就会很简单了。另外，还需要考虑的是在页面还在加载时页面的“中间状态”（例如，当 web 字体没有加载完时）。计划计划计划，重要的事情说三遍！如果早期进行优化那么会很容易实现目标，但是没有计划或者没有制定切合实际的、为公司量身定制的业绩目标那么就很难保持性能。 选择正确的度量 不是所有的度量都一样重要。 研究哪些度量对于你的应用程序最重要：通常，这与你能够以多快的速度开始渲染最重要的像素（以及它们的效果）以及如何为这些渲染像素提供输入最快的响应速度有关。 这可以帮助你为后续的工作提供最佳的优化结果。 不管怎样，不要专注于整个页面加载时间（例如 onLoad 和 DOMContentLoaded 时间），而是要优先按照用户可以感知到的页面加载。 也就是说要关注一组稍微不同的度量。首次有内容渲染，视觉完整和可交互时间之间的区别。来自于：@denar90你可以参考下面这样度量： 首次有效渲染（FMP，是指主要内容出现在页面上所需的时间）， 重要渲染时间（页面最重要部分渲染完成所需的时间）， 可交互时间（TTI，是指页面布局已经稳定，关键的页面字体已经可见，主进程可以足够的处理用户的输入 —— 基本的时间标记是，用户可以在 UI 上进行点击和交互）， 输入响应，接口响应用户操作所需的时间， Speed Index，测量填充页面内容的速度。 分数越低越好， 自定义度量，由你的业务需求和用户体验来决定。 Steve Souders 对 每个度量都进行了详细的解释。在许多情况下，根据你的应用程序的使用场景，可交互时间和输入响应 会是最关键的。但这些度量可能会不同：例如，对于 Netflix 电视的用户界面来说，关键输入响应、内存使用和可交互时间更为重要。 从具有代表性的用户使用的设备收集数据 为了收集准确的数据，我们需要尽可能全的选择要测试的设备。最好是 Moto G4，或者一款中档的三星设备又或者是一个 Nexus 5X 这样的普通的设备。如果你手边没有设备，可以使用节流 CPU（5× 减速）来限制网速（例如，150 ms 的往返时延，1.5 Mbps 以下和0.7 Mbps 以上）实现在桌面设备上模拟移动设备的体验。最终，切换到常规的 3G，4G 和 Wi-Fi。为了使性能体验的影响更明显，你甚至可以使用 2G 或 一个节流的 3G 网络，以便进行更快的测试。 幸运的是，有很多优秀的选项可以帮助你自动收集数据，并根据这些度量衡量你的网站在一段时间内的性能。 请记住，良好的性能度量是需要被动和主动监控工具的组合： 被动监测工具，可以根据请求来模拟用户交互（综合测试，如Lighthouse，WebPageTest） 主动监测工具， 是那些不断记录和评价用户交互行为的（真正的用户监控，如 SpeedCurve，New Relic —— 这两种工具也提供综合测试） 前者在开发过程中特别有用，因为它可以在使用产品时持续跟踪。 后者在长期维护非常有用，因为它可以帮助你了解在实际访问站点时发生的性能瓶颈。通过使用导航定时、资源定时、绘图定时、长时间任务等内置的 RUM API，被动和主动性能监视工具一起提供应用程序性能的完整画面。 例如，你可以使用PWMetrics，Calibre，SpeedCurve，mPulse，Boomerang 和 Sitespeed.io，这些都是性能监测工具的绝佳选择。注意：选择浏览器外部的网络级别的限制器总是比较安全的，例如 DevTools 由于实现的方式而存在与 HTTP/2 推送交互的问题（感谢Yoav！）。 与你的同事分享性能清单 为了避免误解，要确保你团队里的每个同事都对清单很熟悉。每个决策都对性能有影响。项目将极大地受益于前端开发人员正确地将性能价值传达给整个团队。从而使每个人都对它负责，而不仅仅是前端开发人员。根据绩效预算和清单中定义的优先顺序来设计决策。 制定现实的目标 控制响应时间在 100ms 内，控制帧速在 60 帧/秒 为了让交互感觉起来很顺畅，接口有 100ms 来响应用户的输入。任何比它长的时间，用户都会认为该应用程序很慢。RAIL，一个以用户为中心的性能模型会为你提供健壮的目标。为了让页面达到小于 100ms 的响应，页面必须要在小于 50ms 前最迟将控制权返回给主线程。预计输入延迟时间 告诉我们，如果我们能达到这个门槛，在理想情况下，它应该低于 50ms。对于像动画这样性能消耗比较大的地方，最好的做法是，在能够优化的地方，尽量优化到极致；在不能优化的地方，让性能开销降至最低。同时，每一帧动画应该要在 16 毫秒内完成，从而达到 60 帧每秒（1秒 ÷ 60 = 16.6 毫秒） —— 最好可以在 10 毫秒完成。因为浏览器需要时间将新框架绘制到屏幕上，你的代码应该在触发 16.6 毫秒以内完成。保持乐观和明智地利用空闲时间。显然，这些目标适用于运行时的性能，而不是加载性能。 速度指标(SpeedIndex) &lt; 1250，3G 上交互时间 &lt; 5s，关键文件大小 &lt; 170Kb（SpeedIndex &lt; 1250, TTI &lt; 5s on 3G, Critical file size budget &lt; 170Kb） 虽然这可能很难实现，一个好的最终目标是首次有效渲染低于 1 秒并且速度指标的值低于 1250。因为我们是以 200 美金为基准的 Android 手机（如 Moto G4）和一个缓慢的 3G 网络上，模拟 400ms 的往返延时和 400kb 的传输速度，所以我们的目标是可交互时间低于 5s，并且再次访问的时间低于 2s。请注意，当谈到可交互时间时，最好来区分一下首次交互和连续交互以避免对它们之间的误解。前者是在主要内容已经渲染出来后最早出现的点（窗口至少需要 5s，页面才开始响应）。后者是期望页面可以一直进行输入响应的点。HTML 的前 14~15kb 加载是是最关键的有效载荷块 —— 也是第一次往返（这是在400 ms 往返延时下 1 秒内所得到的）预算中唯一可以交付的部分。一般来说，为了实现上述目标，我们必须在关键的文件大小内进行操作。最高预算压缩之后 170 Kb（0.8-1MB解压缩），它已经占用多达 1s （取决于资源类型）来解析和编译。稍微高于这个值是可以的，但是要尽可能地降低这些值。尽管如此，还是可以提高绑定的规模预算。例如，你可以在浏览器主线程的活动中设置性能预算，例如，在开始渲染前的绘制时间或者跟踪前端 CPU 。像 Calibre，SpeedCurve 和 Bundlesize 这些工具可以帮助你保持你的预算控制，并集成到你的构建过程。 定义环境 做好构建工具的选型以及搭建好（适合自己的）构建工具 现如今不要太在意那些很酷的技术栈。根据你的项目使用你的构建工具，无论是 Grunt，Gulp，Webpack，Parcel，还是工具间的组合。只要你能快速的得到结果，并且保证你的构建过程没问题。那么，你就可以选择该构建工具。 渐进式增强 安全的选择是将 渐进式增强 作为前端架构和项目部署的指导原则。首先设计和构建核心体验，然后为有能力的浏览器使用高级特性增强体验，创造 弹性 体验。如果你的网站是在一个网络不佳的并且有个糟糕的显示屏上糟糕的浏览器上运行，速度还很快的话，那么，当它运行在一个快速网络下快速的浏览器的机器上，它只会运行得更快。 选择一个强大的性能基准 有这么多未知因素影响加载 —— 网络、热保护、缓存回收、第三方脚本、解析器阻塞模式、磁盘的读写、IPC jank、插件安装、CPU、硬件和内存限制、L2/L3缓存、RTTS、图像、Web字体加载行为的差异 —— JavaScript 的代价是最大的，web 字体阻塞默认渲染和图片的加载消耗了大量的内存。随着性能瓶颈从 服务器端转移到客户端，作为开发人员，我们必须更仔细地考虑所有这些未知因素。在 170kb 的预算中，已经包括了关键路径的 HTML / CSS / JavaScript、路由器、状态管理、实用程序、框架和应用程序逻辑，我们必须彻底检查网络传输成本，解析/编译时间和运行时间来选择我们的框架。 正如 Seb Markbage 所 指出的，测量框架的启动成本的好方法是首先渲染视图，再删除它，然后再渲染，因为它可以告诉你框架是如何扩展的。第一次渲染倾向于预热一堆编译迟缓的代码，当它扩展时，更大的分支可以从中受益。第二次渲染基本上是仿效页面上的代码重用是如何随着页面复杂度的增长来影响性能特征。并不是每个项目都需要框架。事实上，某些项目 可以完全移除某些框架并从中受益。一旦选择了一个框架，你最少会使用好几年。所以，如果你需要使用它，确保你的选择是经过深思熟虑的 并且 对其完全了解。在进行选择前，至少要考虑总大小的成本 + 初始解析时间：轻量级的选项像 Preact，Inferno，Vue，Svelte 或者 Polymer 都做得很好。框架的大小基线将为你的应用程序代码定义约束条件。。 请记住，在移动设备上，与台式计算机相比，预计速度会有 4-5 倍的下降。因为移动设备的 GPU、CPU、内存及电池特性都不同。在手机上的解析时间比桌面设备的要高 36%。所以总在一个最能代表普遍用户的平均的设备上测试。不同的框架将会对性能产生不同的影响，并且需要不同的优化策略。因此，你必须清楚地了解你所依赖的框架的所有细节。当创建一个 web 应用的时候，参考 PRPL 模式 和 应用程序 shell 体系结构。这个想法很简单: 用最少的代码来将初始路由的交互快速呈现，然后使用 service worker 进行缓存和预缓存资源，然后使用懒加载异步加载所需的路由。 PRPL 代表的是保持推送关键资源，渲染初始路由，预缓存剩余路由和延迟加载必要的剩余路由。 应用程序 shell 是最小的 HTML、CSS 和 JavaScript 驱动的用户界面。 你的项目需要使用 AMP 和 Instant Articles 么？ 译者注:AMP 即加速移动页面，是一种制作可快速加载的轻量型网页的方法，特别适合于移动设备。依赖于你的组织优先级和战略，你可以考虑使用谷歌的 AMP 和 Facebook 的 Instant Articles 或者苹果的 Apple News。如果不使用它们，你也可以实现很好的性能，但是 AMP 确实提供了一个免费的内容分发网络（CDN）的性能框架，而 Instant Articles 将提高你在 Facebook 上的知名度和表现。对于用户而言，这些技术主要的优势是确保性能，所以有时他们更喜欢 AMP-/Apple News/Instant Pages 链接，而不是“常规”和潜在的臃肿页面。对于那些以内容为主的网站，主要处理很多第三方法内容，这些选择极大地加速渲染的时间。对于站长而言，这些样式在各个平台可发现性并且 增强在搜索引擎中的可见性。你也可以重新使用 AMP 作为你的 PWA 数据源来构建渐进的 Web AMPs。有什么缺点呢？显然，在一个有围墙的区域里，开发者可以创造并维持与内容分离的单独版本，防止 Instant Articles 和 Apple News 没有实际的URLs。（谢谢，Addy，Jeremy） 合理使用 CDN 根据你拥有的动态数据量，你可以将部分内容外包给静态站点生成工具 如 Jekyll、Hexo 生成的静态文件，接着把静态文件推到 CDN 中，最后 CDN 只是提供静态文件的静态版本。所以这样就可以避免发起对数据库的读写请求。你甚至可以选择一个基于 CDN 的静态主机平台(这样就可以)通过给页面添加可交互组件的方式来丰富你的页面，并以此作为性能提升的标志 (JAMStack)。请注意，CDN 也是可以托管并卸载（offload）动态内容的，所以咱们没有必要把 CDN 的服务范围限定在静态资源。（另外需要你记住的是），不管你的 CDN 是否执行内容压缩（GZip）、内容转换、HTTP/2 传输以及 ESI（一种标记语言，可以用它把网页划分为单独的可缓存的实体）等操作，我们还是需要复核上述操作的，这是因为上述操作不仅会在 CDN 的 edge 处（服务器最接近用户的地方）聚合页面中的静态以及动态内容，也还会执行其它任务。 构建优化 分清轻重缓急 你应该知道优先处理什么。运行你所有静态资源（JavaScript、图片、字体、第三方脚本和页面中“昂贵的”模块，比如：轮播图、复杂的图表和多媒体内容），并将它们划分成组。先搞清楚资源（assets）可以分为几类，大致可以分为： 针对传统的浏览器，定义基本的核心功能（比如：完全可访问的核心内容） 针对多功能浏览器提升功能（比如：丰富多彩的，完美的体验） 其他资源（不是绝对需要而且可以被延迟加载的资源，如 Web 字体、不必要的样式、旋转木马脚本、视频播放器、社交媒体按钮、大型图像） 我们在“Improving Smashing Magazine’s Performance”上发布了一篇文章，上面详细描述了该方法。 考虑使用“cutting-the-mustard”模式 虽然这个技术已经很老了，但我们仍然可以使用 cutting-the-mustard 技术 使传统浏览器使用核心功能并增强对现代浏览器的体验。严格限制加载的资源：优先加载核心功能，然后是提升的，最后是其他的。注意：该技术可以从浏览器版本中推断出设备功能，而现在我们已经不再这样做了。例如：在发展中国家，廉价的安卓手机主要运行 Chrome，他们的内存和 CPU 有限。PRPL 模式 就是一个好的选择。最终，使用 Device Memory Client Hints Header，我们就能够更可靠地识别出低端设备。现在，只有在 Blink 中才支持 header （Blink 支持client hints）。因为设备存储也有一个在 Chrome 中可以调用的 JavaScript API，一种选择是基于 API 的特性检测，只在不支持的情况下回退到“符合标准”技术（谢谢，Yoav！）。 减少解析JavaScript 的成本 当我们处理单页面应用时，在你的页面渲染之前你需要初始化应用。寻找模块和技术加快初始化渲染时间（例如：如何调试 React 性能，以及如何提高 Angular 性能），因为大多数性能问题来自于启动应用程序的初始解析时间。JavaScript 有成本，但不一定是文件大小影响性能。解析和执行时间的不同很大程度依赖设备的硬件。在一个普通的手机上（Moto G4），仅解析 1MB （未压缩的）的 JavaScript 大概需要 1.3-1.4 秒，会有 15 - 20% 的时间耗费在手机的解析上。在执行编译过程中，只是用在 JavaScript 准备平均需要 4 秒，在手机上页面展示其主要内容所需的时间（First Meaningful Paint）需要 11 秒。解释：在低端移动设备上，解析和执行时间可以轻松提高 2 至 5 倍。Ember 最近做了一个实验，使用二进制模板（binary templates ）巧妙的避免解析开销的方式。这些模板不需要解析。（感谢，Leonardo！）这就是检查每个 JavaScript 依赖性的关键，像 webpack-bundle-analyzer、Source Map Explorer 和 Bundle Buddy 这样的工具可以帮助你完成这些。度量 JavaScript 解析和编译时间。Etsy 的 DeviceTiming，一个小工具可以让你的 JavaScript 测量任何设备或浏览器上的解析和执行时间。重要的是，虽然文件的大小重要，但它不是最重要的。解析和编译时间并不是随着脚本大小增加而线性增加。Webpack Bundle Analyzer visualizes JavaScript dependencies. 你使用 ahead-of-time 编译器么？ 使用 ahead-of-time 编译器 来 减轻从客户端 到 服务端的渲染 的开销，因此快速输出有用的结果。最后，考虑使用 Optimize.js 通过包装可快速调用的函数来实现(在app初始时能够)快速载入（尽管，它可能不需要）。 你使用 tree-shaking、scope hoisting、code-splitting 么 Tree-shaking 是一种清理构建过程的方法通过只加载生产中实际使用的代码并清除 在 Webpack 中 未使用的 import。使用 Webpack 3 和 Rollup，我们还可以使用 scope hoisting(作用域提升)，scope hoisting 允许工具检测哪些 import 可以被提升或者可以转换成一个内联函数。有了 Webpack 4，你现在可以使用 JSON Tree Shaking。UnCSS 或者 Helium 可以帮助你去删除未使用 CSS 样式。而且，你需要考虑 如何编写有效的 CSS 选择器 以及 如何避免编写臃肿和开销浪费的样式。你也可以使用 Webpack 缩短类名和在编译时使用独立作用域来 动态地重命名 CSS 类Code-splitting 是 Webpack 的另一个特性，可将你的代码分解为按需加载的“块”。并不是所有的 JavaScript 都是必须下载、解析和编译的。一旦你在代码中确定了分割点，Webpack 会处理这些依赖关系和输出文件。在应用发送请求的时候，这样基本上确保初始的下载足够小并且实现按需加载。另外，考虑使用 preload-webpack-plugin 获取代码拆分的路径，然后使用 &lt;link rel=&quot;preload&quot;&gt; or &lt;link rel=&quot;prefetch&quot;&gt; 提示浏览器预加载它们。在哪里定义分离点？通过追踪哪些 CSS/JavaScript 块被使用和哪些没有被使用。Umar Hansa 解释了你如何使用 Devtools 的 Code Coverage 来实现。如果你没有使用 Webpack，那么相比于 Browserify 的输出结果， Rollup 的输出更好一些。当使用 Rollup 时，推荐你了解下 Rollupify，它可以将 ECMAScript 2015 modules 转化为一个大的 CommonJS module —— 因为小的模块会有令人惊讶的高性能开销（取决于打包工具和模块加载系统的选择）。Addy Osmani 的从快速默认：现代加载的最佳实践。幻灯片76。最后，随着现代浏览器对 ES2015 支持越来越好，考虑 使用babel-preset-env 只转换现代浏览器不支持的 ES2015+ 的特性。然后设置两个构建，一个为 ES6 一个为 ES5。我们可以 使用script type=&quot;module&quot; 让具有 ES 模块浏览器支持加载文件，而老的浏览器可以加载传统的 script nomodule。对于 loadsh，使用 babel-plugin-lodash 将只加载你仅在源码中使用的模块。这可能会为你节省相当多的 JavaScript 负载。 利用你使用的 JavaScript 引擎对其进行优化 研究 JavaScript 引擎在用户基础中占的比例，然后探索优化它们的方法。例如，当优化的 V8 引擎是用在 Blink 浏览器，Node.js 运行和 Electron 的时候，对每个脚本使用脚本流。一旦下载开始，它允许 async 或 defer scripts 在一个单独的后台线程进行解析，因此在某些情况下，提高 10% 的页面加载时间。实际上，在 &lt;head&gt; 中 使用 &lt;script defer&gt;，以便 浏览器更早地可以发现资源，然后在后台线程中解析它。Caveat：Opera Mini 不支持 defement 脚本，如果你正在印度和非洲从事开发工作，defer 将会被忽略，导致阻塞渲染直到脚本加载（感谢 Jeremy）!。 渐进引导：使用服务器端呈现获得首次有效绘制，但也包含一些最小必要的 JavaScript 来保持实时交互来接近首次有效绘制。 客户端渲染还是服务端渲染？ 在两种场景下，我们的目标应该是建立 渐进引导：使用服务端呈现获得首次有效绘制，而且还要包含一些最小必要的 JavaScript 来保持实时交互来接近首次有效绘制。如果 JavaScript 在首次有效绘制没有获取到，那么浏览器可能会在解析时锁住主线程，编译和执行最新发现的 JavaScript，从而对站点或应用程序的交互性造成限制。为了避免这样做，总是将执行函数分离成一个个，异步任务和可能用到 requestIdleCallback 的地方。考虑 UI 的懒加载部分使用 WebPack 动态 import 支持，避免加载、解析和编译开销直到用户真的需要他们（感谢 Addy!）。在本质上，交互时间（TTI）告诉我们导航和交互之间的时间。度量是通过在窗口初始内容呈现后的第一个五秒来定义的，在这个过程中，JavaScript 任务都不超过 50ms。如果发生超过 50ms 的任务，则重新开始搜索五秒钟的窗口。因此，浏览器首先会假定它达到了交互式，只是切换到冻结状态，最终切换回交互式。一旦我们达到交互式，然后，我们可以按需或等到时间允许，启动应用程序的非必需部分。不幸的是，随着 Paul Lewis 提到的，框架通常没有优先级的概念，因此渐进式引导很难用大多数库和框架实现。如果你有时间和资源，使用该策略可以极大地改善前端性能。 你是否限制第三方脚本的影响？ 随着所有性能优化的到位，我们常常无法控制来自业务需求的第三方脚本。第三方脚本的度量不受用户体验的影响，所以，一个单一的脚本常常会以调用令人讨厌的，长长的第三方脚本为结尾，因此，破坏了为性能专门作出的努力。为了控制和减轻这些脚本带来的性能损失，仅异步加载（可能通过 defer）和通过资源提示，如：dns-prefetch 或者 preconnect 加速他们是不足够的。正如 Yoav Weiss 在他的必须关注第三方脚本的通信中解释的，在很多情况下，下载资源的这些脚本是动态的。页面负载之间的资源是变化的，因此我们不知道主机是从哪下载的资源以及这些资源是什么。这时，我们有什么选择？考虑 通过一个超时来使用 service workers 下载资源，如果在特定的时间间隔内资源没有响应，返回一个空的响应告知浏览器执行解析页面。你可以记录或者限制那些失败的第三方请求和没有执行特定标准请求。另一个选择是建立一个 内容安全策略（CSP） 来限制第三方脚本的影响，比如：不允许下载音频和视频。最好的选择是通过 &lt;iframe&gt; 嵌入脚本使得脚本运行在 iframe 环境中，因此如果没有接入页面 DOM 的权限，在你的域下不能运行任何代码。Iframe 可以 使用 sandbox 属性进一步限制，因此你可以禁止 iframe 的任何功能，比如阻止脚本运行，阻止警告、表单提交、插件、访问顶部导航等等。例如，它可能必须要允许脚本运行 &lt;iframe sandbox=&quot;allow-scripts&quot;&gt;。每一个限制都可以通过多种允许值在 ‘sandbox’ 属性中（几乎处处支持）解除，所以将它们限制在允许做的最低限度。考虑使用 Safeframe 和 Intersection Observer；这将使广告嵌入 iframe 的同时仍然调度事件或需要从 DOM 获取信息（例如广告知名度）。注意新的策略如 特征策略）、资源的大小限制、CPU 和带宽优先级限制损害的网络功能和会减慢浏览器的脚本，例如：同步脚本，同步 XHR 请求，document.write 和超时的实现。要对第三方进行 压力测试，在 DevTools 上自底向上概要地检查页面的性能，测试在请求被阻止或超时后会发生什么情况，对于后者，你可以使用 WebPageTest 的 Blackhole 服务器 72.66.115.13，你可以在你的 hosts 文件中指定特定的域名。最好是最好是自主主机并使用单个主机名，但是同时生成一个请求映射，当脚本变化时，暴露给第四方调用和检测。Harry Roberts HTTP cache 头部设置是否合理？ 再次检查一遍 expires，cache-control，max-age 和其他 HTTP cache 头部都是否设置正确。通常，资源应该是可缓存的，不管是短时间的（它们是否很可能改变），还是无限期的（它们是否是静态的）。 你可以在需要更新的时候，改变它们 URL 中的版本即可。在任何资源上禁止头部 Last-Modified 都会导致一个 If-Modified-Since 条件查询，即使资源在缓存中。与 Etag 一样，即使它在使用中。使用 Cache-control: immutable，(其实是为了解决fingerprinted静态资源的缓存问题而被设计出来的，解决了客户端revalidation问题（截至 2017年12月，在 FireFox，Edge 和 Safari 中支持；只有 FireFox 在 HTTPS 中支持）。你也可以使用 Heroku 的 HTTP 缓存头部，Jake Archibald 的 “Caching Best Practices“ ，以及 Ilya Grigorik 的 HTTP caching primer 作为指导。而且，注意不同的头部，尤其是在关系到 CDN 时，并且注意并且要注意关键头文件，有助于避免在新请求稍有差异时进行额外的验证，但从以前请求标准，并不是必要的（感谢，Guy！）。 静态资源优化 你是否使用 Brotli 或 Zopfli 进行纯文本压缩？ 在 2005 年，Google 推出了 Brotli，一个新的开源无损数据压缩格式，现在已经 被所有的现代浏览器所支持。实际上，Brotli 比 Gzip 和 Deflate 更有效。压缩速度可能会非常慢，取决于设置信息。但是缓慢的压缩过程会提高压缩率，并且仍然可以快速解压。当然，解压缩速度很快。只有当用户通过 HTTPS 访问网站时，浏览器才会采用。Brotli 现在还不能预装在某些服务器上，而且如果不自己构建 NGINX 和 UBUNTU 的话很难部署。不过这也并不难。实际上，一些 CDN 是支持的，甚至 也可以通过服务器在不支持 CDN 的情况下启用 Brotli。在最高级别的压缩下，Brotli 的速度会变得非常慢，以至于服务器在等待动态压缩资源时开始发送响应所花费的时间可能会使我们对文件大小的优化无效。但是，对于静态压缩，高压缩比的设置比较受欢迎 —— （感谢 Jeremy!）或者，你可以考虑使用 Zopfli 的压缩算法，将数据编码为 Deflate，Gzip 和 Zlib 格式。Zopfli 改进的 Deflate 编码使得任何使用 Gzip 压缩的文件受益，因为这些文件大小比 用Zlib 最强压缩后还要小 3％ 到 8％。问题在于压缩文件的时间是原来的大约 80倍。这就是为什么虽然 使用 Zopfli 是一个好主意但是变化并不大，文件都需要设计为只压缩一次可以多次下载的。比较好的方法是你可以绕过动态压缩静态资源的成本。Brotli 和 Zopfli 都可以用于明文传输 —— HTML，CSS，SVG，JavaScript 等。有什么方法呢？在最高等级和 Brotli 的 1-4 级动态压缩 HTML 使用 Brotli+Gzip 预压缩静态资源。同时，检查 Brotli 是否支持 CDN，（例如 KeyCDN，CDN77，Fastly）。确保服务器能够使用 Brotli 或 gzip 处理内容。如果你不能安装或者维护服务器上的 Brotli，那么请使用 Zopfli。 图像是否进行了适当的优化？ 尽可能通过 srcset，sizes 和 &lt;picture&gt; 元素使用 响应式图片。也可以通过 &lt;picture&gt; 元素使用 WebP 格式的图像（Chrom，Opera，Firefox soon支持），或者一个 JPEG 的回调（见 Andreas Bovens 的 code snippet）或者通过使用内容协商（使用 Accept 头信息）。Sketch 本身就支持 WebP 并且 WebP 图像可以通过使用 WebP 插件 从 PhotoShop 中导出。也有其他选择可以使用，如果你使用 WordPress 或者 Joomla，也有可以轻松支持 WebP 的扩展，例如 Optimus 和 Cache Enabler（通过 Cody Arsenault）你可以仍然使用 client hints，但仍需要获得一些浏览器支持。没有足够的资源支持响应式图片？使用 断点发生器 或者类似 Cloudinary 这样的服务自动优化图片。同样，在许多情况下，只使用 srcset 和 sizes 会有不错的效果。 响应图像断点生成器自动生成图像和标记生成。 图片优化进阶别 现在有一个至关重要着陆页，有一个特定的图片的加载速度非常关键，确保 JPEGs 是渐进式的并且使用 Adept、 mozJPEG （通过操纵扫描级来改善开始渲染时间）或者 Guetzli 压缩，谷歌新的开源编码器重点是能够感官的性能，并借鉴 Zopfli 和 WebP。唯一的 不足 是：处理的时间慢（每百万像素 CPU 一分钟）。至于 png，我们可以使用 Pingo，和 svgo，对于 SVG 的处理，我们使用 SVGO 或 SVGOMG每一个图像优化的文章会说明，但始终会提醒要保持矢量资源干净和紧密。确保清理未使用的资源，删除不必要的元数据，并减少图稿中的路径点数量（从而减少SVG代码）。（感谢，Jeremy！）到目前为止，这些优化只涵盖了基础知识。 Addy Osmani 已经发布了 一个非常详细的基本图像优化指南，深入到图像压缩和颜色管理的细节。 例如，您可以模糊图像中不必要的部分（通过对其应用高斯模糊滤镜）以减小文件大小，最终甚至可以开始移除颜色或将图像变成黑白色，以进一步缩小图像尺寸。 对于背景图像， 从Photoshop 导出的照片质量为 0 到 10％ 也是绝对可以接受的。那么 GIF 图片呢？我们可以使用 循环的 HTML5 视频，而不是影响渲染性能和带宽的重度 GIF 动画，而使用循环的 HTML5 视频，虽然 &lt;video&gt; 会使得 浏览器的性能很慢，但是与图像不同的是，浏览器不会预先加载 &lt;video&gt; 内容。我们也可以使用 Lossy GIF, gifsicle 或者 giflossy 添加有损压缩 GIF。好 消息: 希望不久以后我们可以使用 &lt;img src=&quot;.mp4&quot;&gt; 来加载视频, 早期的测试表明 img 标签比同等大小的 GIF 显示速度的要快 20 多倍，解析速度要快 7 倍多。还不够好？那么，你也可以使用 多个背景图像技术 提高图像的感知性能。 记着，减少对比度 和模糊不必要的细节（或消除颜色）也可以减小文件的大小。 你需要放大一个小照片而不失真？考虑使用 Letsenhance.ioZach Leatherman 的 字体加载策略综合指南 提供了十几种更好的网页字体发送选项 是否对 Web字体进行了优化？ 首先需要问一个问题，你是否能不使用 UI 系统字体。 如果不可以，那么你有很大可能使用 Web 网络字体，会包含字形和额外的功能以及用不到的加粗。你可以向字体设计公司获取网络字体子集或子集，如果您使用的是开源字体（例如，通过仅包含带有某些特殊的重音字形的拉丁语），则可以只选择部分 Web 字体来减少其文件大小。WOFF2 的支持非常好，对于不支持WOFF2的浏览器，你可以使用 WOFF 和 OTF 作为不支持它的浏览器的备选。另外，从 Zach Leatherman 的《字体加载策略综合指南》（代码片段也可以作为 Web字体加载片段）中选择一种策略，并使用服务器缓存持久地缓存字体。是不是感觉小有成就？Pixel Ambacht 有一个 快速教程和案例研究，让你的字体按顺序排列。如果你无法从你的服务器拿到字体并依赖于第三方主机，请确保使用 字体加载事件（或对不支持它的浏览器使用 Web字体加载器）FOUT 要优于 FOIT; 立即开始渲染文本，并异步加载字体 —— 也可以使用 loadCSS。 你也可以 摆脱本地安装的操作系统字体，也可以使用 可变的 字体。怎么才能是一个无漏洞的字体加载策略？ 从 font-display 开始，然后到 Font Loading API，然后到 Bram Stein 的 Font Face Observer（感谢 Jeremy！）如果你有兴趣从用户的角度来衡量字体加载的性能， Andreas Marschke 探索了 使用 Font API 和 UserTiming API 进行性能跟踪此外，不要忘记包含 font-display：optional 描述符来提供弹性和快速的字体回退，unicode-range 将大字体分解成更小的语言特定的字体，以及Monica Dinculescu 的字体样式匹配器 用来解决由于两种字体之间的大小差异，最大限度地减少了布局上的震动的问题。 交付优化 你是否异步加载 JavaScript？ 当用户请求页面时，浏览器获取 HTML 并构造 DOM，然后获取 CSS 并构造 CSSOM，然后通过匹配 DOM 和 CSSOM 生成一个渲染树。如果有任何的 JavaScript 需要解决，浏览器将不会开始渲染页面，直到 JavaScript 解决完毕，这样就会延迟渲染。 作为开发人员，我们必须明确告诉浏览器不要等待并立即开始渲染页面。 为脚本执行此操作的方法是使用 HTML 中的 defer 和 async 属性。事实证明，我们 应该把 async 改为 defer（因为 ie9 及以下不支持 async）。 另外，如上所述，限制第三方库和脚本的影响，特别是使用社交共享按钮和嵌入的 &lt;iframe&gt; 嵌入（如地图）。 大小限制 有助于防止 JavaScript 库过大：如果您不小心添加了大量依赖项，该工具将通知你并抛出错误。 你可以使用 静态社交分享按钮（如通过 SSBG ）和 静态链接 来代替交互式地图。 你对开销很大的 JS 是否使用懒加载并使用 Intersection Observer？ 如果您需要延迟加载图片、视频、广告脚本、A/B 测试脚本或任何其他资源，则可以使用 Intersection Observer API，它提供了一种方法异步观察目标元素与 祖先元素或顶层文档的视口。基本上，你需要创建一个新的 IntersectionObserver 对象，它接收一个回调函数和一组选项。 然后我们添加一个目标来观察。当目标变得可见或不可见时执行回调函数，所以当它拦截视口时，可以在元素变得可见之前开始采取一些行动。 事实上，我们可以精确地控制观察者的回调何时被调用，使用 rootMargin 和 threshold（一个数字或者一个数字数组来表示目标可见度的百分比）。Alejandro Garcia Anglada 发表了一个 简单的教程 关于如何实际实施的教程。你甚至可以通过向你的网页添加 渐进式图片加载 来将其提升到新的水平。 与 Facebook，Pinterest 和 Medium 类似，你可以首先加载低质量或模糊的图像，然后在页面继续加载时，使用 Guy Podjarny 提出的 LQIP (Low Quality Image Placeholders) technique（低质量图像占位符）技术替换它们的清晰版本。（可以参考知乎）如果技术提高了用户体验，观点就不一样了，但它肯定会提高第一次有意义的绘画的时间。我们甚至可以通过使用 SQIP 创建图像的低质量版本作为 SVG 占位符来实现自动化。 这些占位符可以嵌入 HTML 中，因为它们自然可以用文本压缩方法压缩。 Dean Hume 在他的文章中 描述了 如何使用 Intersection Observer 来实现这种技术。浏览器支持程度如何呢？Decent，与 Chrome，火狐，Edge 和 Samsung Internet 已经支持了。 WebKit 目前 正在开发中。如果浏览器不支持呢？ 如果不支持Intersection Observer，我们仍然可以 延迟加载 一个 polyfill 或立即加载图像。甚至还有一个 library。通常，我们会使用懒加载来处理所有代价较大的组件，如字体，JavaScript，轮播，视频和 iframe。 你甚至可以根据网络质量调整内容服务。网络信息 API，特别是 navigator.connection.effectiveType（Chrome 62+）使用 RTT 和下行链路值来更准确地表示连接和用户可以处理的数据。 您可以使用它来完全删除视频自动播放，背景图片或 Web 字体，以便连接速度太慢。 你是否优先加载关键的 CSS？ 为确保浏览器尽快开始渲染页面，通常 会收集开始渲染页面的第一个可见部分所需的所有 CSS（称为 “关键CSS” 或 “首屏 CSS”）并将其内联添加到页面的 &lt;head&gt; 中，从而减少往返。 由于在慢启动阶段交换包的大小有限，所以关键 CSS 的预算大约是 14 KB。如果超出这个范围，浏览器将需要额外往返取得更多样式。 CriticalCSS 和 Critical 可以做到这一点。 你可能需要为你使用的每个模板执行此操作。 如果可能的话，考虑使用 Filament Group 使用的 条件内联方法。使用 HTTP/2，关键 CSS 可以存储在一个单独的 CSS 文件中，并通过 服务器推送 来传递，而不会增大 HTML 的大小。 问题在于，服务器推送是很 麻烦，因为浏览器中存在许多问题和竞争条件。 它一直不被支持，并有一些缓存问题（参见 [Hooman Beheshti介绍的文章](Hooman Beheshti’s presentation) 114 页内容）。事实上，这种影响可能是 负面的，会使网络缓冲区膨胀，从而阻止文档中的真实帧被传送。 而且，由于 TCP 启动缓慢，似乎服务器推送在热连接上 更加有效。即使使用 HTTP/1，将关键 CSS 放在根目录上的单独文件中也是有 好处的，有时甚至比缓存和内联更为有效。 Chrome 请求这个页面的时候会再发送一个 HTTP 连接到根目录，从而不需要 TCP 连接来获取这个 CSS（感谢 Philip！）需要注意的一点是：和 preload 不同的是，preload 可以触发来自任何域的预加载，而你只能从你自己的域或你所授权的域中推送资源。 一旦服务器得到来自客户端的第一个请求，就可以启动它。 服务器将资源压入缓存，并在连接终止时被删除。 但是，由于可以在多个选项卡之间重复使用 HTTP/2 连接，所以推送的资源也可以被来自其他选项卡的请求声明（感谢 Inian！）。目前，服务器并没有一个简单的方法得知被推送的资源 是否已经存在于用户的缓存中，因此每个用户的访问都会继续推送资源。因此，您可能需要创建一个 缓存监测 HTTP/2 服务器推送机制。如果被提取，您可以尝试从缓存中获取它们，这样可以避免再次推送。但请记住，新的 cache-digest 规范 无需手动建立这样的 “缓存感知” 的服务器，基本上在 HTTP/2 中声明的一个新的帧类型就可以表达该主机的内容。因此，它对于 CDN 也是特别有用的。对于动态内容，当服务器需要一些时间来生成响应时，浏览器无法发出任何请求，因为它不知道页面可能引用的任何子资源。 在这种情况下，我们可以预热连接并增加 TCP 拥塞窗口大小，以便将来的请求可以更快地完成。 而且，所有内联配置对于服务器推送都是较好的选择。事实上，Inian Parameshwaran 对 HTTP/2 Push 和 HTTP Preload 进行了比较 深入的研究，内容很不错，其中包含了您可能需要的所有细节。服务器到底是推送还是不推送呢？你可以阅读一下 Colin Bendell 的 Should I Push?。底线：正如 Sam Saccone 所说，preload 有利于将资源的开始下载时间更接近初始请求， 而服务器推送是一个完整的 RTT（或 更多，这取决于您的服务器反应时间 —— 如果你有一个服务器可以防止不必要的推送。你使用 流响应 吗？通过流，在初始导航请求中呈现的 HTML 可以充分利用浏览器的流式 HTML 解析器。 你使用流响应吗? streams 经常被遗忘和忽略，它提供了异步读取或写入数据块的接口，在任何给定的时间内，只有一部分数据可能在内存中可用。 基本上，只要第一个数据块可用，它们就允许原始请求的页面开始处理响应，并使用针对流进行优化的解析器逐步显示内容。我们可以从多个来源创建一个流。例如，您可以让服务器构建一个壳子来自于缓存，内容来自网络的流，而不是提供一个空的 UI 外壳并让它填充它。 正如 Jeff Posnick 指出的，如果您的 web 应用程序由 CMS 提供支持的，那么服务器渲染 HTML 是通过将部分模板拼接在一起来呈现的，该模型将直接转换为使用流式响应，而模板逻辑将从服务器复制而不是你的服务器。Jake Archibald 的 The Year of Web Streams 文章重点介绍了如何构建它。对于性能的提升是非常明显的。流式传输整个 HTML 响应的一个重要优点是，在初始导航请求期间呈现的 HTML 可以充分利用浏览器的流式 HTML 解析器。 在页面加载之后插入到文档中的 HTML 块（与通过 JavaScript 填充的内容一样常见）无法利用此优化。浏览器支持程度如何呢? 详情请看这里 Chrome 52+、Firefox 57、Safari 和 Edge 支持此 API 并且服务器已经支持所有的 现代浏览器. 你使用 Save-Data 存储数据吗? 特别是在新兴市场工作时，你可能需要考虑优化用户选择节省数据的体验。 Save-Data 客户端提示请求头 允许我们为成本和性能受限的用户定制应用程序和有效载荷。 实际上，您可以将 高 DPI 图像的请求重写为低 DPI 图像，删除网页字体和花哨的特效，关闭视频自动播放，服务器推送，甚至更改提供标记的方式。该头部目前仅支持 Chromium，Android 版 Chrome 或 桌面设备上的 Data Saver 扩展。最后，你还可以使用 service worker 和 Network Information API 来提供基于网络类型的低/高分辨率的图像。 你是否激活了连接以加快传输？ 使用 资源提示 来节约时间，如 dns-prefetch （在后台执行 DNS 查询），preconnect （告诉浏览器在后台进行连接握手（DNS, TCP, TLS）），prefetch (告诉浏览器请求一个资源) 和 preload (预先获取资源而不执行他们)。最近，我们至少会使用 preconnect 和 dns-prefetch，我们会小心使用 prefetch 和 preload；前者只能在你非常确定用户后续需要什么资源的情况下使用（类似于采购渠道）。注意，prerender 已被弃用，不再被支持。请注意，即使使用 preconnect 和 dns-prefetch，浏览器也会对它将并行查找或连接的主机数量进行限制，因此最好是将它们根据优先级进行排序（感谢 Philip！）。事实上，使用资源提示可能是最简单的提高性能的方法，它确实很有效。什么时候该使用呢？Addy Osmani 已经做了解释，我们应该预加载确定将在当前页面中使用的资源。预获取可能用于未来页面的资源，例如用户尚未访问的页面所需的 Webpack 包。Addy 的关于 Chrome 中加载优先级的文章展示了 Chrome 是如何精确地解析资源提示的，因此一旦你决定哪些资源对页面渲染比较重要，你就可以给它们赋予比较高的优先级。你可以在 Chrome DevTools 网络请求表格（或者 Safari Technology Preview）中启动“priority”列来查看你的请求的优先级。DevTools 中的 “Priority” 列。图片来源于：Ben Schwarz，重要的请求例如，由于字体通常是页面上的重要资源，所以最好使用 preload 请求浏览器下载字体。你也可以 动态加载 JavaScript ，从而有效的执行延迟加载。同样的，因为 &lt;link rel=&quot;preload&quot;&gt; 接收一个 media 的属性，你可以基于 @media 查询规则来有选择性地优先加载资源。需要注意的一些问题是：preload 可以 将资源的下载时间移到请求开始时，但是这些缓存在内存中的预先加载的资源是绑定在所发送请求的页面上，也就是说预先加载的请求不能被页面所共享。而且，preload 与 HTTP 缓存配合得也很好：如果缓存命中则不会发送网络请求。因此，它对后发现的资源也非常有用，如：通过 background-image 加载的一幅 hero image，内联关键 CSS （或 JavaScript），并预先加载其他 CSS （或 JavaScript）。此外，只有当浏览器从服务器接收 HTML，并且前面的解析器找到了 preload 标签后，preload 标签才可以启动预加载。由于我们不等待浏览器解析 HTML 以启动请求，所以通过 HTTP 头进行预加载要快一些。早期提示将有助于进一步，在发送 HTML 响应标头之前启动预加载。请注意：如果你正在使用 preload，as 必须定义否则什么都不会加载，还有，预加载字体时如果没有 crossorigin 属性将会获取两次 你优化渲染性能了吗？ 使用 CSS containment 隔离昂贵的组件 - 例如，限制浏览器样式、用于非画布导航的布局和绘画工作，第三方组件的范围。确保在滚动页面没有延迟，或者当一个元素进行动画时，持续地达到每秒 60 帧。如果这是不可能的，那么至少要使每秒帧数持续保持在 60 到 15 的范围。使用 CSS 的 will-change 通知浏览器哪个元素的哪个属性将要发生变化。此外，评估运行时渲染性能（例如，使用 DevTools）。可以通过学习 Paul Lewis 免费的关于浏览器渲染优化的 Udacity 课程和 Emily Hayman 的文章优化网页动画和交互来入门。同样，我们有 Sergey Chikuyonok 这篇文章关于如何正确使用 GPU 动画。注意：对 GPU-composited 层的更改是代价最小的，如果你能通过“不透明”和“变形”来触发合成，那么你就是在正确的道路上。 你优化过渲染体验吗？ 组件以何种顺序显示在页面上以及我们如何给浏览器提供资源固然重要，但是我们同样也不能低估了感知性能的角色。这一概念涉及到等待的心理学，主要是让用户在其他事情发生时保持忙碌。这就涉及到了感知管理，优先开始，提前完成和宽容管理。这一切意味着什么？在加载资源时，我们可以尝试始终领先于客户一步，所以将很多处理放置到后台，响应会很迅速。让客户参与进来，我们可以用骨架屏幕（实例演示），而不是当没有更多优化可做时、用加载指示，添加一些动画/过渡欺骗用户体验。 HTTP/2 迁移到 HTTPS，然后打开 HTTP/2. 在谷歌提出向更安全的网页进军以及Chrome 会把（所有使用 HTTP 的）网页认定为“不安全”的大环境下，迁移到HTTP/2是不可避免的。HTTP/2 从目前来看支持得非常好，并且，在某些场景下，使用 HTTP/2 会让你大力出奇迹。一旦运行在 HTTPS 上，你至少能够在 service workers 和 server push 方面获得显著的性能提升。最终，谷歌计划将所有 HTTP 页面标记为不安全的，并将有问题的 HTTPS 的 HTTP 安全指示器更改为红色三角形。（图片来源）最耗时的任务将是迁移到 HTTPS，取决于你的 HTTP/1.1 用户基础有多大（即使用旧版操作系统或浏览器的用户），你将不得不为旧版的浏览器性能优化发送不同的构建版本，这需要你采用不同的构建流程。注意：开始迁移和新的构建过程可能会很棘手，而且耗费时间。接下来所讲的内容，都是针对之前切过 HTTP/2 环境或者现在正准备切 HTTP/2 环境（的读者）来展开的。 正确地部署 HTTP/2. 再次强调一下，需要对现阶段正如何提供在你开始使用 HTTP/2 请求资源之前，需要搞清楚你以前是如何请求资源的。另外需要你在载入大模块以及并行载入小模块之间找到一个平衡点。 。最终，仍然是最好的请求就是没有请求，然而我们的目标是在快速传输资源和缓存之间找到一个好的平衡点。一方面，你可能想要避免合并所有资源，而是把整个界面分解成许多小模块，然后在构建过程中压缩这些小模块，最后通过 “scount” approach 的方法引用和并行加载这些小模块。这样的话，一个文件的更改就不需要重新下载整个样式表或 JavaScript。这样还可以 最小化解析时间 ，并将单个页面的负荷保持在较低的水平。另一方面，打包仍然很重要。首先，压缩将获益。在压缩大文件的过程中，借助目录重用的特点，达到优化性能的目的，而小的单独的文件则不会。有标准的工作来解决这个问题，但现在还远远不够。其次，浏览器还没有为这种工作流优化。例如，Chrome 将触发进程间通信（IPCs），与资源的数量成线性关系，因此页面中如果包含数以百计的资源将会造成浏览器性能损失。 你的服务和 CDNs 支持 HTTP/2 吗？ 不同的服务和 CDNs 可能对 HTTP/2 的支持情况不一样，但是可以使用TLS 来查看你的可选服务，或者快速的查看你的服务的性能以及你想要其支持的特性。 TLS工具功能如下： Is TLS Fast Yet? 允许你检查你转换到 HTTP/2 时你的服务器和 CDN 的选项。 是否启动了 OCSP stapling？ 通过在你的服务上启动 OCSP stapling，你可以加速 TLS 握手。在线证书状态协议（OCSP）的提出是为了替代证书注销列表（CRL）协议。两个协议都是用于检查一个 SSL 证书是否已被撤回。但是，OCSP 协议不需要浏览器花时间下载然后在列表中搜索认证信息，因此减少了握手时间。 你是否已采用了 IPv6？ 因为 IPv4 即将用完以及主要的移动网络正在迅速采用 IPv6（美国已经达到50% 的 IPv6 使用阈值），将你的 DNS 更新到 IPv6 以应对未来是一个好的想法。只要确保在网络上提供双栈支持，就可以让 IPv6 和 IPv4 同时运行。毕竟，IPv6 不是向后兼容的。研究显示，也是正因为 IPv6 自带 NDP 以及路由优化，所以才能够让网站的载入速度提升10%到15%。 你使用（针对 HTTP 响应头压缩的）HPACK 压缩算法了吗？ 如果你使用 HTTP/2，请再次检查，确保您的服务针对 HTTP 响应头部实现 HPACK 压缩以减少不必要的开销。由于 HTTP/2 服务相对较新，它们可能不完全支持该规范，HPACK 就是一个例子。可以使用 H2spec 这个伟大的（如果技术上很详细）工具来检查。HPACK作品。 H2spec (View large version (Image source)H2spec (超大图 (图片来源) 务必保证服务器的安全性 所有实现了 HTTP/2 的浏览器都在 TLS 上运行的大背景下，如果你遇到以下问题： 浏览器中出现安全警告 页面上的某些元素不起作用。 那么，你需要 仔细检查那些与安全相关的 HTTP 头部，看是否设置正确 使用一些工具来排除已知漏洞， 检查你的证书看是否失效 确保所有外部插件和跟踪脚本通过 HTTPS 加载，不允许跨站点脚本 正确设置 HTTP 中的 strict-transport-security和 content-security-policy请求头。 是否使用了 service workers 来缓存以及用作网络回退？ 没有什么网络性能优化能快过用户机器上的本地缓存。如果你的网站运行在 HTTPS 上，那么请参考使用 “Service Workers 的实用指南”。使用 service worker 中缓存静态资源并存储离线资源（甚至离线页面）的目的，而且还会教你如何从用户的设备里面拿数据，也就是说，你现在是不需要通过网络的方式去请求之前的数据。同时，参考Jake 的 Offline Cookbook 和 Udacity 免费课程“离线 Web 应用程序”。浏览器支持？如上所述，它得到了广泛支持 （Chrome、Firefox、Safari TP、Samsung Internet、Edge 17+），但不管怎么说，它都是网络。它有助于提高性能吗？是的，Service Workers确实会提升性能。 测试和监控 你是了解否在代理浏览器和旧版浏览器中测试过？ 在 Chrome 和 Firefox 中进行测试是不够的。你应该去了解你的网站在代理浏览器和旧版浏览器中是如何工作的。例如，UC 浏览器和 Opera Mini，这些浏览器 在亚洲有大量的市场份额 （达到 35%）。在你感兴趣的国家测量平均网络速度从而避免在未来发现“大惊喜”。测试网络节流，并仿真一个高 DPI 设备。BrowserStack 很不错，但也要在实际设备上测试。 k6 可以让你像写单元测试一样编写性能测试用例。 是否启用了持续监控？ 有一个WebPagetest私人的实例总是有利于快速和无限的测试。但是，一个带有自动警报的连续监视工具将会给您提供更详细的性能描述。设置您自己的用户计时标记来度量和监视特定的业务度量。同时，考虑添加自动化性能回归警报来监控随着时间而发生的变化。使用 RUM 解决方案来监视性能随时间的变化。对于自动化的类单元测试的负载测试工具，您可以使用 k6 脚本 API。此外，可以了解下 SpeedTracker、Lighthouse 和 Calibre。 速效方案这个列表非常全面，完成所有的优化可能需要很长时间。所以，如果你只有一个小时的时间来进行重大的改进，你会怎么做？让我们把这一切归结为10个低挂的水果。显然，在你开始之前和完成之后，测量结果，包括开始渲染时间以及在 3G 和电缆连接下的速度指数。 测量实际环境的体验并设定适当的目标。一个好的目标是：第一次有意义的绘制 &lt; 1 s，速度指数 &lt; 1250，在慢速的 3G 网络上的交互 &lt; 5s，对于重复访问，TTI &lt; 2s。优化渲染开始时间和交互时间。 为您的主模板准备关键的 CSS，并将其包含在页面的 &lt;head&gt; 中。（你的预算是 14 KB）。对于 CSS/JS，文件大小不超过 170 KB gzipped（解压后 0.8-1 MB）。 延迟加载尽可能多的脚本，包括您自己的和第三方的脚本——特别是社交媒体按钮、视频播放器和耗时的 JavaScript 脚本。 添加资源提示，使用 dns-lookup、preconnect、prefetch 和 preload 加速传输。 分离 web 字体，并以异步方式加载它们（或切换到系统字体）。 优化图像，并在重要页面（例如登录页面）中考虑使用 WebP。 检查 HTTP 缓存头和安全头是否设置正确。 在服务器上启用 Brotli 或 Zopfli 压缩。（如果做不到，不要忘记启用 Gzip 压缩。） 如果 HTTP/2 可用，启用 HPACK 压缩并开启混合内容警告监控。如果您正在运行 LTS，也可以启用 OCSP stapling。 在 service worker 缓存中尽可能多的缓存资产，如字体、样式、JavaScript 和图像。清单下载（PDF, Apple Pages）记住了这个清单，您就已经为任何类型的前端性能项目做好了准备。请随意下载该清单的打印版PDF，以及一个可编辑的苹果页面文档，以定制您需要的清单： Download the checklist PDF (PDF, 0.129 MB) Download the checklist in Apple Pages (.pages, 0.236 MB) 如果你需要其他选择，你也可以参考 Rublic 的前端清单和 Jon Yablonski 的“设计师的 Web 性能清单”。 动身吧一些优化可能超出了您的工作或预算范围，或者由于需要处理遗留代码而显得过度滥用。没问题！使用这个清单作为一个通用（并且希望是全面的）指南，并创建适用于你的环境的你自己的问题清单。但最重要的是，测试和权衡您自己的项目，以在优化前确定问题。祝大家 2018 年的性能大涨！非常感谢 Guy Podjarny, Yoav Weiss, Addy Osmani, Artem Denysov, Denys Mishunov, Ilya Pukhalski, Jeremy Wagner, Colin Bendell, Mark Zeman, Patrick Meenan, Leonardo Losoviz, Andy Davies, Rachel Andrew, Anselm Hannemann, Patrick Hamann, Andy Davies, Tim Kadlec, Rey Bango, Matthias Ott, Mariana Peralta, Philipp Tellis, Ryan Townsend, Mohamed Hussain S H, Jacob Groß, Tim Swalling, Bob Visser, Kev Adamson, Aleksey Kulikov and Rodney Rehm 对这篇文章的校对，同样也感谢我们出色的社区，分享了他们在性能优化工作中学习到的技术和经验，供大家使用。你们真正的非常了不起！ 作者：sunshine小小倩链接：https://juejin.im/post/5a966bd16fb9a0635172a50a来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
  </entry>
  <entry>
    <title><![CDATA[PWA]]></title>
    <url>%2F2019%2F11%2F11%2Fyuque%2FPWA%2F</url>
    <content type="text"><![CDATA[Service Worker 全面进阶 链接PWA PWA入门：手把手教你制作一个PWA应用 PWA官网 ReactPWA]]></content>
  </entry>
  <entry>
    <title><![CDATA[html5 API]]></title>
    <url>%2F2019%2F11%2F08%2Fyuque%2Fhtml5%20API%2F</url>
    <content type="text"><![CDATA[http://www.html5plus.org/doc/zh_cn/webview.html#plus.webview.WebviewStyle]]></content>
  </entry>
  <entry>
    <title><![CDATA[react新特性新尝试]]></title>
    <url>%2F2019%2F11%2F08%2Fyuque%2Freact%E6%96%B0%E7%89%B9%E6%80%A7%E6%96%B0%E5%B0%9D%E8%AF%95%2F</url>
    <content type="text"><![CDATA[react精华之Suspense 带来的异步操作革命 适用于纯函数 可以不依赖生命周期函数]]></content>
  </entry>
  <entry>
    <title><![CDATA[2019年了，整理了N个实用案例帮你快速迁移到React Hooks]]></title>
    <url>%2F2019%2F11%2F08%2Fyuque%2F2019%E5%B9%B4%E4%BA%86%EF%BC%8C%E6%95%B4%E7%90%86%E4%BA%86N%E4%B8%AA%E5%AE%9E%E7%94%A8%E6%A1%88%E4%BE%8B%E5%B8%AE%E4%BD%A0%E5%BF%AB%E9%80%9F%E8%BF%81%E7%A7%BB%E5%88%B0React%20Hooks%2F</url>
    <content type="text"><![CDATA[在React Conf 2018宣布React Hooks后，我第一时间开始尝试使用React Hooks，现在新项目基本不写Class组件了。对我来说，它确实让我的开发效率提高了很多，改变了已有的组件开发思维和模式.我在React组件设计实践总结04 - 组件的思维中已经总结过React Hooks的意义，以及一些应用场景。那这篇文章就完全是介绍React Hooks的应用实例，列举了我使用React Hooks的一些实践。 希望通过这些案例，可以帮助你快速熟练，并迁移到React Hooks开发模式. 文章篇幅很长，建议收藏不看, 至少看看目录吧 把之前文章整理的React Hooks应用场景总结拿过来, 本文基本按照这个范围进行组织: 如果你想要了解React Hooks的原理可以阅读这些文章: React hooks: not magic, just arrays 从Preact中了解组件和hooks基本原理 目录索引 1. 组件状态 1-1 useSetState 模拟传统的setState 1-2 useReducer Redux风格状态管理 1-3 useForceUpdate 强制重新渲染 1-4 useStorage 简化localStorage存取 1-5 useRefState 引用state的最新值 1-5-1 每次重新渲染都创建闭包会影响效率吗? 1-6 useRefProps 引用最新的Props 1-7 useInstance ‘实例’变量存取 1-9 usePrevious 获取上一次渲染的值 1-10 useImmer 简化不可变数据操作 1-11 封装’工具Hooks’简化State的操作 1-11-1 useToggle 开关 1-11-2 useArray 简化数组状态操作 2. 模拟生命周期函数 2-1 useOnMount 模拟componentDidMount 2-2 useOnUnmount 模拟componentWillUnmount 2-3 useOnUpdate 模拟componentDidUpdate 3. 事件处理 3-1 useChange 简化onChange表单双向绑定 3-2 useBind 绑定回调参数 3-3 自定义事件封装 3-3-1 useActive 3-3-2 useTouch 手势事件封装 3-3-3 useDraggable 拖拽事件封装 3-3-4 react-events 面向未来的高级事件封装 3-4 useSubscription 通用事件源订阅 3-5 useObservable Hooks和RxJS优雅的结合(rxjs-hooks) 3-6 useEventEmitter 对接eventEmitter 4. Context的妙用 4-1 useTheme 主题配置 4-2 unstated 简单状态管理器 4-3 useI18n 国际化 4-4 useRouter 简化路由状态的访问 4-5 react-hook-form Hooks和表单能擦出什么火花? 5. 副作用封装 5-1 useTimeout 超时修改状态 5-2 useOnlineStatus 监听在线状态 6. 副作用衍生 6-1 useTitle 设置文档title 6-2 useDebounce 6-3 useThrottle 7. 简化业务逻辑 7-1 usePromise 封装异步请求 7-2 usePromiseEffect 自动进行异步请求 7-3 useInfiniteList 实现无限加载列表 7-4 usePoll 用hook实现轮询 7-5 业务逻辑抽离 8. 开脑洞 8-1 useScript: Hooks + Suspend = ❤️ 8-2 useModal 模态框数据流管理 React Hooks 技术地图 总结 1. 组件状态React提供了一个很基本的组件状态设置Hook: 12const [state, setState] = useState(initialState);复制代码 useState返回一个state，以及更新state的函数. setState可以接受一个新的值，会触发组件重新渲染. React会确保setState函数是稳定的，不会在组件重新渲染时改变。下面的useReducer的dispatch函数、useRef的current属性也一样。这就意味着setState、dispatch、ref.current, 可以安全地在useEffect、useMemo、 useCallback中引用 1-1 useSetState 模拟传统的setStateuseState和Class组件的setState不太一样.Class组件的state属性一般是一个对象，调用setState时，会浅拷贝到state属性, 并触发更新, 比如: 123456789101112class MyComp extends React.Component &#123; state = &#123; name: '_sx_', age: 10 &#125; handleIncrementAge = () =&gt; &#123; // 只更新age this.setState(&#123;age: this.state.age + 1&#125;) &#125; // ...&#125;复制代码 而useState会直接覆盖state值。为了实现和setState一样的效果, 可以这样子做: 1234567891011const initialState = &#123;name: 'sx', age: 10&#125;const MyComp: FC = props =&gt; &#123; const [state, setState] = useState(initialState) const handleIncrementAge = useCallback(() =&gt; &#123; // setState方法支持接收一个函数，通过这个函数可以获取最新的state值 // 然后使用...操作符实现对象浅拷贝 setState((prevState) =&gt; (&#123;...preState, age: prevState.age + 1&#125;) ) &#125;, []) // ...&#125;复制代码 Ok，现在把它封装成通用的hooks，在其他组件中复用。这时候就体现出来Hooks强大的逻辑抽象能力：Hooks 旨在让组件的内部逻辑组织成可复用的更小单元，这些单元各自维护一部分组件‘状态和逻辑’看看我们的useSetState, 我会使用Typescript进行代码编写: 123456789101112131415161718192021222324252627282930function useSetState&lt;S extends object&gt;( initalState: S | (() =&gt; S),): [S, (state: Partial&lt;S&gt; | ((state: S) =&gt; Partial&lt;S&gt;)) =&gt; void] &#123; const [_state, _setState] = useState&lt;S&gt;(initalState) const setState = useCallback((state: Partial&lt;S&gt; | ((state: S) =&gt; Partial&lt;S&gt;)) =&gt; &#123; _setState((prev: S) =&gt; &#123; let nextState = state if (typeof state === 'function') &#123; nextState = state(prev) &#125; return &#123; ...prev, ...nextState &#125; &#125;) &#125;, []) return [_state, setState]&#125;// ------// EXAMPLE// ------export default function UseSetState() &#123; const [state, setState] = useSetState&lt;&#123; name: string; age: number &#125;&gt;(&#123; name: 'sx', age: 1 &#125;) const incrementAge = () =&gt; &#123; setState(prev =&gt; (&#123; age: prev.age + 1 &#125;)) &#125; return ( &lt;div onClick=&#123;incrementAge&#125;&gt; &#123;state.name&#125;: &#123;state.age&#125; &lt;/div&gt; )&#125;复制代码 hooks命名以use为前缀 ⤴️回到顶部 1-2 useReducer Redux风格状态管理如果组件状态比较复杂，推荐使用useReducer来管理状态。如果你熟悉Redux，会很习惯这种方式。 123456789101112131415161718192021222324252627282930// 定义初始状态const initialState = &#123;count: 0&#125;;// 定义Reducer// ruducer接受当前state，以及一个用户操作，返回一个'新'的statefunction reducer(state, action) &#123; switch (action.type) &#123; case 'increment': return &#123;count: state.count + 1&#125;; case 'decrement': return &#123;count: state.count - 1&#125;; default: throw new Error(); &#125;&#125;// --------// EXAMPLE// --------function Counter() &#123; // 返回state，以及dispatch函数 // dispatch函数可以触发reducer执行，给reducer传递指令和载荷 const [state, dispatch] = useReducer(reducer, initialState); return ( &lt;&gt; Count: &#123;state.count&#125; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: 'increment'&#125;)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: 'decrement'&#125;)&#125;&gt;-&lt;/button&gt; &lt;/&gt; );&#125;复制代码 了解更多reducer的思想可以参考Redux文档 ⤴️回到顶部 1-3 useForceUpdate 强制重新渲染Class组件可以通过forceUpdate实例方法来触发强制重新渲染。使用useState也可以模拟相同的效果： 1234567891011121314151617export default function useForceUpdate() &#123; const [, setValue] = useState(0) return useCallback(() =&gt; &#123; // 递增state值，强制React进行重新渲染 setValue(val =&gt; (val + 1) % (Number.MAX_SAFE_INTEGER - 1)) &#125;, [])&#125;// -------// EXAMPLE// -------function ForceUpdate() &#123; const forceUpdate = useForceUpdate() useEffect(() =&gt; &#123; somethingChange(forceUpdate) &#125;, [])&#125;复制代码 ⤴️回到顶部 1-4 useStorage 简化localStorage存取通过自定义Hooks，可以将状态代理到其他数据源，比如localStorage。 下面案例展示如果使用Hooks封装和简化localStorage的存取: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import &#123; useState, useCallback, Dispatch, SetStateAction &#125; from 'react'export default function useStorage&lt;T&gt;( key: string, // 默认值 defaultValue?: T | (() =&gt; T), // 是否在窗口关闭后保持数据 keepOnWindowClosed: boolean = true,): [T | undefined, Dispatch&lt;SetStateAction&lt;T&gt;&gt;, () =&gt; void] &#123; const storage = keepOnWindowClosed ? localStorage : sessionStorage // 尝试从Storage恢复值 const getStorageValue = () =&gt; &#123; try &#123; const storageValue = storage.getItem(key) if (storageValue != null) &#123; return JSON.parse(storageValue) &#125; else if (defaultValue) &#123; // 设置默认值 const value = typeof defaultValue === 'function' ? (defaultValue as () =&gt; T)() : defaultValue storage.setItem(key, JSON.stringify(value)) return value &#125; &#125; catch (err) &#123; console.warn(`useStorage 无法获取$&#123;key&#125;: `, err) &#125; return undefined &#125; const [value, setValue] = useState&lt;T | undefined&gt;(getStorageValue) // 更新组件状态并保存到Storage const save = useCallback&lt;Dispatch&lt;SetStateAction&lt;T&gt;&gt;&gt;(value =&gt; &#123; setValue(prev =&gt; &#123; const finalValue = typeof value === 'function' ? (value as (prev: T | undefined) =&gt; T)(prev) : value storage.setItem(key, JSON.stringify(finalValue)) return finalValue &#125;) &#125;, []) // 移除状态 const clear = useCallback(() =&gt; &#123; storage.removeItem(key) setValue(undefined) &#125;, []) return [value, save, clear]&#125;// --------// EXAMPLE// --------function Demo() &#123; // 保存登录状态 const [use, setUser, clearUser] = useStorage('user') const handleLogin = (user) =&gt; &#123; setUser(user) &#125; const handleLogout = () =&gt; &#123; clearUser() &#125; // ....&#125;复制代码 ⤴️回到顶部 1-5 useRefState 引用state的最新值上图是今年六月份VueConf，尤雨溪的Slide截图，他对比了Vue最新的FunctionBase API和React Hook. 它指出React Hooks有很多问题: 每个Hooks在组件每次渲染时都执行。也就是说每次渲染都要重新创建闭包和对象 需要理解闭包变量 内容回调/对象会导致纯组件props比对失效, 导致组件永远更新 闭包变量问题是你掌握React Hooks过程中的重要一关。闭包问题是指什么呢？举个简单的例子, Counter: 12345678function Counter() &#123; const [count, setCount] = useState(0) const handleIncr = () =&gt; &#123; setCount(count + 1) &#125; return (&lt;div&gt;&#123;count&#125;: &lt;ComplexButton onClick=&#123;handleIncr&#125;&gt;increment&lt;/ComplexButton&gt;&lt;/div&gt;)&#125;复制代码 假设ComplexButton是一个非常复杂的组件，每一次点击它，我们会递增count，从而触发组将重新渲染。因为Counter每次渲染都会重新生成handleIncr，所以也会导致ComplexButton重新渲染，不管ComplexButton使用了PureComponent还是使用React.memo包装。 为了解决这个问题，React也提供了一个useCallback Hook, 用来‘缓存’函数, 保持回调的不变性. 比如我们可以这样使用: 12345678function Counter() &#123; const [count, setCount] = useState(0) const handleIncr = useCallback(() =&gt; &#123; setCount(count + 1) &#125;, []) return (&lt;div&gt;&#123;count&#125;: &lt;ComplexButton onClick=&#123;handleIncr&#125;&gt;increment&lt;/ComplexButton&gt;&lt;/div&gt;)&#125;复制代码 上面的代码是有bug的，不过怎么点击，count会一直显示为1！再仔细阅读useCallback的文档，useCallback支持第二个参数，当这些值变动时更新缓存的函数, useCallback的内部逻辑大概是这样的： 12345678910let memoFn, memoArgsfunction useCallback(fn, args) &#123; // 如果变动则更新缓存函数 if (!isEqual(memoArgs, args)) &#123; memoArgs = args return (memoFn = fn) &#125; return memoFn&#125;复制代码 Ok, 现在理解一下为什么会一直显示1？ 首次渲染时缓存了闭包，这时候闭包捕获的count值是0。在后续的重新渲染中，因为useCallback第二个参数指定的值没有变动，handleIncr闭包会永远被缓存。这就解释了为什么每次点击，count只能为1.解决办法也很简单，让我们在count变动时，让useCallback更新缓存函数: 12345678function Counter() &#123; const [count, setCount] = useState(0) const handleIncr = useCallback(() =&gt; &#123; setCount(count + 1) &#125;, [count]) return (&lt;div&gt;&#123;count&#125;: &lt;ComplexButton onClick=&#123;handleIncr&#125;&gt;increment&lt;/ComplexButton&gt;&lt;/div&gt;)&#125;复制代码 如果useCallback依赖很多值，你的代码可能是这样的：useCallback(fn, [a, b, c, d, e]). 反正我是无法接受这种代码的，很容易遗漏, 而且可维护性很差，尽管通过ESLint插件可以检查这些问题**。 其实通过useRef Hook，可以让我们像Class组件一样保存一些‘实例变量’, React会保证useRef返回值的稳定性，我们可以在组件任何地方安全地引用ref。基于这个原理，我们尝试封装一个useRefState, 它在useState的基础上扩展了一个返回值，用于获取state的最新值: 123456789101112131415161718192021222324import &#123; useState, useRef, useCallback, Dispatch, SetStateAction, MutableRefObject &#125; from 'react'function useRefState(initialState) &#123; const ins = useRef() const [state, setState] = useState(() =&gt; &#123; // 初始化 const value = typeof initialState === 'function' ? initialState() : initialState ins.current = value return value &#125;) const setValue = useCallback(value =&gt; &#123; if (typeof value === 'function') &#123; setState(prevState =&gt; &#123; const finalValue = value(prevState) ins.current = finalValue return finalValue &#125;) &#125; else &#123; ins.current = value setState(value) &#125; &#125;, []) return [state, setValue, ins]&#125;复制代码 使用示例: 1234567891011121314function Counter() &#123; const [count, setCount, countRef] = useRefState(0) const handleIncr = useCallback(() =&gt; &#123; setCount(countRef.current + 1) &#125;, []) useEffect(() =&gt; &#123; return () =&gt; &#123; // 在组件卸载时保存当前的count saveCount(countRef.current) &#125; &#125;, []) return (&lt;div&gt;&#123;count&#125;: &lt;ComplexButton onClick=&#123;handleIncr&#125;&gt;increment&lt;/ComplexButton&gt;&lt;/div&gt;)&#125;复制代码 useEffect、useMemo和useCallback一样存在闭包变量问题，它们和useCallback一个支持指定第二个参数，当这个参数变化时执行副作用。 ⤴️回到顶部 1-5-1 每次重新渲染都创建闭包会影响效率吗?函数组件和Class组件不一样的是，函数组件将所有状态和逻辑都放到一个函数中, 每一次重新渲染会重复创建大量的闭包、对象。而传统的Class组件的render函数则要简洁很多，一般只放置JSX渲染逻辑。相比大家都跟我一样，会怀疑函数组件的性能问题我们看看官方是怎么回应的： 我在SegmentFault的react function组件与class组件性能问题也进行了详细的回答, 结论是: 目前而言，实现同样的功能，类组件和函数组件的效率是不相上下的。但是函数组件是未来，而且还有优化空间，React团队会继续优化它。而类组件会逐渐退出历史 为了提高函数组件的性能，可以在这些地方做一些优化: 能否将函数提取为静态的 12345678910111213141516171819// 1️⃣例如将不依赖于组件状态的回调抽取为静态方法const goback = () =&gt; &#123; history.go(-1)&#125;function Demo() &#123; //const goback = () =&gt; &#123; // history.go(-1) //&#125; return &lt;button onClick=&#123;goback&#125;&gt;back&lt;/button&gt;&#125;// 2️⃣ 抽离useState的初始化函数const returnEmptyObject = () =&gt; Object.create(null)const returnEmptyArray = () =&gt; []function Demo() &#123; const [state, setState] = useState(returnEmptyObject) const [arr, setArr] = useState(returnEmptyArray) // ...&#125;复制代码 简化组件的复杂度，动静分离 再拆分更细粒度的组件，这些组件使用React.memo缓存 ⤴️回到顶部 1-6 useRefProps 引用最新的Props现实项目中也有很多这种场景: 我们想在组件的任何地方获取最新的props值，这个同样可以通过useRef来实现： 123456789101112131415161718192021export default function useRefProps&lt;T&gt;(props: T) &#123; const ref = useRef&lt;T&gt;(props) // 每次重新渲染设置值 ref.current = props return ref&#125;// ---------// EXAMPLE// ---------function MyButton(props) &#123; const propsRef = useRefProps(props) // 永久不变的事件处理器 const handleClick = useCallback(() =&gt; &#123; const &#123; onClick &#125; = propsRef.current if (onClick) &#123; onClick() &#125; &#125;, []) return &lt;ComplexButton onClick=&#123;handleClick&#125;&gt;&lt;/ComplexButton&gt;&#125;复制代码 ⤴️回到顶部 1-7 useInstance ‘实例’变量存取1234567891011121314151617181920212223242526272829303132333435363738function isFunction&lt;T&gt;(initial?: T | (() =&gt; T)): initial is () =&gt; T &#123; return typeof initial === 'function'&#125;function useInstance&lt;T extends &#123;&#125;&gt;(initial?: T | (() =&gt; T)) &#123; const instance = useRef&lt;T&gt;() // 初始化 if (instance.current == null) &#123; if (initial) &#123; instance.current = isFunction(initial) ? initial() : initial &#125; else &#123; instance.current = &#123;&#125; as T &#125; &#125; return instance.current&#125;// ---------// EXAMPLE// ---------function Demo() &#123; const inst = useInstance(&#123; count: 1 &#125;) const update = useForceUpdate() useEffect(() =&gt; &#123; const timer = setInterval(() =&gt; &#123; // 像类组件一样，进行‘实例变量’存储 // 在函数组件的任意地方引用 // 只不过更新这些数据不会触发组件的重新渲染 inst.count++ &#125;, 1000) return () =&gt; clearInterval(timer) &#125;, []) return ( &lt;div&gt; count: &#123;inst.count&#125; &lt;button onClick=&#123;update&#125;&gt;刷新&lt;/button&gt; &lt;/div&gt; )&#125;复制代码 注意不要滥用 ⤴️回到顶部 1-9 usePrevious 获取上一次渲染的值在Class组件中，我们经常会在shouldComponentUpdate或componentDidUpdate这类生命周期方法中对props或state进行比对，来决定做某些事情，例如重新发起请求、监听事件等等.Hooks中我们可以使用useEffect或useMemo来响应状态变化，进行状态或副作用衍生. 所以上述比对的场景在Hooks中很少见。但也不是不可能，React官方案例中就有一个usePrevious: 1234567891011121314function usePrevious(value) &#123; const ref = useRef(); // useEffect会在完成这次'渲染'之后执行 useEffect(() =&gt; &#123; ref.current = value; &#125;); return ref.current;&#125;// --------// EXAMPLE// --------const calculation = count * 100;const prevCalculation = usePrevious(calculation);复制代码 ⤴️回到顶部 1-10 useImmer 简化不可变数据操作这个案例来源于use-immer, 结合immer.js和Hooks来简化不可变数据操作, 看看代码示例: 123456789101112131415const [person, updatePerson] = useImmer(&#123; name: "Michel", age: 33&#125;);function updateName(name) &#123; updatePerson(draft =&gt; &#123; draft.name = name; &#125;);&#125;function becomeOlder() &#123; updatePerson(draft =&gt; &#123; draft.age++; &#125;);&#125;复制代码 实现也非常简单: 12345678910export function useImmer(initialValue) &#123; const [val, updateValue] = useState(initialValue); return [ val, useCallback(updater =&gt; &#123; updateValue(produce(updater)); &#125;, []) ];&#125;复制代码 简洁的Hooks配合简洁的Immer，简直完美 ⤴️回到顶部 1-11 封装’工具Hooks’简化State的操作Hooks只是普通函数，所以可以灵活地自定义。下面举一些例子，利用自定义Hooks来简化常见的数据操作场景 1-11-1 useToggle 开关实现boolean值切换 12345678910111213function useToggle(initialValue?: boolean) &#123; const [value, setValue] = useState(!!initialValue) const toggler = useCallback(() =&gt; setValue(value =&gt; !value), []) return [value, toggler]&#125;// --------// EXAMPLE// --------function Demo() &#123; const [enable, toggleEnable] = useToggle() return &lt;Switch value=&#123;enable&#125; onClick=&#123;toggleEnable&#125;&gt;&lt;/Switch&gt;&#125;复制代码 ⤴️回到顶部 1-11-2 useArray 简化数组状态操作1234567891011121314151617181920212223242526272829303132function useArray&lt;T&gt;(initial?: T[] | (() =&gt; T[]), idKey: string = 'id') &#123; const [value, setValue] = useState(initial || []) return &#123; value, setValue, push: useCallback(a =&gt; setValue(v =&gt; [...v, a]), []), clear: useCallback(() =&gt; setValue(() =&gt; []), []), removeById: useCallback(id =&gt; setValue(arr =&gt; arr.filter(v =&gt; v &amp;&amp; v[idKey] !== id)), []), removeIndex: useCallback( index =&gt; setValue(v =&gt; &#123; v.splice(index, 1) return v &#125;), [], ), &#125;&#125;// ---------// EXAMPLE// ---------function Demo() &#123; const &#123;value, push, removeById&#125; = useArray&lt;&#123;id: number, name: string&#125;&gt;() const handleAdd = useCallback(() =&gt; &#123; push(&#123;id: Math.random(), name: getName()&#125;) &#125;, []) return (&lt;div&gt; &lt;div&gt;&#123;value.map(i =&gt; &lt;span key=&#123;i.id&#125; onClick=&#123;() =&gt; removeById(i.id)&#125;&gt;&#123;i.name&#125;&lt;/span&gt;)&#125;&lt;/div&gt; &lt;button onClick=&#123;handleAdd&#125;&gt;add&lt;/button&gt; &lt;/div&gt;)&#125;复制代码 限于篇幅，其他数据结构, 例如Set、Map, 就不展开介绍了，读者可以自己发挥想象力. ⤴️回到顶部 2. 模拟生命周期函数组件生命周期相关的操作依赖于useEffect Hook. React在函数组件中刻意淡化了组件生命周期的概念，而更关注‘数据的响应’.useEffect名称意图非常明显，就是专门用来管理组件的副作用。和useCallback一样，useEffect支持传递第二个参数，告知React在这些值发生变动时才执行父作用. 原理大概如下: 12345678910111213141516171819202122let memoCallback = &#123;fn: undefined, disposer: undefined&#125;let memoArgsfunction useEffect(fn, args) &#123; // 如果变动则执行副作用 if (args == null || !isEqual(memoArgs, args)) &#123; memoArgs = args memoCallback.fn = fn // 放进队列等待调度执行 pushIntoEffectQueue(memoCallback) &#125;&#125;// 副作用执行// 这个会在组件完成渲染，在布局(layout)和绘制(paint)之后被执行// 如果是useLayoutEffect, 执行的时机会更早一些function queueExecute(callback) &#123; // 先执行清理函数 if (callback.disposer) &#123; callback.disposer() &#125; callback.disposer = callback.fn()&#125;复制代码 关于useEffect官网有详尽的描述; Dan Abramov也写了一篇useEffect 完整指南, 推荐👍。 ⤴️回到顶部 2-1 useOnMount 模拟componentDidMount123456789101112131415161718export default function useOnMount(fn: Function) &#123; useEffect(() =&gt; &#123; fn() &#125;, []) // 第二个参数设置为[], 表示不必对任何数据， 所以只在首次渲染时调用&#125;// ---------// EXAMPLE// ---------function Demo() &#123; useOnMount(async () =&gt; &#123; try &#123; await loadList() &#125; catch &#123; // log &#125; &#125;)&#125;复制代码 如果需要在挂载/状态更新时请求一些资源、并且需要在卸载时释放这些资源，还是推荐使用useEffect，因为这些逻辑最好放在一起, 方便维护和理解: 12345678910// 但是useEffect传入的函数不支持async/await(返回Promise)useEffect(() =&gt; &#123; // 请求资源 const subscription = props.source.subscribe(); // 释放资源 return () =&gt; &#123; subscription.unsubscribe(); &#125;;&#125;, []);复制代码 ⤴️回到顶部 2-2 useOnUnmount 模拟componentWillUnmount12345678export default function useOnUnmount(fn: Function) &#123; useEffect(() =&gt; &#123; return () =&gt; &#123; fn() &#125; &#125;, [])&#125;复制代码 ⤴️回到顶部 2-3 useOnUpdate 模拟componentDidUpdate12345678910111213141516171819202122function useOnUpdate(fn: () =&gt; void, dep?: any[]) &#123; const ref = useRef(&#123; fn, mounted: false &#125;) ref.current.fn = fn useEffect(() =&gt; &#123; // 首次渲染不执行 if (!ref.current.mounted) &#123; ref.current.mounted = true &#125; else &#123; ref.current.fn() &#125; &#125;, dep)&#125;// -----------// EXAMPLE// -----------function Demo(props) &#123; useOnUpdate(() =&gt; &#123; dosomethingwith(props.a) &#125;, [props.a]) return &lt;div&gt;...&lt;/div&gt;&#125;复制代码 其他生命周期函数的模拟: shouldComponentUpdate - React.memo包裹组件 componentDidCatch - 暂不支持 ⤴️回到顶部 3. 事件处理 3-1 useChange 简化onChange表单双向绑定表单值的双向绑定在项目中非常常见，通常我们的代码是这样的: 12345678function Demo() &#123; const [value, setValue] = useState('') const handleChange = useCallback&lt;React.ChangeEventHandler&lt;HTMLInputElement&gt;&gt;(evt =&gt; &#123; setValue(evt.target.value) &#125;, []) return &lt;input value=&#123;value&#125; onChange=&#123;handleChange&#125; /&gt;&#125;复制代码 如果需要维护多个表单，这种代码就会变得难以接受。幸好有Hooks，我们可以简化这些代码: 123456789101112131415161718192021222324252627282930313233function useChange&lt;S&gt;(initial?: S | (() =&gt; S)) &#123; const [value, setValue] = useState&lt;S | undefined&gt;(initial) const onChange = useCallback(e =&gt; setValue(e.target.value), []) return &#123; value, setValue, onChange, // 绑定到原生事件 bindEvent: &#123; onChange, value, &#125;, // 绑定到自定义组件 bind: &#123; onChange: setValue, value, &#125;, &#125;&#125;// ----------// EXAMPLE// ----------function Demo() &#123; const userName = useChange('') const password = useChange('') return ( &lt;div&gt; &lt;input &#123;...userName.bindEvent&#125; /&gt; &lt;input type="password" &#123;...password.bindEvent&#125; /&gt; &lt;/div&gt; )&#125;复制代码 ⤴️回到顶部 3-2 useBind 绑定回调参数绑定一些回调参数，并利用useMemo给下级传递一个缓存的回调, 避免重新渲染: 123456789101112131415161718function useBind(fn?: (...args: any[]) =&gt; any, ...args: any[]): (...args: any[]) =&gt; any &#123; return useMemo(() =&gt; &#123;fn &amp;&amp; fn.bind(null, ...args)&#125;, args)&#125;// ---------// EXAMPLE// ---------function Demo(props) &#123; const &#123;id, onClick&#125; = props const handleClick = useBind(onClick, id) return &lt;ComplexComponent onClick=&#123;handleClick&#125;&gt;&lt;/ComplexComponent&gt;&#125;// 等价于function Demo(props) &#123; const &#123;id, onClick&#125; = props const handleClick = useCallback(() =&gt; onClick(id), [id]) return &lt;ComplexComponent onClick=&#123;handleClick&#125;&gt;&lt;/ComplexComponent&gt;&#125;复制代码 ⤴️回到顶部 3-3 自定义事件封装Hooks也可以用于封装一些高级事件或者简化事件的处理，比如拖拽、手势、鼠标Active/Hover等等； 3-3-1 useActive举个简单的例子, useActive, 在鼠标按下时设置状态为true，鼠标释放时恢复为false: 1234567891011121314151617181920212223242526272829303132function useActive(refEl: React.RefObject&lt;HTMLElement&gt;) &#123; const [value, setValue] = useState(false) useEffect(() =&gt; &#123; const handleMouseDown = () =&gt; &#123; setValue(true) &#125; const handleMouseUp = () =&gt; &#123; setValue(false) &#125; // DOM 事件监听 if (refEl &amp;&amp; refEl.current) &#123; refEl.current.addEventListener('mousedown', handleMouseDown) refEl.current.addEventListener('mouseup', handleMouseUp) &#125; return () =&gt; &#123; if (refEl &amp;&amp; refEl.current) &#123; refEl.current.removeEventListener('mousedown', handleMouseDown) refEl.current.removeEventListener('mouseup', handleMouseUp) &#125; &#125; &#125;, []) return value&#125;// ----------// EXAMPLE// ----------function Demo() &#123; const elRef = useRef(null) const active = useActive(inputRef) return (&lt;div ref=&#123;elRef&#125;&gt;&#123;active ? "Active" : "Nop"&#125;&lt;/div&gt;)&#125;复制代码 ⤴️回到顶部 3-3-2 useTouch 手势事件封装更复杂的自定义事件, 例如手势。限于篇幅就不列举它们的实现代码，我们可以看看它们的Demo: 12345678910function Demo() &#123; const &#123;ref&#125; = useTouch(&#123; onTap: () =&gt; &#123; /* 点击 */ &#125;, onLongTap: () =&gt; &#123; /* 长按 */ &#125;, onRotate: () =&gt; &#123;/* 旋转 */&#125; // ... &#125;) return (&lt;div className="box" ref=&#123;ref&#125;&gt;&lt;/div&gt;)&#125;复制代码 useTouch的实现可以参考useTouch.ts ⤴️回到顶部 3-3-3 useDraggable 拖拽事件封装拖拽也是一个典型的自定义事件, 下面这个例子来源于这里 1234567891011121314151617181920212223242526272829303132333435363738394041424344function useDraggable(ref: React.RefObject&lt;HTMLElement&gt;) &#123; const [&#123; dx, dy &#125;, setOffset] = useState(&#123; dx: 0, dy: 0 &#125;) useEffect(() =&gt; &#123; if (ref.current == null) &#123; throw new Error(`[useDraggable] ref未注册到组件中`) &#125; const el = ref.current const handleMouseDown = (event: MouseEvent) =&gt; &#123; const startX = event.pageX - dx const startY = event.pageY - dy const handleMouseMove = (event: MouseEvent) =&gt; &#123; const newDx = event.pageX - startX const newDy = event.pageY - startY setOffset(&#123; dx: newDx, dy: newDy &#125;) &#125; document.addEventListener('mousemove', handleMouseMove) document.addEventListener( 'mouseup', () =&gt; &#123; document.removeEventListener('mousemove', handleMouseMove) &#125;, &#123; once: true &#125;, ) &#125; el.addEventListener('mousedown', handleMouseDown) return () =&gt; &#123; el.removeEventListener('mousedown', handleMouseDown) &#125; &#125;, [dx, dy]) useEffect(() =&gt; &#123; if (ref.current) &#123; ref.current.style.transform = `translate3d($&#123;dx&#125;px, $&#123;dy&#125;px, 0)` &#125; &#125;, [dx, dy])&#125;// -----------// EXAMPLE// -----------function Demo() &#123; const el = useRef(); useDraggable(el); return &lt;div className="box" ref=&#123;el&#125; /&gt;&#125;复制代码 可运行例子 ⤴️回到顶部 3-3-4 react-events 面向未来的高级事件封装我在&lt;谈谈React事件机制和未来(react-events)&gt;介绍了React-Events这个实验性的API。当这个API成熟后，我们可以基于它来实现更优雅的高级事件的封装： 1234567891011121314import &#123; PressResponder, usePressListener &#125; from 'react-events/press';const Button = (props) =&gt; ( const listener = usePressListener(&#123; // ⚛️ 通过hooks创建Responder onPressStart, onPress, onPressEnd, &#125;) return ( &lt;div listeners=&#123;listener&#125;&gt; &#123;subtrees&#125; &lt;/div&gt; ););复制代码 ⤴️回到顶部 3-4 useSubscription 通用事件源订阅React官方维护了一个use-subscription包，支持使用Hooks的形式来监听事件源. 事件源可以是DOM事件、RxJS的Observable等等.先来看看使用示例: 12345678910111213141516171819// 监听rxjs behaviorSubjectfunction Demo() &#123; const subscription = useMemo( () =&gt; (&#123; getCurrentValue: () =&gt; behaviorSubject.getValue(), subscribe: callback =&gt; &#123; // 当事件触发时调用callback const subscription = behaviorSubject.subscribe(callback); // 和useEffect一样，返回一个函数来取消订阅 return () =&gt; subscription.unsubscribe(); &#125; &#125;), // 在behaviorSubject变化后重新订阅 [behaviorSubject] ); const value = useSubscription(subscription); return &lt;div&gt;&#123;value&#125;&lt;/div&gt;&#125;复制代码 现在来看看实现: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546export function useSubscription&lt;T&gt;(&#123; getCurrentValue, subscribe,&#125;: &#123; // 获取当前值 getCurrentValue?: () =&gt; T // 用于订阅事件源 subscribe: (callback: Function) =&gt; () =&gt; void&#125;): T &#123; const [state, setState] = useState(() =&gt; (&#123; getCurrentValue, subscribe, value: getCurrentValue() &#125;)) let valueToReturn = state.value // 更新getCurrentValue和subscribe if (state.getCurrentValue !== getCurrentValue || state.subscribe !== subscribe) &#123; valueToReturn = getCurrentValue() setState(&#123; getCurrentValue, subscribe, value: valueToReturn &#125;) &#125; useEffect(() =&gt; &#123; let didUnsubscribe = false const checkForUpdates = () =&gt; &#123; if (didUnsubscribe) &#123; return &#125; setState(prevState =&gt; &#123; // 检查getCurrentValue和subscribe是否变动 // setState时如果返回值没有变化，则不会触发重新渲染 if (prevState.getCurrentValue !== getCurrentValue || prevState.subscribe !== subscribe) &#123; return prevState &#125; // 值没变动 const value = getCurrentValue() if (prevState.value === value) &#123; return prevState &#125; return &#123; ...prevState, value &#125; &#125;) &#125; const unsubscribe = subscribe(checkForUpdates) checkForUpdates() return () =&gt; &#123; didUnsubscribe = true unsubscribe() &#125; &#125;, [getCurrentValue, subscribe]) return valueToReturn&#125;复制代码 实现也不复杂，甚至可以说有点啰嗦. ⤴️回到顶部 3-5 useObservable Hooks和RxJS优雅的结合(rxjs-hooks)如果要配合RxJS使用，LeetCode团队封装了一个rxjs-hooks库，用起来则要优雅很多, 非常推荐: 123456789function App() &#123; const value = useObservable(() =&gt; interval(500).pipe(map((val) =&gt; val * 3))); return ( &lt;div className="App"&gt; &lt;h1&gt;Incremental number: &#123;value&#125;&lt;/h1&gt; &lt;/div&gt; );&#125;复制代码 ⤴️回到顶部 3-6 useEventEmitter 对接eventEmitter我在React组件设计实践总结04 - 组件的思维这篇文章里面提过：自定义 hook 和函数组件的代码结构基本一致, 所以有时候hooks 写着写着原来越像组件, 组件写着写着越像 hooks. 我觉得可以认为组件就是一种特殊的 hook, 只不过它输出 Virtual DOMHooks跟组件一样，是一个逻辑和状态的聚合单元。可以维护自己的状态、有自己的’生命周期’.useEventEmitter就是一个典型的例子，可以独立地维护和释放自己的资源: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const functionReturnObject = () =&gt; (&#123;&#125;)const functionReturnArray = () =&gt; []export function useEventEmitter(emmiter: EventEmitter) &#123; const disposers = useRef&lt;Function[]&gt;([]) const listeners = useRef&lt;&#123; [name: string]: Function &#125;&gt;(&#123;&#125;) const on = useCallback(&lt;P&gt;(name: string, cb: (data: P) =&gt; void) =&gt; &#123; if (!(name in listeners.current)) &#123; const call = (...args: any[]) =&gt; &#123; const fn = listeners.current[name] if (fn) &#123; fn(...args) &#125; &#125; // 监听eventEmitter emmiter.on(name, call) disposers.current.push(() =&gt; &#123; emmiter.off(name, call) &#125;) &#125; listeners.current[name] = cb &#125;, []) useEffect(() =&gt; &#123; // 资源释放 return () =&gt; &#123; disposers.current.forEach(i =&gt; i()) &#125; &#125;, []) return &#123; on, emit: emmiter.emit, &#125;&#125;// ---------// EXAMPLE// ---------function Demo() &#123; const &#123; on, emit &#125; = useEventEmitter(eventBus) // 事件监听 on('someEvent', () =&gt; &#123; // do something &#125;) const handleClick = useCallback(() =&gt; &#123; // 事件触发 emit('anotherEvent', someData) &#125;, []) return (&lt;div onClick=&#123;handleClick&#125;&gt;...&lt;/div&gt;)&#125;复制代码 更多脑洞： use-socketio ⤴️回到顶部 4. Context的妙用通过useContext可以方便地引用Context。不过需要注意的是如果上级Context.Provider的value变化，使用useContext的组件就会被强制重新渲染。 4-1 useTheme 主题配置原本需要使用高阶组件注入或Context.Consumer获取的Context值，现在变得非常简洁： 123456789101112/** * 传统方式 */// 通过高阶组件注入withTheme(MyComponent)// 获取利用Context.Consumerconst MyComponentWithTheme = (props) =&gt; &#123; return (&lt;ThemeContext.Consumer&gt; &#123;value =&gt; &lt;MyComponent theme=&#123;value&#125; &#123;...props&#125;&gt;&lt;/MyComponent&gt;&#125; &lt;/ThemeContext.Consumer&gt;)&#125;复制代码 Hooks方式 123456789101112131415161718192021222324252627282930import React, &#123; useContext, FC &#125; from 'react'const ThemeContext = React.createContext&lt;object&gt;(&#123;&#125;)export const ThemeProvider: FC&lt;&#123; theme: object &#125;&gt; = props =&gt; &#123; return &lt;ThemeContext.Provider value=&#123;props.theme&#125;&gt;&#123;props.children&#125;&lt;/ThemeContext.Provider&gt;&#125;export function useTheme&lt;T extends object&gt;(): T &#123; return useContext(ThemeContext)&#125;// ---------// EXAMPLE// ---------const theme = &#123; primary: '#000', secondary: '#444',&#125;function App() &#123; return ( &lt;ThemeProvider theme=&#123;theme&#125;&gt; &lt;div&gt;...&lt;/div&gt; &lt;/ThemeProvider&gt; )&#125;const Button: FC = props =&gt; &#123; const t = useTheme&lt;typeof theme&gt;() const style = &#123; color: t.primary, &#125; return &lt;button style=&#123;style&#125;&gt;&#123;props.children&#125;&lt;/button&gt;&#125;复制代码 ⤴️回到顶部 4-2 unstated 简单状态管理器Hooks + Context 也可以用于实现简单的状态管理。我在React组件设计实践总结05 - 状态管理就提到过unstated-next， 这个库只有主体代码十几行，利用了React本身的机制来实现状态管理.先来看看使用示例 1234567891011121314151617181920import React, &#123; useState &#125; from "react"import &#123; createContainer &#125; from "unstated-next"function useCounter(initialState = 0) &#123; let [count, setCount] = useState(initialState) let decrement = () =&gt; setCount(count - 1) let increment = () =&gt; setCount(count + 1) return &#123; count, decrement, increment &#125;&#125;let Counter = createContainer(useCounter)function CounterDisplay() &#123; let counter = Counter.useContainer() return ( &lt;div&gt; &lt;button onClick=&#123;counter.decrement&#125;&gt;-&lt;/button&gt; &lt;span&gt;&#123;counter.count&#125;&lt;/span&gt; &lt;button onClick=&#123;counter.increment&#125;&gt;+&lt;/button&gt; &lt;/div&gt; )&#125;复制代码 看看它的源码: 123456789101112131415161718192021export function createContainer(useHook) &#123; // 只是创建一个Context let Context = React.createContext(null) function Provider(props) &#123; let value = useHook(props.initialState) return &lt;Context.Provider value=&#123;value&#125;&gt;&#123;props.children&#125;&lt;/Context.Provider&gt; &#125; function useContainer() &#123; // 只是使用useContext let value = React.useContext(Context) if (value === null) &#123; throw new Error("Component must be wrapped with &lt;Container.Provider&gt;") &#125; return value &#125; return &#123; Provider, useContainer &#125;&#125;export function useContainer(container) &#123; return container.useContainer()&#125;复制代码 到这里，你会说，我靠，就这样? 这个库感觉啥事情都没干啊?需要注意的是, Context不是万金油，它作为状态管理有一个比较致命的缺陷，我在浅谈React性能优化的方向文章中也提到了这一点:它是可以穿透React.memo或者shouldComponentUpdate的比对的，也就是说，一旦 Context 的 Value 变动，所有依赖该 Context 的组件会全部 forceUpdate所以如果你打算使用Context作为状态管理，一定要注意规避这一点. 它可能会导致组件频繁重新渲染. 其他状态管理方案: easy-peasy react-hooks-global-state ⤴️回到顶部 4-3 useI18n 国际化I18n是另一个Context的典型使用场景。react-intl和react-i18next都与时俱进，推出了自己的Hook API, 基本上原本使用高阶组件(HOC)实现的功能都可以用Hooks代替，让代码变得更加简洁: 1234567import React from 'react';import &#123; useTranslation &#125; from 'react-i18next';export function MyComponent() &#123; const &#123; t, i18n &#125; = useTranslation(); return &lt;p&gt;&#123;t('my translated text')&#125;&lt;/p&gt;&#125;复制代码 ⤴️回到顶部 4-4 useRouter 简化路由状态的访问React Hooks 推出已经接近一年，ReactRouter竟然还没有正式推出Hook API。不过它们也提上了计划 —— The Future of React Router and @reach/router，5.X版本会推出Hook API. 我们暂时先看看一些代码示例: 1234567891011121314function SomeComponent() &#123; // 访问路由变量 const &#123; userId &#125; = useParams() // ...&#125;function usePageViews() &#123; // 访问location对象 // 原本对于非路由组件，需要访问路由信息需要通过withRouter高阶组件注入 const &#123; location &#125; = useLocation() useEffect(() =&gt; &#123; ga('send', 'pageview', location.pathname) &#125;, [location])&#125;复制代码 再等等吧! ⤴️回到顶部 4-5 react-hook-form Hooks和表单能擦出什么火花?react-hook-form是Hooks+Form的典型案例，比较符合我理想中的表单管理方式: 12345678910111213141516171819202122import React from 'react';import useForm from 'react-hook-form';function App() &#123; const &#123; register, handleSubmit, errors &#125; = useForm(); // initialise the hook const onSubmit = data =&gt; &#123; console.log(data); &#125;; // callback when validation pass return ( &lt;form onSubmit=&#123;handleSubmit(onSubmit)&#125;&gt; &lt;input name="firstname" ref=&#123;register&#125; /&gt; &#123;/* register an input */&#125; &lt;input name="lastname" ref=&#123;register(&#123; required: true &#125;)&#125; /&gt; &#123;errors.lastname &amp;&amp; 'Last name is required.'&#125; &lt;input name="age" ref=&#123;register(&#123; pattern: /\d+/ &#125;)&#125; /&gt; &#123;errors.age &amp;&amp; 'Please enter number for age.'&#125; &lt;input type="submit" /&gt; &lt;/form&gt; );&#125;复制代码 ⤴️回到顶部 5. 副作用封装我们可以利用Hooks来封装或监听组件外部的副作用，将它们转换为组件的状态。 5-1 useTimeout 超时修改状态useTimeout由用户触发，在指定时间后恢复状态. 比如可以用于’短期禁用’按钮, 避免重复点击: 123456789function Demo() &#123; const [disabled, start] = useTimeout(5000) const handleClick = () =&gt; &#123; start() dosomething() &#125; return &lt;Button onClick=&#123;handleClick&#125; disabled=&#123;disabled&#125;&gt;点我&lt;/Button&gt;&#125;复制代码 实现: 1234567891011121314151617function useTimeout(ms: string) &#123; const [ready, setReady] = useState(false) const timerRef = useRef&lt;number&gt;() const start = useCallback(() =&gt; &#123; clearTimeout(timerRef.current) setReady(true) timerRef.current = setTimeout(() =&gt; &#123; setReady(false) &#125;, ms) &#125;, [ms]) const stop = useCallback(() =&gt; &#123; clearTimeout(timeRef.current) &#125;, []) useOnUnmount(stop) return [ready, start, stop]&#125;复制代码 ⤴️回到顶部 5-2 useOnlineStatus 监听在线状态副作用封装一个比较典型的案例就是监听主机的在线状态： 1234567891011121314151617181920212223242526272829function getOnlineStatus() &#123; return typeof navigator.onLine === 'boolean' ? navigator.onLine : true&#125;function useOnlineStatus() &#123; let [onlineStatus, setOnlineStatus] = useState(getOnlineStatus()) useEffect(() =&gt; &#123; const online = () =&gt; setOnlineStatus(true) const offline = () =&gt; setOnlineStatus(false) window.addEventListener('online', online) window.addEventListener('offline', offline) return () =&gt; &#123; window.removeEventListener('online', online) window.removeEventListener('offline', offline) &#125; &#125;, []) return onlineStatus&#125;// --------// EXAMPLE// --------function Demo() &#123; let onlineStatus = useOnlineStatus(); return ( &lt;div&gt; &lt;h1&gt;网络状态: &#123;onlineStatus ? "在线" : "离线"&#125;&lt;/h1&gt; &lt;/div&gt; );&#125;复制代码 还有很多案例, 这里就不一一列举，读者可以自己尝试去实现，比如: useDeviceOrientation 监听设备方向 useGeolocation 监听GPS坐标变化 useScrollPosition 监听滚动位置 useMotion 监听设备运动 useMediaDevice 监听媒体设备 useDarkMode 夜间模式监听 useKeyBindings 监听快捷键 …. ⤴️回到顶部 6. 副作用衍生和副作用封装相反，副作用衍生是指当组件状态变化时，衍生出其他副作用. 两者的方向是相反的.副作用衍生主要会用到useEffect，使用useEffect来响应状态的变化. 6-1 useTitle 设置文档titleuseTitle是最简单的，当给定的值变化时，更新document.title 12345678910111213function useTitle(t: string) &#123; useEffect(() =&gt; &#123; document.title = t &#125;, [t])&#125;// --------// EXAMPLE// --------function Demo(props) &#123; useTitle(props.isEdit ? '编辑' : '新增') // ....&#125;复制代码 ⤴️回到顶部 6-2 useDebounce再来个复杂一点的，useDebounce：当某些状态变化时，它会延迟执行某些操作： 12345678910111213141516171819202122232425262728293031323334function useDebounce(fn: () =&gt; void, args?: any[], ms: number = 100, skipMount?: boolean) &#123; const mounted = useRef(false) useEffect(() =&gt; &#123; // 跳过挂载执行 if (skipMount &amp;&amp; !mounted.current) &#123; mounted.current = true return undefined &#125; const timer = setTimeout(fn, ms) return () =&gt; &#123; // 如果args变化，先清除计时器 clearTimeout(timer) &#125; &#125;, args)&#125;// -----------// EXAMPLE// -----------const returnEmptyArray = () =&gt; []function Demo() &#123; const [query, setQuery] = useState('') const [list, setList] = useState(returnEmptyArray) // 搜索 const handleSearch = async () =&gt; &#123; setList(await fetchList(query)) &#125; // 当query变化时执行搜索 useDebounce(handleSearch, [query], 500) return (&lt;div&gt; &lt;SearchBar value=&#123;query&#125; onChange=&#123;setQuery&#125; /&gt; &lt;Result list=&#123;list&#125;&gt;&lt;/Result&gt; &lt;/div&gt;)&#125;复制代码 ⤴️回到顶部 6-3 useThrottle同理可以实现useThrottle, 下面的例子来源于react-use: 1234567891011121314151617181920212223242526272829const useThrottleFn = &lt;T&gt;(fn: (...args: any[]) =&gt; T, ms: number = 200, args: any[]) =&gt; &#123; const [state, setState] = useState&lt;T&gt;(null as any); const timeout = useRef&lt;any&gt;(null); const nextArgs = useRef(null) as any; const hasNextArgs = useRef(false) as any; useEffect(() =&gt; &#123; if (!timeout.current) &#123; setState(fn(...args)); const timeoutCallback = () =&gt; &#123; if (hasNextArgs.current) &#123; hasNextArgs.current = false; setState(fn(...nextArgs.current)); timeout.current = setTimeout(timeoutCallback, ms); &#125; else &#123; timeout.current = null; &#125; &#125;; timeout.current = setTimeout(timeoutCallback, ms); &#125; else &#123; nextArgs.current = args; hasNextArgs.current = true; &#125; &#125;, args); useOnUnmount(() =&gt; &#123; clearTimeout(timeout.current); &#125;); return state;&#125;;复制代码 ⤴️回到顶部 7. 简化业务逻辑80%的程序员80%的时间在写业务代码. 有了Hooks，React开发者如获至宝. 组件的代码可以变得很精简，且这些Hooks可以方便地在组件之间复用: 下面介绍，如何利用Hooks来简化业务代码 7-1 usePromise 封装异步请求第一个例子，试试封装一下promise，简化简单页面异步请求的流程. 先来看看usePromise的使用示例，我理想中的usePromise应该长这样: 1234567891011121314151617function Demo() &#123; const list = usePromise(async (id: string) =&gt; &#123; return fetchList(id) &#125;) return (&lt;div&gt; &#123;/* 触发请求 */&#125; &lt;button onClick=&#123;() =&gt; list.callIgnoreError('myId')&#125;&gt;Get List&lt;/button&gt; &#123;/* 错误信息展示和重试 */&#125; &#123;!!list.error &amp;&amp; &lt;ErrorMessage error=&#123;list.error&#125; retry=&#123;list.retry&#125;&gt;加载失败:&lt;/ErrorMessage&gt;&#125; &#123;/* 加载状态 */&#125; &lt;Loader loading=&#123;list.loading&#125;&gt; &#123;/* 请求结果 */&#125; &lt;Result value=&#123;list.value&#125;&gt;&lt;/Result&gt; &lt;/Loader&gt; &lt;/div&gt;)&#125;复制代码 usePromise是我用得比较多的一个Hooks，所以我把它完整的代码，包括Typescript注解都贴出来，供大家参考参考: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105// 定义usePromise的返回值export interface Res&lt;T, S&gt; &#123; loading: boolean error?: Error value?: S setValue: (v: S) =&gt; void call: T callIgnoreError: T reset: () =&gt; void retry: () =&gt; void&#125;// 定义usePromise 参数export interface UsePromiseOptions &#123; // 如果promise正在加载中则跳过，默认为true skipOnLoading?: boolean&#125;// 👇 下面是一堆Typescript函数重载声明，为了方便Typescript推断泛型变量. 小白可以跳过function usePromise&lt;T&gt;(action: () =&gt; Promise&lt;T&gt;, option?: UsePromiseOptions): Res&lt;() =&gt; Promise&lt;T&gt;, T&gt;function usePromise&lt;T, A&gt;(action: (arg0: A) =&gt; Promise&lt;T&gt;, option?: UsePromiseOptions): Res&lt;(arg0: A) =&gt; Promise&lt;T&gt;, T&gt;function usePromise&lt;T, A, B&gt;(action: (arg0: A, arg1: B) =&gt; Promise&lt;T&gt;, option?: UsePromiseOptions): Res&lt;(arg0: A, arg1: B) =&gt; Promise&lt;T&gt;, T&gt;function usePromise&lt;T, A, B, C&gt;( action: (arg0: A, arg1: B, arg2: C) =&gt; Promise&lt;T&gt;, option?: UsePromiseOptions): Res&lt;(arg0: A, arg1: B, arg2: C) =&gt; Promise&lt;T&gt;, T&gt;function usePromise&lt;T, A, B, C, D&gt;(action: (arg0: A, arg1: B, arg2: C, arg3: D) =&gt; Promise&lt;T&gt;, option?: UsePromiseOptions): Res&lt;(arg0: A, arg1: B, arg2: C, arg3: D) =&gt; Promise&lt;T&gt;, T&gt;function usePromise(action: (...args: any[]) =&gt; Promise&lt;any&gt;, option?: UsePromiseOptions): Res&lt;(...args: any) =&gt; Promise&lt;any&gt;, any&gt;// 👆 上面是一堆Typescript函数重载声明，可以跳过/** * 接受一个action，用于执行异步操作 */function usePromise( action: (...args: any[]) =&gt; Promise&lt;any&gt;, option: UsePromiseOptions = &#123; skipOnLoading: true &#125;,): Res&lt;(...args: any) =&gt; Promise&lt;any&gt;, any&gt; &#123; const actionRef = useRefProps(action) const optionRef = useRefProps(option) const [loading, setLoading, loadingRef] = useRefState(false) const taskIdRef = useRef&lt;number&gt;() const argsRef = useRef&lt;any[]&gt;() const [value, setValue] = useState() const [error, setError, errorRef] = useRefState&lt;Error | undefined&gt;() const caller = useCallback(async (...args: any[]) =&gt; &#123; argsRef.current = args if (loadingRef.current &amp;&amp; optionRef.current.skipOnLoading) &#123; return &#125; const taskId = getUid() taskIdRef.current = taskId // 已经有新的任务在执行了，什么都不做 const shouldContinue = () =&gt; &#123; if (taskId !== taskIdRef.current) &#123; return false &#125; return true &#125; try &#123; setLoading(true) setError(undefined) const res = await actionRef.current(...args) if (!shouldContinue()) return setValue(res) return res &#125; catch (err) &#123; if (shouldContinue()) &#123; setError(err) &#125; throw err &#125; finally &#123; if (shouldContinue()) &#123; setLoading(false) &#125; &#125; &#125;, []) // 不抛出异常 const callIgnoreError = useCallback( async (...args: any[]) =&gt; &#123; try &#123; return await caller(...args) &#125; catch &#123; // ignore &#125; &#125;, [caller], ) const reset = useCallback(() =&gt; &#123; setLoading(false) setValue(undefined) setError(undefined) &#125;, []) // 失败后重试 const retry = useCallback(() =&gt; &#123; if (argsRef.current &amp;&amp; errorRef.current) &#123; return callIgnoreError(...argsRef.current) &#125; throw new Error(`not call yet`) &#125;, []) return &#123; loading, error, call: caller, callIgnoreError, value, setValue, reset, retry, &#125;&#125;复制代码 ⤴️回到顶部 7-2 usePromiseEffect 自动进行异步请求很多时候，我们是在组件一挂载或者某些状态变化时自动进行一步请求的，我们在usePromise的基础上，结合useEffect来实现自动调用: 123456789101112131415161718192021// 为了缩短篇幅，这里就不考虑跟usePromise一样的函数重载了export default function usePromiseEffect&lt;T&gt;( action: (...args: any[]) =&gt; Promise&lt;T&gt;, args?: any[],) &#123; const prom = usePromise(action) // 使用useEffect监听参数变动并执行 useEffect(() =&gt; &#123; prom.callIgnoreError.apply(null, args) &#125;, args) return prom&#125;// ---------// EXAMPLE// ---------function Demo(props) &#123; // 在挂载或者id变化时请求 const list = usePromiseEffect((id) =&gt; fetchById(id), [id]) // 同usePromise&#125;复制代码 看到这里，应该惊叹Hooks的抽象能力了吧！😸 ⤴️回到顶部 7-3 useInfiniteList 实现无限加载列表这里例子在之前的文章中也提及过 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950export default function useInfiniteList&lt;T&gt;( fn: (params: &#123; offset: number; pageSize: number; list: T[] &#125;) =&gt; Promise&lt;T[]&gt;, pageSize: number = 20,) &#123; const [list, setList] = useState&lt;T[]&gt;(returnEmptyArray) // 列表是否全部加载完毕 const [hasMore, setHasMore, hasMoreRef] = useRefState(true) // 列表是否为空 const [empty, setEmpty] = useState(false) const promise = usePromise(() =&gt; fn(&#123; list, offset: list.length, pageSize &#125;)) const load = useCallback(async () =&gt; &#123; if (!hasMoreRef.current) &#123; return &#125; const res = await promise.call() if (res.length &lt; pageSize) &#123; setHasMore(false) &#125; setList(l =&gt; &#123; if (res.length === 0 &amp;&amp; l.length === 0) &#123; setEmpty(true) &#125; return [...l, ...res] &#125;) &#125;, []) // 清空列表 const clean = useCallback(() =&gt; &#123; setList([]) setHasMore(true) setEmpty(false) promise.reset() &#125;, []) // 刷新列表 const refresh = useCallback(() =&gt; &#123; clean() setTimeout(() =&gt; &#123; load() &#125;) &#125;, []) return &#123; list, hasMore, empty, loading: promise.loading, error: promise.error, load, refresh, &#125;&#125;复制代码 使用示例: 1234567891011121314151617181920212223242526272829interface Item &#123; id: number name: string&#125;function App() &#123; const &#123; load, list, hasMore, refresh &#125; = useInfiniteList&lt;Item&gt;(async (&#123; offset, pageSize &#125;) =&gt; &#123; const list = [] for (let i = offset; i &lt; offset + pageSize; i++) &#123; if (i === 200) &#123; break &#125; list.push(&#123; id: i, name: `$&#123;i&#125;-----` &#125;) &#125; return list &#125;) useEffect(() =&gt; &#123; load() &#125;, []) return ( &lt;div className="App"&gt; &lt;button onClick=&#123;refresh&#125;&gt;Refresh&lt;/button&gt; &#123;list.map(i =&gt; ( &lt;div key=&#123;i.id&#125;&gt;&#123;i.name&#125;&lt;/div&gt; ))&#125; &#123;hasMore ? &lt;button onClick=&#123;load&#125;&gt;Load more&lt;/button&gt; : &lt;div&gt;No more&lt;/div&gt;&#125; &lt;/div&gt; )&#125;复制代码 ⤴️回到顶部 7-4 usePoll 用hook实现轮询下面使用Hooks实现一个定时轮询器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677export interface UsePollOptions&lt;T&gt; &#123; /** * 决定是否要继续轮询 * @param arg 上一次轮询返回的值 */ condition: (arg?: T, error?: Error) =&gt; Promise&lt;boolean&gt; /** * 轮询操作 */ poller: () =&gt; Promise&lt;T&gt; onError?: (err: Error) =&gt; void /** * 轮询间隔. 默认 5000 */ duration?: number /** * 监听的参数，当这些参数变化时，重新检查轮询条件，决定是否继续轮询 */ args?: any[] /** * 是否立即轮询 */ immediately?: boolean&#125;/** * 实现页面轮询机制 */export default function usePoll&lt;T = any&gt;(options: UsePollOptions&lt;T&gt;) &#123; const [polling, setPolling, pollingRef] = useRefState(false) const [error, setError] = useState&lt;Error&gt;() const state = useInstance&lt;&#123; timer?: number; unmounted?: boolean &#125;&gt;(&#123;&#125;) const optionsRef = useRefProps(options) const poll = useCallback(async (immediate?: boolean) =&gt; &#123; // 已经卸载，或其他轮询器正在轮询 if (state.unmounted || pollingRef.current) return setPolling(true) state.timer = window.setTimeout( async () =&gt; &#123; if (state.unmounted) return try &#123; let res: T | undefined let error: Error | undefined setError(undefined) try &#123; res = await optionsRef.current.poller() &#125; catch (err) &#123; error = err setError(err) if (optionsRef.current.onError) &#123; optionsRef.current.onError(err) &#125; &#125; // 准备下一次轮询 if (!state.unmounted &amp;&amp; (await optionsRef.current.condition(res, error))) &#123; setTimeout(poll) &#125; &#125; finally &#123; !state.unmounted &amp;&amp; setPolling(false) &#125; &#125;, immediate ? 0 : optionsRef.current.duration || 5000, ) &#125;, []) useOnUpdate( async () =&gt; &#123; if (await optionsRef.current.condition()) poll(options.immediately) &#125;, options.args || [], false, ) useOnUnmount(() =&gt; &#123; state.unmounted = true clearTimeout(state.timer) &#125;) return &#123; polling, error &#125;&#125;复制代码 使用示例: 1234567891011121314151617function Demo() &#123; const [query, setQuery] = useState(') const [result, setResult] = useState&lt;Result&gt;() usePoll(&#123; poller: await() =&gt; &#123; const res =await fetch(query) setResult(res) return res &#125; condition: async () =&gt; &#123; return query !== '' &#125;, args: [query], &#125;) // ...&#125;复制代码 ⤴️回到顶部 7-5 业务逻辑抽离通过上面的案例可以看到, Hooks非常适合用于抽离重复的业务逻辑。在React组件设计实践总结02 - 组件的组织介绍了容器组件和展示组件分离，Hooks时代，我们可以自然地将逻辑都放置到Hooks中，实现逻辑和视图的分离。抽离的后业务逻辑可以复用于不同的’展示平台’, 例如 web 版和 native 版: 12345Login/ useLogin.ts // 将所有逻辑都抽取到Hooks中 index.web.tsx // 只保留视图 index.tsx复制代码 ⤴️回到顶部 8. 开脑洞一些奇奇怪怪的东西，不知道怎么分类。作者想象力非常丰富! 8-1 useScript: Hooks + Suspend = ❤️这个案例来源于the-platform, 使用script标签来加载外部脚本: 123456789101112131415// 注意: 这还是实验性特性import &#123;createResource&#125; from 'react-cache'export const ScriptResource = createResource((src: string) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; const script = document.createElement('script'); script.src = src; script.onload = () =&gt; resolve(script); script.onerror = reject; document.body.appendChild(script); &#125;);&#125;);function useScript(options: &#123; src: string &#125;) &#123; return ScriptResource.read(src);&#125;复制代码 使用示例: 12345678910import &#123; useScript &#125; from 'the-platform';const Example = () =&gt; &#123; useScript(&#123; src: 'bundle.js' &#125;); // ...&#125;;// Suspendfunction App() &#123; return &lt;Suspense fallback=&#123;'loading...'&#125;&gt;&lt;Example&gt;&lt;/Example&gt;&lt;/Suspense&gt;&#125;复制代码 同理还可以实现 useStylesheet 用于加载样式表 fetch-suspense ⤴️回到顶部 8-2 useModal 模态框数据流管理我在React组件设计实践总结04 - 组件的思维也举到一个使用Hooks + Context来巧妙实现模态框管理的例子。先来看看如何使用Context来渲染模态框, 很简单, ModalContext.Provider给下级组件暴露一个render方法，通过这个方法来传递需要渲染的模态框组件和props: 12345678910111213141516171819202122232425262728293031323334353637383940414243// 模态框组件要实现的接口export interface BaseModalProps &#123; visible: boolean onHide: () =&gt; void&#125;interface ModalContextValue &#123; render(Component: React.ComponentType&lt;any&gt;, props: any): void&#125;const Context = React.createContext&lt;ModalContextValue&gt;(&#123; render: () =&gt; &#123; throw new Error("useModal 必须在ModalRenderer 下级") &#125;,&#125;)// 模态框渲染器const ModalRenderer: FC&lt;&#123;&#125;&gt; = props =&gt; &#123; const [modal, setModal] = useState&lt; | &#123; Comp: React.ComponentType&lt;any&gt;; props: any; visible?: boolean &#125; | undefined &gt;() const hide = useCallback(() =&gt; &#123; setModal(prev =&gt; prev &amp;&amp; &#123; ...prev, visible: false &#125;) &#125;, []) // 由下级组件调用，传递需要渲染的组件和props const render = useCallback&lt;ModalContextValue["render"]&gt;((Comp, props) =&gt; &#123; setModal(&#123; Comp, props, visible: true &#125;) &#125;, []) const value = useMemo(() =&gt; (&#123;render&#125;), []) return ( &lt;Context.Provider value=&#123;value&#125;&gt; &#123;props.children&#125; &lt;div className="modal-container"&gt; &#123;/*模态框渲染 */&#125; &#123;!!modal &amp;&amp; React.createElement(modal.Comp, &#123; ...modal.props, visible: modal.visible, onHide: hide, &#125;)&#125; &lt;/div&gt; &lt;/Context.Provider&gt; )&#125;复制代码 再看看Hooks的实现, 也很简单，就是使用useContext来访问ModalContext， 并调用render方法: 123456789101112export function useModal&lt;P extends BaseModalProps&gt;( Modal: React.ComponentType&lt;P&gt;,) &#123; const renderer = useContext(Context) return useCallback( (props: Omit&lt;P, keyof BaseModalProps&gt;) =&gt; &#123; renderer.render(Modal, props || &#123;&#125;) &#125;, [Modal], )&#125;复制代码 应用示例: 12345678910111213141516171819202122const MyModal: FC&lt;BaseModalProps &amp; &#123; a: number &#125;&gt; = props =&gt; &#123; return ( &lt;Modal visible=&#123;props.visible&#125; onOk=&#123;props.onHide&#125; onCancel=&#123;props.onHide&#125;&gt; &#123;props.a&#125; &lt;/Modal&gt; )&#125;const Home: FC&lt;&#123;&#125;&gt; = props =&gt; &#123; const showMyModal = useModal(MyModal) const handleShow = useCallback(() =&gt; &#123; // 显示模态框 showMyModal(&#123; a: 123, &#125;) &#125;, []) return ( &lt;div&gt; showMyModal: &lt;button onClick=&#123;handleShow&#125;&gt;show&lt;/button&gt; &lt;/div&gt; )&#125;复制代码 可运行的完整示例可以看这里 ⤴️回到顶部 React Hooks 技术地图全家桶和Hooks的结合: Redux + Hooks Mobx + Hooks ReactSpring + Hooks Appoll react-i18next react-router Come in soon 一些有趣的Hooks集合: the-platform react-use rehooks/ideas 一起开脑洞 react-hanger Awesome Awesome React Hooks Hooks.Guide useHooks FAQ 官方Hooks FAQ 可以解答大部分的疑问]]></content>
  </entry>
  <entry>
    <title><![CDATA[这可能是最通俗的 React Fiber(时间分片) 打开方式]]></title>
    <url>%2F2019%2F11%2F08%2Fyuque%2F%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%9C%80%E9%80%9A%E4%BF%97%E7%9A%84%20React%20Fiber(%E6%97%B6%E9%97%B4%E5%88%86%E7%89%87)%20%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[写一篇关于 React Fiber 的文章， 这个 Flag 立了很久，这也是今年的目标之一。 最近的在掘金的文章获得很多关注和鼓励，给了我很多动力，所以下定决心好好把它写出来。 我会以最通俗的方式将它讲透, 因此这算是一篇科普式的文章。不管你是使用React、还是Vue，这里面的思想值得学习学习!一年一度的 React 春晚: React Conf 即将到来，不知道今年会不会有什么惊喜，去年是 React Hooks，前年是 React Fiber…我得赶在 React Conf 之前发布这篇文章: 😲 React Fiber 已经出来这么久了， 这文章是老酒装新瓶吧? 对于我来说，通过这篇文章我重新认识了 React Fiber，它不是一个新东西, 它也是老酒装新瓶，不信你就看吧… 🆕 React Fiber 不是一个新的东西，但在前端领域是第一次广为认知的应用。 😦 了解它有啥用? React Fiber 代码很复杂，门槛很高，你不了解它，后面 React 新出的 Killer Feature 你可能就更不能理解了 🤥 我不是升到React v16了吗? 没什么出奇的啊? _真正要体会到 React Fiber 重构效果，可能下个月、可能要等到 v17。v16 只是一个过渡版本，也就是说，现在的React 还是同步渲染的，一直在跳票、不是说今年第二季度就出来了吗_？ 😁 不好意思，一不小心又写得有点长，你就当小说看吧, 代码都是伪代码 以下文章大纲 单处理进程调度: Fiber 不是一个新的东西 类比浏览器JavaScript执行环境 何为 Fiber 1. 一种流程控制原语 2. 一个执行单元 React 的Fiber改造 1. 数据结构的调整 2. 两个阶段的拆分 3. Reconcilation 4. 双缓冲 5. 副作用的收集和提交 ⚠️ 未展开部分 🚧 – 中断和恢复 凌波微步 站在巨人的肩膀上单处理进程调度: Fiber 不是一个新的东西这个黑乎乎的界面应该就是微软的 DOS 操作系统微软 DOS 是一个单任务操作系统, 也称为’单工操作系统‘. 这种操作系统同一个时间只允许运行一个程序. invalid s在《在没有GUI的时代(只有一个文本界面），人们是怎么运行多个程序的？》 的回答中将其称为: ‘一种压根没有任务调度的“残疾”操作系统‘.在这种系统中，你想执行多个任务，只能等待前一个进程退出，然后再载入一个新的进程。直到 Windows 3.x，它才有了真正意义的进程调度器，实现了多进程并发执行。 注意并发和并行不是同一个概念。 现代操作系统都是多任务操作系统. 进程的调度策略如果按照CPU核心数来划分，可以分为单处理器调度和多处理器调度。本文只关注的是单处理器调度，因为它可以类比JavaScript的运行机制。🔴说白了，为了实现进程的并发，操作系统会按照一定的调度策略，将CPU的执行权分配给多个进程，多个进程都有被执行的机会，让它们交替执行，形成一种“同时在运行”假象, 因为CPU速度太快，人类根本感觉不到。实际上在单核的物理环境下同时只能有一个程序在运行。这让我想起了“龙珠”中的分身术(小时候看过，说错了别喷)，实质上是一个人，只不过是他运动速度太快，看起来就像分身了. 这就是所谓的并发(Concurrent)(单处理器)。相比而言, 火影忍者中的分身术，是物理存在的，他们可以真正实现同时处理多个任务，这就是并行(严格地讲这是Master-Slave架构，分身虽然物理存在，但应该没有独立的意志)。所以说🔴并行可以是并发，而并发不一定是并行，两种不能划等号, 并行一般需要物理层面的支持。 关于并发和并行，Go 之父 Rob Pike 有一个非常著名的演讲Concurrency is not parallelism扯远了，接下来进程怎么调度就是教科书的内容了。如果读者在大学认真学过操作系统原理, 你可以很快理解以下几种单处理器进程调度策略(我就随便科普一下，算送的, 如果你很熟悉这块，可以跳过)：0️⃣ 先到先得(First-Come-First-Served, FCFS)这是最简单的调度策略, 简单说就是没有调度。谁先来谁就先执行，执行完毕后就执行下一个。不过如果中间某些进程因为I/O阻塞了，这些进程会挂起移回就绪队列(说白了就是重新排队).FCFS 上面 DOS 的单任务操作系统没有太大的区别。所以非常好理解，因为生活中到处是这样的例子:。 FCFS 对短进程不利。 短进程即执行时间非常短的进程，可以用饭堂排队来比喻: 在饭堂排队打饭的时候，最烦那些一个人打包好好几份的人，这些人就像长进程一样，霸占着CPU资源，后面排队只打一份的人会觉得很吃亏，打一份的人会觉得他们优先级应该更高，毕竟他们花的时间很短，反正你打包那么多份再等一会也是可以的，何必让后面那么多人等这么久… FCFS 对I/O密集不利。I/O密集型进程(这里特指同步I/O)在进行I/O操作时，会阻塞休眠，这会导致进程重新被放入就绪队列，等待下一次被宠幸。 可以类比ZF部门办业务: 假设 CPU 一个窗口、I/O 一个窗口。在CPU窗口好不容易排到你了，这时候发现一个不符合条件或者漏办了, 需要去I/O搞一下，Ok 去 I/O窗口排队，I/O执行完了，到CPU窗口又得重新排队。对于这些丢三落四的人很不公平… 所以 FCFS 这种原始的策略在单处理器进程调度中并不受欢迎。1️⃣ 轮转这是一种基于时钟的抢占策略，这也是抢占策略中最简单的一种: 公平地给每一个进程一定的执行时间，当时间消耗完毕或阻塞，操作系统就会调度其他进程，将执行权抢占过来。 决策模式: 抢占策略相对应的有非抢占策略，非抢占策略指的是让进程运行直到结束、阻塞(如I/O或睡眠)、或者主动让出控制权；抢占策略支持中断正在运行的进程，将主动权掌握在操作系统这里，不过通常开销会比较大。 这种调度策略的要点是确定合适的时间片长度: 太长了，长进程霸占太久资源，其他进程会得不到响应(等待执行时间过长)，这时候就跟上述的 FCFS 没什么区别了; 太短了也不好，因为进程抢占和切换都是需要成本的, 而且成本不低，时间片太短，时间可能都浪费在上下文切换上了，导致进程干不了什么实事。因此时间片的长度最好符合大部分进程完成一次典型交互所需的时间.轮转策略非常容易理解，只不过确定时间片长度需要伤点脑筋；另外和FCFS一样，轮转策略对I/O进程还是不公平。2️⃣ 最短进程优先(Shortest Process Next, SPN)上面说了先到先得策略对短进程不公平，最短进程优先索性就让’最短’的进程优先执行，也就是说: 按照进程的预估执行时间对进程进行优先级排序，先执行完短进程，后执行长进程。这是一种非抢占策略。这样可以让短进程能得到较快的响应。但是怎么获取或者评估进程执行时间呢？一是让程序的提供者提供，这不太靠谱；二是由操作系统来收集进程运行数据，并对它们进程统计分析。例如最简单的是计算它们的平均运行时间。不管怎么说都比上面两种策略要复杂一点。SPN 的缺陷是: 如果系统有大量的短进程，那么长进程可能会饥饿得不到响应。另外因为它不是抢占性策略, 尽管现在短进程可以得到更多的执行机会，但是还是没有解决 FCFS 的问题: 一旦长进程得到CPU资源，得等它执行完，导致后面的进程得不到响应。3️⃣ 最短剩余时间(Shortest Remaining Time, SRT)SRT 进一步优化了SPN，增加了抢占机制。在 SPN 的基础上，当一个进程添加到就绪队列时，操作系统会比较_刚添加的新进程和当前正在执行的老进程_的‘剩余时间’，如果新进程剩余时间更短，新进程就会抢占老进程。相比轮转的抢占，SRT 没有中断处理的开销。但是在 SPN 的基础上，操作系统需要记录进程的历史执行时间，这是新增的开销。另外长进程饥饿问题还是没有解决。4️⃣ 最高响应比优先(HRRN)为了解决长进程饥饿问题，同时提高进程的响应速率。还有一种最高响应比优先的策略，首先了解什么是响应比: 12响应比 = （等待执行时间 + 进程执行时间） / 进程执行时间复制代码 这种策略会选择响应比最高的进程优先执行： 对于短进程来说，因为执行时间很短，分母很小，所以响应比比较高，会被优先执行 对于长进程来说，执行时间长，一开始响应比小，但是随着等待时间增长，它的优先级会越来越高，最终可以被执行 5️⃣ 反馈法SPN、SRT、HRRN都需要对进程时间进行评估和统计，实现比较复杂且需要一定开销。而反馈法采取的是事后反馈的方式。这种策略下: 每个进程一开始都有相同的优先级，每次被抢占(需要配合其他抢占策略使用，如轮转)，优先级就会降低一级。因此通常它会根据优先级划分多个队列。举个例子: 12345队列1队列2...队列N复制代码 新增的任务会推入队列1，队列1会按照轮转策略以一个时间片为单位进行调度。短进程可以很快得到响应，而对于长进程可能一个时间片处理不完，就会被抢占，放入队列2。队列2会在队列1任务清空后被执行，有时候低优先级队列可能会等待很久才被执行，所以一般会给予一定的补偿，例如增加执行时间，所以队列2的轮转时间片长度是2。反馈法仍然可能导致长进程饥饿，所以操作系统可以统计长进程的等待时间，当等待时间超过一定的阈值，可以选择提高它们的优先级。没有一种调度策略是万能的, 它需要考虑很多因素: 响应速率。进程等待被执行的时间 公平性。兼顾短进程、长进程、I/O进程 这两者在某些情况下是对立的，提高了响应，可能会减低公平性，导致饥饿。短进程、长进程、I/O进程之间要取得平衡也非常难。上面这些知识对本文来说已经足够了，现实世界操作系统的进程调度算法比教科书上说的要复杂的多，有兴趣读者可以去研究一下 Linux 相关的进程调度算法，这方面的资料也非常多, 例如《Linux进程调度策略的发展和演变》。 类比浏览器JavaScript执行环境JavaScript 就像单行道JavaScript 是单线程运行的，而且在浏览器环境屁事非常多，它要负责页面的JS解析和执行、绘制、事件处理、静态资源加载和处理, 这些任务可以类比上面’进程‘。 这里特指Javascript 引擎是单线程运行的。 严格来说，Javascript 引擎和页面渲染引擎在同一个渲染线程，GUI 渲染和 Javascript执行 两者是互斥的. 另外异步 I/O 操作底层实际上可能是多线程的在驱动。 图片来源: Rendering Performance它只是一个’JavaScript’，同时只能做一件事情，这个和 DOS 的单任务操作系统一样的，事情只能一件一件的干。要是前面有一个傻叉任务长期霸占CPU，后面什么事情都干不了，浏览器会呈现卡死的状态，这样的用户体验就会非常差。对于’前端框架‘来说，解决这种问题有三个方向: 1️⃣ 优化每个任务，让它有多快就多快。挤压CPU运算量 2️⃣ 快速响应用户，让用户觉得够快，不能阻塞用户的交互 3️⃣ 尝试 Worker 多线程 Vue 选择的是第1️⃣, 因为对于Vue来说，使用模板让它有了很多优化的空间，配合响应式机制可以让Vue可以精确地进行节点更新, 读者可以去看一下今年Vue Conf 尤雨溪的演讲，非常棒!；而 React 选择了2️⃣ 。对于Worker 多线程渲染方案也有人尝试，要保证状态和视图的一致性相当麻烦。React 为什么要引入 Fiber 架构？ 看看下面的火焰图，这是React V15 下面的一个列表渲染资源消耗情况。整个渲染花费了130ms, 🔴在这里面 React 会递归比对VirtualDOM树，找出需要变动的节点，然后同步更新它们, 一气呵成。这个过程 React 称为 Reconcilation(中文可以译为协调).在 Reconcilation 期间，React 会霸占着浏览器资源，一则会导致用户触发的事件得不到响应, 二则会导致掉帧，用户可以感知到这些卡顿。这样说，你可能没办法体会到，通过下面两个图片来体会一下(图片来源于：Dan Abramov 的 Beyond React 16 演讲, 推荐看一下👍. 另外非常感谢淡苍 将一个类似的DEMO 分享在了 CodeSandbox上🎉，大家自行体验):同步模式下的 React:优化后的 Concurrent 模式下的 React:React 的 Reconcilation 是CPU密集型的操作, 它就相当于我们上面说的’长进程‘。所以初衷和进程调度一样，我们要让高优先级的进程或者短进程优先运行，不能让长进程长期霸占资源。所以React 是怎么优化的？ 划重点， 🔴为了给用户制造一种应用很快的’假象’，我们不能让一个程序长期霸占着资源. 你可以将浏览器的渲染、布局、绘制、资源加载(例如HTML解析)、事件响应、脚本执行视作操作系统的’进程’，我们需要通过某些调度策略合理地分配CPU资源，从而提高浏览器的用户响应速率, 同时兼顾任务执行效率。🔴所以 React 通过Fiber 架构，让自己的Reconcilation 过程变成可被中断。 ‘适时’地让出CPU执行权，除了可以让浏览器及时地响应用户的交互，还有其他好处: 与其一次性操作大量 DOM 节点相比, 分批延时对DOM进行操作，可以得到更好的用户体验。这个在《「前端进阶」高性能渲染十万条数据(时间分片)》 以及司徒正美的《React Fiber架构》 都做了相关实验 司徒正美在《React Fiber架构》 也提到：🔴给浏览器一点喘息的机会，他会对代码进行编译优化（JIT）及进行热代码优化，或者对reflow进行修正. 这就是为什么React 需要 Fiber 😏。 何为 Fiber对于 React 来说，Fiber 可以从两个角度理解: 1. 一种流程控制原语Fiber 也称协程、或者纤程。 笔者第一次接触这个概念是在学习 Ruby 的时候，Ruby就将协程称为 Fiber。后来发现很多语言都有类似的机制，例如Lua 的Coroutine, 还有前端开发者比较熟悉的 ES6 新增的Generator。 本文不纠结 Processes, threads, green threads, protothreads, fibers, coroutines: what’s the difference? 🔴 其实协程和线程并不一样，协程本身是没有并发或者并行能力的（需要配合线程），它只是一种控制流程的让出机制。要理解协程，你得和普通函数一起来看, 以Generator为例:普通函数执行的过程中无法被中断和恢复： 12345678const tasks = []function run() &#123; let task while (task = tasks.shift()) &#123; execute(task) &#125;&#125;复制代码 而 Generator 可以: 12345678910111213const tasks = []function * run() &#123; let task while (task = tasks.shift()) &#123; // 🔴 判断是否有高优先级事件需要处理, 有的话让出控制权 if (hasHighPriorityEvent()) &#123; yield &#125; // 处理完高优先级事件后，恢复函数调用栈，继续执行... execute(task) &#125;&#125;复制代码 React Fiber 的思想和协程的概念是契合的: 🔴React 渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染。那么现在你应该有以下疑问: 1️⃣ 浏览器没有抢占的条件, 所以React只能用让出机制? 2️⃣ 怎么确定有高优先任务要处理，即什么时候让出？ 3️⃣ React 那为什么不使用 Generator？ 答1️⃣: 没错, 主动让出机制一是浏览器中没有类似进程的概念，’任务‘之间的界限很模糊，没有上下文，所以不具备中断/恢复的条件。二是没有抢占的机制，我们无法中断一个正在执行的程序。所以我们只能采用类似协程这样控制权让出机制。这个和上文提到的进程调度策略都不同，它有更一个专业的名词：合作式调度(Cooperative Scheduling), 相对应的有抢占式调度(Preemptive Scheduling)这是一种’契约‘调度，要求我们的程序和浏览器紧密结合，互相信任。比如可以由浏览器给我们分配执行时间片(通过requestIdleCallback实现, 下文会介绍)，我们要按照约定在这个时间内执行完毕，并将控制权还给浏览器。这种调度方式很有趣，你会发现这是一种身份的对调，以前我们是老子，想怎么执行就怎么执行，执行多久就执行多久; 现在为了我们共同的用户体验统一了战线, 一切听由浏览器指挥调度，浏览器是老子，我们要跟浏览器申请执行权，而且这个执行权有期限，借了后要按照约定归还给浏览器。当然你超时不还浏览器也拿你没办法 🤷‍… 合作式调度的缺点就在于此，全凭自律，用户要挖大坑，谁都拦不住。 答2️⃣: requestIdleCallback API上面代码示例中的 hasHighPriorityEvent() 在目前浏览器中是无法实现的，我们没办法判断当前是否有更高优先级的任务等待被执行。只能换一种思路，通过超时检查的机制来让出控制权。解决办法是: _确定一个合理的运行时长，然后在合适的检查点检测是否超时(比如每执行一个小任务)，如果超时就停止执行，将控制权交换给浏览器_。举个例子，为了让视图流畅地运行，可以按照人类能感知到最低限度每秒60帧的频率划分时间片，这样每个时间片就是 16ms。其实浏览器提供了相关的接口 —— requestIdleCallback API： 12345window.requestIdleCallback( callback: (dealine: IdleDeadline) =&gt; void, option?: &#123;timeout: number&#125; )复制代码 IdleDeadline的接口如下： 12345interface IdleDealine &#123; didTimeout: boolean // 表示任务执行是否超过约定时间 timeRemaining(): DOMHighResTimeStamp // 任务可供执行的剩余时间&#125;复制代码 单从名字上理解的话, requestIdleCallback的意思是让浏览器在’有空’的时候就执行我们的回调，这个回调会传入一个期限，表示浏览器有多少时间供我们执行, 为了不耽误事，我们最好在这个时间范围内执行完毕。那浏览器什么时候有空？我们先来看一下浏览器在一帧(Frame，可以认为事件循环的一次循环)内可能会做什么事情:你可以打开 Chrome 开发者工具的Performance标签，这里可以详细看到Javascript的每一帧都执行了什么任务(Task), 花费了多少时间。图片来源: 你应该知道的requestIdleCallback浏览器在一帧内可能会做执行下列任务，而且它们的执行顺序基本是固定的: 处理用户输入事件 Javascript执行 requestAnimation 调用 布局 Layout 绘制 Paint 上面说理想的一帧时间是 16ms (1000ms / 60)，如果浏览器处理完上述的任务(布局和绘制之后)，还有盈余时间，浏览器就会调用 requestIdleCallback 的回调。例如但是在浏览器繁忙的时候，可能不会有盈余时间，这时候requestIdleCallback回调可能就不会被执行。 为了避免饿死，可以通过requestIdleCallback的第二个参数指定一个超时时间。 另外不建议在requestIdleCallback中进行DOM操作，因为这可能导致样式重新计算或重新布局(比如操作DOM后马上调用 getBoundingClientRect)，这些时间很难预估的，很有可能导致回调执行超时，从而掉帧。 目前 requestIdleCallback 目前只有Chrome支持。所以目前 React 自己实现了一个。它利用MessageChannel 模拟将回调延迟到’绘制操作’之后执行:简单看一下代码 123456789101112131415161718192021222324252627282930313233const el = document.getElementById('root')const btn = document.getElementById('btn')const ch = new MessageChannel()let pendingCallbacklet startTimelet timeoutch.port2.onmessage = function work() &#123; // 在绘制之后被执行 if (pendingCallback) &#123; const now = performance.now() // 通过now - startTime可以计算出requestAnimationFrame到绘制结束的执行时间 // 通过这些数据来计算剩余时间 // 另外还要处理超时(timeout)，避免任务被饿死 // ... if (hasRemain &amp;&amp; noTimeout) &#123; pendingCallback(deadline) &#125; &#125;&#125;// ...function simpleRequestIdleCallback(callback, timeout) &#123; requestAnimationFrame(function animation() &#123; // 在绘制之前被执行 // 记录开始时间 startTime = performance.now() timeout = timeout dosomething() // 调度回调到绘制结束后执行 pendingCallback = callback ch.port1.postMessage('hello') &#125;)&#125;复制代码 任务优先级上面说了，为了避免任务被饿死，可以设置一个超时时间. 这个超时时间不是死的，低优先级的可以慢慢等待, 高优先级的任务应该率先被执行. 目前 React 预定义了 5 个优先级, 这个我在[《谈谈React事件机制和未来(react-events)》]中也介绍过: Immediate(-1) - 这个优先级的任务会同步执行, 或者说要马上执行且不能中断 UserBlocking(250ms) 这些任务一般是用户交互的结果, 需要即时得到反馈 Normal (5s) 应对哪些不需要立即感受到的任务，例如网络请求 Low (10s) 这些任务可以放后，但是最终应该得到执行. 例如分析通知 Idle (没有超时时间) 一些没有必要做的任务 (e.g. 比如隐藏的内容), 可能会被饿死 答3️⃣: 太麻烦官方在《Fiber Principles: Contributing To Fiber》 也作出了解答。主要有两个原因： Generator 不能在栈中间让出。比如你想在嵌套的函数调用中间让出, 首先你需要将这些函数都包装成Generator，另外这种栈中间的让出处理起来也比较麻烦，难以理解。除了语法开销，现有的生成器实现开销比较大，所以不如不用。 Generator 是有状态的, 很难在中间恢复这些状态。 上面理解可能有出入，建议看一下原文 可能都没看懂，简单就是 React 尝试过用 Generator 实现，后来发现很麻烦，就放弃了。 2. 一个执行单元Fiber的另外一种解读是’纤维‘: 这是一种数据结构或者说执行单元。我们暂且不管这个数据结构长什么样，🔴将它视作一个执行单元，每次执行完一个’执行单元’, React 就会检查现在还剩多少时间，如果没有时间就将控制权让出去.上文说了，React 没有使用 Generator 这些语言/语法层面的让出机制，而是实现了自己的调度让出机制。这个机制就是基于’Fiber‘这个执行单元的，它的过程如下：假设用户调用 setState 更新组件, 这个待更新的任务会先放入队列中, 然后通过 requestIdleCallback 请求浏览器调度： 123updateQueue.push(updateTask);requestIdleCallback(performWork, &#123;timeout&#125;);复制代码 现在浏览器有空闲或者超时了就会调用performWork来执行任务： 123456789101112// 1️⃣ performWork 会拿到一个Deadline，表示剩余时间function performWork(deadline) &#123; // 2️⃣ 循环取出updateQueue中的任务 while (updateQueue.length &gt; 0 &amp;&amp; deadline.timeRemaining() &gt; ENOUGH_TIME) &#123; workLoop(deadline); &#125; // 3️⃣ 如果在本次执行中，未能将所有任务执行完毕，那就再请求浏览器调度 if (updateQueue.length &gt; 0) &#123; requestIdleCallback(performWork); &#125;&#125;复制代码 workLoop 的工作大概猜到了，它会从更新队列(updateQueue)中弹出更新任务来执行，每执行完一个‘执行单元‘，就检查一下剩余时间是否充足，如果充足就进行执行下一个执行单元，反之则停止执行，保存现场，等下一次有执行权时恢复: 1234567891011121314151617181920// 保存当前的处理现场let nextUnitOfWork: Fiber | undefined // 保存下一个需要处理的工作单元let topWork: Fiber | undefined // 保存第一个工作单元function workLoop(deadline: IdleDeadline) &#123; // updateQueue中获取下一个或者恢复上一次中断的执行单元 if (nextUnitOfWork == null) &#123; nextUnitOfWork = topWork = getNextUnitOfWork(); &#125; // 🔴 每执行完一个执行单元，检查一次剩余时间 // 如果被中断，下一次执行还是从 nextUnitOfWork 开始处理 while (nextUnitOfWork &amp;&amp; deadline.timeRemaining() &gt; ENOUGH_TIME) &#123; // 下文我们再看performUnitOfWork nextUnitOfWork = performUnitOfWork(nextUnitOfWork, topWork); &#125; // 提交工作，下文会介绍 if (pendingCommit) &#123; commitAllWork(pendingCommit); &#125;&#125;复制代码 画个流程图吧！ React 的Fiber改造Fiber 的核心内容已经介绍完了，现在来进一步看看React 为 Fiber 架构做了哪些改造, 如果你对这部分内容不感兴趣可以跳过。 1. 数据结构的调整左侧是Virtual DOM，右侧可以看作diff的递归调用栈上文中提到 React 16 之前，Reconcilation 是同步的、递归执行的。也就是说这是基于函数’调用栈‘的Reconcilation算法，因此通常也称它为Stack Reconcilation. 你可以通过这篇文章《从Preact中了解React组件和hooks基本原理》 来回顾一下历史。栈挺好的，代码量少，递归容易理解, 至少比现在的 React Fiber架构好理解😂, 递归非常适合树这种嵌套数据结构的处理。只不过这种依赖于调用栈的方式不能随意中断、也很难被恢复, 不利于异步处理。 这种调用栈，不是程序所能控制的， 如果你要恢复递归现场，可能需要从头开始, 恢复到之前的调用栈。因此首先我们需要对React现有的数据结构进行调整，模拟函数调用栈, 将之前需要递归进行处理的事情分解成增量的执行单元，将递归转换成迭代.React 目前的做法是使用链表, 每个 VirtualDOM 节点内部现在使用 Fiber表示, 它的结构大概如下: 12345678910111213export type Fiber = &#123; // Fiber 类型信息 type: any, // ... // ⚛️ 链表结构 // 指向父节点，或者render该节点的组件 return: Fiber | null, // 指向第一个子节点 child: Fiber | null, // 指向下一个兄弟节点 sibling: Fiber | null,&#125;复制代码 用图片来展示这种关系会更直观一些：使用链表结构只是一个结果，而不是目的，React 开发者一开始的目的是冲着模拟调用栈去的。这个很多关于Fiber 的文章都有提及, 关于调用栈的详细定义参见Wiki： 调用栈最经常被用于存放子程序的返回地址。在调用任何子程序时，主程序都必须暂存子程序运行完毕后应该返回到的地址。因此，如果被调用的子程序还要调用其他的子程序，其自身的返回地址就必须存入调用栈，在其自身运行完毕后再行取回。除了返回地址，还会保存本地变量、函数参数、环境传递(Scope?) React Fiber 也被称为虚拟栈帧(Virtual Stack Frame), 你可以拿它和函数调用栈类比一下, 两者结构非常像: 函数调用栈 Fiber 基本单位 函数 Virtual DOM 节点 输入 函数参数 Props 本地状态 本地变量 State 输出 函数返回值 React Element 下级 嵌套函数调用 子节点(child) 上级引用 返回地址 父节点(return) Fiber 和调用栈帧一样, 保存了节点处理的上下文信息，因为是手动实现的，所以更为可控，我们可以保存在内存中，随时中断和恢复。有了这个数据结构调整，现在可以以迭代的方式来处理这些节点了。来看看 performUnitOfWork 的实现, 它其实就是一个深度优先的遍历： 12345678910111213141516171819202122232425262728/** * @params fiber 当前需要处理的节点 * @params topWork 本次更新的根节点 */function performUnitOfWork(fiber: Fiber, topWork: Fiber) &#123; // 对该节点进行处理 beginWork(fiber); // 如果存在子节点，那么下一个待处理的就是子节点 if (fiber.child) &#123; return fiber.child; &#125; // 没有子节点了，上溯查找兄弟节点 let temp = fiber; while (temp) &#123; completeWork(temp); // 到顶层节点了, 退出 if (temp === topWork) &#123; break &#125; // 找到，下一个要处理的就是兄弟节点 if (temp.sibling) &#123; return temp.sibling; &#125; // 没有, 继续上溯 temp = temp.return; &#125;&#125;复制代码 你可以配合上文的 workLoop 一起看，Fiber 就是我们所说的工作单元，performUnitOfWork 负责对 Fiber 进行操作，并按照深度遍历的顺序返回下一个 Fiber。因为使用了链表结构，即使处理流程被中断了，我们随时可以从上次未处理完的Fiber继续遍历下去。整个迭代顺序和之前递归的一样, 下图假设在 div.app 进行了更新：比如你在text(hello)中断了，那么下一次就会从 p 节点开始处理这个数据结构调整还有一个好处，就是某些节点异常时，我们可以打印出完整的’节点栈‘，只需要沿着节点的return回溯即可。 2. 两个阶段的拆分如果你现在使用最新的 React 版本(v16), 使用 Chrome 的 Performance 工具，可以很清晰地看到每次渲染有两个阶段：Reconciliation(协调阶段) 和 Commit(提交阶段). 我在之前的多篇文章中都有提及: 《自己写个React渲染器: 以 Remax 为例(用React写小程序)》 除了Fiber 工作单元的拆分，两阶段的拆分也是一个非常重要的改造，在此之前都是一边Diff一边提交的。先来看看这两者的区别: ⚛️ 协调阶段: 可以认为是 Diff 阶段, 这个阶段可以被中断, 这个阶段会找出所有节点变更，例如节点新增、删除、属性变更等等, 这些变更React 称之为’副作用(Effect)’ . 以下生命周期钩子会在协调阶段被调用： constructor componentWillMount 废弃 componentWillReceiveProps 废弃 static getDerivedStateFromProps shouldComponentUpdate componentWillUpdate 废弃 render getSnapshotBeforeUpdate() ⚛️ 提交阶段: 将上一个阶段计算出来的需要处理的副作用(Effects)一次性执行了。这个阶段必须同步执行，不能被打断. 这些生命周期钩子在提交阶段被执行: componentDidMount componentDidUpdate componentWillUnmount 也就是说，在协调阶段如果时间片用完，React就会选择让出控制权。因为协调阶段执行的工作不会导致任何用户可见的变更，所以在这个阶段让出控制权不会有什么问题。需要注意的是：因为协调阶段可能被中断、恢复，甚至重做，⚠️React 协调阶段的生命周期钩子可能会被调用多次!, 例如 componentWillMount 可能会被调用两次。因此建议 协调阶段的生命周期钩子不要包含副作用. 索性 React 就废弃了这部分可能包含副作用的生命周期方法，例如componentWillMount、componentWillUpdate. v17后我们就不能再用它们了, 所以现有的应用应该尽快迁移.现在你应该知道为什么’提交阶段’必须同步执行，不能中断的吧？ 因为我们要正确地处理各种副作用，包括DOM变更、还有你在componentDidMount中发起的异步请求、useEffect 中定义的副作用… 因为有副作用，所以必须保证按照次序只调用一次，况且会有用户可以察觉到的变更, 不容差池。关于为什么要拆分两个阶段，这里有更详细的解释。 3. Reconcilation接下来就是就是我们熟知的Reconcilation(为了方便理解，本文不区分Diff和Reconcilation, 两者是同一个东西)阶段了. 思路和 Fiber 重构之前差别不大, 只不过这里不会再递归去比对、而且不会马上提交变更。首先再进一步看一下Fiber的结构: 1234567891011121314151617181920212223242526272829303132333435363738394041424344interface Fiber &#123; /** * ⚛️ 节点的类型信息 */ // 标记 Fiber 类型, 例如函数组件、类组件、宿主组件 tag: WorkTag, // 节点元素类型, 是具体的类组件、函数组件、宿主组件(字符串) type: any, /** * ⚛️ 结构信息 */ return: Fiber | null, child: Fiber | null, sibling: Fiber | null, // 子节点的唯一键, 即我们渲染列表传入的key属性 key: null | string, /** * ⚛️ 节点的状态 */ // 节点实例(状态)： // 对于宿主组件，这里保存宿主组件的实例, 例如DOM节点。 // 对于类组件来说，这里保存类组件的实例 // 对于函数组件说，这里为空，因为函数组件没有实例 stateNode: any, // 新的、待处理的props pendingProps: any, // 上一次渲染的props memoizedProps: any, // The props used to create the output. // 上一次渲染的组件状态 memoizedState: any, /** * ⚛️ 副作用 */ // 当前节点的副作用类型，例如节点更新、删除、移动 effectTag: SideEffectTag, // 和节点关系一样，React 同样使用链表来将所有有副作用的Fiber连接起来 nextEffect: Fiber | null, /** * ⚛️ 替身 * 指向旧树中的节点 */ alternate: Fiber | null,&#125;复制代码 Fiber 包含的属性可以划分为 5 个部分: 🆕 结构信息 - 这个上文我们已经见过了，Fiber 使用链表的形式来表示节点在树中的定位 节点类型信息 - 这个也容易理解，tag表示节点的分类、type 保存具体的类型值，如div、MyComp 节点的状态 - 节点的组件实例、props、state等，它们将影响组件的输出 🆕 副作用 - 这个也是新东西. 在 Reconciliation 过程中发现的’副作用’(变更需求)就保存在节点的effectTag 中(想象为打上一个标记).那么怎么将本次渲染的所有节点副作用都收集起来呢？ 这里也使用了链表结构，在遍历过程中React会将所有有‘副作用’的节点都通过nextEffect连接起来 🆕 替身 - React 在 Reconciliation 过程中会构建一颗新的树(官方称为workInProgress tree，WIP树)，可以认为是一颗表示当前工作进度的树。还有一颗表示已渲染界面的旧树，React就是一边和旧树比对，一边构建WIP树的。 alternate 指向旧树的同等节点。 现在可以放大看看beginWork 是如何对 Fiber 进行比对的: 123456789101112131415function beginWork(fiber: Fiber): Fiber | undefined &#123; if (fiber.tag === WorkTag.HostComponent) &#123; // 宿主节点diff diffHostComponent(fiber) &#125; else if (fiber.tag === WorkTag.ClassComponent) &#123; // 类组件节点diff diffClassComponent(fiber) &#125; else if (fiber.tag === WorkTag.FunctionComponent) &#123; // 函数组件节点diff diffFunctionalComponent(fiber) &#125; else &#123; // ... 其他类型节点，省略 &#125;&#125;复制代码 宿主节点比对: 123456789101112function diffHostComponent(fiber: Fiber) &#123; // 新增节点 if (fiber.stateNode == null) &#123; fiber.stateNode = createHostComponent(fiber) &#125; else &#123; updateHostComponent(fiber) &#125; const newChildren = fiber.pendingProps.children; // 比对子节点 diffChildren(fiber, newChildren);&#125;复制代码 类组件节点比对也差不多: 12345678910111213141516171819function diffClassComponent(fiber: Fiber) &#123; // 创建组件实例 if (fiber.stateNode == null) &#123; fiber.stateNode = createInstance(fiber); &#125; if (fiber.hasMounted) &#123; // 调用更新前生命周期钩子 applybeforeUpdateHooks(fiber) &#125; else &#123; // 调用挂载前生命周期钩子 applybeforeMountHooks(fiber) &#125; // 渲染新节点 const newChildren = fiber.stateNode.render(); // 比对子节点 diffChildren(fiber, newChildren); fiber.memoizedState = fiber.stateNode.state&#125;复制代码 子节点比对: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function diffChildren(fiber: Fiber, newChildren: React.ReactNode) &#123; let oldFiber = fiber.alternate ? fiber.alternate.child : null; // 全新节点，直接挂载 if (oldFiber == null) &#123; mountChildFibers(fiber, newChildren) return &#125; let index = 0; let newFiber = null; // 新子节点 const elements = extraElements(newChildren) // 比对子元素 while (index &lt; elements.length || oldFiber != null) &#123; const prevFiber = newFiber; const element = elements[index] const sameType = isSameType(element, oldFiber) if (sameType) &#123; newFiber = cloneFiber(oldFiber, element) // 更新关系 newFiber.alternate = oldFiber // 打上Tag newFiber.effectTag = UPDATE newFiber.return = fiber &#125; // 新节点 if (element &amp;&amp; !sameType) &#123; newFiber = createFiber(element) newFiber.effectTag = PLACEMENT newFiber.return = fiber &#125; // 删除旧节点 if (oldFiber &amp;&amp; !sameType) &#123; oldFiber.effectTag = DELETION; oldFiber.nextEffect = fiber.nextEffect fiber.nextEffect = oldFiber &#125; if (oldFiber) &#123; oldFiber = oldFiber.sibling; &#125; if (index == 0) &#123; fiber.child = newFiber; &#125; else if (prevFiber &amp;&amp; element) &#123; prevFiber.sibling = newFiber; &#125; index++ &#125;&#125;复制代码 上面的代码很粗糙地还原了 Reconciliation 的过程, 但是对于我们理解React的基本原理已经足够了.这里引用一下Youtube: Lin Clark presentation in ReactConf 2017 的Slide，来还原 Reconciliation 的过程. Lin Clark 这个演讲太经典了，几乎所有介绍 React Fiber 的文章都会引用它的Slide. 偷个懒，我也用下: 这篇文章《React Fiber》 用文字版解释了Link Clark Slide. 上图是 Reconciliation 完成后的状态，左边是旧树，右边是WIP树。对于需要变更的节点，都打上了’标签’。 在提交阶段，React 就会将这些打上标签的节点应用变更。 4. 双缓冲WIP 树构建这种技术类似于图形化领域的’双缓存(Double Buffering)‘技术, 图形绘制引擎一般会使用双缓冲技术，先将图片绘制到一个缓冲区，再一次性传递给屏幕进行显示，这样可以防止屏幕抖动，优化渲染性能。放到React 中，WIP树就是一个缓冲，它在Reconciliation 完毕后一次性提交给浏览器进行渲染。它可以减少内存分配和垃圾回收，WIP 的节点不完全是新的，比如某颗子树不需要变动，React会克隆复用旧树中的子树。双缓存技术还有另外一个重要的场景就是异常的处理，比如当一个节点抛出异常，仍然可以继续沿用旧树的节点，避免整棵树挂掉。Dan 在 Beyond React 16 演讲中用了一个非常恰当的比喻，那就是Git 功能分支，你可以将 WIP 树想象成从旧树中 Fork 出来的功能分支，你在这新分支中添加或移除特性，即使是操作失误也不会影响旧的分支。当你这个分支经过了测试和完善，就可以合并到旧分支，将其替换掉. 这或许就是’提交(commit)阶段‘的提交一词的来源吧？: 5. 副作用的收集和提交接下来就是将所有打了 Effect 标记的节点串联起来，这个可以在completeWork中做, 例如: 123456789101112131415161718function completeWork(fiber) &#123; const parent = fiber.return // 到达顶端 if (parent == null || fiber === topWork) &#123; pendingCommit = fiber return &#125; if (fiber.effectTag != null) &#123; if (parent.nextEffect) &#123; parent.nextEffect.nextEffect = fiber &#125; else &#123; parent.nextEffect = fiber &#125; &#125; else if (fiber.nextEffect) &#123; parent.nextEffect = fiber.nextEffect &#125;&#125;复制代码 最后了，将所有副作用提交了: 12345678910111213function commitAllWork(fiber) &#123; let next = fiber while(next) &#123; if (fiber.effectTag) &#123; // 提交，偷一下懒，这里就不展开了 commitWork(fiber) &#125; next = fiber.nextEffect &#125; // 清理现场 pendingCommit = nextUnitOfWork = topWork = null&#125;复制代码 ⚠️ 未展开部分 🚧 – 中断和恢复上文只是介绍了简单的中断和恢复机制，我们从哪里跌倒就从哪里站起来，在哪个节点中断就从哪个节点继续处理下去。 也就是说，到目前为止：⚠️更新任务还是串行执行的，我们只是将整个过程碎片化了. 对于那些需要优先处理的更新任务还是会被阻塞。我个人觉得这才是 React Fiber 中最难处理的一部分。实际情况是，在 React 得到控制权后，应该优先处理高优先级的任务。也就是说中断时正在处理的任务，在恢复时会让位给高优先级任务，原本中断的任务可能会被放弃或者重做。但是如果不按顺序执行任务，可能会导致前后的状态不一致。 比如低优先级任务将 a 设置为0，而高优先级任务将 a 递增1, 两个任务的执行顺序会影响最终的渲染结果。因此要让高优先级任务插队, 首先要保证状态更新的时序。解决办法是: 所有更新任务按照顺序插入一个队列, 状态必须按照插入顺序进行计算，但任务可以按优先级顺序执行, 例如：红色表示高优先级任务。要计算它的状态必须基于前序任务计算出来的状态, 从而保证状态的最终一致性：最终红色的高优先级任务 C 执行时的状态值是a=5,b=3. 在恢复控制权时，会按照优先级先执行 C, 前面的A、 B暂时跳过上面被跳过任务不会被移除，在执行完高优先级任务后它们还是会被执行的。因为不同的更新任务影响的节点树范围可能是不一样的，举个例子 a、b 可能会影响 Foo 组件树，而 c 会影响 Bar 组件树。所以为了保证视图的最终一致性, 所有更新任务都要被执行。首先 C 先被执行，它更新了 Foo 组件接着执行 A 任务，它更新了Foo 和 Bar 组件，由于 C 已经以最终状态a=5, b=3更新了Foo组件，这里可以做一下性能优化，直接复用C的更新结果， 不必触发重新渲染。因此 A 仅需更新 Bar 组件即可。接着执行 B，同理可以复用 Foo 更新结果。道理讲起来都很简单，React Fiber 实际上非常复杂，不管执行的过程怎样拆分、以什么顺序执行，最重要的是保证状态的一致性和视图的一致性，这给了 React 团队很大的考验，以致于现在都没有正式release出来。 凌波微步同样来自Link Clark 的 Slider前面说了一大堆，从操作系统进程调度、到浏览器原理、再到合作式调度、最后谈了React的基本改造工作, 地老天荒… 就是为了上面的小人可以在练就凌波微步, 它脚下的坑是浏览器的调用栈。React 开启 Concurrent Mode 之后就不会挖大坑了，而是一小坑一坑的挖，挖一下休息一下，有紧急任务就优先去做。来源：Flarnie Marchan - Ready for Concurrent Mode?开启 Concurrent Mode 后，我们可以得到以下好处(详见Concurrent Rendering in React): 快速响应用户操作和输入，提升用户交互体验 让动画更加流畅，通过调度，可以让应用保持高帧率 利用好I/O 操作空闲期或者CPU空闲期，进行一些预渲染。 比如离屏(offscreen)不可见的内容，优先级最低，可以让 React 等到CPU空闲时才去渲染这部分内容。这和浏览器的preload等预加载技术差不多。 用Suspense 降低加载状态(load state)的优先级，减少闪屏。 比如数据很快返回时，可以不必显示加载状态，而是直接显示出来，避免闪屏；如果超时没有返回才显式加载状态。 但是它肯定不是完美的，因为浏览器无法实现抢占式调度，无法阻止开发者做傻事的，开发者可以随心所欲，想挖多大的坑，就挖多大的坑。为了共同创造美好的世界，我们要严律于己，该做的优化还需要做: 纯组件、虚表、简化组件、缓存…尤雨溪在今年的Vue Conf一个观点让我印象深刻：如果我们可以把更新做得足够快的话，理论上就不需要时间分片了。时间分片并没有降低整体的工作量，该做的还是要做, 因此React 也在考虑利用CPU空闲或者I/O空闲期间做一些预渲染。所以跟尤雨溪说的一样：React Fiber 本质上是为了解决 React 更新低效率的问题，不要期望 Fiber 能给你现有应用带来质的提升, 如果性能问题是自己造成的，自己的锅还是得自己背. 站在巨人的肩膀上本文之所以能成文，离不开社区上优质的开源项目和资料。迷你 Fiber 实现:React 现在的代码库太复杂了! 而且一直在变动和推翻自己，Hax 在 《为什么社区里那些类 React 库至今没有选择实现 Fiber 架构？》 就开玩笑说: Fiber 性价比略低… 到了这个阶段，竞品太多，facebook 就搞一个 fiber 来作为护城河……这种工程量不是一般团队能Hold住的， 如果你只是想了解 Fiber，去读 React 的源码性价比也很低，不妨看看这些 Mini 版实现, 感受其精髓，不求甚解: anu 司徒正美 开发的类React框架 Fre 伊撒尔 开发的类React框架，代码很精简⁉️ Luy didact 优秀的文章 &amp; 演讲本文只是对React Fiber进行了简单的科普，实际上React 的实现比本文复杂的多，如果你想深入理解React Fiber的，下面这些文章不容错过: Lin Clark - A Cartoon Intro to Fiber - React Conf 2017 👍🎦 React Fiber 启蒙，YouTube Beyond React 16 - Dan Abramov 👍🎦 Concurrent Rendering in React - Andrew Clark and Brian Vaughn 👍🎦 司徒正美: React Fiber架构 👍 看不如写 展望 React 17，回顾 React 往事 👍 看完 Heaven 的相关文章，会觉得你了解的React 知识真的只是冰山一角，我们都没资格说我们懂 React。 浅入 React16/fiber 系列 👍 同样来自 Heaven 淡苍：深入剖析 React Concurrent 👍 Didact Fiber: Incremental reconciliation 👍 实现了简单的 React Fiber 程墨: React Fiber是什么 译 深入React fiber架构及源码 黯羽轻扬: 完全理解React Fiber Fiber Principles: Contributing To Fiber Scheduling in React 桃翁: Deep In React 之浅谈 React Fiber 架构（一） 为 Luy 实现 React Fiber 架构 妖僧风月: React Fiber Flarnie Marchan - Ready for Concurrent Mode? 🎦 Web Fundamentals &gt; Performance 你应该知道的requestIdleCallback 深入探究 eventloop 与浏览器渲染的时序问题 Accurately measuring layout on the web 自荐React 相关文章回顾一下今年写的关于 React 的相关文章Concurrent模式预览（推荐）: React Concurrent 模式抢先预览: Suspense 篇 React Concurrent 模式抢先预览下篇: useTransition 的平行世界 往期文章: React组件设计实践总结 系列 共5篇 自己写个React渲染器: 以 Remax 为例(用React写小程序) 谈谈React事件机制和未来(react-events) 2019年了，整理了N个实用案例帮你快速迁移到React Hooks 浅谈React性能优化的方向 从Preact中了解React组件和hooks基本原理 React性能测量和分析 本文讲了 React 如何优化 CPU 问题，React 野心远不在于此, I/O 方向的优化也在实践，例如 Suspend… 还有很多没讲完，后面的文章见！ 完全理解React Fiberhttps://blog.csdn.net/juzipidemimi/article/details/96753874 一.目标Fiber是对React核心算法的重构，2年重构的产物就是Fiber reconciler核心目标：扩大其_适用性_，包括动画，布局和手势。分为5个具体目标（后2个算送的）： 把可中断的工作拆分成小任务 对正在做的工作调整优先次序、重做、复用上次（做了一半的）成果 在父子任务之间从容切换（yield back and forth），以支持React执行过程中的布局刷新 支持render()返回多个元素 更好地支持error boundary 既然初衷是不希望JS不受控制地长时间执行（想要手动调度），那么，为什么JS长时间执行会影响交互响应、动画？ 因为JavaScript在浏览器的主线程上运行，恰好与样式计算、布局以及许多情况下的绘制一起运行。如果JavaScript运行时间过长，就会阻塞这些其他工作，可能导致掉帧。 （引自Optimize JavaScript Execution）React希望通过Fiber重构来改变这种不可控的现状，进一步提升交互体验P.S.关于Fiber目标的更多信息，请查看Codebase Overview 二.关键特性Fiber的关键特性如下： 增量渲染（把渲染任务拆分成块，匀到多帧） 更新时能够暂停，终止，复用渲染任务 给不同类型的更新赋予优先级 并发方面新的基础能力 增量渲染用来解决掉帧的问题，渲染任务拆分之后，每次只做一小段，做完一段就把时间控制权交还给主线程，而不像之前长时间占用。这种策略叫做cooperative scheduling（合作式调度），操作系统的3种任务调度策略之一（Firefox还对真实DOM应用了这项技术）另外，React自身的_killer feature_是virtual DOM，2个原因： coding UI变简单了（不用关心浏览器应该怎么做，而是把下一刻的UI描述给React听） 既然DOM能virtual，别的（硬件、VR、native App）也能 React实现上分为2部分： reconciler 寻找某时刻前后两版UI的差异。包括之前的Stack reconciler与现在的Fiber reconciler renderer 插件式的，平台相关的部分。包括React DOM、React Native、React ART、ReactHardware、ReactAframe、React-pdf、ReactThreeRenderer、ReactBlessed等等 这一波是对reconciler的彻底改造，对killer feature的增强 三.fiber与fiber treeReact运行时存在3种实例： 123DOM 真实DOM节点Instances React维护的vDOM tree nodeElements 描述UI长什么样子（type, props） Instances是根据Elements创建的，对组件及DOM节点的抽象表示，vDOM tree维护了组件状态以及组件与DOM树的关系在首次渲染过程中构建出vDOM tree，后续需要更新时（setState()），diff vDOM tree得到DOM change，并把DOM change应用（patch）到DOM树Fiber之前的reconciler（被称为Stack reconciler）自顶向下的递归mount/update，_无法中断_（持续占用主线程），这样主线程上的布局、动画等周期性任务以及交互响应就无法立即得到处理，影响体验Fiber解决这个问题的_思路_是把渲染/更新过程（递归diff）拆分成一系列小任务，每次检查树上的一小部分，做完看是否还有时间继续下一个任务，有的话继续，没有的话把自己挂起，主线程不忙的时候再继续增量更新需要更多的上下文信息，之前的vDOM tree显然难以满足，所以扩展出了_fiber tree_（即Fiber上下文的vDOM tree），更新过程就是根据输入数据以及现有的fiber tree构造出新的fiber tree（workInProgress tree）。因此，Instance层新增了这些实例： 12345678910111213141516DOM 真实DOM节点- - - -effect 每个workInProgress tree节点上都有一个effect list 用来存放diff结果 当前节点更新完毕会向上merge effect list（queue收集diff结果）- - - -workInProgress workInProgress tree是reconcile过程中从fiber tree建立的当前进度快照，用于断点恢复- - - - -fiber fiber tree与vDOM tree类似，用来描述增量更新所需的上下文信息-------Elements 描述UI长什么样子（type, props） 注意：放在虚线上的2层都是临时的结构，仅在更新时有用，日常不持续维护。_effect_指的就是side effect，包括将要做的DOM changefiber tree上各节点的主要结构（每个节点称为_fiber_）如下： 12345678// fiber tree节点结构&#123; stateNode, child, return, sibling, ...&#125; return表示当前节点处理完毕后，应该向谁提交自己的成果（effect list）P.S.fiber tree实际上是个单链表（Singly Linked List）树结构，见react/packages/react-reconciler/src/ReactFiber.jsP.S.注意小fiber与大Fiber，前者表示fiber tree上的节点，后者表示React Fiber 四.Fiber reconcilerreconcile过程分为2个阶段（phase）： （可中断）render/reconciliation 通过构造workInProgress tree得出change （不可中断）commit 应用这些DOM change render/reconciliation以fiber tree为蓝本，把每个fiber作为一个工作单元，自顶向下逐节点构造_workInProgress tree_（构建中的新fiber tree）具体过程如下（以组件节点为例）： 如果当前节点不需要更新，直接把子节点clone过来，跳到5；要更新的话打个tag 更新当前节点状态（props, state, context等） 调用shouldComponentUpdate()，false的话，跳到5 调用render()获得新的子节点，并为子节点创建fiber（创建过程会尽量复用现有fiber，子节点增删也发生在这里） 如果没有产生child fiber，该工作单元结束，把effect list归并到return，并把当前节点的sibling作为下一个工作单元；否则把child作为下一个工作单元 如果没有剩余可用时间了，等到下一次主线程空闲时才开始下一个工作单元；否则，立即开始做 如果没有下一个工作单元了（回到了workInProgress tree的根节点），第1阶段结束，进入pendingCommit状态 实际上是1-6的_工作循环_，7是出口，工作循环每次只做一件事，做完看要不要喘口气。工作循环结束时，workInProgress tree的根节点身上的effect list就是收集到的所有side effect（因为每做完一个都向上归并）所以，构建workInProgress tree的过程就是diff的过程，通过requestIdleCallback来调度执行一组任务，每完成一个任务后回来看看有没有插队的（更紧急的），每完成一组任务，把时间控制权交还给主线程，直到下一次requestIdleCallback回调再继续构建workInProgress treeP.S.Fiber之前的reconciler被称为Stack reconciler，就是因为这些调度上下文信息是由系统栈来保存的。虽然之前一次性做完，强调栈没什么意义，起个名字只是为了便于区分Fiber reconciler requestIdleCallback 通知主线程，要求在不忙的时候告诉我，我有几个不太着急的事情要做 具体用法如下： 1234567891011121314151617window.requestIdleCallback(callback[, options])// 示例let handle = window.requestIdleCallback((idleDeadline) =&gt; &#123; const &#123;didTimeout, timeRemaining&#125; = idleDeadline; console.log(`超时了吗？$&#123;didTimeout&#125;`); console.log(`可用时间剩余$&#123;timeRemaining.call(idleDeadline)&#125;ms`); // do some stuff const now = +new Date, timespent = 10; while (+new Date &lt; now + timespent); console.log(`花了$&#123;timespent&#125;ms搞事情`); console.log(`可用时间剩余$&#123;timeRemaining.call(idleDeadline)&#125;ms`);&#125;, &#123;timeout: 1000&#125;);// 输出结果// 超时了吗？false// 可用时间剩余49.535000000000004ms// 花了10ms搞事情// 可用时间剩余38.64ms _注意_，requestIdleCallback调度只是希望做到流畅体验，并不能绝对保证什么，例如： 123// do some stuffconst now = +new Date, timespent = 300;while (+new Date &lt; now + timespent); 如果搞事情（对应React中的生命周期函数等时间上不受React控制的东西）就花了300ms，什么机制也保证不了流畅P.S.一般剩余可用时间也就10-50ms，可调度空间不很宽裕 commit第2阶段直接一口气做完： 处理effect list（包括3种处理：更新DOM树、调用组件生命周期函数以及更新ref等内部状态） 出对结束，第2阶段结束，所有更新都commit到DOM树上了 注意，真的是_一口气做完_（同步执行，不能喊停）的，这个阶段的实际工作量是比较大的，所以尽量不要在后3个生命周期函数里干重活儿 生命周期hook生命周期函数也被分为2个阶段了： 123456789// 第1阶段 render/reconciliationcomponentWillMountcomponentWillReceivePropsshouldComponentUpdatecomponentWillUpdate// 第2阶段 commitcomponentDidMountcomponentDidUpdatecomponentWillUnmount 第1阶段的生命周期函数可能会被_多次调用_，默认以low优先级（后面介绍的6种优先级之一）执行，被高优先级任务打断的话，稍后重新执行 五.fiber tree与workInProgress tree双缓冲技术（double buffering），就像redux里的nextListeners，以fiber tree为主，workInProgress tree为辅双缓冲具体指的是workInProgress tree构造完毕，得到的就是新的fiber tree，然后喜新厌旧（把current指针指向workInProgress tree，丢掉旧的fiber tree）就好了这样做的好处： 能够复用内部对象（fiber） 节省内存分配、GC的时间开销 每个fiber上都有个alternate属性，也指向一个fiber，创建workInProgress节点时优先取alternate，没有的话就创建一个： 1234567891011121314let workInProgress = current.alternate;if (workInProgress === null) &#123; //...这里很有意思 workInProgress.alternate = current; current.alternate = workInProgress;&#125; else &#123; // We already have an alternate. // Reset the effect tag. workInProgress.effectTag = NoEffect; // The effect list is no longer valid. workInProgress.nextEffect = null; workInProgress.firstEffect = null; workInProgress.lastEffect = null;&#125; 如注释指出的，fiber与workInProgress互相持有引用，“喜新厌旧”之后，旧fiber就作为新fiber更新的_预留空间_，达到复用fiber实例的目的P.S.源码里还有一些有意思的技巧，比如tag的位运算 六.优先级策略每个工作单元运行时有6种优先级： synchronous 与之前的Stack reconciler操作一样，同步执行 task 在next tick之前执行 animation 下一帧之前执行 high 在不久的将来立即执行 low 稍微延迟（100-200ms）执行也没关系 offscreen 下一次render时或scroll时才执行 synchronous首屏（首次渲染）用，要求尽量快，不管会不会阻塞UI线程。animation通过requestAnimationFrame来调度，这样在下一帧就能立即开始动画过程；后3个都是由requestIdleCallback回调执行的；offscreen指的是当前隐藏的、屏幕外的（看不见的）元素高优先级的比如键盘输入（希望立即得到反馈），低优先级的比如网络请求，让评论显示出来等等。另外，紧急的事件允许插队这样的优先级机制存在_2个问题_： 生命周期函数怎么执行（可能被频频中断）：触发顺序、次数没有保证了 starvation（低优先级饿死）：如果高优先级任务很多，那么低优先级任务根本没机会执行（就饿死了） 生命周期函数的问题有一个官方例子： 12345678low AcomponentWillUpdate()high BcomponentWillUpdate()componentDidUpdate()restart low AcomponentWillUpdate()componentDidUpdate() 第1个问题正在解决（还没解决），生命周期的问题会破坏一些现有App，给平滑升级带来困难，Fiber团队正在努力寻找优雅的升级途径第2个问题通过尽量复用已完成的操作（reusing work where it can）来缓解，听起来也是正在想办法解决这两个问题本身不太好解决，只是解决到什么程度的问题。比如第一个问题，如果组件生命周期函数掺杂副作用太多，就没有办法无伤解决。这些问题虽然会给升级Fiber带来一定阻力，但绝不是不可解的（退一步讲，如果新特性有足够的吸引力，第一个问题大家自己想办法就解决了） 七.总结 已知React在一些响应体验要求较高的场景不适用，比如动画，布局和手势根本原因是渲染/更新过程一旦开始无法中断，持续占用主线程，主线程忙于执行JS，无暇他顾（布局、动画），造成掉帧、延迟响应（甚至无响应）等不佳体验 求一种能够彻底解决主线程长时间占用问题的机制，不仅能够应对眼前的问题，还要有长远意义 The “fiber” reconciler is a new effort aiming to resolve the problems inherent in the stack reconciler and fix a few long-standing issues. 解把渲染/更新过程拆分为小块任务，通过合理的调度机制来控制时间（更细粒度、更强的控制力）那么，面临5个子问题： 1.拆什么？什么不能拆？把渲染/更新过程分为2个阶段（diff + patch）： 121.diff ~ render/reconciliation2.patch ~ commit diff的实际工作是对比prevInstance和nextInstance的状态，找出差异及其对应的DOM change。diff本质上是一些计算（遍历、比较），是可拆分的（算一半待会儿接着算）patch阶段把本次更新中的所有DOM change应用到DOM树，是一连串的DOM操作。这些DOM操作虽然看起来也可以拆分（按照change list一段一段做），但这样做一方面可能造成DOM实际状态与维护的内部状态不一致，另外还会影响体验。而且，一般场景下，DOM更新的耗时比起diff及生命周期函数耗时不算什么，拆分的意义不很大所以，render/reconciliation阶段的工作（diff）可以拆分，commit阶段的工作（patch）不可拆分P.S.diff与reconciliation只是对应关系，并不等价，如果非要区分的话，reconciliation包括diff： This is a part of the process that React calls reconciliation which starts when you call ReactDOM.render() or setState(). By the end of the reconciliation, React knows the result DOM tree, and a renderer like react-dom or react-native applies the minimal set of changes necessary to update the DOM nodes (or the platform-specific views in case of React Native). （引自Top-Down Reconciliation） 2.怎么拆？先凭空乱来几种diff工作拆分方案： 按组件结构拆。不好分，无法预估各组件更新的工作量 按实际工序拆。比如分为getNextState(), shouldUpdate(), updateState(), checkChildren()再穿插一些生命周期函数 按组件拆太粗，显然对大组件不太公平。按工序拆太细，任务太多，频繁调度不划算。那么有没有合适的拆分单位？有。Fiber的拆分单位是fiber（fiber tree上的一个节点），实际上就是_按虚拟DOM节点拆_，因为fiber tree是根据vDOM tree构造出来的，树结构一模一样，只是节点携带的信息有差异所以，实际上是vDOM node粒度的拆分（以fiber为工作单元），每个组件实例和每个DOM节点抽象表示的实例都是一个工作单元。工作循环中，每次处理一个fiber，处理完可以中断/挂起整个工作循环 3.如何调度任务？分2部分： 工作循环 优先级机制 工作循环是_基本的任务调度机制_，工作循环中每次处理一个任务（工作单元），处理完毕有一次喘息的机会： 1234// Flush asynchronous work until the deadline runs out of time.while (nextUnitOfWork !== null &amp;&amp; !shouldYield()) &#123; nextUnitOfWork = performUnitOfWork(nextUnitOfWork);&#125; shouldYield就是看时间用完了没（idleDeadline.timeRemaining()），没用完的话继续处理下一个任务，用完了就结束，把时间控制权还给主线程，等下一次requestIdleCallback回调再接着做： 1234// If there's work left over, schedule a new callback.if (nextFlushedExpirationTime !== NoWork) &#123; scheduleCallbackWithExpiration(nextFlushedExpirationTime);&#125; 也就是说，（不考虑突发事件的）正常调度是由工作循环来完成的，基本_规则_是：每个工作单元结束检查是否还有时间做下一个，没时间了就先“挂起”优先级机制用来处理突发事件与优化次序，例如： 到commit阶段了，提高优先级 高优任务做一半出错了，给降一下优先级 抽空关注一下低优任务，别给饿死了 如果对应DOM节点此刻不可见，给降到最低优先级 这些策略用来动态调整任务调度，是工作循环的_辅助机制_，最先做最重要的事情 4.如何中断/断点恢复？中断：检查当前正在处理的工作单元，保存当前成果（firstEffect, lastEffect），修改tag标记一下，迅速收尾并再开一个requestIdleCallback，下次有机会再做断点恢复：下次再处理到该工作单元时，看tag是被打断的任务，接着做未完成的部分或者重做P.S.无论是时间用尽“自然”中断，还是被高优任务粗暴打断，对中断机制来说都一样 5.如何收集任务结果？Fiber reconciliation的工作循环具体如下： 找到根节点优先级最高的workInProgress tree，取其待处理的节点（代表组件或DOM节点） 检查当前节点是否需要更新，不需要的话，直接到4 标记一下（打个tag），更新自己（组件更新props，context等，DOM节点记下DOM change），并为孩子生成workInProgress node 如果没有产生子节点，归并effect list（包含DOM change）到父级 把孩子或兄弟作为待处理节点，准备进入下一个工作循环。如果没有待处理节点（回到了workInProgress tree的根节点），工作循环结束 通过每个节点更新结束时_向上归并effect list_来收集任务结果，reconciliation结束后，根节点的effect list里记录了包括DOM change在内的所有side effect 举一反三既然任务可拆分（只要最终得到完整effect list就行），那就允许_并行执行_（多个Fiber reconciler + 多个worker），首屏也更容易分块加载/渲染（vDOM森林）并行渲染的话，据说Firefox测试结果显示，130ms的页面，只需要30ms就能搞定，所以在这方面是值得期待的，而React已经做好准备了，这也就是在React Fiber上下文经常听到的待_unlock_的更多特性之一 八.源码简析从15到16，源码结构发生了很大变化： 再也看不到mountComponent/updateComponent()了，被拆分重组成了（beginWork/completeWork/commitWork()） ReactDOMComponent也被去掉了，在Fiber体系下DOM节点抽象用ReactDOMFiberComponent表示，组件用ReactFiberClassComponent表示，之前是ReactCompositeComponent Fiber体系的核心机制是负责任务调度的ReactFiberScheduler，相当于之前的ReactReconciler vDOM tree变成fiber tree了，以前是自上而下的简单树结构，现在是基于单链表的树结构，维护的节点关系更多一些 fiber tree来张图感受一下：fiber-tree其实稍一细想，从Stack reconciler到Fiber reconciler，源码层面就是干了一件_递归改循环_的事情（当然，实际做的事情远不止递归改循环，但这是第一步）总之，源码变化很大，如果对Fiber思路没有预先了解的话，看源码会比较_艰难_（看过React[15-]的源码的话，就更容易迷惑了）P.S.这张清明流程图要正式退役了 参考资料 Lin Clark – A Cartoon Intro to Fiber – React Conf 2017：_5星推荐_，声音很好听，比Jing Chen好100倍 acdlite/react-fiber-architecture Codebase Overview A look inside React Fiber – how work will get done.：Fiber源码解读，小说体看着有点费劲]]></content>
  </entry>
  <entry>
    <title><![CDATA[高效开发，必知必会的Chrome开发工具]]></title>
    <url>%2F2019%2F11%2F07%2Fyuque%2F%E9%AB%98%E6%95%88%E5%BC%80%E5%8F%91%EF%BC%8C%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E7%9A%84Chrome%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[作者：酷 壳 – CoolShell 链接：https://coolshell.cn/articles/17634.html Chrome的开发者工具是个很强大的东西，不过有些小功能可能并不为大众所知，所以，本文罗列了一些可能你所不知道的实用功能，也欢迎大家补充交流。话不多话，我们开始。 代码格式化 有很多css/js的代码都会被 minify 掉，你可以点击代码窗口左下角的那个 { } 标签，chrome会帮你给格式化掉。 强制DOM状态 有些HTML的DOM是有状态的，比如 标签，其会有 active，hover， focus，visited这些状态，有时候，我们的CSS会来定关不同状态的样式，在分析网页查看网页上DOM的CSS样式时，我们可以点击CSS样式上的 :hov 这个小按钮来强制这个DOM的状态。 动画 现在的网页上都会有一些动画效果。在Chrome的开发者工具中，通过右上角的菜单中的 More Tools =&gt; Animations 呼出相关的选项卡。于是你就可以慢动作播放动画了（可以点选 25% 或 10%），然后，Chrome还可以帮你把动画录下来，你可以拉动动再画的过程，甚至可以做一些简单的修改。 直接编辑网页 在你的 console 里 输入下面的命令：document.designMode = “on”于是你就可以直接修改网页上的内容了。P.S. 下面这个抓屏中还演示了一个如何清空console的示例。你可以输入 clear() 或是 按 Ctrl+L（Windows下），CMD + K (Mac下) 网络限制 你可以设置你的网络的访问速度来模拟一个网络很慢的情况。 复制HTTP请求 这个是我很喜欢 的一个功能，你可以在 network选项卡里，点击 XHR 过滤相关的Ajax请求，然后在相关的请求上点鼠标右键，在菜单中选择： Copy =&gt; Copy as cURL，然后就可以到你的命令行下去 执行 curl 的命令了。这个可以很容易做一些自动化的测试。 友情提示：这个操作有可能会把你的个人隐私信息复制出去，比如你个人登录后的cookie。 抓个带手机的图 这个可能有点无聊了，不过我觉得挺有意思的。在device显示中，先选择一个手机，然后在右上角选 Show Device Frame，然后你就看到手机的样子了，然后再到那个菜中中选 Capture snapshot，就可以抓下一个有手机样子的截图了。 我抓的图如下（当然，不是所有的手机都有frame的） 设置断点 除了给Javascript的源代码上设置断点调试，你还可以：给DOM设置断点选中一个DOM，然后在右键菜单中选 Break on … 你可以看到如下三个选项： 给XHR和Event Lisener设置断点在 Sources 面页中，你可以看到右边的那堆break points中，除了上面我们说的给DOM设置断点，你还可以给XHR和Event Listener设置断点，载图如下： 关于Console中的技巧 DOM操作 chrome会帮你buffer 5个你查看过的DOM对象，你可以直接在Console中用 $0, $1, $2, $3, $4来访问。 你还可以使用像jQuery那样的语法来获得DOM对象，如：$(“#mydiv”) 你还可使用 $$(“.class”) 来选择所有满足条件的DOM对象。 你可以使用 getEventListeners($(“selector”)) 来查看某个DOM对象上的事件（如下图所示）。 你还可以使用 monitorEvents($(“selector”)) 来监控相关的事件。比如： monitorEvents(document.body, “click”); Console中的一些函数1）monitor函数使用 monitor函数来监控一函数，如下面的示例2）copy函数copy函数可以把一个变量的值copy到剪贴板上。3）inspect函数inspect函数可以让你控制台跳到你需要查看的对象上。如：更多的函数请参数官方文档 – Using the Console / Command Line Reference Console的输出我们知道，除了console.log之外，还有console.debug，console.info，console.warn，console.error这些不同级别的输出。另外一个鲜为人知的功能是，console.log中，你还可以对输出的文本加上css的样式，如下所示：console.log(“%c左耳朵”, “font-size:90px;color:#888”) 于是，你可以定义一些相关的log函数，如：console.todo = function( msg){ console.log( ‘%c%s %s %s’, ‘font-size:20px; color:yellow; background-color: blue;’, ‘–’, msg, ‘–’);}console.important = function( msg){ console.log( ‘%c%s %s %s’, ‘font-size:20px; color:brown; font-weight: bold; text-decoration: underline;’, ‘–’, msg, ‘–’);} 关于console.log中的格式化，你可以参看如下表格： 指示符 输出 %s 格式化输出一个字符串变量。 %i or %d 格式化输出一个整型变量的值。 %f 格式化输出一个浮点数变量的值。 %o 格式化输出一个DOM对象。 %O 格式化输出一个Javascript对象。 %c 为后面的字符串加上CSS样式 除了console.log打印js的数组，你还可以使用console.table来打印，如下所示：var pets = [ { animal: ‘Horse’, name: ‘Pony’, age: 23 }, { animal: ‘Dog’, name: ‘Snoopy’, age: 13 }, { animal: ‘Cat’, name: ‘Tom’, age: 18 }, { animal: ‘Mouse’, name: ‘Jerry’, age: 12}];console.table(pets) 关于console对象 console对象除了上面的打日志的功能，其还有很多功能，比如： console.trace() 可以打出js的函数调用栈 console.time() 和 console.timeEnd() 可以帮你计算一段代码间消耗的时间。 console.profile() 和 console.profileEnd() 可以让你查看CPU的消耗。 console.count() 可以让你看到相同的日志当前被打印的次数。 console.assert(expression, object) 可以让你assert一个表达式 这些东西都可以看看Google的Console API的文档。其实，还有很多东西，你可以参看Google的官方文档 – Chrome DevTools 关于快捷键 点击在 DevTools的右上角的那三个坚排的小点，你会看到一个菜单，点选 Shortcuts，你就可以看到所有的快捷键了如果你知道更多，也欢迎补充！]]></content>
  </entry>
  <entry>
    <title><![CDATA[可能是最全的 “文本溢出截断省略” 方案合集]]></title>
    <url>%2F2019%2F11%2F07%2Fyuque%2F%E5%8F%AF%E8%83%BD%E6%98%AF%E6%9C%80%E5%85%A8%E7%9A%84%20%E2%80%9C%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E6%88%AA%E6%96%AD%E7%9C%81%E7%95%A5%E2%80%9D%20%E6%96%B9%E6%A1%88%E5%90%88%E9%9B%86%2F</url>
    <content type="text"><![CDATA[先来点基础的，单行文本溢出省略核心 CSS 语句 overflow: hidden；（文字长度超出限定宽度，则隐藏超出的内容） white-space: nowrap；（设置文字在一行显示，不能换行） text-overflow: ellipsis；（规定当文本溢出时，显示省略符号来代表被修剪的文本） 优点 无兼容问题 响应式截断 文本溢出范围才显示省略号，否则不显示省略号 省略号位置显示刚好 短板 只支持单行文本截断 适用场景 适用于单行文本溢出显示省略号的情况 Demo 12345678910&lt;style&gt; .demo &#123; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;demo&quot;&gt;这是一段很长的文本&lt;/div&gt;&lt;/body&gt; 示例图片 进阶一下，多行文本溢出省略（按行数） ○ 纯 CSS 实现方案核心 CSS 语句 -webkit-line-clamp: 2；（用来限制在一个块元素显示的文本的行数，2 表示最多显示 2 行。为了实现该效果，它需要组合其他的 WebKit 属性） display: -webkit-box；（和 1 结合使用，将对象作为弹性伸缩盒子模型显示 ） -webkit-box-orient: vertical；（和 1 结合使用 ，设置或检索伸缩盒对象的子元素的排列方式 ） overflow: hidden；（文本溢出限定的宽度就隐藏内容） text-overflow: ellipsis；（多行文本的情况下，用省略号 “…” 隐藏溢出范围的文本) 优点 响应式截断 文本溢出范围才显示省略号，否则不显示省略号 省略号显示位置刚好 短板 兼容性一般：-webkit-line-clamp 属性只有 WebKit 内核的浏览器才支持 适用场景 多适用于移动端页面，因为移动设备浏览器更多是基于 WebKit 内核 Demo 1234567891011&lt;style&gt; .demo &#123; display: -webkit-box; overflow: hidden; -webkit-line-clamp: 2; -webkit-box-orient: vertical; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&apos;demo&apos;&gt;这是一段很长的文本&lt;/div&gt;&lt;/body&gt; 示例图片 ○ 基于 JavaScript 的实现方案优点 无兼容问题 响应式截断 文本溢出范围才显示省略号，否则不显示省略号 短板 需要 JS 实现，背离展示和行为相分离原则 文本为中英文混合时，省略号显示位置略有偏差 适用场景 适用于响应式截断，多行文本溢出省略的情况 Demo当前仅适用于文本为中文，若文本中有英文，可自行修改 123456789101112131415161718192021222324252627282930&lt;script type=&quot;text/javascript&quot;&gt; const text = &apos;这是一段很长的文本&apos;; const totalTextLen = text.length; const formatStr = () =&gt; &#123; const ele = document.getElementsByClassName(&apos;demo&apos;)[0]; const lineNum = 2; const baseWidth = window.getComputedStyle(ele).width; const baseFontSize = window.getComputedStyle(ele).fontSize; const lineWidth = +baseWidth.slice(0, -2); // 所计算的strNum为元素内部一行可容纳的字数(不区分中英文) const strNum = Math.floor(lineWidth / +baseFontSize.slice(0, -2)); let content = &apos;&apos;; // 多行可容纳总字数 const totalStrNum = Math.floor(strNum * lineNum); const lastIndex = totalStrNum - totalTextLen; if (totalTextLen &gt; totalStrNum) &#123; content = text.slice(0, lastIndex - 3).concat(&apos;...&apos;); &#125; else &#123; content = text; &#125; ele.innerHTML = content; &#125; formatStr(); window.onresize = () =&gt; &#123; formatStr(); &#125;;&lt;/script&gt;&lt;body&gt; &lt;div class=&apos;demo&apos;&gt;&lt;/div&gt;&lt;/body&gt; 示例图片 再进阶一步，多行文本溢出省略（按高度） ○ 多行文本溢出不显示省略号核心 CSS 语句 overflow: hidden；（文本溢出限定的宽度就隐藏内容） line-height: 20px；（结合元素高度，高度固定的情况下，设定行高， 控制显示行数） max-height: 40px；（设定当前元素最大高度） 优点 无兼容问题 响应式截断 短板 单纯截断文字, 不展示省略号，观感上较为生硬 适用场景 适用于文本溢出不需要显示省略号的情况 Demo 12345678910&lt;style&gt; .demo &#123; overflow: hidden; max-height: 40px; line-height: 20px; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&apos;demo&apos;&gt;这是一段很长的文本&lt;/div&gt;&lt;/body&gt; 示例图片 ○ 伪元素 + 定位实现多行省略核心 CSS 语句 position: relative; （为伪元素绝对定位） overflow: hidden; （文本溢出限定的宽度就隐藏内容） position: absolute;（给省略号绝对定位） line-height: 20px; （结合元素高度,高度固定的情况下,设定行高, 控制显示行数） height: 40px; （设定当前元素高度） ::after {} （设置省略号样式） 优点 无兼容问题 响应式截断 短板 无法识别文字的长短，无论文本是否溢出范围, 一直显示省略号 省略号显示可能不会刚刚好，有时会遮住一半文字 适用场景 适用于对省略效果要求较低，文本一定会溢出元素的情况 Demo 123456789101112131415161718&lt;style&gt; .demo &#123; position: relative; line-height: 20px; height: 40px; overflow: hidden; &#125; .demo::after &#123; content: &quot;...&quot;; position: absolute; bottom: 0; right: 0; padding: 0 20px 0 10px; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&apos;demo&apos;&gt;这是一段很长的文本&lt;/div&gt;&lt;/body&gt; 示例图片 ○ 利用 Float 特性，纯 CSS 实现多行省略核心 CSS 语句 line-height: 20px；（结合元素高度,高度固定的情况下,设定行高, 控制显示行数） overflow: hidden；（文本溢出限定的宽度就隐藏内容） float: right/left；（利用元素浮动的特性实现） position: relative；（根据自身位置移动省略号位置, 实现文本溢出显示省略号效果） word-break: break-all；（使一个单词能够在换行时进行拆分） 优点 无兼容问题 响应式截断 文本溢出范围才显示省略号，否则不显示省略号 短板 省略号显示可能不会刚刚好，有时会遮住一半文字 适用场景 适用于对省略效果要求较低，多行文本响应式截断的情况 Demo 1234567891011121314151617181920212223242526272829303132&lt;style&gt; .demo &#123; background: #099; max-height: 40px; line-height: 20px; overflow: hidden; &#125; .demo::before&#123; float: left; content:&apos;&apos;; width: 20px; height: 40px; &#125; .demo .text &#123; float: right; width: 100%; margin-left: -20px; word-break: break-all; &#125; .demo::after&#123; float:right; content:&apos;...&apos;; width: 20px; height: 20px; position: relative; left:100%; transform: translate(-100%,-100%); &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&apos;demo&apos;&gt;这是一段很长的文本&lt;/div&gt;&lt;/body&gt; 示例图片原理讲解有 A、B、C 三个盒子，A 左浮动，B、C 右浮动。设置 A 盒子的高度与 B 盒子高度（或最大高度）要保持一致 当 B 盒子高度低于 A 盒子，C 盒子仍会处于 B 盒子右下方。 如果 B 盒子文本过多，高度超过了 A 盒子，则 C 盒子不会停留在右下方，而是掉到了 A 盒子下。 接下来对 C 盒子进行相对定位，将 C 盒子位置向右侧移动 100%，并向左上方向拉回一个 C 盒子的宽高（不然会看不到哟）。这样在文本未溢出时不会看到 C 盒子，在文本溢出时，显示 C 盒子。 收，大道归简，能力封装 凡重复的，让它单一；凡复杂的，让它简单。 每次都要搞一坨代码，太麻烦。这时候你需要考虑将文本截断的能力，封装成一个可随时调用的自定义容器组件。市面上很多 UI 组件库，都提供了同类组件的封装，如基于 Vue 的 ViewUI Pro，或面向小程序提供组件化解决能力的 MinUI。 结语本文介绍了几种目前常见的文本截断省略的方案，各有利弊，各位同学可根据实际开发情况及需求选择方案。如果你还知道更好其他实现方案，欢迎在评论区留下宝贵评论。]]></content>
  </entry>
  <entry>
    <title><![CDATA[9个项目助你在2020年成为前端大神！]]></title>
    <url>%2F2019%2F11%2F05%2Fyuque%2F9%E4%B8%AA%E9%A1%B9%E7%9B%AE%E5%8A%A9%E4%BD%A0%E5%9C%A82020%E5%B9%B4%E6%88%90%E4%B8%BA%E5%89%8D%E7%AB%AF%E5%A4%A7%E7%A5%9E%EF%BC%81%2F</url>
    <content type="text"><![CDATA[原文链接：dev.to/simonholdor…DEV的年度热文，读完觉得不错，所以翻译出来供大家参考，个人水平有限，文中可能会有一些翻译错误，可以在评论区指正。本篇文章一共涉及了9个流行的框架/库，没有具体的介绍使用方法，而是给了一些非常棒的实战教程。初学者(也许一些有经验的开发者也是一样)在读完官方文档，想写一个项目练手的时候不知道做什么项目好，或是有想法，但是无从下手。那么这篇文章将会给你带来很大的帮助。 导读无论你是编程新手还是经验丰富的开发人员。在这个行业中，我们不得不一直学习新概念和新语言或是框架，才能跟上快速变化。以React为例 —— FaceBook 四年前开源，现在它已经成为了全球JS开发者的首选。但是与此同时，Vue 和 Angular 也有自己的追求者。然后是 Svelte，Next 和 Nuxt.js，Gatsby，Gridsome,quasar 等等，如果你想成为专业的 JavaScript 开发人员，你在使用自己熟悉的框架进行开发的同时，还需要对不同的框架和库有一些了解。为了帮助你在2020年成为一个前端大神，我收集了9个使用了不同JS框架/库的项目，你可以去构建或者将他们加入到自己未来的开发计划中。记住，没什么比实际开发一个项目更有帮助。所以，不要犹豫，试着去开发一下。 1. 使用React(with hooks)构建一个电影搜索应用首先，你可以使用React构建一个电影搜索应用。展示如下： 你将学到什么？构建这个项目，你可以使用较新的 Hook API 来提升你的 React 技能。示例项目使用了React组件，很多 hooks 以及一些外部的 API，当然还有一些CSS样式。 技术栈/点 React(Hooks) create-react-app JSX CSS 你可以在这里看到这个示例项目：www.freecodecamp.org/news/how-to… 2.使用Vue构建一个聊天应用另外一个要介绍给你的很棒的项目是使用Vue构建的聊天应用程序。展示如下： 你将学到什么？您将学习到如何从头开始设置Vue应用，创建组件，处理状态，创建路由，连接到第三方服务，甚至是处理身份验证。 技术栈/点 Vue Vuex Vue Router Vue CLI Pusher CSS 这真的是一个非常棒的项目，不管是用来学习Vue或者是提升现有的技能，以应对2020年的发展。你可以查看这个教程： www.sitepoint.com/pusher-vue-… 3. 使用Augular8构建一款漂亮的天气应用此示例将帮助你使用 Google 的 Angular 8 来构建一块漂亮的天气应用程序： 你将学到什么？该项目将教你一些宝贵的技能，例如从头开始创建应用，从设计到开发，一直到生产就绪部署。 技术栈/点 Angular 8 Firebase SSR 网络布局和Flexbox 移动端友好 &amp;&amp; 响应式布局 深色模式 漂亮的用户界面 对于这个综合项目，我真正喜欢的是，不是孤立地学习东西，而是从设计到最终部署的整个开发过程。medium.com/@hamedbaato… 4. 使用 Svelte 构建一个 To-Do 应用与React，Vue和Angular相比，Svelte 还很新，但仍是热门之一。好的，To-Do应用不一定是那里最热门的项目，但这确实可以帮助你提高Svelte技能，如下： 你将学到什么？本教程将向你展示如何从头到尾使用Svelte3制作应用。 它利用了组件，样式和事件处理程序。 技术栈/点 Svelte 3 Components CSS ES6语法 Svelte 没有太多优秀的入门项目，这个是我觉得不错的一个上手项目：medium.com/codingthesm… 5. 使用 Next.js 构建购物车Next.js 是一个轻量级的 React 服务端渲染应用框架，该项目将向你展示如何构建一个如下所示的购物车： 你将学到什么？在这个项目中，你将学习如何设置 Next.js 的开发环境，创建新页面和组件，获取数据，设置样式并部署一个 next 应用。 技术栈/点 Next.js 组件和页面 数据获取 样式 部署 SSR和SPA 你可以在此处找到该教程：snipcart.com/blog/next-j… 6. 使用 Nuxt.js 构建一个多语言博客网站Nuxt.js 是 Vue 服务端渲染应用框架。你可以创建一个如下所示的应用程序： 你将学到什么？这个示例项目从初始设置到最终部署一步一步教你如何使用 Nuxt.js 构建一个完整的网站。它使用了 Nuxt 提供的许多出色功能，如页面和组件以及SCSS样式。 技术栈/点 Nuxt.js 组件和页面 Storyblok模块 Mixins Vuex SCSS Nuxt中间件 这个项目包含了涵盖了 Nuxt.js 的许多出色功能。我个人很喜欢使用 Nuxt 进行开发，你应该尝试使用它，这将使你成为更好的 Vue 开发人员！www.storyblok.com/tp/nuxt-js-…除此之外，我还找到了一个B站的视频：www.bilibili.com/video/av211… 7. 使用 Gatsby 构建一个博客Gatsby是一个出色的静态站点生成器，它允许使用React作为渲染引擎引擎来搭建一个静态站点，它真正具有现代web应用程序所期望的所有优点。该项目如下： 你将学到什么？在本教程中，你将学习如何利用 Gatsby 构建出色的博客。 技术栈/点 Gatsby React GraphQL Plugins &amp; Themes MDX / Markdown Bootstrap CSS Templates 如果你想创建博客，这个示例教你如何利用 React 和 GraphQL 来搭建。并不是说 Wordpress 是一个不好的选择，但是有了 Gatsby ，你可以在使用 React 的同时创建高性能站点！blog.bitsrc.io/how-to-buil… 8. 使用 Gridsome 构建一个博客Gridsome 和 Vue的关系与 Gatsby 和 React 的关系一样。Gridsome 和 Gatsby 都使用 GraphQL 作为数据层，但是 Gridsome 使用的是 VueJS。这也是一个很棒的静态站点生成器，它将帮助您创建出色的博客： 你将学到什么？该项目将教你如何使用 Gridsome，GraphQL 和 Markdown 构建一个简单的博客，它还介绍了如何通过Netlify 部署应用程序。 技术栈/点 Gridsome Vue GraphQL Markdown Netlify 当然，这不是最全面的教程，但涵盖了 Gridsome 和 Markdown 的基本概念，可能是一个很好的起点。www.telerik.com/blogs/build… 9.使用 Quasar 构建一个类似 SoundCloud 的音频播放器Quasar 是另一个 Vue 框架，也可以用于构建移动应用程序。 在这个项目中，你将创建一个音频播放器应用程序，如下所示： 你将学到什么？不少项目主要关注Web应用程序，但这个项目展示了如何通过 Quasar 框架创建移动应用程序。你应该已经配置了可工作的 Cordova 设置，并配置了 android studio / xcode。 如果没有，在教程中有一个指向quasar 网站的链接，在那里你可以学习如何进行设置。 技术栈/点 Quasar Vue Cordova Wavesurfer UI Components 一个展示了Quasar在构建移动应用程序方面的强大功能的小项目：www.learningsomethingnew.com/how-to-buil… 总结本文展示了你可以构建的9个项目，每个项目专注于一个JavaScript框架或库。现在，你可以自行决定：使用以前未使用的框架来尝试一些新的东西或是通过做一个项目来提升已有的技能，或者在2020年完成所有项目？ 作者：刘小夕链接：https://juejin.im/post/5dc0c744e51d456e7e41f5ac来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTTP1.0、HTTP1.1 和 HTTP2.0 的区别]]></title>
    <url>%2F2019%2F11%2F01%2Fyuque%2FHTTP1.0%E3%80%81HTTP1.1%20%E5%92%8C%20HTTP2.0%20%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[一、HTTP的历史早在 HTTP 建立之初，主要就是为了将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器。也是说对于前端来说，我们所写的HTML页面将要放在我们的 web 服务器上，用户端通过浏览器访问url地址来获取网页的显示内容，但是到了 WEB2.0 以来，我们的页面变得复杂，不仅仅单纯的是一些简单的文字和图片，同时我们的 HTML 页面有了 CSS，Javascript，来丰富我们的页面展示，当 ajax 的出现，我们又多了一种向服务器端获取数据的方法，这些其实都是基于 HTTP 协议的。同样到了移动互联网时代，我们页面可以跑在手机端浏览器里面，但是和 PC 相比，手机端的网络情况更加复杂，这使得我们开始了不得不对 HTTP 进行深入理解并不断优化过程中。 二、HTTP的基本优化影响一个 HTTP 网络请求的因素主要有两个：带宽和延迟。 带宽：如果说我们还停留在拨号上网的阶段，带宽可能会成为一个比较严重影响请求的问题，但是现在网络基础建设已经使得带宽得到极大的提升，我们不再会担心由带宽而影响网速，那么就只剩下延迟了。 延迟： 浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。 DNS 查询（DNS Lookup）：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。 建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。 三、HTTP1.0和HTTP1.1的一些区别HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在： 缓存处理，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。 带宽优化及网络连接的使用，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。 错误通知的管理，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。 Host头处理，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。 长连接，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。 四、HTTPS与HTTP的一些区别 HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。 HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。 HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。 五、SPDY：HTTP1.x的优化2012年google如一声惊雷提出了SPDY的方案，优化了HTTP1.X的请求延迟，解决了HTTP1.X的安全性，具体如下： 降低延迟，针对HTTP高延迟的问题，SPDY优雅的采取了多路复用（multiplexing）。多路复用通过多个请求stream共享一个tcp连接的方式，解决了HOL blocking的问题，降低了延迟同时提高了带宽的利用率。 请求优先级（request prioritization）。多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。 header压缩。前面提到HTTP1.x的header很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。 基于HTTPS的加密协议传输，大大提高了传输数据的可靠性。 服务端推送（server push），采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。SPDY构成图： SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。 六、HTTP2.0性能惊人HTTP/2: the Future of the Internet https://link.zhihu.com/?target=https://http2.akamai.com/demo 是 Akamai 公司建立的一个官方的演示，用以说明 HTTP/2 相比于之前的 HTTP/1.1 在性能上的大幅度提升。 同时请求 379 张图片，从Load time 的对比可以看出 HTTP/2 在速度上的优势。 七、HTTP2.0：SPDY的升级版HTTP2.0可以说是SPDY的升级版（其实原本也是基于SPDY设计的），但是，HTTP2.0 跟 SPDY 仍有不同的地方，如下：HTTP2.0和SPDY的区别： HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS HTTP2.0 消息头的压缩算法采用 HPACK http://http2.github.io/http2-spec/compression.html，而非 SPDY 采用的 DEFLATE http://zh.wikipedia.org/wiki/DEFLATE 八、HTTP2.0和HTTP1.X相比的新特性 新的二进制格式（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。 多路复用（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。 header压缩，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。 服务端推送（server push），同SPDY一样，HTTP2.0也具有server push功能。 九、HTTP2.0的升级改造 前文说了HTTP2.0其实可以支持非HTTPS的，但是现在主流的浏览器像chrome，firefox表示还是只支持基于 TLS 部署的HTTP2.0协议，所以要想升级成HTTP2.0还是先升级HTTPS为好。 当你的网站已经升级HTTPS之后，那么升级HTTP2.0就简单很多，如果你使用NGINX，只要在配置文件中启动相应的协议就可以了，可以参考*NGINX白皮书，NGINX配置HTTP2.0官方指南 *https://www.nginx.com/blog/nginx-1-9-5/。 使用了HTTP2.0那么，原本的HTTP1.x怎么办，这个问题其实不用担心，HTTP2.0完全兼容HTTP1.x的语义，对于不支持HTTP2.0的浏览器，NGINX会自动向下兼容的。 十、附注HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？ HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接； HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞； HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；具体如图： 服务器推送到底是什么？服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。具体如下： 普通的客户端请求过程： 服务端推送的过程： 为什么需要头部压缩？假定一个页面有100个资源需要加载（这个数量对于今天的Web而言还是挺保守的）, 而每一次请求都有1kb的消息头（这同样也并不少见，因为Cookie和引用等东西的存在）, 则至少需要多消耗100kb来获取这些消息头。HTTP2.0可以维护一个字典，差量更新HTTP头部，大大降低因头部传输产生的流量。具体参考：HTTP/2 头部压缩技术介绍 HTTP2.0多路复用有多好？HTTP 性能优化的关键并不在于高带宽，而是低延迟。TCP 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。 十一、参考HTTP/2.0 相比1.0有哪些重大改进？深入研究：HTTP2 的真正性能到底如何HTTP/2 头部压缩技术介绍]]></content>
  </entry>
  <entry>
    <title><![CDATA[Redux]]></title>
    <url>%2F2019%2F10%2F31%2Fyuque%2FRedux%2F</url>
    <content type="text"><![CDATA[redux视频教育 http://jspang.com/posts/2019/06/20/redux.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[接私活必备的 10 个开源项目！]]></title>
    <url>%2F2019%2F10%2F25%2Fyuque%2F%E6%8E%A5%E7%A7%81%E6%B4%BB%E5%BF%85%E5%A4%87%E7%9A%84%2010%20%E4%B8%AA%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%EF%BC%81%2F</url>
    <content type="text"><![CDATA[Web 开发中几乎的平台都需要一个后台管理，但是从零开发一套后台控制面板并不容易，幸运的是有很多开源免费的后台控制面板可以给开发者使用，那么有哪些优秀的开源免费的控制面板呢？我在 Github 上收集了一些优秀的后台控制面板，并总结得出 Top 10。 1、AdminLTEGithub Star 数 24969 ， Github 地址： https://github.com/almasaeed2010/AdminLTE非常流行的基于 Bootstrap 3.x 的免费的后台 UI 框架。 2、vue-Element-AdminGithub Star 数 19546， Github 地址： https://github.com/PanJiaChen/vue-element-admin一个基于 vue2.0 和 Eelement 的控制面板 UI 框架。 3、tablerGithub Star 数 15870， Github 地址： https://github.com/tabler/tabler构建在 BootStrap 4 之上的免费的 HTML 控制面板框架 4、GentelellaGithub Star 数 15654， Github 地址： https://github.com/puikinsh/gentelella一个基于 Bootstarp 的免费的后台控制面板。 5、ng2-adminGithub Star 数 13181， Github 地址： https://github.com/akveo/ngx-admin基于 Angular 2, Bootstrap 4 和 Webpack 的后台管理面板框架。 6、ant-design-proGithub Star 数 12707，Github 地址： https://github.com/ant-design/ant-design-pro开箱即用的中台前端/设计解决方案 7、blur-adminGithub Star 数 9241，Github 地址： https://github.com/akveo/blur-admin基于 Angular 和 Bootstrap 的后台管理面板框架。 8、vue-adminGithub Star 数 8676，Github 地址： https://github.com/vue-bulma/vue-admin基于 Vue 和 Bulma 的控制面板。 9、iview-adminGithub Star 数 8668，Github 地址： https://github.com/iview/iview-admin基于 iView 的 Vue 2.0 控制面板。 10、material-dashboardGithub Star 数 7111，Github 地址： https://github.com/creativetimofficial/material-dashboard基于 Bootstrap 4 和 Material 风格的控制面板。 1作者：SevDothttps://www.jianshu.com/p/3bc7404af88 ##]]></content>
  </entry>
  <entry>
    <title><![CDATA[微信h5支付]]></title>
    <url>%2F2019%2F10%2F25%2Fyuque%2F%E5%BE%AE%E4%BF%A1h5%E6%94%AF%E4%BB%98%2F</url>
    <content type="text"><![CDATA[https://www.yuque.com/robinson/fe-guide/gt9hb4?from=timeline&amp;isappinstalled=0]]></content>
  </entry>
  <entry>
    <title><![CDATA[真正能让效率翻倍的VSCode插件推荐]]></title>
    <url>%2F2019%2F10%2F22%2Fyuque%2F%E7%9C%9F%E6%AD%A3%E8%83%BD%E8%AE%A9%E6%95%88%E7%8E%87%E7%BF%BB%E5%80%8D%E7%9A%84VSCode%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90%2F</url>
    <content type="text"><![CDATA[https://mp.weixin.qq.com/s/pO3QgyIVhvmP24pPXRCJ8Q在2019年StackOverflow的调查中,VSCode的受欢迎程度首次超越宇宙第一IDE–Visual Studio.VSCode成为最受欢迎开发环境好了,书归正传,我是VSCode的重度使用者,除了在Idea上敲敲Java之外,几乎所有的代码时间都花在了VSCode上,我心里有非常多的VSCode使用心得可以分享,包括实用插件、快捷键使用、调试技巧、主题配置、插件编写等等,今天就先从最轻松的开始,就是实用插件的推荐. VSCode的优势开始之前容我再吹一波VSCode,讲讲他的优势,VSCode的前景比很多人想象的更大,如果你现在还没有一个主力开发环境,那么我首推VSCode,当然了Idea之于Java、Xcode之于swift/OC等等是无可撼动的. 定位准确对于VSCode到底算IDE还是算Editor至今都有一定争议,如果算IDE它远没有到Idea、VS那种开箱即用的程度，如果算是Editor，那么VSCode天然集成了版本管理、调试、代码理解等功能，其实这是VSCode团队有意为之的,他们在两者之间寻找最佳平衡点，VSCode就是一个介于IDE和Editor之间的类IDE.类IEDVSCode兼顾了编辑器的轻量级和IDE开箱即用,如果你是一个前端开发者,可能只需要下载几个插件就能愉快地开始编码了. 海量插件VSCode的插件生态太繁荣了,常用的几乎所有需求都可以通过插件去解决,甚至会有非常多的娱乐插件.比如,用VSCode听歌用VSCode刷题甚至用VSCode炒股当然,以上的插件我都没下载,纯属娱乐.VSCode目前对前端生态的插件支持最为繁荣,这也是VSCode插件基于Typescript编写的结果,而对于其他语言的支持也趋于完善,但是依然没办法跟Idea和VS这种特定语言的完美开发环境媲美(这也是我为什么写Java还是用Idea的原因),如果你的语言没有特别好的IDE,VSCode会是首选. 开源我个人认为VSCode最大的优势就是开源,除了能吸引更多的用户和社区贡献之外,还有一个关键就是Cloud IDE的逐渐进入主流.那么VSCode跟Cloud IDE有什么关系呢?Cloud IDE基于浏览器运行,势必得借助Web技术,而传统的桌面技术发挥空间有限,由于VSCode开源且拥有巨大用户,又是基于Chromium渲染,后续各个厂商开发的Cloud IDE都势必会兼容VSCode生态,此后VSCode可能会成为web IDE的标准.而事实上这些情况已经在发生了,据我了解,国内一些大厂开发Cloud IDE的团队的一个目标就是兼容VSCode的插件生态,而且在体验上向VSCode靠齐.以后服务上云是不可逆的趋势,Cloud IDE天生为云端而生,也会是将来的一个趋势: Cloud IDE无需安装,在任何电脑、任何环境下都可以在统一的云端开发. 解放本地资源,Cloud IDE在云端开发,只要你的电脑不是卡的不能打字,就能在云端非常流畅地开发,你可以用3000块笔记本享受顶配MBP的体验. 统一团队,云端开发环境的工作区依赖容器,一个容器可以分享给整个团队的开发者,团队的开发环境从此统一,再也不会有「在我这能跑通啊，你那什么情况？」 所以，如果你现在用了VSCode，将来在云端开发的时候会减少很多阻力. VSCode插件推荐 版本管理插件GitLens: 虽然VSCode内置了Git版本管理工具,但是依然不够强大,比如不能比较commit如何阅读差异,而GitLens是内置Git工具的完美代替者.GitLensGit Project Manager: 在VSCode中迅速以git Project为维度打开窗口的神器Git Project ManagerGitHub Pull Request: GitHub用户的神器,开发者可以在VS Code中查看和审核 GitHub 上的 Pull Request,比较VSCode的代码阅读体验要比GitHub好太多.GitHub Pull Request 提示类插件Rainbow Brackets: 非常常用的功能,将括号进行颜色配对,有利于代码阅读,减少低级错误各种括号提示Indent Rainbow: 除了括号之外,还有一个影响阅读的就是缩进,恰好Indent Rainbow提供了缩进提示缩进提示vscode-pigments: CSS开发的利器,对应代码将被其颜色渲染pigmentsImport Cost: 它会提示你你引入的npm包的大小,十分有利于管控项目体积引入npm自动显示TODO Highlight: 经常在代码里写了// TODO后这个坑就忘记填了,这个插件通过高亮来时刻提示开发者记着填坑TODO Highlight 配置类插件Settings Sync: 换机神器,我之前经历过换机后从头到尾自己配置了一遍VSCode,耗时耗力,直到后面知道有Settings Sync同步工具.Settings SyncWakaTime: 通过此插件可以监控你每天编码的时间情况,用了之后你会发现,你的编码时间远远小于工作时长,我们都被各种琐事磨掉了时间.WakaTime 自动类插件Prettier: Prettier名声在外,不多介绍了,代码美化神器,从此告别手动美化.PrettierChange Case: 文本转换神器,可以用于转驼峰、大小写转换、下划线转换等命名转换神器Code Runner: 立即执行代码,支持市面上几乎所有主流语言立即运行代码 新插件VS Code Remote: 非常强大的插件,直接通过VSCode在远程服务器中开发,配置好SSH之后一键连接服务器,告别Vim用VSCode在服务器编码是非常爽的体验,我现在是此插件的重度用户笔者已经连接了两台服务器]]></content>
  </entry>
  <entry>
    <title><![CDATA[MVVM]]></title>
    <url>%2F2019%2F10%2F19%2Fyuque%2FMVVM%2F</url>
    <content type="text"><![CDATA[简单的双向绑定，不是MVVM的 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt; &lt;title&gt;如何实现双向绑定 mvvm&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello, &lt;span id="name"&gt;&lt;/span&gt;&lt;/p&gt; &lt;input type="text" id="input" /&gt; &lt;script&gt; const obj = &#123; input: "" &#125;; const inputDOM = document.getElementById("input"); const nameDOM = document.getElementById("name"); inputDOM.addEventListener("input", function(e) &#123; obj.input = e.target.value; &#125;); Object.defineProperty(obj, "input", &#123; set: function(newValue) &#123; nameDOM.innerHTML = newValue.trim().toUpperCase(); &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 正宗的MVVM，通过双向绑定来解说 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt; &lt;title&gt;如何实现双向绑定 mvvm&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;input type="text" v-model="school.name" /&gt; &lt;div&gt;姓名：&#123;&#123; school.name &#125;&#125;&lt;/div&gt; &lt;div&gt;年龄：&#123;&#123; school.age &#125;&#125;&lt;/div&gt; 介绍：&#123;&#123; getNewName &#125;&#125; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;1&lt;/li&gt; &lt;/ul&gt; &lt;button v-on:click="change"&gt;更新操作&lt;/button&gt; 消息： &lt;div v-html="message"&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- &lt;script src="./node_modules/vue/dist/vue.min.js"&gt;&lt;/script&gt; --&gt; &lt;script src="./MVVM.js"&gt;&lt;/script&gt; &lt;script&gt; let vm = new Vue(&#123; el: "#app", data: &#123; school: &#123; name: "芳草", age: 30 &#125;, message: "&lt;h1&gt;欢迎大家&lt;/h1&gt;" &#125;, computed: &#123; getNewName() &#123; return this.school.name + "架构"; &#125; &#125;, methods: &#123; change() &#123; this.school.name = "天涯"; &#125; &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307//MVVM.js//https://github.com/DMQ/mvvm/** * 观察者（发布订阅） 观察者 被观察者 * * @class Dep */class Dep &#123; constructor() &#123; this.subs = []; //存放所有的watcher &#125; //订阅 addSub(watcher) &#123; //添加watcher this.subs.push(watcher); &#125; //发布 notify() &#123; this.subs.forEach(watcher =&gt; &#123; watcher.update(); &#125;); &#125;&#125;/** * 观察者 * * @class Watcher */class Watcher &#123; /** *Creates an instance of Watcher. * @param &#123;*&#125; vm 数据 * @param &#123;*&#125; expr 表达式 * @param &#123;*&#125; cb callback * @memberof Watcher */ constructor(vm, expr, cb) &#123; this.vm = vm; this.expr = expr; this.cb = cb; //默认先存放一个老值 this.oldValue = this.get(); &#125; get() &#123; // vm.$data.school vm.$data.school.name Dep.target = this; //先把自己放在this上 //取值 把这个观察者 和数据关联起来 let value = CompileUtil.getVal(this.vm, this.expr); Dep.target = null; //不取消 任何值取值，都会添加watcher return value; &#125; update() &#123; //更新操作 数据变化后 会调用观察者的update方法 let newVal = CompileUtil.getVal(this.vm, this.expr); if (newVal !== this.oldValue) &#123; this.cb(newVal); &#125; &#125;&#125;// vm.$watch(vm, 'school.name', newVal =&gt; &#123; &#125;)//实现数据挟持过程class Observer &#123; constructor(data) &#123; this.observer(data); &#125; observer(data) &#123; if (data &amp;&amp; typeof data === "object") &#123; //如果是对象 for (let key in data) &#123; this.defineReactive(data, key, data[key]); &#125; &#125; &#125; defineReactive(obj, key, value) &#123; this.observer(value); // school : [watcher,warcher] b:[wartcher] let dep = new Dep(); //给每一个属性 都加上一个具有发布订阅的功能 Object.defineProperty(obj, key, &#123; get() &#123; //创建watcher时 回取到对应的内容，并且把wartcher放到了全局上 Dep.target &amp;&amp; dep.addSub(Dep.target); return value; &#125;, set: newVal =&gt; &#123; if (newVal !== value) &#123; // 新的值是object的话，进行监听 this.observer(newVal); value = newVal; // 通知订阅者 dep.notify(); &#125; &#125; &#125;); &#125;&#125;//基类 调度 解析模板指令class Compiler &#123; constructor(el, vm) &#123; // 判断el属性 是不是一个元素 如果不是元素 那就获取 this.el = this.isElementNode(el) ? el : document.querySelector(el); //把当前节点中的元素 获取到 放到内存中 this.vm = vm; let fragment = this.node2fragment(this.el); //把节点中的内容进行替换 //编译模版 用数据编译 this.compile(fragment); //把内容再塞到页面中 this.el.appendChild(fragment); &#125; isDirective(attrName) &#123; return attrName.startsWith("v-"); &#125; //编译元素 compileElement(node) &#123; let attributes = node.attributes; //类数组 [...attributes].forEach(attr =&gt; &#123; let &#123; name, value: expr &#125; = attr; //判断是不是指令 if (this.isDirective(name)) &#123; let [, directive] = name.split("-"); //v-on:click let [directiveName, eventName] = directive.split(":"); CompileUtil[directiveName](node, expr, this.vm, eventName); &#125; &#125;); &#125; //编译文本 compileText(node) &#123; //判断当前文本节点中内容是否包含&#123;&#123;xxx&#125;&#125; let content = node.textContent; if (/\&#123;\&#123;(.+?)\&#125;\&#125;/.test(content)) &#123; // console.log(content); //找到所有文本 //文本节点 CompileUtil["text"](node, content, this.vm); //&#123;&#123;a&#125;&#125; &#123;&#123;b&#125;&#125; &#125; &#125; //核心的编译方法 compile(node) &#123; //用来编译内存中的dom节点 let childNodes = node.childNodes; [...childNodes].forEach(child =&gt; &#123; if (this.isElementNode(child)) &#123; this.compileElement(child); //如果是元素的话 需要把自己传进去 再去遍历子节点 this.compile(child); &#125; else &#123; this.compileText(child); &#125; &#125;); &#125; //把节点移动到内存中 node2fragment(node) &#123; //创建一个文档节点 let fragment = document.createDocumentFragment(); let firstChild; // 将原生节点拷贝到fragment while ((firstChild = node.firstChild)) &#123; //appendChild具有移动性 fragment.appendChild(firstChild); &#125; return fragment; &#125; isElementNode(node) &#123; //是不是元素节点 return node.nodeType === 1; &#125;&#125;// 指令处理集合CompileUtil = &#123; //根据表达式来取到对应的数据 getVal(vm, expr) &#123; // let arr = expr.split("."); // if (arr.length === 0) &#123; // return vm.$data[expr]; // &#125; return expr .replace(/^\s+(.*?)\s+$/g, "$1") .split(".") .reduce((data, current) =&gt; &#123; return data[current]; &#125;, vm.$data); &#125;, setValue(vm, expr, value) &#123; expr.replace(/^\s+(.*?)\s+$/g, "$1") .split(".") .reduce((data, current, index, arr) =&gt; &#123; if (index == arr.length - 1) &#123; data[current] = value; &#125; return data[current]; &#125;, vm.$data); &#125;, //解析v-model这个指令 model(node, expr, vm) &#123; //给输入框赋予value属性 node.value=xxx let fn = this.updater["modelUpdater"]; new Watcher(vm, expr, newVal =&gt; &#123; //给输入框加一个观察者 数据更新后会出发此方法，会拿新值 给输入框赋值 fn(node, newVal); &#125;); node.addEventListener("input", e =&gt; &#123; let value = e.target.value; this.setValue(vm, expr, value); &#125;); let value = this.getVal(vm, expr); fn(node, value); &#125;, html(node, expr, vm) &#123; //v-html="message" let fn = this.updater["htmlUpdater"]; new Watcher(vm, expr, newVal =&gt; &#123; //给输入框加一个观察者 数据更新后会出发此方法，会拿新值 给输入框赋值 fn(node, newVal); &#125;); let value = this.getVal(vm, expr); fn(node, value); &#125;, getContentValue(vm, expr) &#123; //遍历表达式 将内容 重新替换成一个完整的内容 返还回去 return expr.replace(/\&#123;\&#123;(.+?)\&#125;\&#125;/g, (...args) =&gt; &#123; return this.getVal(vm, args[1]); &#125;); &#125;, on(node, expr, vm, eventName) &#123; //expr: v-on:click="change" node.addEventListener(eventName, e =&gt; &#123; vm[expr].call(vm, e); &#125;); &#125;, text(node, expr, vm) &#123; let fn = this.updater["textUpdater"]; let content = expr.replace(/\&#123;\&#123;(.+?)\&#125;\&#125;/g, (...args) =&gt; &#123; //给表达式每个人 &#123;&#123;&#125;&#125; 都加上观察者 new Watcher(vm, args[1], newVal =&gt; &#123; fn(node, this.getContentValue(vm, expr)); //返回了一个全的字符串 &#125;); return this.getVal(vm, args[1]); &#125;); fn(node, content); &#125;, updater: &#123; //把数据插入到节点中 modelUpdater(node, value) &#123; // node.value = value; node.value = typeof value == "undefined" ? "" : value; &#125;, htmlUpdater(node, value) &#123; //xss攻击 // node.innerHTML = value; node.innerHTML = typeof value == "undefined" ? "" : value; &#125;, textUpdater(node, value) &#123; // node.textContent = value; node.textContent = typeof value == "undefined" ? "" : value; &#125; &#125;&#125;;class Vue &#123; constructor(options) &#123; this.$el = options.el; this.$data = options.data; let computed = options.computed; let methods = options.methods; //这个根元素 存在 编译模版 if (this.$el) &#123; //把数据 全部转化成用Object.defineProperty来定义 new Observer(this.$data); for (let key in computed) &#123; Object.defineProperty(this.$data, key, &#123; get: () =&gt; &#123; return computed[key].call(this); &#125; &#125;); &#125; for (let key in methods) &#123; Object.defineProperty(this, key, &#123; get() &#123; return methods[key]; &#125; &#125;); &#125; //把数据获取操作 vm上的取值操作 都代理套vm.$data this.proxyVm(this.$data); new Compiler(this.$el, this); &#125; &#125; proxyVm(data) &#123; for (let key in data) &#123; Object.defineProperty(this, key, &#123; get() &#123; return data[key]; &#125; &#125;); &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[React可以写命令行，你知道吗？]]></title>
    <url>%2F2019%2F10%2F17%2Fyuque%2FReact%E5%8F%AF%E4%BB%A5%E5%86%99%E5%91%BD%E4%BB%A4%E8%A1%8C%EF%BC%8C%E4%BD%A0%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[https://mp.weixin.qq.com/s/IK0X1LwS1BD5RCaCyRKxSQReact可以写命令行，你知道吗？ 一、介绍命令行工具，大家应该比较熟悉了。比如我们平常使用的vue-cli、create-react-app、angular-cli等工具，这类都是命令行工具。一个好的命令行工具，能给对应的框架加分，也同时显示出了框架开发者的水平。那么，如何写出一个好看的命令行呢？本文给大家介绍一些，如何使用React来写命令行，来达到更好用的命令行的效果。 二、入门实践 2.1 新建工程12345678// 创建一个工程路径mkdir helloworld// 进入这个目录cd helloworld// 初始化npmnpm init -y// 安装依赖npm install ink react import-jsx -s 2.2 编写代码我们创建index.js文件 12'use strict';require('import-jsx')('./hello'); 然后我们再新建一个hello.js: 1234567891011121314151617181920212223242526272829'use strict';const React = require('react');const &#123;render, Color&#125; = require('ink');class Counter extends React.Component &#123; constructor() &#123; super(); this.state = &#123; counter: 0 &#125;; &#125; render() &#123; return ( &lt;Color green&gt; &#123;this.state.counter&#125; tests passed &lt;/Color&gt; ); &#125; componentDidMount() &#123; this.timer = setInterval(() =&gt; &#123; this.setState(prevState =&gt; (&#123; counter: prevState.counter + 1 &#125;)); &#125;, 100); &#125; componentWillUnmount() &#123; clearInterval(this.timer); &#125;&#125;render(&lt;Counter/&gt;); 文件结构如下： 2.3 运行代码我们运行我们的代码 1node ./index.js 然后我们看到：image.png然后tests前面的数字不停地在变化，然后按ctrl + c 可以退出我们的命令行。 2.4 解释写过react的很好理解，render函数里面就是会输出原先的界面信息，内部用到了state.counter的变量。由于在componentDidMount这个生命周期创建了一个定时器，每100ms修改一下这个变量。最终我们看到了tests passed前面的数字不停的在变化。如果我们想要让他输出一下，就退出，那就把这个定时器删除就好了。 三、进阶实践前面我们看到了一个基本的react写一个命令行程序的例子。下面让我们深入学习 3.1 文档地址我们看到上面我们用的最核心的是ink，大家可以打开ink的地址：https://github.com/vadimdemedes/ink 3.2 普通组件进阶篇，我们可以首先看一下作者给我们提供了哪些组件： Box Color Text3.3 生态组件 Input组件：https://github.com/vadimdemedes/ink-text-input2. 旋转Spinner组件： https://github.com/vadimdemedes/ink-spinner3. 选择组件：https://github.com/vadimdemedes/ink-select-input4.超链接组件：https://github.com/sindresorhus/ink-link5.大banner组件：https://github.com/sindresorhus/ink-box6.颜色渐进组件：https://github.com/sindresorhus/ink-gradient7.大字组件：https://github.com/sindresorhus/ink-big-text8.图片显示组件：https://github.com/kevva/ink-image9. tab选择组件：https://github.com/jdeniau/ink-tab10. 带背景色的组件：https://github.com/LitoMore/ink-color-pipe11.多选组件：https://github.com/karaggeorge/ink-multi-select12.分割线组件：https://github.com/JureSotosek/ink-divider四、可学习的软件4.1 命令行输出emoji的工具代码地址：https://github.com/sindresorhus/emoj效果：4.2 命令行查找npm包的工具代码地址：https://github.com/maticzav/emma-cli效果：4.3 命令行查找changelog工具代码地址：https://github.com/jdeniau/changelog-view总结所以本文主要介绍了如何使用React去开发炫酷的命令行工具。如果听了之后，对你有所启发和帮助，希望能帮忙转发一下。本公众号特点：分享Node相关好玩好用的东西，希望各位看官关注下面公众号，如果有问题，也可以发送问题给我]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端码农之蜕变 — AST（抽象语法树）]]></title>
    <url>%2F2019%2F10%2F15%2Fyuque%2F%E5%89%8D%E7%AB%AF%E7%A0%81%E5%86%9C%E4%B9%8B%E8%9C%95%E5%8F%98%20%E2%80%94%20AST%EF%BC%88%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[首先，先说明下该文章是译文，原文出自《AST for JavaScript developers》(https://itnext.io/ast-for-javascript-developers-3e79aeb08343)。很少花时间特地翻译一篇文章，咬文嚼字是件很累的事情，实在是这篇写的太棒了，所以忍不住想和大家一起分享。该译文出自我的博客：https://github.com/CodeLittlePrince/blog/issues/19，我的博客会不定时更新各种类型文章，希望大家支持。OK，我们直接进入正题。 为什么要谈AST（抽象语法树）?如果你查看目前任何主流的项目中的 devDependencies，会发现前些年的不计其数的插件诞生。我们归纳一下有：javascript转译、代码压缩、css预处理器、elint、pretiier，等。有很多js模块我们不会在生产环境用到，但是它们在我们的开发过程中充当着重要的角色。所有的上述工具，不管怎样，都建立在了AST这个巨人的肩膀上。 所有的上述工具，不管怎样，都建立在了AST这个巨人的肩膀上。我们定一个小目标，从解释什么是AST开始，然后到怎么从一般代码开始去构建它。我们将简单地接触在AST处理基础上，一些最流行的使用例子和工具。并且，我计划谈下我的js2flowchart项目，它是一个不错的利用AST的demo。OK，让我们开始吧。 什么是AST（抽象语法树）？It is a hierarchical program representation that presents source code structure according to the grammar of a programming language, each AST node corresponds to an item of a source code. 估计很多同学会和图中的喵一样，看完这段官方的定义一脸懵逼。OK，我们来看例子： 这很简化。实际上，正真AST每个节点会有更多的信息。但是，这是大体思想。从纯文纯中，我们将得到树形结构的数据。每个条目和树中的节点一一对应。那怎么从纯文本中得到AST呢？哇哦，我们知道当下的编译器都做了这件事前。那我们就看看一般的编译器怎么做的就可以了。 想做一款编译器是个比较消耗发量的事情，但幸运的是，我们无需贯穿编译器的所有知识点，最后将高级语言转译为二进制代码。我们只需要关注词法分析和预发分析。这两步是从代码中生成AST的关键所在。第一步，词法分析，也叫做扫描scanner。它读取我们的代码，然后把它们按照预定的规则合并成一个个的标识tokens。同时，它会移除空白符，注释，等。最后，整个代码将被分割进一个tokens列表（或者说一维数组）。 当词法分析源代码的时候，它会一个一个字母地读取代码，所以很形象地称之为扫描-scans；当它遇到空格，操作符，或者特殊符号的时候，它会认为一个话已经完成了。第二步，语法分析，也解析器。它会将词法分析出来的数组转化成树形的表达形式。同时，验证语法，语法如果有错的话，抛出语法错误。 当生成树的时候，解析器会删除一些没必要的标识tokens（比如不完整的括号），因此AST不是100%与源码匹配的，但是已经能让我们知道如何处理了。说个题外话，解析器100%覆盖所有代码结构生成树叫做CST（具体语法树） 我们最终得到的。 the-super-tiny-compiler想要学习更多关于编译器的知识？the-super-tiny-compiler，一个贼好的项目。大概200来行代码，几乎每行都有注释。 LangSandbox想要自己创建门编程语言？LangSandbox，一个更好的项目。它演示了如何创造一门编程语言。当然，设计编程语言这样的书市面上也一坨坨。所以，这项目更加深入，与the-super-tiny-compiler的项目将Lisp转为C语言不同，这个项目你可以写一个你自己的语言，并且将它编译成C语言或者机器语言，最后运行它。我能直接用三方库来生成AST吗？当然可以！有一坨坨的三方库可以用。你可以访问astexplorer，然后挑你喜欢的库。astexplorer是一个很棒的网站，你可以在线玩转AST，而且除了js，还有很多其它语言的AST库。 babylon我不得不强调一款我觉得很棒的三方库，叫做babylon。 它被用在大名鼎鼎的babel中，也许这也是它之所以这么火的原因。因为有babel项目的支持，我们可以意料到它将与时俱进，一直支持最新的JS特性，我们可以放心大胆地用，不怕以后JS又出新版导致代码的大规模重构。另外，它的API也非常的简单，容易使用。Ok，现在你知道怎么将代码生成AST了，让我们继续，来看看现实中的用例。第一个用例，我想谈谈代码转化，没错，就是那个货，babel。Babel is not a ‘tool for having ES6 support’. Well, it is, but it is far not only what it is about.经常把beble和支持es6/7/8联系起来，实际上，这也是我们经常用它的原因。但是，它仅仅是一组插件中的一个。我们也可以使用它来压缩代码，react相关预发转译（如jsx），flow插件等。 babel是一个javascript编译器。宏观来说，它分3个阶段运行代码：解析（parsing），转译（transforming），生成（generation）。我们可以给babel 一些javascript代码，它修改代码然后生成新的代码返回。那它是怎样修改代码的呢？没错！它创建了AST，遍历树，修改tokens，最后从AST中生成新的代码。我们来从下面的demo中看下这个过程： 像我之前提到的，babel使用babylon，所以，首先，我们解析代码成AST，然后遍历AST，再反转所有的变量名，最后生成代码。完成！正如我们看到的，第一步（解析）和第三步（生成）看起来非常常规，我们每次都会做这两步。所以，babel接管处理了它俩。最后，我们最为关心的，那就是AST转译这一步了。当我们开发babel-plugin的时候，我们只需要描述转化你AST的节点“visitors”就可以了。 将它加入你的babel插件列表中，设置你webpack的babel-loader配置或者 .babelrc中的plugins即可。如果你想要学习怎么创建你的第一个babel-plugin，可以查看Babel-handbook jscodeshift让我们继续，下一个用例，我想提到的是自动代码重构工具，以及神器JSCodeshift。比如说你想要替换掉所有的老掉牙的匿名函数，把他们变成Lambda表达式（箭头函数）。 ####你的代码编辑器很可能没法这么做，因为这并不是简单地查找替换操作。这时候jscodeshift就登场了。如果你听过 jscodeshift，你很可能也听过 codemods，一开始挺这两个词可能很困惑，不过没关系，接下来就解释。jscodeshift是一个跑 codemods的工具。 codemod是一段描述AST要转化成什么样的代码，这思想和babel的插件如出一辙。 所以，如果你想创建自动把你的代码从旧的框架迁移到新的框架，这就是一种很乃思的方式。举个例子，react 16的prop-types重构。 有很多不同的 codemodes已经创建了，你可以保存你需要的，以免手动的修改一坨坨代码，拿去挥霍吧： https://github.com/facebook/jscodeshift https://github.com/reactjs/react-codemod 最后一个用例，我想要提到Prettier，因为可能每个码农都在日常工作中用到它。 Prettier 格式化我们的代码。它调整长句，整理空格，括号等。所以它将代码作为输入，修改后的代码作为输出。听起来很熟悉是吗？当然！ 思路还是一样。首先，将代码生成AST。之后依然是处理AST，最后生成代码。但是，中间过程其实并不像它看起来那么简单。同样，如果你想学习更多在美化打印背后理论，这里有一本你可以深入的书 《A prettier printer》(http://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf)。 js2flowchart文章迎来尾声，我们继续，今天最后一件事，我想提及的就是我的库，叫做 js2flowchart(4.5 k stars 在 Github)。 ####顾名思义，它将js代码转化生成svg流程图。这是一个很好的例子，因为它向你展现了你，当你拥有AST时，可以做任何你想要做的事。把AST转回成字符串代码并不是必要的，你可以通过它画一个流程图，或者其它你想要的东西。js2flowchart使用场景是什么呢？通过流程图，你可以解释你的代码，或者给你代码写文档；通过可视化的解释学习其他人的代码；通过简单的js语法，为每个处理过程简单的描述创建流程图。 js-code-to-svg-flowchart马上用最简单的方式尝试一下吧，去线上编辑看看 js-code-to-svg-flowchart你也可以在代码中使用它，或者通过CLI，你只需要指向你想生成SVG的文件就行。而且，还有VS Code插件（链接在项目readme中）那么，它还能做什么呢？哇哦，我这里就不废话了，大家有兴趣直接看这个项目的文档吧。OK，那它是如何工作的呢？ 首先，解析代码成AST，然后，我们遍历AST并且生成另一颗树，我称之为工作流树。它删除很多不重要的额tokens，但是将关键块放在一起，如函数、循环、条件等。再之后，我们遍历工作流树并且创建形状树。每个形状树的节点包含可视化类型、位置、在树中的连接等信息。最后一步，我们遍历所有的形状，生成对应的SVG，合并所有的SVG到一个文件中。 结尾寻找和筛选资料着实辛苦，希望同学们可以多多支持！ http://segmentfault.com/a/1190000017152442 https://zhuanlan.zhihu.com/p/51174224]]></content>
  </entry>
  <entry>
    <title><![CDATA[AST(抽象语法树)]]></title>
    <url>%2F2019%2F10%2F15%2Fyuque%2FAST(%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91)%2F</url>
    <content type="text"><![CDATA[打造前端性能平台https://myslide.cn/slides/17099 What is AST什么是AST?AST是Abstract Syntax Tree（抽象语法树）的缩写。生成抽象语法树需要经过两个阶段： 分词（tokenize） 语义分析(parse) 其中，分词是将源码source code分割成语法单元，语义分析是在分词结果之上分析这些语法单元之间的关系。以var a = 42这句代码为例，简单理解，可以得到下面分词结果 12345678910[ &#123;type:'identifier',value:'var'&#125;, &#123;type:'whitespace',value:' '&#125;, &#123;type:'identifier',value:'a'&#125;, &#123;type:'whitespace',value:' '&#125;, &#123;type:'operator',value:'='&#125;, &#123;type:'whitespace',value:' '&#125;, &#123;type:'num',value:'42'&#125;, &#123;type:'sep',value:';'&#125;] 实际使用babylon6解析这一代码时，分词结果为生成的抽象语法树为 1234567891011121314151617181920&#123; "type":"Program", "body":[ &#123; "type":"VariableDeclaration", "kind":"var", "declarations":&#123; "type":"VariableDeclarator", "id":&#123; "type":"Identifier", "value":"a" &#125;, "init":&#123; "type":"Literal", "value":42 &#125; &#125; &#125; ]&#125; 社区中有各种AST parser实现 早期有uglifyjs和esprima espree, 基于esprima，用于eslint,Introducing Espree, an Esprima alternative acorn,号称是相对于esprima性能更优， Acorn: yet another JavaScript parser babylon,出自acorn,用于babel babel-eslint,babel团队维护的，用于配合使用ESLint, GitHub - babel/babel-eslint: ESLint using Babel as the parser. AST in ESLintESLint是一个用来检查和报告JavaScript编写规范的插件化工具，通过配置规则来规范代码，以no-cond-assign规则为例，启用这一规则时，代码中不允许在条件语句中赋值，这一规则可以避免在条件语句中，错误的将判断写成赋值 1234//check ths user's job titleif(user.jobTitle = "manager")&#123; user.jobTitle is now incorrect&#125; ESLint的检查基于AST，除了这些内置规则外，ESLint为我们提供了API，使得我们可以利用源代码生成的AST，开发自定义插件和自定义规则。 123456789module.exports = &#123; rules: &#123; "var-length": &#123; create: function (context) &#123; //规则实现 &#125; &#125; &#125;&#125;; 自定义规则插件的结构如上，在create方法中，我们可以定义我们关注的语法单元类型并且实现相关的规则逻辑，ESLint会在遍历语法树时，进入对应的单元类型时，执行我们的检查逻辑。比如我们要实现一条规则，要求赋值语句中，变量名长度大于两位 123456789101112131415module.exports = &#123; rules: &#123; "var-length": &#123; create: function (context) &#123; return &#123; VariableDeclarator: node =&gt; &#123; if (node.id.name.length &lt; 2) &#123; context.report(node, 'Variable names should be longer than 1 character'); &#125; &#125; &#125;; &#125; &#125; &#125;&#125;; 为这一插件编写package.json 1234567891011&#123; "name": "eslint-plugin-my-eslist-plugin", "version": "0.0.1", "main": "index.js", "devDependencies": &#123; "eslint": "~2.6.0" &#125;, "engines": &#123; "node": "&gt;=0.10.0" &#125;&#125; 在项目中使用时，通过npm安装依赖后，在配置中启用插件和对应规则 123456"plugins": [ "my-eslint-plugin"]"rules": &#123; "my-eslint-plugin/var-length": "warn"&#125; 通过这些配置，便可以使用上述自定义插件。 有时我们不想要发布新的插件，而仅想编写本地自定义规则，这时我们可以通过自定义规则来实现。自定义规则与插件结构大致相同，如下是一个自定义规则，禁止在代码中使用console的方法调用。 123456789101112131415161718192021222324252627282930313233const disallowedMethods = ["log", "info", "warn", "error", "dir"];module.exports = &#123; meta: &#123; docs: &#123; description: "Disallow use of console", category: "Best Practices", recommended: true &#125; &#125;, create(context) &#123; return &#123; Identifier(node) &#123; const isConsoleCall = looksLike(node, &#123; name: "console", parent: &#123; type: "MemberExpression", property: &#123; name: val =&gt; disallowedMethods.includes(val) &#125; &#125; &#125;); // find the identifier with name 'console' if (!isConsoleCall) &#123; return; &#125; context.report(&#123; node, message: "Using console is not allowed" &#125;); &#125; &#125;; &#125;&#125;; AST in Babelhttps://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md https://github.com/Pines-Cheng/blog/issues/53https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.mdBabel是为使用下一代JavaScript语法特性来开发而存在的编译工具，最初这个项目名为6to5，意为将ES6语法转换为ES5。发展到现在，Babel已经形成了一个强大的生态。业界大佬的评价：Babel is the new jQuery Babel的工作过程经过三个阶段，parse、transform、generate，具体来说，如下图所示，在parse阶段，使用babylon库将源代码转换为AST，在transform阶段，利用各种插件进行代码转换，如图中的JSX transform将React JSX转换为plain object，在generator阶段，再利用代码生成工具，将AST转换成代码。 Babel为我们提供了API让我们可以对代码进行AST转换并且进行各种操作 1234567891011121314151617import * as babylon from "babylon";import traverse from "babel-traverse";import generate from "babel-generator";const code = `function square(n) &#123; return n * n;&#125;`const ast = babylon.parse(code);traverse(ast,&#123; enter(path)&#123; if(path.node.type === 'Identifier' &amp;&amp; path.node.name === 'n')&#123; path.node.name = 'x' &#125; &#125;&#125;)generate(ast,&#123;&#125;,code) 直接使用这些API的场景倒不多，项目中经常用到的，是各种Babel插件，比如 babel-plugin-transform-remove-console插件，可以去除代码中所有对console的方法调用，主要代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243module.exports = function(&#123; types: t &#125;) &#123; return &#123; name: "transform-remove-console", visitor: &#123; CallExpression(path, state) &#123; const callee = path.get("callee"); if (!callee.isMemberExpression()) return; if (isIncludedConsole(callee, state.opts.exclude)) &#123; // console.log() if (path.parentPath.isExpressionStatement()) &#123; path.remove(); &#125; else &#123; //var a = console.log() path.replaceWith(createVoid0()); &#125; &#125; else if (isIncludedConsoleBind(callee, state.opts.exclude)) &#123; // console.log.bind() path.replaceWith(createNoop()); &#125; &#125;, MemberExpression: &#123; exit(path, state) &#123; if ( isIncludedConsole(path, state.opts.exclude) &amp;&amp; !path.parentPath.isMemberExpression() ) &#123; //console.log = func if ( path.parentPath.isAssignmentExpression() &amp;&amp; path.parentKey === "left" ) &#123; path.parentPath.get("right").replaceWith(createNoop()); &#125; else &#123; //var a = console.log path.replaceWith(createNoop()); &#125; &#125; &#125; &#125; &#125; &#125;; 使用这一插件，可以将程序中如下调用进行转换 AST in CodemodCodemod可以用来帮助你在一个大规模代码库中，自动化修改你的代码。jscodeshift是一个运行codemods的JavaScript工具，主要依赖于recast和ast-types两个工具库。recast作为JavaScript parser提供AST接口，ast-types提供类型定义。利用jscodeshift接口，完成前面类似功能，将代码中对console的方法调用代码删除 12345678910111213141516171819export default (fileInfo,api)=&gt;&#123; const j = api.jscodeshift; const root = j(fileInfo.source); const callExpressions = root.find(j.CallExpression,&#123; callee:&#123; type:'MemberExpression', object:&#123; type:'Identifier', name:'console' &#125; &#125; &#125;); callExpressions.remove(); return root.toSource();&#125; 如果想要代码看起来更加简洁，也可以使用链式API调用 12345678910111213141516export default (fileInfo,api)=&gt;&#123; const j = api.jscodeshift; return j(fileInfo.source) .find(j.CallExpression,&#123; callee:&#123; type:'MemberExpression', object:&#123; type:'Identifier', name:'console' &#125; &#125; &#125;) .remove() .toSource();&#125; 在了解了jscodeshift之后，头脑中立即出现了一个疑问，就是我们为什么需要jscodeshift呢？利用AST进行代码转换，Babel不是已经完全搞定了吗？带着这个问题进行一番搜索，发现Babel团队这处提交说明babel-core: add options for different parser/generator。前文提到，Babel处理流程中包括了parse、transform和generation三个步骤。在生成代码的阶段，Babel不关心生成代码的格式，因为生成的编译过的代码目标不是让开发者阅读的，而是生成到发布目录供运行的，这个过程一般还会对代码进行压缩处理。 这一次过程在使用Babel命令时也有体现，我们一般使用的命令形式为 1babel src -d dist 而在上述场景中，我们的目标是在代码库中，对源码进行处理，这份经过处理的代码仍需是可读的，我们仍要在这份代码上进行开发，这一过程如果用Babel命令来体现，实际是这样的过程 1babel src -d src 在这样的过程中，我们会检查转换脚本对源代码到底做了哪些变更，来确认我们的转换正确性。这就需要这一个差异结果是可读的，而直接使用Babel完成上述转换时，使用git diff输出差异结果时，这份差异结果是混乱不可读的。基于这个需求，Babel团队现在允许通过配置自定义parser和generator 1234567891011&#123; "plugins":[ "./plugins.js" ], "parserOpts":&#123; "parser":"recast" &#125;, "generatorOpts":&#123; "generator":"recast" &#125;&#125; 假设我们有如下代码，我们通过脚本，将代码中import模式进行修改 12345678910111213141516171819202122232425import fs, &#123;readFile&#125; from 'fs'import &#123;resolve&#125; from 'path'import cp from 'child_process'resolve(__dirname, './thing')readFile('./thing.js', 'utf8', (err, string) =&gt; &#123; console.log(string)&#125;)fs.readFile('./other-thing', 'utf8', (err, string) =&gt; &#123; const resolve = string =&gt; string console.log(resolve())&#125;)cp.execSync('echo "hi"')//转换为import fs from 'fs';import _path from 'path';import cp from 'child_process'_path.resolve(__dirname, './thing')fs.readFile('./thing.js', 'utf8', (err, string) =&gt; &#123; console.log(string)&#125;)fs.readFile('./other-thing', 'utf8', (err, string) =&gt; &#123; const resolve = string =&gt; string console.log(resolve())&#125;)cp.execSync('echo "hi"') 完成这一转换的plugin.js为 1234567891011121314151617181920212223242526272829303132333435363738394041424344module.exports = function(babel) &#123; const &#123; types: t &#125; = babel // could just use https://www.npmjs.com/package/is-builtin-module const nodeModules = [ 'fs', 'path', 'child_process', ] return &#123; name: 'node-esmodule', // not required visitor: &#123; ImportDeclaration(path) &#123; const specifiers = [] let defaultSpecifier path.get('specifiers').forEach(specifier =&gt; &#123; if (t.isImportSpecifier(specifier)) &#123; specifiers.push(specifier) &#125; else &#123; defaultSpecifier = specifier &#125; &#125;) const &#123;node: &#123;value: source&#125;&#125; = path.get('source') if (!specifiers.length || !nodeModules.includes(source)) &#123; return &#125; let memberObjectNameIdentifier if (defaultSpecifier) &#123; memberObjectNameIdentifier = defaultSpecifier.node.local &#125; else &#123; memberObjectNameIdentifier = path.scope.generateUidIdentifier(source) path.node.specifiers.push(t.importDefaultSpecifier(memberObjectNameIdentifier)) &#125; specifiers.forEach(specifier =&gt; &#123; const &#123;node: &#123;imported: &#123;name&#125;&#125;&#125; = specifier const &#123;referencePaths&#125; = specifier.scope.getBinding(name) referencePaths.forEach(refPath =&gt; &#123; refPath.replaceWith( t.memberExpression(memberObjectNameIdentifier, t.identifier(name)) ) &#125;) specifier.remove() &#125;) &#125; &#125; &#125;&#125; 删除和加上parserOpts和generatorOpts设置运行两次，使用git diff命令输出结果，可以看出明显的差异 使用recast 不使用recast AST in WebpackWebpack是一个JavaScript生态的打包工具，其打出bundle结构是一个IIFE(立即执行函数) 1(function(module)&#123;&#125;)([function()&#123;&#125;,function()&#123;&#125;]); Webpack在打包流程中也需要AST的支持，它借助acorn库解析源码，生成AST，提取模块依赖关系 在各类打包工具中，由Rollup提出，Webpack目前也提供支持的一个特性是treeshaking。treeshaking可以使得打包输出结果中，去除没有引用的模块，有效减少包的体积。 1234567891011121314151617181920212223242526//math.jsexport &#123;doMath, sayMath&#125;const add = (a, b) =&gt; a + bconst subtract = (a, b) =&gt; a - bconst divide = (a, b) =&gt; a / bconst multiply = (a, b) =&gt; a * bfunction doMath(a, b, operation) &#123; switch (operation) &#123; case 'add': return add(a, b) case 'subtract': return subtract(a, b) case 'divide': return divide(a, b) case 'multiply': return multiply(a, b) default: throw new Error(`Unsupported operation: $&#123;operation&#125;`) &#125;&#125;function sayMath() &#123; return 'MATH!'&#125;//main.jsimport &#123;doMath&#125;doMath(2, 3, 'multiply') // 6 上述代码中，math.js输出doMath,sayMath方法，main.js中仅引用doMath方法，采用Webpack treeshaking特性，再加上uglify的支持，在输出的bundle文件中，可以去掉sayMath相关代码，输出的math.js形如 12345678910111213141516171819export &#123;doMath&#125;const add = (a, b) =&gt; a + bconst subtract = (a, b) =&gt; a - bconst divide = (a, b) =&gt; a / bconst multiply = (a, b) =&gt; a * bfunction doMath(a, b, operation) &#123; switch (operation) &#123; case 'add': return add(a, b) case 'subtract': return subtract(a, b) case 'divide': return divide(a, b) case 'multiply': return multiply(a, b) default: throw new Error(`Unsupported operation: $&#123;operation&#125;`) &#125;&#125; 进一步分析main.js中的调用，doMath(2, 3, ‘multiply’) 调用仅会执行doMath的一个分支，math.js中定义的一些help方法如add,subtract,divide实际是不需要的，理论上，math.js最优可以被减少为 12345export &#123;doMath&#125;const multiply = (a, b) =&gt; a * bfunction doMath(a, b) &#123; return multiply(a, b)&#125; 基于AST，进行更为完善的代码覆盖率分析，应当可以实现上述效果，这里只是一个想法，没有具体的实践。参考Faster JavaScript with SliceJS 参考文章 writing-custom-eslint-rules Write Code to Rewrite Your Code: jscodeshift The State of Babel Understanding ASTs by Building Your Own Babel Plugin Faster JavaScript with SliceJS Babel是如何读懂JS代码的 https://zhuanlan.zhihu.com/p/32189701]]></content>
  </entry>
  <entry>
    <title><![CDATA[taro]]></title>
    <url>%2F2019%2F09%2F24%2Fyuque%2Ftaro%2F</url>
    <content type="text"><![CDATA[https://taro.jd.com/]]></content>
  </entry>
  <entry>
    <title><![CDATA[React16.9.0]]></title>
    <url>%2F2019%2F08%2F13%2Fyuque%2FReact16.9.0%2F</url>
    <content type="text"><![CDATA[1.将不符合规范的周期函数转换12cd your_projectnpx react-codemod rename-unsafe-lifecycles 将不符合规范的周期函数转换；2.]]></content>
  </entry>
  <entry>
    <title><![CDATA[从URL输入到页面展现到底发生什么？]]></title>
    <url>%2F2019%2F08%2F07%2Fyuque%2F%E4%BB%8EURL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[前言打开浏览器从输入网址到网页呈现在大家面前，背后到底发生了什么？经历怎么样的一个过程？先给大家来张总体流程图，具体步骤请看下文分解！总体来说分为以下几个过程: DNS 解析:将域名解析成 IP 地址 TCP 连接：TCP 三次握手 发送 HTTP 请求 服务器处理请求并返回 HTTP 报文 浏览器解析渲染页面 断开连接：TCP 四次挥手一、URL 到底是啥URL（Uniform Resource Locator），统一资源定位符，用于定位互联网上资源，俗称网址。 比如 http://www.w3school.com.cn/html/index.asp，遵守以下的语法规则：scheme://host.domain:port/path/filename各部分解释如下： scheme - 定义因特网服务的类型。常见的协议有 http、https、ftp、file，其中最常见的类型是 http，而 https 则是进行加密的网络传输。 host - 定义域主机（http 的默认主机是 www） domain - 定义因特网域名，比如 w3school.com.cn port - 定义主机上的端口号（http 的默认端口号是 80） path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。 filename - 定义文档/资源的名称二、域名解析（DNS）在浏览器输入网址后，首先要经过域名解析，因为浏览器并不能直接通过域名找到对应的服务器，而是要通过 IP 地址。大家这里或许会有个疑问—-计算机既可以被赋予 IP 地址，也可以被赋予主机名和域名。比如 www.hackr.jp。那怎么不一开始就赋予个 IP 地址？这样就可以省去解析麻烦。我们先来了解下什么是 IP 地址1.IP 地址IP 地址是指互联网协议地址，是 IP Address 的缩写。IP 地址是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP 地址是一个 32 位的二进制数，比如 127.0.0.1 为本机 IP。域名就相当于 IP 地址乔装打扮的伪装者，带着一副面具。它的作用就是便于记忆和沟通的一组服务器的地址。用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 IP 地址访问。因为与 IP 地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯。但要让计算机去理解名称，相对而言就变得困难了。因为计算机更擅长处理一长串数字。为了解决上述的问题，DNS 服务应运而生。2.什么是域名解析DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。DNS 是一个网络服务器，我们的域名解析简单来说就是在 DNS 上记录一条信息记录。 例如 baidu.com 220.114.23.56（服务器外网IP地址）80（服务器端口号）3. 浏览器如何通过域名去查询 URL 对应的 IP 呢 浏览器缓存：浏览器会按照一定的频率缓存 DNS 记录。 操作系统缓存：如果浏览器缓存中找不到需要的 DNS 记录，那就去操作系统中找。 路由缓存：路由器也有 DNS 缓存。 ISP 的 DNS 服务器：ISP 是互联网服务提供商(Internet Service Provider)的简称，ISP 有专门的 DNS 服务器应对 DNS 查询请求。 根服务器：ISP 的 DNS 服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS 服务器先问根域名服务器.com 域名服务器的 IP 地址，然后再问.baidu 域名服务器，依次类推） 4. 小结浏览器通过向 DNS 服务器发送域名，DNS 服务器查询到与域名相对应的 IP 地址，然后返回给浏览器，浏览器再将 IP 地址打在协议上，同时请求参数也会在协议搭载，然后一并发送给对应的服务器。接下来介绍向服务器发送 HTTP 请求阶段，HTTP 请求分为三个部分：TCP 三次握手、http 请求响应信息、关闭 TCP 连接。 三、TCP 三次握手在客户端发送数据之前会发起 TCP 三次握手用以同步客户端和服务端的序列号和确认号，并交换 TCP 窗口大小信息。 1.TCP 三次握手的过程如下： 客户端发送一个带 SYN=1，Seq=X 的数据包到服务器端口（第一次握手，由浏览器发起，告诉服务器我要发送请求了） 服务器发回一个带 SYN=1， ACK=X+1， Seq=Y 的响应包以示传达确认信息（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧） 客户端再回传一个带 ACK=Y+1， Seq=Z 的数据包，代表“握手结束”（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）2.为啥需要三次握手谢希仁著《计算机网络》中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。四、发送 HTTP 请求 TCP 三次握手结束后，开始发送 HTTP 请求报文。 请求报文由请求行（request line）、请求头（header）、请求体四个部分组成,如下图所示： 1.请求行包含请求方法、URL、协议版本 请求方法包含 8 种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。 URL 即请求地址，由 &lt;协议&gt;：//&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt;?&lt;参数&gt; 组成 协议版本即 http 版本号 POST /chapter17/user.html HTTP/1.1 以上代码中“POST”代表请求方法，“/chapter17/user.html”表示 URL，“HTTP/1.1”代表协议和协议的版本。现在比较流行的是 Http1.1 版本 2.请求头包含请求的附加信息，由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息。它包含许多有关的客户端环境和请求正文的有用信息。其中比如：Host，表示主机名，虚拟主机；Connection,HTTP/1.1 增加的，使用 keepalive，即持久连接，一个连接可以发多个请求；User-Agent，请求发出者，兼容性以及定制化需求。 3.请求体，可以承载多个请求参数的数据，包含回车符、换行符和请求数据，并不是所有请求都具有请求数据。 name=tom&amp;password=1234&amp;realName=tomson 上面代码，承载着 name、password、realName 三个请求参数。 五、服务器处理请求并返回 HTTP 报文 1. 服务器服务器是网络环境中的高性能计算机，它侦听网络上的其他计算机（客户机）提交的服务请求，并提供相应的服务，比如网页服务、文件下载服务、邮件服务、视频服务。而客户端主要的功能是浏览网页、看视频、听音乐等等，两者截然不同。 每台服务器上都会安装处理请求的应用——web server。常见的 web server 产品有 apache、nginx、IIS 或 Lighttpd 等。web server 担任管控的角色，对于不同用户发送的请求，会结合配置文件，把不同请求委托给服务器上处理相应请求的程序进行处理（例如 CGI 脚本，JSP 脚本，servlets，ASP 脚本，服务器端 JavaScript，或者一些其它的服务器端技术等），然后返回后台程序处理产生的结果作为响应。 2.MVC 后台处理阶段后台开发现在有很多框架，但大部分都还是按照 MVC 设计模式进行搭建的。 MVC 是一个设计模式，将应用程序分成三个核心部件：模型（model）– 视图（view）–控制器（controller），它们各自处理自己的任务，实现输入、处理和输出的分离。 1、视图（view） 它是提供给用户的操作界面，是程序的外壳。 2、模型（model） 模型主要负责数据交互。在 MVC 的三个部件中，模型拥有最多的处理任务。一个模型能为多个视图提供数据。 3、控制器（controller） 它负责根据用户从”视图层”输入的指令，选取”模型层”中的数据，然后对其进行相应的操作，产生最终结果。控制器属于管理者角色，从视图接收请求并决定调用哪个模型构件去处理请求，然后再确定用哪个视图来显示模型处理返回的数据。 这三层是紧密联系在一起的，但又是互相独立的，每一层内部的变化不影响其他层。每一层都对外提供接口（Interface），供上面一层调用。 至于这一阶段发生什么？简而言之，首先浏览器发送过来的请求先经过控制器，控制器进行逻辑处理和请求分发，接着会调用模型，这一阶段模型会获取 redis db 以及 MySQL 的数据，获取数据后将渲染好的页面，响应信息会以响应报文的形式返回给客户端，最后浏览器通过渲染引擎将网页呈现在用户面前。 3.http 响应报文响应报文由响应行（request line）、响应头部（header）、响应主体三个部分组成。如下图所示：(1) 响应行包含：协议版本，状态码，状态码描述状态码规则如下： 1xx：指示信息–表示请求已接收，继续处理。 2xx：成功–表示请求已被成功接收、理解、接受。 3xx：重定向–要完成请求必须进行更进一步的操作。 4xx：客户端错误–请求有语法错误或请求无法实现。 5xx：服务器端错误–服务器未能实现合法的请求。(2) 响应头部包含响应报文的附加信息，由 名/值 对组成(3) 响应主体包含回车符、换行符和响应返回数据，并不是所有响应报文都有响应数据 六、浏览器解析渲染页面浏览器拿到响应文本 HTML 后，接下来介绍下浏览器渲染机制浏览器解析渲染页面分为一下五个步骤： 根据 HTML 解析出 DOM 树 根据 CSS 解析生成 CSS 规则树 结合 DOM 树和 CSS 规则树，生成渲染树 根据渲染树计算每一个节点的信息 根据计算好的信息绘制页面 1.根据 HTML 解析 DOM 树 根据 HTML 的内容，将标签按照结构解析成为 DOM 树，DOM 树解析的过程是一个深度优先遍历。即先构建当前节点的所有子节点，再构建下一个兄弟节点。 在读取 HTML 文档，构建 DOM 树的过程中，若遇到 script 标签，则 DOM 树的构建会暂停，直至脚本执行完毕。 2.根据 CSS 解析生成 CSS 规则树 解析 CSS 规则树时 js 执行将暂停，直至 CSS 规则树就绪。 浏览器在 CSS 规则树生成之前不会进行渲染。 3.结合 DOM 树和 CSS 规则树，生成渲染树 DOM 树和 CSS 规则树全部准备好了以后，浏览器才会开始构建渲染树。 精简 CSS 并可以加快 CSS 规则树的构建，从而加快页面相应速度。 4.根据渲染树计算每一个节点的信息（布局） 布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸 回流：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。 5.根据计算好的信息绘制页面 绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。 重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘。 回流：某个元素的尺寸发生了变化，则需重新计算渲染树，重新渲染。 七、断开连接 当数据传送完毕，需要断开 tcp 连接，此时发起 tcp 四次挥手。 发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FINWAIT1 状态。(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧) 被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FINWAIT2 状态。(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧) 被动方向发起方发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态。(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧) 发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)参考文章 从输入页面地址到展示页面信息都发生了些什么？ 前端经典面试题: 从输入 URL 到页面加载发生了什么？ TCP 的三次握手四次挥手 访问 Web，tcp 传输全过程（三次握手、请求、数据传输、四次挥手） 浏览器发送 http 请求过程分析 谢希仁著《计算机网络》第四版 图解 http]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端开发者必备的nginx知识]]></title>
    <url>%2F2019%2F08%2F07%2Fyuque%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%80%85%E5%BF%85%E5%A4%87%E7%9A%84nginx%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[nginx在应用程序中的作用 解决跨域 请求过滤 配置gzip 负载均衡 静态资源服务器 nginx是一个高性能的HTTP和反向代理服务器，也是一个通用的TCP/UDP代理服务器，最初由俄罗斯人Igor Sysoev编写。 nginx现在几乎是众多大型网站的必用技术，大多数情况下，我们不需要亲自去配置它，但是了解它在应用程序中所担任的角色，以及如何解决这些问题是非常必要的。下面我将从nginx在企业中的真实应用来解释nginx在应用程序中起到的作用。为了便于理解，首先先来了解一下一些基础知识， nginx是一个高性能的反向代理服务器那么什么是反向代理呢？ 正向代理与反向代理代理是在服务器和客户端之间假设的一层服务器，代理将接收客户端的请求并将它转发给服务器，然后将服务端的响应转发给客户端。不管是正向代理还是反向代理，实现的都是上面的功能。 正向代理 正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。 正向代理是为我们服务的，即为客户端服务的，客户端可以根据正向代理访问到它本身无法访问到的服务器资源。正向代理对我们是透明的，对服务端是非透明的，即服务端并不知道自己收到的是来自代理的访问还是来自真实客户端的访问。 反向代理 反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。 反向代理是为服务端服务的，反向代理可以帮助服务器接收来自客户端的请求，帮助服务器做请求转发，负载均衡等。反向代理对服务端是透明的，对我们是非透明的，即我们并不知道自己访问的是代理服务器，而服务器知道反向代理在为他服务。 基本配置 配置结构下面是一个nginx配置文件的基本结构： events { } http { server { location path { ... } location path { ... } } server { ... } } main:nginx的全局配置，对全局生效。 events:配置影响nginx服务器或与用户的网络连接。 http：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。 server：配置虚拟主机的相关参数，一个http中可以有多个server。 location：配置请求的路由，以及各种页面的处理情况。 upstream：配置后端服务器具体地址，负载均衡配置不可或缺的部分。内置变量下面是 nginx一些配置中常用的内置全局变量，你可以在配置的任何位置使用它们。 变量名 功能 $host 请求信息中的 Host，如果请求中没有 Host行，则等于设置的服务器名 $request_method 客户端请求类型，如 GET、 POST $remote_addr 客户端的 IP地址 $args 请求中的参数 $content_length 请求头中的 Content-length字段 $http_user_agent 客户端agent信息 $http_cookie 客户端cookie信息 $remote_addr 客户端的IP地址 $remote_port 客户端的端口 $server_protocol 请求使用的协议，如 HTTP/1.0、·HTTP/1.1` $server_addr 服务器地址 $server_name 服务器名称 $server_port 服务器的端口号 解决跨域先追本溯源以下，跨域究竟是怎么回事。 跨域的定义同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。通常不允许不同源间的读操作。 同源的定义如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的源。 nginx解决跨域的原理例如： 前端server的域名为： fe.server.com 后端服务的域名为： dev.server.com 现在我在 fe.server.com对 dev.server.com发起请求一定会出现跨域。现在我们只需要启动一个nginx服务器，将 server_name设置为 fe.server.com,然后设置相应的location以拦截前端需要跨域的请求，最后将请求代理回 dev.server.com。如下面的配置： server { listen 80; server_name fe.server.com; location / { proxy_pass dev.server.com; } } 这样可以完美绕过浏览器的同源策略： fe.server.com访问 nginx的 fe.server.com属于同源访问，而 nginx对服务端转发的请求不会触发浏览器的同源策略。 请求过滤根据状态码过滤 error_page 500 501 502 503 504 506 /50x.html; location = /50x.html { #将跟路径改编为存放html的路径。 root /root/static/html; } 根据URL名称过滤，精准匹配URL，不匹配的URL全部重定向到主页。 location / { rewrite ^.*$ /index.html redirect; } 根据请求类型过滤。 if ( $request_method !~ ^(GET|POST|HEAD)$ ) { return 403; } 配置gzipGZIP是规定的三种标准HTTP压缩格式之一。目前绝大多数的网站都在使用 GZIP传输 HTML、 CSS、 JavaScript 等资源文件。对于文本文件， GZip 的效果非常明显，开启后传输所需流量大约会降至 1/4~1/3。并不是每个浏览器都支持 gzip的，如何知道客户端是否支持 gzip呢，请求头中的 Accept-Encoding来标识对压缩的支持。启用 gzip同时需要客户端和服务端的支持，如果客户端支持 gzip的解析，那么只要服务端能够返回 gzip的文件就可以启用 gzip了,我们可以通过 nginx的配置来让服务端支持 gzip。下面的 respone中 content-encoding:gzip，指服务端开启了 gzip的压缩方式。 gzip on; gzip_http_version 1.1; gzip_comp_level 5; gzip_min_length 1000; gzip_types text/csv text/xml text/css text/plain text/javascript application/javascript application/x-javascript application/json application/xml; gzip 开启或者关闭 gzip模块 默认值为 off 可配置为 on/off gziphttpversion 启用 GZip 所需的 HTTP 最低版本 默认值为 HTTP/1.1 这里为什么默认版本不是 1.0呢？HTTP 运行在 TCP 连接之上，自然也有着跟 TCP 一样的三次握手、慢启动等特性。启用持久连接情况下，服务器发出响应后让 TCP连接继续打开着。同一对客户/服务器之间的后续请求和响应可以通过这个连接发送。为了尽可能的提高 HTTP 性能，使用持久连接就显得尤为重要了。HTTP/1.1默认支持 TCP持久连接， HTTP/1.0 也可以通过显式指定 Connection:keep-alive 来启用持久连接。对于 TCP持久连接上的 HTTP 报文，客户端需要一种机制来准确判断结束位置，而在 HTTP/1.0中，这种机制只有 Content-Length。而在 HTTP/1.1中新增的 Transfer-Encoding:chunked 所对应的分块传输机制可以完美解决这类问题。nginx同样有着配置 chunked的属性 chunked_transfer_encoding，这个属性是默认开启的。Nginx在启用了 GZip的情况下，不会等文件 GZip 完成再返回响应，而是边压缩边响应，这样可以显著提高 TTFB( TimeToFirstByte，首字节时间，WEB 性能优化重要指标)。这样唯一的问题是， Nginx 开始返回响应时，它无法知道将要传输的文件最终有多大，也就是无法给出 Content-Length这个响应头部。所以，在 HTTP1.0中如果利用 Nginx启用了 GZip，是无法获得 Content-Length的，这导致HTTP1.0中开启持久链接和使用 GZip只能二选一，所以在这里 gzip_http_version默认设置为 1.1。 gzipcomplevel 压缩级别，级别越高压缩率越大，当然压缩时间也就越长（传输快但比较消耗cpu）。 默认值为 1 压缩级别取值为 1-9 gzipminlength 设置允许压缩的页面最小字节数， Content-Length小于该值的请求将不会被压缩 默认值: 0 当设置的值较小时，压缩后的长度可能比原文件大，建议设置 1000以上 gzip_types 要采用gzip压缩的文件类型( MIME类型) 默认值: text/html(默认不压缩 js/ css) 负载均衡 什么是负载均衡如上面的图，前面是众多的服务窗口，下面有很多用户需要服务，我们需要一个工具或策略来帮助我们将如此多的用户分配到每个窗口，来达到资源的充分利用以及更少的排队时间。把前面的服务窗口想像成我们的后端服务器，而后面终端的人则是无数个客户端正在发起请求。负载均衡就是用来帮助我们将众多的客户端请求合理的分配到各个服务器，以达到服务端资源的充分利用和更少的请求时间。 nginx如何实现负载均衡Upstream指定后端服务器地址列表 upstream balanceServer { server 10.1.22.33:12345; server 10.1.22.34:12345; server 10.1.22.35:12345; } 在server中拦截响应请求，并将请求转发到Upstream中配置的服务器列表。 server { server_name fe.server.com; listen 80; location /api { proxy_pass http://balanceServer; } } 上面的配置只是指定了nginx需要转发的服务端列表，并没有指定分配策略。 nginx实现负载均衡的策略轮询策略默认情况下采用的策略，将所有客户端请求轮询分配给服务端。这种策略是可以正常工作的，但是如果其中某一台服务器压力太大，出现延迟，会影响所有分配在这台服务器下的用户。 upstream balanceServer { server 10.1.22.33:12345; server 10.1.22.34:12345; server 10.1.22.35:12345; } 最小连接数策略将请求优先分配给压力较小的服务器，它可以平衡每个队列的长度，并避免向压力大的服务器添加更多的请求。 upstream balanceServer { least_conn; server 10.1.22.33:12345; server 10.1.22.34:12345; server 10.1.22.35:12345; } 最快响应时间策略依赖于NGINX Plus，优先分配给响应时间最短的服务器。 upstream balanceServer { fair; server 10.1.22.33:12345; server 10.1.22.34:12345; server 10.1.22.35:12345; } 客户端ip绑定来自同一个ip的请求永远只分配一台服务器，有效解决了动态网页存在的session共享问题。 upstream balanceServer { ip_hash; server 10.1.22.33:12345; server 10.1.22.34:12345; server 10.1.22.35:12345; } 静态资源服务器 location ~* \.(png|gif|jpg|jpeg)$ { root /root/static/; autoindex on; access_log off; expires 10h;# 设置过期时间为10小时 } 匹配以 png|gif|jpg|jpeg为结尾的请求，并将请求转发到本地路径， root中指定的路径即nginx本地路径。同时也可以进行一些缓存的设置。]]></content>
  </entry>
  <entry>
    <title><![CDATA[DOM事件第二弹（UIEvent事件）]]></title>
    <url>%2F2019%2F08%2F02%2Fyuque%2FDOM%E4%BA%8B%E4%BB%B6%E7%AC%AC%E4%BA%8C%E5%BC%B9%EF%BC%88UIEvent%E4%BA%8B%E4%BB%B6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[此文章主要总结UIEvent相关的事件，如有不对的地方，欢迎指正。 一、uitls.js(绑定事件公共类)123456789101112131415161718192021222324var fixs = &#123; 'focusin': &#123; standard: 'focus', ie: 'focusin' &#125;, 'focusout':&#123; standard: 'blur', ie: 'foucsout' &#125;, 'input': &#123; standard: 'input', ie: 'propertychange' &#125;&#125;var uitls = &#123; bindEvent: function(dom, eventType, fun, useCapture)&#123; var fix = fixs[eventType]; if(document.addEventListener)&#123; dom.addEventListener( fix ? fix.standard : eventType, fun, useCapture); &#125;else&#123; dom.attachEvent('on' + ( fix ? fix.ie : eventType ), fun); &#125; &#125;&#125;; 主要做一些事件名的兼容性处理。 二、baseEvent 事件名 说明 load 在内容或页面加载完成后触发。此节点应用于document的节点上（但不能在document上绑定此事件），可以绑定元素：body、img、frame、frameset、iframe、link、script。js对象：image、windows、layer（h5的） unload 在页面或内容被移除时触发。元素：body、frameset；Js对象：window。 onbeforeunload 提示用户是否关闭当前网页 abort 图片加载完成之前被用户终止时触发，元素：img；js对象：image error 资源加载出错被触发，元素：script、img、style；js对象：window，image select 文本被选中触发，js对象：window 2.1 兼容点 当load事件应用在script元素上时，在Ie不支持，需要用onreadystatechange事件来代替（error会作为一个状态来传递）; script的error，在ie上也是不支持的，也是通过onreadystatechange事件来代替（状态值）。 select相关兼容性参考：’做一个留言板：输入框’2.2 一些代码 12345678910111213141516171819var img = document.getElementById('img');var btn = document.getElementById('btn');uitls.bindEvent(img, 'load', function(event)&#123; console.log('load img');&#125;);uitls.bindEvent(btn, 'click', function(event)&#123; img.src = '../../img/bck.png';&#125;);window.onload = function(event)&#123; console.log('window');&#125;window.onbeforeunload = function(event)&#123; console.log('window onbeforeunload'); return false;&#125;window.onunload = function(evet)&#123; console.log('window unload');&#125;img.src='../../img/a.jpg'; onbeforeunload：可以控制是否向用户提示 离开，还是留在当前页面。三、焦点事件不是所有的标签都支持焦点事件，如div（不可编辑状态）、span、p等这类布局和显示内容的标签不支持焦点事件，主要form、以及form下的标签支持焦点事件。 事件名 说明 focus 获得焦点，不冒泡 blur 失去焦点，不冒泡 focusin 获得焦点，冒泡 focusout 失去焦点，冒泡 DOMFocusin 获得焦点，不冒泡，遗留方案 DOMFocusout 失去焦点，不冒泡，遗留方案 3.1 代理事件的兼容处理方案 ie、opera、chrome等都支持focusin和focusout，但firefox不支持focusin和focusout。 但opera、chrome、firefox的focus和blur不支持冒泡，但支持捕获3.2 实现代码 1234567891011&lt;form id="form" &gt; &lt;input type="text" /&gt; &lt;input type="text" /&gt;&lt;/form&gt;&lt;script src="./uitls.js"&gt;&lt;/script&gt;&lt;script&gt; var _form = document.getElementById('form'); uitls.bindEvent(_form, 'focusin', function(event)&#123; console.log('focusin: ' + ( event.target || event.srcElement )); &#125;, true);&lt;/script&gt; 设置了addEventListener的第三个参数为true，表示在捕获阶段执行。 3.3 代码触focusin事件我们这里需要做一个兼容方案处理，在现代浏览器下需要用focus来触发，因为我们绑定是focus事件。 1234var inputone = document.getElementById('inputone');var focusinEvent = document.createEvent('UIEvents');focusinEvent.initUIEvent('focus',true,true); //后面两个参数为true或false都没有影响， 因为focusin发生在捕获阶段_form.dispatchEvent(focusinEvent); //inputone也可以 四、输入事件(oninput和onpropertychange)实现输入内容的动态监测。 4.1 区别与兼容性 oninput为现代浏览器的特性(ie9+都ok)，只有改变控件的value才会触发oninput，但js改变value不会触发oninput，并且oninput需要只能通过addEventListener注册 onpropertychange可以用attachEvent和.onpropertychanage注册，但input为disable=true的不能执行 oninput，在从浏览器自动下拉提示中选取时，不会触发. 4.2 注意 onpropertychanage事件，是属性值发生改变就会触发，如果我们一个动作导致两个属性值改变，就会触发两次： 1234567891011&lt;select id="sel" &gt; &lt;option value="1" &gt;1&lt;/option&gt; &lt;option value="2" &gt;2&lt;/option&gt; &lt;option value="3" &gt;3&lt;/option&gt; &lt;option value="4" &gt;4&lt;/option&gt;&lt;/select&gt;var sel = document.getElementById('sel');uitls.bindEvent(sel, 'input', function(event)&#123; var target = event.target || event.srcElement; console.log("sel:" + target.value);&#125;); 五、复合事件 事件名 说明 compositionstart ime输入开始 compositionupdate ime接受输入框值改变 compositionend ime输入结束 说明： 这三个事件中传入的event对象，会多一个data属性，代表当前输入的字符。 英文输入状态不会触发这三个事件，只有非英文输入才触发（用输入法来确定的） ie8-不支持此类事件5.1 composition与input事件的结合，以及标准浏览与ie、edge的区别示例代码： 1234567891011121314151617&lt;input id="input" type="text" /&gt;&lt;script src="./uitls.js"&gt;&lt;/script&gt;&lt;script&gt; var input = document.getElementById('input'); uitls.bindEvent(input, 'compositionstart', function(event)&#123; //英文不行，中文可以（识别的是输入法），开始输入状态 console.log('compositionstart: ' + event.target + " " + event.data); &#125;); uitls.bindEvent(input, 'compositionend', function(event)&#123; //输入结束状态 console.log('compositionend: ' + event.target + " " + event.data) &#125;); uitls.bindEvent(input, 'compositionupdate', function(event)&#123; //输入过程中， console.log('compositionupdate: ' + event.target + " " + event.data) &#125;); uitls.bindEvent(input, 'input', function(event)&#123; console.log('input: ' + input.value); &#125;);&lt;/script&gt; 说明： 程序主动触发代码如下： 123var compositionstartEvent = document.createEvent('UIEvents');compositionstartEvent.initUIEvent('compositionstart', false, false);input.dispatchEvent(compositionstartEvent); 转自：https://cloud.tencent.com/developer/article/1021768]]></content>
  </entry>
  <entry>
    <title><![CDATA[Javascript - 事件顺序]]></title>
    <url>%2F2019%2F08%2F02%2Fyuque%2FJavascript%20-%20%E4%BA%8B%E4%BB%B6%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[原文标题：Javascript - Event order原文链接：https://www.quirksmode.org/js/events_order.htmlNetscape 4 只支持事件捕获，Explorer只支持事件冒泡。Netscape 6和 Konqueror冒泡和捕获均支持，但Opera 和iCab冒泡和捕获均不支持。在介绍事件的那篇文章（文章链接：https://www.quirksmode.org/js/introevents.html）中，我提了个看起来比较难以理解的问题：“假设一个元素及其祖先元素的事件句柄指向了同一事件，哪个先触发？”不出意料，这取决于**浏览器**。这个问题其实很简单。假定一个父元素内有一个子元素：———————————–| element1 || ————————- || |element2 | || ————————- || |———————————–二者均有一个onClick事件句柄。如果用户点击了元素2，就会触发元素1和元素2的点击事件。可两个事件哪个先被触发呢？哪个事件句柄先执行呢？换句话说，事件顺序是怎样？ 两种模型可以预见的是，很久以前Netscape和Microsoftde的做法就是截然不同的。 Netscape指定元素1的事件先发生，称之为事件_捕获_。 Microsoft表示元素2的事件先发生，称之为事件_冒泡_。 以上的两种做法完全背道而驰。Explorer只支持事件冒泡。Mozilla,Opera 7和Konqueror冒泡和捕获均支持。旧版本的Opera和iCab冒泡和捕获均不支持。 事件捕获当你使用事件捕获时：| |—————| |—————–| element1 | | || ———–| |———– || |element2 \ / | || ————————- || Event CAPTURING |———————————–元素1的事件句柄先被触发，元素2的事件句柄后被触发。 事件冒泡当你使用事件冒泡时：/ &lt;br /&gt;—————| |—————–| element1 | | || ———–| |———– || |element2 | | | || ————————- || Event BUBBLING |———————————–元素2的事件句柄先被触发，元素1的事件句柄后被触发。 W3C模型W3C明智地在争论中保持了中立。任何发生在W3C事件模型中的事件首先会被捕获，直到它到达目标元素才会冒泡。| | / &lt;br /&gt;—————–| |–| |—————–| element1 | | | | || ————-| |–| |———– || |element2 \ / | | | || ——————————– || W3C event model |——————————————Web开发者可以选择是否在捕获或冒泡阶段注册一个事件句柄。这可以通过在先进模型那篇有相应解释的addEventListener()方法实现。如果它的最后一个参数是true，事件句柄会为捕获阶段而设置，如果是false，事件句柄会为冒泡阶段而设置。假设你这样做了element1.addEventListener(‘click’,doSomething2,true)element2.addEventListener(‘click’,doSomething,false)假如用户点击元素2，会发生以下情况： 点击事件发生在捕获阶段。事件看起来好像元素2的任何祖先元素都有对应于捕获阶段的onclick事件句柄。 元素1上绑定的doSomething2()事件被执行。 事件传递到目标，没有发现任何一个对应捕获阶段的事件句柄。事件移向冒泡阶段并执行在冒泡阶段为元素2注册的doSomething()。 事件又一次向上传递并检查目标的任何祖先元素是否有对应冒泡阶段的事件句柄。最后没有发现任何句柄，因此什么也没发生。 顺序反过来就是element1.addEventListener(‘click’,doSomething2,false)element2.addEventListener(‘click’,doSomething,false)现在如果用户点击元素2，会发生以下情况： 点击事件发生于捕获阶段。事件会查看元素2的任何祖先元素是否存在对于捕获阶段的onclick事件句柄，但没有发现。 事件传递到目标。事件移动到自己的冒泡阶段并执行为元素2注册的对应冒泡阶段的doSomething()。 事件再次向上移动并检查目标的任何祖先元素是否有对应冒泡阶段的事件句柄。 事件在元素1上发现了事件句柄。于是doSomething2()被执行。兼容传统模型在支持W3C DOM的浏览器中，一个传统的事件注册element1.onclick = doSomething2;被视为在冒泡阶段注册。事件冒泡的使用很少有web开发者自觉使用事件捕获或冒泡。现在的Web网页没有必要将一个冒泡事件与几个不同的事件句柄绑定。用户可能会对点击一次鼠标后发生多个动作感到困惑，而你通常会保持你的事件处理脚本彼此分离。当用户点击了一个元素，一个动作被触发，点击另一个元素就会触发另一个动作。当然在未来这种情况也许会改变，能有向上兼容的模型当然更好。但现在事件捕获和冒泡的主要实际应用是默认功能的注册。 这总会发生你首先需要理解事件捕获或冒泡总会发生。如果你为整个文档定义了一个普通的onclick事件句柄：document.onclick = doSomething;if (document.captureEvents) document.captureEvents(Event.CLICK);文档中的任何点击事件都将冒泡到文档并触发那个事件句柄。仅当一个在它之前的事件处理脚本命令该事件停止冒泡，事件才不会冒泡到文档。使用由于任何事件都要在文档上结束，因此默认事件句柄成为可能。假设你有下面这个页面：————————————| document || ————— ———— || | element1 | | element2 | || ————— ———— || |———————————— element1.onclick = doSomething;element2.onclick = doSomething;document.onclick = defaultFunction; 现在假如用户点击元素1或元素2，doSomething()被执行。只要愿意，你可以终止事件的传递。如果你没有终止它，事件会冒泡到defaultFunction()。如果用户点击了其他地方，defaultFunction()也被执行。这在某些时候会很有用。在拖拽脚本中设置文档宽度事件句柄很有必要。通常一个图层的mousedown事件会选中这一图层，并使它响应mousemove事件。尽管mousedown为了避免浏览器bug通常在这一图层注册，但其他的事件句柄一定是文档宽度。记住浏览器法则第一条：任何事都可能发生，尤其是当你没有准备时。可能当用户大幅度地移动鼠标时脚本无法正常工作，导致鼠标不会在图层上出现。 如果onmousemove事件句柄注册给了图层，图层就不会对鼠标移动做出反应，这会让人困惑。 如果onmouseup事件句柄在图层上被注册，事件就不会被捕获。所以图层会保持对鼠标的反应，甚至当用户以为自己放下图层后仍会保持反应。 所以在这种情况下冒泡是很有用的，因为在文档层面注册你的事件句柄能保证它们总会被执行。 关闭这个功能但你经常想要停用所有的捕获和冒泡，因为这样函数间就不会彼此干扰。除此之外如果你的文档结构很复杂(有很多嵌套表格之类)，你可以通过关闭冒泡来节省系统资源。浏览器必须查看事件目标的每一个祖先元素是否存在事件句柄。即使什么都没发现，搜索仍然会耗费不少时间。在微软模式下你必须设置事件的cancleBubble属性的值为true。window.event.cancelBubble = trueW3C模型中你必须调用stopPropagation()方法。e.stopPropagation()这会阻止冒泡阶段事件的传递。在跨浏览器时：function doSomething(e){ if (!e) var e = window.event; e.cancelBubble = true; if (e.stopPropagation) e.stopPropagation();}在浏览器中设置cancleBubble属性无法保证不会有负面效果。浏览器会创建属性。当然它并没有真正禁止冒泡，但任这种分配本身是安全的。 当前目标正如早先所见，拥有target或srcElement的事件包含了事件发生时对元素的一个引用。我们的例子是元素2，因为用户会点击它。理解在冒泡和捕获阶段（或任意一个）目标不变是很重要的：它始终保持对元素2的引用。但假设我们注册了以下这些事件句柄;element1.onclick = doSomething;element2.onclick = doSomething;如果用户点击元素2，doSomething()会被执行两次。但你怎么知道是哪个HTML元素最近绑定了这个事件？target/srcElement没有给出线索，因为元素2是事件的源头，它们经常指向元素2。为解决这个问题W3C增加了currentTarget属性。它包含了最近绑定了事件的元素的引用：这正是我们需要的。不幸的是，微软模式并没有一个与之相似的属性。你可以使用this关键字，在例子中它指向事件绑定的那个HTML元素，就像currentTarget。 微软模型的问题但当你使用微软事件注册模型时this关键字没有指向HTML元素。结合微软模型中一个与currentTarget类似的属性的缺点，这意味着如果你这样做的话：element1.attachEvent(‘onclick’,doSomething)element2.attachEvent(‘onclick’,doSomething)你无法知道是哪个HTML元素最近绑定了事件。这是微软事件注册模型最严重的问题，也是我从不使用它的原因，哪怕是IE/WIN才有的应用我也不使用。我希望微软可以尽快地添加一个类似currentTarget的属性—或者干脆遵从标准？Web开发者需要这个好消息。 尾声如果你从头到尾看完了这篇文章，建议你应该继续看看鼠标事件（文章链接：https://www.quirksmode.org/js/events_mouse.html）。]]></content>
  </entry>
  <entry>
    <title><![CDATA[网页性能管理详解]]></title>
    <url>%2F2019%2F08%2F02%2Fyuque%2F%E7%BD%91%E9%A1%B5%E6%80%A7%E8%83%BD%E7%AE%A1%E7%90%86%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[你遇到过性能很差的网页吗？这种网页响应非常缓慢，占用大量的CPU和内存，浏览起来常常有卡顿，页面的动画效果也不流畅。你会有什么反应？我猜想，大多数用户会关闭这个页面，改为访问其他网站。作为一个开发者，肯定不愿意看到这种情况，那么怎样才能提高性能呢？本文将详细介绍性能问题的出现原因，以及解决方法。 一、网页生成的过程要理解网页性能为什么不好，就要了解网页是怎么生成的。网页的生成过程，大致可以分成五步。 HTML代码转化成DOM CSS代码转化成CSSOM（CSS Object Model） 结合DOM和CSSOM，生成一棵渲染树（包含每个节点的视觉信息） 生成布局（layout），即将所有渲染树的所有节点进行平面合成 将布局绘制（paint）在屏幕上 这五步里面，第一步到第三步都非常快，耗时的是第四步和第五步。“生成布局”（flow）和”绘制”（paint）这两步，合称为”渲染”（render）。 二、重排和重绘网页生成的时候，至少会渲染一次。用户访问的过程中，还会不断重新渲染。以下三种情况，会导致网页重新渲染。 修改DOM 修改样式表 用户事件（比如鼠标悬停、页面滚动、输入框键入文字、改变窗口大小等等） 重新渲染，就需要重新生成布局和重新绘制。前者叫做”重排”（reflow），后者叫做”重绘”（repaint）。需要注意的是，“重绘”不一定需要”重排”，比如改变某个网页元素的颜色，就只会触发”重绘”，不会触发”重排”，因为布局没有改变。但是，“重排”必然导致”重绘”，比如改变一个网页元素的位置，就会同时触发”重排”和”重绘”，因为布局改变了。 三、对于性能的影响重排和重绘会不断触发，这是不可避免的。但是，它们非常耗费资源，是导致网页性能低下的根本原因。提高网页性能，就是要降低”重排”和”重绘”的频率和成本，尽量少触发重新渲染。前面提到，DOM变动和样式变动，都会触发重新渲染。但是，浏览器已经很智能了，会尽量把所有的变动集中在一起，排成一个队列，然后一次性执行，尽量避免多次重新渲染。 div.style.color = ‘blue’; div.style.marginTop = ‘30px’; 上面代码中，div元素有两个样式变动，但是浏览器只会触发一次重排和重绘。如果写得不好，就会触发两次重排和重绘。 div.style.color = ‘blue’; var margin = parseInt(div.style.marginTop); div.style.marginTop = (margin + 10) + ‘px’; 上面代码对div元素设置背景色以后，第二行要求浏览器给出该元素的位置，所以浏览器不得不立即重排。一般来说，样式的写操作之后，如果有下面这些属性的读操作，都会引发浏览器立即重新渲染。 offsetTop/offsetLeft/offsetWidth/offsetHeight scrollTop/scrollLeft/scrollWidth/scrollHeight clientTop/clientLeft/clientWidth/clientHeight getComputedStyle() 所以，从性能角度考虑，尽量不要把读操作和写操作，放在一个语句里面。 // bad div.style.left = div.offsetLeft + 10 + “px”; div.style.top = div.offsetTop + 10 + “px”; // good var left = div.offsetLeft; var top = div.offsetTop; div.style.left = left + 10 + “px”; div.style.top = top + 10 + “px”; 一般的规则是： 样式表越简单，重排和重绘就越快。 重排和重绘的DOM元素层级越高，成本就越高。 table元素的重排和重绘成本，要高于div元素四、提高性能的九个技巧有一些技巧，可以降低浏览器重新渲染的频率和成本。第一条是上一节说到的，DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。第二条，如果某个样式是通过重排得到的，那么最好缓存结果。避免下一次用到的时候，浏览器又要重排。第三条，不要一条条地改变样式，而要通过改变class，或者csstext属性，一次性地改变样式。 // bad var left = 10; var top = 10; el.style.left = left + “px”; el.style.top = top + “px”; // good el.className += “ theclassname”; // good el.style.cssText += “; left: “ + left + “px; top: “ + top + “px;”; 第四条，尽量使用离线DOM，而不是真实的网面DOM，来改变元素样式。比如，操作Document Fragment对象，完成后再把这个对象加入DOM。再比如，使用 cloneNode() 方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点。第五条，先将元素设为display: none（需要1次重排和重绘），然后对这个节点进行100次操作，最后再恢复显示（需要1次重排和重绘）。这样一来，你就用两次重新渲染，取代了可能高达100次的重新渲染。第六条，position属性为absolute或fixed的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响。第七条，只在必要的时候，才将元素的display属性为可见，因为不可见的元素不影响重排和重绘。另外，visibility : hidden的元素只对重绘有影响，不影响重排。第八条，使用虚拟DOM的脚本库，比如React等。第九条，使用 window.requestAnimationFrame()、window.requestIdleCallback() 这两个方法调节重新渲染（详见后文）。 五、刷新率很多时候，密集的重新渲染是无法避免的，比如scroll事件的回调函数和网页动画。网页动画的每一帧（frame）都是一次重新渲染。每秒低于24帧的动画，人眼就能感受到停顿。一般的网页动画，需要达到每秒30帧到60帧的频率，才能比较流畅。如果能达到每秒70帧甚至80帧，就会极其流畅。大多数显示器的刷新频率是60Hz，为了与系统一致，以及节省电力，浏览器会自动按照这个频率，刷新动画（如果可以做到的话）。所以，如果网页动画能够做到每秒60帧，就会跟显示器同步刷新，达到最佳的视觉效果。这意味着，一秒之内进行60次重新渲染，每次重新渲染的时间不能超过16.66毫秒。一秒之间能够完成多少次重新渲染，这个指标就被称为”刷新率”，英文为FPS（frame per second）。60次重新渲染，就是60FPS。如果想达到60帧的刷新率，就意味着JavaScript线程每个任务的耗时，必须少于16毫秒。一个解决办法是使用Web Worker，主线程只用于UI渲染，然后跟UI渲染不相干的任务，都放在Worker线程。 六、开发者工具的Timeline面板Chrome浏览器开发者工具的Timeline面板，是查看”刷新率”的最佳工具。这一节介绍如何使用这个工具。首先，按下 F12 打开”开发者工具”，切换到Timeline面板。左上角有一个灰色的圆点，这是录制按钮，按下它会变成红色。然后，在网页上进行一些操作，再按一次按钮完成录制。Timeline面板提供两种查看方式：横条的是”事件模式”（Event Mode），显示重新渲染的各种事件所耗费的时间；竖条的是”帧模式”（Frame Mode），显示每一帧的时间耗费在哪里。先看”事件模式”，你可以从中判断，性能问题发生在哪个环节，是JavaScript的执行，还是渲染？不同的颜色表示不同的事件。 蓝色：网络通信和HTML解析 黄色：JavaScript执行 紫色：样式计算和布局，即重排 绿色：重绘 哪种色块比较多，就说明性能耗费在那里。色块越长，问题越大。帧模式（Frames mode）用来查看单个帧的耗时情况。每帧的色柱高度越低越好，表示耗时少。你可以看到，帧模式有两条水平的参考线。下面的一条是60FPS，低于这条线，可以达到每秒60帧；上面的一条是30FPS，低于这条线，可以达到每秒30次渲染。如果色柱都超过30FPS，这个网页就有性能问题了。此外，还可以查看某个区间的耗时情况。或者点击每一帧，查看该帧的时间构成。 七、window.requestAnimationFrame()有一些JavaScript方法可以调节重新渲染，大幅提高网页性能。其中最重要的，就是 window.requestAnimationFrame() 方法。它可以将某些代码放到下一次重新渲染时执行。 function doubleHeight(element) { var currentHeight = element.clientHeight; element.style.height = (currentHeight * 2) + ‘px’; } elements.forEach(doubleHeight); 上面的代码使用循环操作，将每个元素的高度都增加一倍。可是，每次循环都是，读操作后面跟着一个写操作。这会在短时间内触发大量的重新渲染，显然对于网页性能很不利。我们可以使用window.requestAnimationFrame()，让读操作和写操作分离，把所有的写操作放到下一次重新渲染。 function doubleHeight(element) { var currentHeight = element.clientHeight; window.requestAnimationFrame(function () { element.style.height = (currentHeight * 2) + ‘px’; }); } elements.forEach(doubleHeight); 页面滚动事件（scroll）的监听函数，就很适合用 window.requestAnimationFrame() ，推迟到下一次重新渲染。 $(window).on(‘scroll’, function() { window.requestAnimationFrame(scrollHandler); }); 当然，最适用的场合还是网页动画。下面是一个旋转动画的例子，元素每一帧旋转1度。 var rAF = window.requestAnimationFrame; var degrees = 0; function update() { div.style.transform = “rotate(“ + degrees + “deg)”; console.log(‘updated to degrees ‘ + degrees); degrees = degrees + 1; rAF(update); } rAF(update); 八、window.requestIdleCallback()还有一个函数window.requestIdleCallback()，也可以用来调节重新渲染。它指定只有当一帧的末尾有空闲时间，才会执行回调函数。 requestIdleCallback(fn); 上面代码中，只有当前帧的运行时间小于16.66ms时，函数fn才会执行。否则，就推迟到下一帧，如果下一帧也没有空闲时间，就推迟到下下一帧，以此类推。它还可以接受第二个参数，表示指定的毫秒数。如果在指定 的这段时间之内，每一帧都没有空闲时间，那么函数fn将会强制执行。 requestIdleCallback(fn, 5000); 上面的代码表示，函数fn最迟会在5000毫秒之后执行。函数 fn 可以接受一个 deadline 对象作为参数。 requestIdleCallback(function someHeavyComputation(deadline) { while(deadline.timeRemaining() &gt; 0) { doWorkIfNeeded(); } if(thereIsMoreWorkToDo) { requestIdleCallback(someHeavyComputation); } }); 上面代码中，回调函数 someHeavyComputation 的参数是一个 deadline 对象。deadline对象有一个方法和一个属性：timeRemaining() 和 didTimeout。（1）timeRemaining() 方法timeRemaining() 方法返回当前帧还剩余的毫秒。这个方法只能读，不能写，而且会动态更新。因此可以不断检查这个属性，如果还有剩余时间的话，就不断执行某些任务。一旦这个属性等于0，就把任务分配到下一轮requestIdleCallback。前面的示例代码之中，只要当前帧还有空闲时间，就不断调用doWorkIfNeeded方法。一旦没有空闲时间，但是任务还没有全执行，就分配到下一轮requestIdleCallback。（2）didTimeout属性deadline对象的 didTimeout 属性会返回一个布尔值，表示指定的时间是否过期。这意味着，如果回调函数由于指定时间过期而触发，那么你会得到两个结果。 timeRemaining方法返回0 didTimeout 属性等于 true 因此，如果回调函数执行了，无非是两种原因：当前帧有空闲时间，或者指定时间到了。 function myNonEssentialWork (deadline) { while ((deadline.timeRemaining() &gt; 0 || deadline.didTimeout) &amp;&amp; tasks.length &gt; 0) doWorkIfNeeded(); if (tasks.length &gt; 0) requestIdleCallback(myNonEssentialWork); } requestIdleCallback(myNonEssentialWork, 5000); 上面代码确保了，doWorkIfNeeded 函数一定会在将来某个比较空闲的时间（或者在指定时间过期后）得到反复执行。requestIdleCallback 是一个很新的函数，刚刚引入标准，目前只有Chrome支持，不过其他浏览器可以用垫片库。 九、参考链接 Domenico De Felice, How browsers work Stoyan Stefanov, Rendering: repaint, reflow/relayout, restyle Addy Osmani, Improving Web App Performance With the Chrome DevTools Timeline and Profiles Tom Wiltzius, Jank Busting for Better Rendering Performance Paul Lewis, Using requestIdleCallback （完）]]></content>
  </entry>
  <entry>
    <title><![CDATA[React Hooks 可以为我们带来什么，及为什么我觉得React才是前端的未来]]></title>
    <url>%2F2019%2F08%2F01%2Fyuque%2FReact%20Hooks%20%E5%8F%AF%E4%BB%A5%E4%B8%BA%E6%88%91%E4%BB%AC%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%EF%BC%8C%E5%8F%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E8%A7%89%E5%BE%97React%E6%89%8D%E6%98%AF%E5%89%8D%E7%AB%AF%E7%9A%84%E6%9C%AA%E6%9D%A5%2F</url>
    <content type="text"><![CDATA[简单说明一下，react hooks 是一个已经在提议中的新功能，预计会随着React 16.7.0一起发布。/以上所述所有React均指ReactJS，下述会用React简称/要明白什么是React Hooks，那可能先了解一下它的两个替代品HOC_和_FaCC/Render Props HOC(Higher-Order Components)，React高阶组件如果我们有一个需要共享的状态，需要在多个组件之间传递。我们会怎么做？或者说，当多个组件有公用的部分的时候，我们会选择怎么做？例如： 123456789101112131415161718// ComponentAimport React, &#123; Component &#125; from "react";export default class ComponentA extends Component &#123; state = &#123; toggle: false &#125;; click = () =&gt; &#123; this.setState(&#123; toggle: !this.state.toggle &#125;); &#125;; render() &#123; const &#123; toggle &#125; = this.state; return ( &lt;div className="App"&gt; &lt;button onClick=&#123;this.click&#125;&gt;Toggle Name&lt;/button&gt; &#123;toggle &amp;&amp; &lt;div&gt;ComponentA&lt;/div&gt;&#125; &lt;/div&gt; ); &#125;&#125;复制代码 这里我们举一个极端的例子，让ComponentB和A做一样的事情 1234567891011121314151617// ComponentBexport default class ComponentB extends Component &#123; state = &#123; toggle: false &#125;; click = () =&gt; &#123; this.setState(&#123; toggle: !this.state.toggle &#125;); &#125;; render() &#123; const &#123; toggle &#125; = this.state; return ( &lt;div className="App"&gt; &lt;button onClick=&#123;this.click&#125;&gt;Toggle Name&lt;/button&gt; &#123;toggle &amp;&amp; &lt;div&gt;ComponentB&lt;/div&gt;&#125; &lt;/div&gt; ); &#125;&#125;复制代码 可以看到代码重复的部分非常多，只有文字显示的不同而已。这里就需要用到HOC了。使用HOC之后，变成 12345678910// ComponentAimport React, &#123; Component &#125; from "react";import HOC from "./HOC";class ComponentA extends Component &#123; render() &#123; return &lt;div&gt;ComponentA&lt;/div&gt;; &#125;&#125;export default HOC(ComponentA);复制代码 ComponentB同上。这里HOC的写法就是提出共有的部分，接收一个Component进行渲染。 123456789101112131415161718const HOC = WrapperComponent =&gt; class HOC extends Component &#123; state = &#123; toggle: false &#125;; click = () =&gt; &#123; this.setState(&#123; toggle: !this.state.toggle &#125;); &#125;; render() &#123; const &#123; toggle &#125; = this.state; return ( &lt;div className="App"&gt; &lt;button onClick=&#123;this.click&#125;&gt;Toggle Name&lt;/button&gt; &#123;toggle &amp;&amp; &lt;WrapperComponent /&gt;&#125; &lt;/div&gt; ); &#125; &#125;;export default HOC;复制代码 可以发现，让公用的部分提取了出去，并且让代码看起来更简单舒服了一些。每一个组件只需要关注自己内部的状态，而公有的部分以及共享状态的部分就交给HOC去解决。这样不论再加多少个类似的Component，都无需大量的写重复代码了。 FaCC(Function as Child Component)原理和HOC差不多，只是运用到了一个叫做 _children_的react props可以讲代码简化成 1234567//ComponentAexport default class ComponentA extends Component &#123; render() &#123; return &lt;FaCC&gt;&#123;toggle =&gt; toggle &amp;&amp; &lt;div&gt;ComponentA&lt;/div&gt;&#125;&lt;/FaCC&gt;; &#125;&#125;复制代码 1234567891011121314151617//FACCexport default class FaCC extends Component &#123; state = &#123; toggle: false &#125;; click = () =&gt; &#123; this.setState(&#123; toggle: !this.state.toggle &#125;); &#125;; render() &#123; const &#123; toggle &#125; = this.state; return ( &lt;div className="App"&gt; &lt;button onClick=&#123;this.click&#125;&gt;Toggle Name&lt;/button&gt; &#123;this.props.children(toggle)&#125; &lt;/div&gt; ); &#125;&#125;复制代码 Render Props是用的一样的方法，只是换了别的属性，不用children而已 那么HOC们，还能做什么？通过上述的行为，我们已经发现了，它们可以共用很多部分的代码。如果再深入思考一下，就可以想到，在复杂的业务逻辑里面，如果发送同一个API请求的haul，我们不应该在每一个独立component里面发送一个请求。因为它们共享了同一个state，这样会造成资源的浪费。我们将HOC的部分代码更改一下，例如： 1234567891011121314151617const HOC = WrapperComponent =&gt; class HOC extends Component &#123; state = &#123; toggle: false, data: &#123;&#125; &#125;; fetchData = () =&gt; &#123; fetch("/api", params).then(response =&gt; &#123; const &#123; data &#125; = data; this.setState(data); &#125;); &#125;; componentDidMount()&#123; this.fetchData(); &#125; render() &#123; /*......*/ &#125;;export default HOC;复制代码 React Hooks在Hooks里面利用它的Effect，可以让我们使用到和Component一样的部分生命周期。关于ReactHooks的详细介绍，我会在别的文章进行详细描述。在这里，我想进行的是React Hooks，HOC，FACC的比较。那么如果想实现上述功能，React Hooks会怎么做呢？ 123456789101112131415161718// Hooksimport &#123; useState, useEffect &#125; from "react";const useHooks = () =&gt; &#123; const [data, setData] = useState(null); const fetchData = () =&gt; &#123; fetch("/api", params).then(response =&gt; &#123; const &#123; data &#125; = data; setData(data); &#125;); &#125;;// Effect，这里相当于componentDidMount useEffect(() =&gt; &#123; fetchData(); &#125;); return data;&#125;;export default useHooks;复制代码 在Component中需要用到公用的这个data的时候，我们只需要这样做 1234// 这一行便是调用data的方法了 const data = Hooks(); return &lt;div&gt;&#123;data&#125;&lt;/div&gt;;复制代码 ReactHooks的优点？ 使用ReactHooks无需复杂的DOM结构。使用HOC们，去除掉了重复应用的问题。可是打开React Dev Tool，我们会发现，我们的DOM结构却也更复杂了。从变成再到 更重要的原因是，我觉得ReactHooks写起来更加简单，易懂，易读。我想通过上述的代码比对，不难得出这个结论。试想一下，在一个庞大项目里面，广泛使用HOC们，会带来什么样的代码复杂度？ 为什么我觉得React才是前端的未来正如我在前文描述的那样，不论是HOC还是FACC/Render Props，都有自己的技术上手难度以及理解困难的地方。但是React Hooks的出现解决了这些问题。一定有人不赞同，不负责任的猜测大概原因如下 行业本身需要有一定的技术门槛，写法和理解的困难是个体本身的学习能力以及钻研程度的问题，框架不应该为此埋单。 React hooks 本身从写法实现上来说，违背一些JS的规范和趋势，如纯函数。 我的解答如下 技术门槛不错，但是我觉得技术是用来改变生活的，而不是为了让部分人找到工作。就好比开车有职业赛车手，也有普通在道路上开车的司机。作为专业从事这个行业的人员来说，我们是应该钻研以及理解一门技术。但是，如果一个后端的同事，或者一个初创小团队，需要做一个这样的东西。我觉得，技术简洁好实现，对他们来说应该是一个吸引点。 很多库为了实现一些简洁的功能，都会出现这样或那样的“奇怪”写法，这点认同。但是，有时候是需要一些取舍。 而我认为目前前端框架里面，能察觉到用简单的方式来处理日趋复杂的业务，这件事的，Angular, Vue 都还没有做到。Angular非常完整，但是学习曲线相对陡。Vue正在面临整库重写。只有React，用简单的方式来处理复杂业务，并且第三方库生态链非常庞大。所以，我看好它。]]></content>
  </entry>
  <entry>
    <title><![CDATA[React16.8中关于children和render props的认知]]></title>
    <url>%2F2019%2F08%2F01%2Fyuque%2FReact16.8%E4%B8%AD%E5%85%B3%E4%BA%8Echildren%E5%92%8Crender%20props%E7%9A%84%E8%AE%A4%E7%9F%A5%2F</url>
    <content type="text"><![CDATA[一、组件的创建方式 1、使用createClass方式创建(已经被淘汰了) 2、类组件 1234567import React, &#123; Component &#125; from 'react'export default class Components1 extends Component &#123; render() &#123; return &lt;div /&gt; &#125;&#125;复制代码 3、函数组件(比较推荐的方式) 123456789101112import React from 'react'function Child(props) &#123; return &lt;&gt;&lt;/&gt;&#125;export default () =&gt; &#123; return ( &lt;&gt; &lt;Child /&gt; &lt;/&gt; )&#125;复制代码 二、组件的调用方式(使用children) 直接把组件当做一个DOM节点,在里面写内容,在该组件中使用childrend进行渲染 1、简单的引用 123456789101112import React from 'react'function Child(props) &#123; return &lt;&gt;我是child组件&lt;/&gt;&#125;export default () =&gt; &#123; return ( &lt;&gt; &lt;Child /&gt; &lt;/&gt; )&#125;复制代码 2、组件中传递html代码 12345678910111213141516171819202122import React from 'react'function Child(props) &#123; console.log(props) return ( &lt;&gt; &lt;p&gt;我是child组件&lt;/p&gt; &#123;props.children&#125; &lt;/&gt; )&#125;export default () =&gt; &#123; return ( &lt;&gt; &lt;Child&gt; &#123;/* 在组件中直接写内容可以传递到该组件的children上 */&#125; &lt;h1&gt;我是父组件传递进去的&lt;/h1&gt; &lt;h2&gt;我是父组件传递进去的内容二&lt;/h2&gt; &lt;/Child&gt; &lt;/&gt; )&#125;复制代码 3、传递一个组件进去 1234567891011121314151617181920212223242526import React from 'react'function Parent(props) &#123; return ( &lt;&gt; &lt;p&gt;我是Parent组件&lt;/p&gt; &#123;props.children&#125; &lt;/&gt; )&#125;function Child(props) &#123; return ( &lt;&gt; &lt;p&gt;我是Child组件&lt;/p&gt; &lt;/&gt; )&#125;export default () =&gt; &#123; return ( &lt;&gt; &lt;Parent&gt; &lt;Child /&gt; &lt;/Parent&gt; &lt;/&gt; )&#125;复制代码 4、组件中传递一个函数进去 12345678910111213141516171819202122import React from 'react'function Child(props) &#123; return ( &lt;&gt; &lt;p&gt;我是child组件&lt;/p&gt; &#123;props.children(&#123; name: '哈哈', gender: '男' &#125;)&#125; &lt;/&gt; )&#125;export default () =&gt; &#123; return ( &lt;&gt; &lt;Child&gt; &#123;args =&gt; &#123; console.log(args) return &lt;div id="child"&gt;&#123;args.name&#125;&lt;/div&gt; &#125;&#125; &lt;/Child&gt; &lt;/&gt; )&#125;复制代码 三、render props的使用参考文档 主要作用点 1、使用Render Props解决来横切关注点(组件的复用[复用组件内部一些逻辑]) 2、Render prop 是一个用于告知组件需要渲染什么内容的函数 prop与传统组件的props有点类似,只是希望渲染的是一个组件或者一个DOM节点 3、Render props主要用于组件代码的复用 代码案例 1、使用render props渲染一个DOM节点 12345678910111213141516171819202122232425262728import React from 'react'export default function Render03() &#123; return ( &lt;div&gt; &lt;Child render=&#123;props =&gt; &#123; // 可以接收render函数里面的参数 console.log(props) return ( &lt;div style=&#123;&#123; color: '#f90' &#125;&#125;&gt; 我是渲染出来的--&#123;props.name&#125;--&#123;props.gender&#125; &lt;/div&gt; ) &#125;&#125; /&gt; &lt;/div&gt; )&#125;function Child(props) &#123; return ( &lt;&gt; &lt;h1&gt;我是child组件&lt;/h1&gt; &#123;/* render里面传递参数,真正渲染的地方接收参数 */&#125; &#123;props.render(&#123; name: '张三', gender: '男' &#125;)&#125; &lt;/&gt; )&#125;复制代码 2、使用render props渲染一个组件 1234567891011121314151617181920212223242526import React from 'react'export default function Render04() &#123; return ( &lt;div id="render04"&gt; &lt;Child1 render=&#123;props =&gt; &lt;Child2 &#123;...props&#125; /&gt;&#125; /&gt; &lt;/div&gt; )&#125;function Child1(props) &#123; return ( &lt;&gt; &lt;h2&gt;我是child1组件&lt;/h2&gt; &#123;props.render(&#123; name: '张三', gender: '男' &#125;)&#125; &lt;/&gt; )&#125;function Child2(props) &#123; console.log(props) return ( &lt;&gt; &lt;h2&gt;我是child2组件&lt;/h2&gt; &lt;h3&gt;&#123;props.name&#125;&lt;/h3&gt; &lt;/&gt; )&#125;复制代码 3、使用render props达到组件的复用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import React, &#123; useState &#125; from 'react'export default function Render05() &#123; return ( &lt;div&gt; &lt;Mouse render=&#123;props =&gt; &#123; return &lt;Cat &#123;...props&#125; /&gt; &#125;&#125; /&gt; &lt;Mouse render=&#123;props =&gt; &#123; console.log(props) return ( &lt;div style=&#123;&#123; width: '100px', height: '100px', background: '#f90', position: 'absolute', top: props.y - 50, left: props.x - 50 &#125;&#125; /&gt; ) &#125;&#125; /&gt; &lt;/div&gt; )&#125;function Cat(props) &#123; return ( &lt;div&gt; &lt;div style=&#123;&#123; position: 'absolute', width: '100px', height: '100px', background: '#f00', cursor: 'move', left: props.x - 50, top: props.y - 50 &#125;&#125; /&gt; &lt;/div&gt; )&#125;function Mouse(props) &#123; const [location, setLocation] = useState(&#123; x: 0, y: 0 &#125;) const handleMouseMove = event =&gt; &#123; setLocation(&#123; x: event.clientX, y: event.clientY &#125;) &#125; return ( &lt;div style=&#123;&#123; height: '100%' &#125;&#125; onMouseMove=&#123;handleMouseMove&#125;&gt; &#123;props.render(location)&#125; &lt;/div&gt; )&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSS Modules详解及React中实践]]></title>
    <url>%2F2019%2F08%2F01%2Fyuque%2FCSS%20Modules%E8%AF%A6%E8%A7%A3%E5%8F%8AReact%E4%B8%AD%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[CSS 是前端领域中进化最慢的一块。由于 ES2015/2016 的快速普及和 Babel/Webpack 等工具的迅猛发展，CSS 被远远甩在了后面，逐渐成为大型项目工程化的痛点。也变成了前端走向彻底模块化前必须解决的难题。CSS 模块化的解决方案有很多，但主要有两类。一类是彻底抛弃 CSS，使用 JS 或 JSON 来写样式。Radium，jsxstyle，react-style 属于这一类。优点是能给 CSS 提供 JS 同样强大的模块化能力；缺点是不能利用成熟的 CSS 预处理器（或后处理器） Sass/Less/PostCSS，:hover 和 :active 伪类处理起来复杂。另一类是依旧使用 CSS，但使用 JS 来管理样式依赖，代表是 CSS Modules。CSS Modules 能最大化地结合现有 CSS 生态和 JS 模块化能力，API 简洁到几乎零学习成本。发布时依旧编译出单独的 JS 和 CSS。它并不依赖于 React，只要你使用 Webpack，可以在 Vue/Angular/jQuery 中使用。是我认为目前最好的 CSS 模块化解决方案。近期在项目中大量使用，下面具体分享下实践中的细节和想法。 CSS 模块化遇到了哪些问题？CSS 模块化重要的是要解决好两个问题：CSS 样式的导入和导出。灵活按需导入以便复用代码；导出时要能够隐藏内部作用域，以免造成全局污染。Sass/Less/PostCSS 等前仆后继试图解决 CSS 编程能力弱的问题，结果它们做的也确实优秀，但这并没有解决模块化最重要的问题。Facebook 工程师 Vjeux 首先抛出了 React 开发中遇到的一系列 CSS 相关问题。加上我个人的看法，总结如下： 全局污染CSS 使用全局选择器机制来设置样式，优点是方便重写样式。缺点是所有的样式都是全局生效，样式可能被错误覆盖，因此产生了非常丑陋的 !important，甚至 inline !important 和复杂的选择器权重计数表，提高犯错概率和使用成本。Web Components 标准中的 Shadow DOM 能彻底解决这个问题，但它的做法有点极端，样式彻底局部化，造成外部无法重写样式，损失了灵活性。 命名混乱由于全局污染的问题，多人协同开发时为了避免样式冲突，选择器越来越复杂，容易形成不同的命名风格，很难统一。样式变多后，命名将更加混乱。 依赖管理不彻底组件应该相互独立，引入一个组件时，应该只引入它所需要的 CSS 样式。但现在的做法是除了要引入 JS，还要再引入它的 CSS，而且 Saas/Less 很难实现对每个组件都编译出单独的 CSS，引入所有模块的 CSS 又造成浪费。JS 的模块化已经非常成熟，如果能让 JS 来管理 CSS 依赖是很好的解决办法。Webpack 的 css-loader 提供了这种能力。 无法共享变量复杂组件要使用 JS 和 CSS 来共同处理样式，就会造成有些变量在 JS 和 CSS 中冗余，Sass/PostCSS/CSS 等都不提供跨 JS 和 CSS 共享变量这种能力。 代码压缩不彻底由于移动端网络的不确定性，现在对 CSS 压缩已经到了变态的程度。很多压缩工具为了节省一个字节会把 ‘16px’ 转成 ‘1pc’。但对非常长的 class 名却无能为力，力没有用到刀刃上。 上面的问题如果只凭 CSS 自身是无法解决的，如果是通过 JS 来管理 CSS 就很好解决，因此 Vjuex 给出的解决方案是完全的 CSS in JS，但这相当于完全抛弃 CSS，在 JS 中以 Object 语法来写 CSS，估计刚看到的小伙伴都受惊了。直到出现了 CSS Modules。 CSS Modules 模块化方案CSS Modules 内部通过 ICSS 来解决样式导入和导出这两个问题。分别对应 :import 和 :export 两个新增的伪类。 12345678:import("path/to/dep.css") &#123; localAlias: keyFromDep; /* ... */&#125;:export &#123; exportedKey: exportedValue; /* ... */&#125; 但直接使用这两个关键字编程太麻烦，实际项目中很少会直接使用它们，我们需要的是用 JS 来管理 CSS 的能力。结合 Webpack 的 css-loader 后，就可以在 CSS 中定义样式，在 JS 中导入。 启用 CSS Modules12// webpack.config.jscss?modules&amp;localIdentName=[name]__[local]-[hash:base64:5] 加上 modules 即为启用，localIdentName 是设置生成样式的命名规则。 123/* components/Button.css */.normal &#123; /* normal 相关的所有样式 */ &#125;.disabled &#123; /* disabled 相关的所有样式 */ &#125; 1234/* components/Button.js */import styles from './Button.css';console.log(styles);buttonElem.outerHTML = `&lt;button class=$&#123;styles.normal&#125;&gt;Submit&lt;/button&gt;` 生成的 HTML 是 1&lt;button class="button--normal-abc53"&gt; Processing... &lt;/button&gt; 注意到 button–normal-abc5436 是 CSS Modules 按照 localIdentName 自动生成的 class 名。其中的 abc5436 是按照给定算法生成的序列码。经过这样混淆处理后，class 名基本就是唯一的，大大降低了项目中样式覆盖的几率。同时在生产环境下修改规则，生成更短的 class 名，可以提高 CSS 的压缩率。上例中 console 打印的结果是： 1234Object &#123; normal: 'button--normal-abc546', disabled: 'button--disabled-def884',&#125; CSS Modules 对 CSS 中的 class 名都做了处理，使用对象来保存原 class 和混淆后 class 的对应关系。通过这些简单的处理，CSS Modules 实现了以下几点： 所有样式都是 local 的，解决了命名冲突和全局污染问题 class 名生成规则配置灵活，可以此来压缩 class 名 只需引用组件的 JS 就能搞定组件所有的 JS 和 CSS 依然是 CSS，几乎 0 学习成本样式默认局部使用了 CSS Modules 后，就相当于给每个 class 名外加加了一个 :local，以此来实现样式的局部化，如果你想切换到全局模式，使用对应的 :global。1234567891011121314151617181920.normal &#123; color: green;&#125;/* 以上与下面等价 */:local(.normal) &#123; color: green; &#125;/* 定义全局样式 */:global(.btn) &#123; color: red;&#125;/* 定义多个全局样式 */:global &#123; .link &#123; color: green; &#125; .box &#123; color: yellow; &#125;&#125; Compose 来组合样式对于样式复用，CSS Modules 只提供了唯一的方式来处理：composes 组合 12345678910/* components/Button.css */.base &#123; /* 所有通用的样式 */ &#125;.normal &#123; composes: base; /* normal 其它样式 */&#125;.disabled &#123; composes: base; /* disabled 其它样式 */&#125; 12import styles from './Button.css';buttonElem.outerHTML = `&lt;button class=$&#123;styles.normal&#125;&gt;Submit&lt;/button&gt;` 生成的 HTML 变为 1&lt;button class="button--base-abc53 button--normal-abc53"&gt; Processing... &lt;/button&gt; 由于在 .normal 中 composes 了 .base，编译后会 normal 会变成两个 class。composes 还可以组合外部文件中的样式。 1234567891011/* settings.css */.primary-color &#123; color: #f40;&#125;/* components/Button.css */.base &#123; /* 所有通用的样式 */ &#125;.primary &#123; composes: base; composes: $primary-color from './settings.css'; /* primary 其它样式 */&#125; 对于大多数项目，有了 composes 后已经不再需要 Sass/Less/PostCSS。但如果你想用的话，由于 composes 不是标准的 CSS 语法，编译时会报错。就只能使用预处理器自己的语法来做样式复用了。 class 命名技巧CSS Modules 的命名规范是从 BEM 扩展而来。BEM 把样式名分为 3 个级别，分别是： Block：对应模块名，如 Dialog Element：对应模块中的节点名 Confirm Button Modifier：对应节点相关的状态，如 disabled、highlight 综上，BEM 最终得到的 class 名为 dialog__confirm-button–highlight。使用双符号 __ 和 – 是为了和区块内单词间的分隔符区分开来。虽然看起来有点奇怪，但 BEM 被非常多的大型项目和团队采用。我们实践下来也很认可这种命名方法。CSS Modules 中 CSS 文件名恰好对应 Block 名，只需要再考虑 Element 和 Modifier。BEM 对应到 CSS Modules 的做法是： 123/* .dialog.css */.ConfirmButton--disabled &#123;&#125; 你也可以不遵循完整的命名规范，使用 camelCase 的写法把 Block 和 Modifier 放到一起： 123/* .dialog.css */.disabledConfirmButton &#123;&#125; 如何实现CSS，JS变量共享上面提到的 :export 关键字可以把 CSS 中的 变量输出到 JS 中。下面演示如何在 JS 中读取 Sass 变量： 12345/* config.scss */$primary-color: #f40;:export &#123; primaryColor: $primary-color;&#125; 1234/* app.js */import style from 'config.scss';// 会输出 #F40console.log(style.primaryColor); CSS Modules 使用技巧CSS Modules 是对现有的 CSS 做减法。为了追求简单可控，作者建议遵循如下原则： 不使用选择器，只使用 class 名来定义样式 不层叠多个 class，只使用一个 class 把所有样式定义好 所有样式通过 composes 组合来实现复用 不嵌套 上面两条原则相当于削弱了样式中最灵活的部分，初使用者很难接受。第一条实践起来难度不大，但第二条如果模块状态过多时，class 数量将成倍上升。一定要知道，上面之所以称为建议，是因为 CSS Modules 并不强制你一定要这么做。听起来有些矛盾，由于多数 CSS 项目存在深厚的历史遗留问题，过多的限制就意味着增加迁移成本和与外部合作的成本。初期使用中肯定需要一些折衷。幸运的是，CSS Modules 这点做的很好：如果我对一个元素使用多个 class 呢？没问题，样式照样生效。如何我在一个 style 文件中使用同名 class 呢？没问题，这些同名 class 编译后虽然可能是随机码，但仍是同名的。如果我在 style 文件中使用了 id 选择器，伪类，标签选择器等呢？没问题，所有这些选择器将不被转换，原封不动的出现在编译后的 css 中。也就是说 CSS Modules 只会转换 class 名相关样式。但注意，上面 3 个“如果”尽量不要发生。 CSS Modules 结合 React 实践在 className 处直接使用 css 中 class 名即可。 1234/* dialog.css */.root &#123;&#125;.confirm &#123;&#125;.disabledConfirm &#123;&#125; 1234567891011121314import classNames from 'classnames';import styles from './dialog.css';export default class Dialog extends React.Component &#123; render() &#123; const cx = classNames(&#123; [styles.confirm]: !this.state.disabled, [styles.disabledConfirm]: this.state.disabled &#125;); return &lt;div className=&#123;styles.root&#125;&gt; &lt;a className=&#123;cx&#125;&gt;Confirm&lt;/a&gt; ... &lt;/div&gt; &#125;&#125; 注意，一般把组件最外层节点对应的 class 名称为 root。这里使用了 classnames 库来操作 class 名。如果你不想频繁的输入 styles.，可以试一下 react-css-modules，它通过高阶函数的形式来避免重复输入 styles.。 CSS Modules 结合历史遗留项目实践好的技术方案除了功能强大炫酷，还要能做到现有项目能平滑迁移。CSS Modules 在这一点上表现的非常灵活。 外部如何覆盖局部样式当生成混淆的 class 名后，可以解决命名冲突，但因为无法预知最终 class 名，不能通过一般选择器覆盖。我们现在项目中的实践是可以给组件关键节点加上 data-role 属性，然后通过属性选择器来覆盖样式。如 12345// dialog.js return &lt;div className=&#123;styles.root&#125; data-role='dialog-root'&gt; &lt;a className=&#123;styles.disabledConfirm&#125; data-role='dialog-confirm-btn'&gt;Confirm&lt;/a&gt; ... &lt;/div&gt; 1234// dialog.css[data-role="dialog-root"] &#123; // override style&#125; 因为 CSS Modules 只会转变类选择器，所以这里的属性选择器不需要添加 :global。 如何与全局样式共存前端项目不可避免会引入 normalize.css 或其它一类全局 css 文件。使用 Webpack 可以让全局样式和 CSS Modules 的局部样式和谐共存。下面是我们项目中使用的 webpack 部分配置代码： 1234567891011121314module: &#123; loaders: [&#123; test: /\.jsx?$/, loader: 'babel' &#125;, &#123; test: /\.scss$/, exclude: path.resolve(__dirname, 'src/styles'), loader: 'style!css?modules&amp;localIdentName=[name]__[local]!sass?sourceMap=true' &#125;, &#123; test: /\.scss$/, include: path.resolve(__dirname, 'src/styles'), loader: 'style!css!sass?sourceMap=true' &#125;]&#125; 123456/* src/app.js */import './styles/app.scss';import Component from './view/Component'/* src/views/Component.js */// 以下为组件相关样式import './Component.scss'; 目录结构如下： 12345678src├── app.js├── styles│ ├── app.scss│ └── normalize.scss└── views ├── Component.js └── Component.scss 这样所有全局的样式都放到 src/styles/app.scss 中引入就可以了。其它所有目录包括 src/views 中的样式都是局部的。 总结CSS Modules 很好的解决了 CSS 目前面临的模块化难题。支持与 Sass/Less/PostCSS 等搭配使用，能充分利用现有技术积累。同时也能和全局样式灵活搭配，便于项目中逐步迁移至 CSS Modules。CSS Modules 的实现也属轻量级，未来有标准解决方案后可以低成本迁移。如果你的产品中正好遇到类似问题，非常值得一试。 原发于知乎专栏 http://zhuanlan.zhihu.com/purerender/20495964 保留所有权利 新浪微博 微信 Twitter Facebook 你可能感兴趣的 你的 css 也需要模块化穿越过来的键盘手css-moduleswebpackcss css 预编译器的再次理解candicecss预处理器 CSS ModulespecialCodermodulecss css模块化思想初探薄大爷lesssasscss CSS module 入门流口水流css-modulescss css布局基础总结王亚辉html5css 前端进阶（12） - css 的弱化与 js 的强化senntyoustylesheetscssjavascript前端优化前端 为什么要用postcssemctycss框架postcsscss 转自：https://segmentfault.com/a/1190000004300065]]></content>
  </entry>
  <entry>
    <title><![CDATA[浏览器HTTP缓存机制]]></title>
    <url>%2F2019%2F08%2F01%2Fyuque%2F%E6%B5%8F%E8%A7%88%E5%99%A8HTTP%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Web缓存是一种保存Web资源副本并在下次请求时直接使用该副本的技术。 Web缓存可以分为这几种：浏览器缓存、CDN缓存、服务器缓存、数据库数据缓存 。因为可能会直接使用副本免于重新发送请求或者仅仅确认资源没变无需重新传输资源实体，Web缓存可以减少延迟加快网页打开速度、重复利用资源减少网络带宽消耗、降低请求次数或者减少传输内容从而减轻服务器压力。 这篇文章主要讨论和前端密切相关的浏览器HTTP缓存机制。浏览器HTTP缓存可以分为强缓存和协商缓存。强缓存和协商缓存最大也是最根本的区别是：强缓存命中的话不会发请求到服务器（比如chrome中的200 from memory cache），协商缓存一定会发请求到服务器，通过资源的请求首部字段验证资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的实体，而是通知客户端可以从缓存中加载这个资源（304 not modified）。简略流程图如下： 浏览器HTTP缓存由HTTP报文的首部字段决定 控制强缓存的字段按优先级介绍 PragmaPragma是HTTP/1.1之前版本遗留的通用首部字段，仅作为于HTTP/1.0的向后兼容而使用。虽然它是一个通用首部，但是它在响应报文中时的行为没有规范，依赖于浏览器的实现。RFC中该字段只有no-cache一个可选值，会通知浏览器不直接使用缓存，要求向服务器发请求校验新鲜度。因为它优先级最高，当存在时一定不会命中强缓存。&lt;br /&gt; Cache-ControlCache-Control是一个通用首部字段，也是HTTP/1.1控制浏览器缓存的主流字段。和浏览器缓存相关的是如下几个响应指令：&lt;br /&gt; 指令 参数 说明 private 无 表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它） public 可省略 表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存 no-cache 可省略 缓存前必需确认其有效性 no-store 无 不缓存请求或响应的任何内容 max-age=[s] 必须 响应的最大值 max-age（单位为s）设置缓存的存在时间，相对于发送请求的时间。只有响应报文首部设置Cache-Control为非0的max-age或者设置了大于请求日期的Expires（下文会讲）才有可能命中强缓存。当满足这个条件，同时响应报文首部中Cache-Control不存在no-cache、no-store且请求报文首部不存在Pragma字段，才会真正命中强缓存。以下所有图片均为刷新（command+R）的截图。 no-cache 表示请求必须先与服务器确认缓存的有效性，如果有效才能使用缓存（协商缓存），无论是响应报文首部还是请求报文首部出现这个字段均一定不会命中强缓存。Chrome硬性重新加载（Command+shift+R）会在请求的首部加上Pragma：no-cache和Cache-Control：no-cache。 no-store 表示禁止浏览器以及所有中间缓存存储任何版本的返回响应，一定不会出现强缓存和协商缓存，适合个人隐私数据或者经济类数据。 public 表明响应可以被浏览器、CDN等等缓存。 private 响应只作为私有的缓存，不能被CDN等缓存。如果要求HTTP认证，响应会自动设置为private。 ExpiresExpires是一个响应首部字段，它指定了一个日期/时间，在这个时间/日期之前，HTTP缓存被认为是有效的。无效的日期比如0，表示这个资源已经过期了。如果同时设置了Cache-Control响应首部字段的max-age，则Expires会被忽略。它也是HTTP/1.1之前版本遗留的通用首部字段，仅作为于HTTP/1.0的向后兼容而使用。 控制协商缓存的字段 Last-Modified/If-Modified-SinceIf-Modified-Since是一个请求首部字段，并且只能用在GET或者HEAD请求中。Last-Modified是一个响应首部字段，包含服务器认定的资源作出修改的日期及时间。当带着If-Modified-Since头访问服务器请求资源时，服务器会检查Last-Modified，如果Last-Modified的时间早于或等于If-Modified-Since则会返回一个不带主体的304响应，否则将重新返回资源。 If-Modified-Since: , :: GMT Last-Modified: , :: GMT ETag/If-None-MatchETag是一个响应首部字段，它是根据实体内容生成的一段hash字符串，标识资源的状态，由服务端产生。If-None-Match是一个条件式的请求首部。如果请求资源时在请求首部加上这个字段，值为之前服务器端返回的资源上的ETag，则当且仅当服务器上没有任何资源的ETag属性值与这个首部中列出的时候，服务器才会返回带有所请求资源实体的200响应，否则服务器会返回不带实体的304响应。ETag优先级比Last-Modified高，同时存在时会以ETag为准。 If-None-Match: If-None-Match: , , … If-None-Match: * ETag属性之间的比较采用的是弱比较算法，即两个文件除了每个比特都相同外，内容一致也可以认为是相同的。例如，如果两个页面仅仅在页脚的生成时间有所不同，就可以认为二者是相同的。 因为ETag的特性，所以相较于Last-Modified有一些优势：1. 某些情况下服务器无法获取资源的最后修改时间2. 资源的最后修改时间变了但是内容没变，使用ETag可以正确缓存3. 如果资源修改非常频繁，在秒以下的时间进行修改，Last-Modified只能精确到秒 整体流程]]></content>
  </entry>
  <entry>
    <title><![CDATA[(VUE)前端预渲染机制引入实践]]></title>
    <url>%2F2019%2F07%2F29%2Fyuque%2F(VUE)%E5%89%8D%E7%AB%AF%E9%A2%84%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E5%BC%95%E5%85%A5%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[周末想顺便把已经做好静态页面的webApp项目做一下SEO优化，由于不想写蹩脚的 SSR 代码，所以准备采用预渲染，本来想着网上有这么多预渲染的文章，随便找个来跟着做不就完了嘛，结果年轻的我付出了整个周末….. 这篇文章就记录一下最后是怎么配置的 T.T声明： 以下配置只保留有必要的 生成目录这里使用 base代替，请自行修改 vue-cli模板使用 webpack，其他模板类推 Github - 配置了预渲染的demo ：https://github.com/SHERlocked93/vue-style-codebase/tree/prerender 经过实践，预渲染后的页面在 FCP 指标上有 30% - 80% 左右的加载速度提升。 1. 简介与使用场景我们知道 SPA 有很多优点，不过一个缺点就是对(不是 Google)愚蠢的搜索引擎的 SEO 不友好，为了照顾这些引擎，目前主要有两个方案：服务端渲染(Server Side Rendering)、预渲染(Prerending)。如果你只需要改善少数页面（例如 /, /about, /contact 等）的 SEO，那么你可能需要预渲染。无需使用 web 服务器实时动态编译 HTML (服务端渲染, SSR)，而是使用预渲染方式，在构建时(build time)简单地生成针对特定路由的静态 HTML 文件。它主要使用 prerender-spa-plugin 插件，其与SSR一样都可以加快页面的加载速度，并且侵入性更小，在已上线的项目稍加改动也可以轻松引入预渲染机制，而SSR方案则需要将整个项目结构推翻；访问预渲染出来的页面在访问时与 SSR一样快，并且它将服务端编译HTML的时机提前到了构建时，因此也降低了服务端的压力，如果你的服务器跟我的一样买的 1M1G1核 的小水管服务器 ( 穷 )，那么预渲染可能更适合你。不过SSR和预渲染的使用场景还是有较明显的区别的。预渲染的使用场景更多是简单的静态页面。服务端渲染适用于复杂、较大型、与服务端交互频繁的功能型网站，比如电商网站。 2. 实践效果经过实践，预渲染后的页面在 FCP 指标上有 40% - 80% 左右的加载速度提升。借用美团团队的一张实践图： 3. 安装配置首先来看看相关技术栈：vue^2.5.2、vue-router^3.0.1、vue-cli^2.9.6、webpack^3.6.0、prerender-spa-plugin^3.3.0下面来看看到底如何配置预渲染项目 3.1 安装安装跟其他库一样 1234# Yarn$ yarn add prerender-spa-plugin -D# or NPM$ npm install prerender-spa-plugin --save-dev 3.2 前端配置首先看看文件结构，用的是vue-cli2的webpack模板生成的文件结构 1234567891011121314151617181920212223242526272829│ .babelrc│ index.html│ package.json│ README.md├─build│ build.js│ check-versions.js│ utils.js│ vue-loader.conf.js│ webpack.base.conf.js│ webpack.dev.conf.js│ webpack.prod.conf.js├─config│ dev.env.js│ index.js│ prod.env.js├─src│ │ App.vue│ │ main.js│ │ │ ├─assets│ ├─components│ ├─router│ │ index.js│ ├─styles│ ├─utils│ └─views│ BigData.vue│ CompanyHonor.vue 然后是router/index.js的配置，预渲染要求是histroy模式，有的文章说不需要history模式，这是错的，否则生成的页面都是同一个html。另外注意加上 base否则如果你希望跳转到二级页面的 localhost/base/home 时候，在页面中点击 &lt;router-linkto=”/home”&gt;home 的时候会跳转 localhost/home// src/router/index.js 12345678import Vue from 'vue'import Router from 'vue-router'Vue.use(Router) export default new Router(&#123; mode: 'history', base: '/base/', routes: [...]&#125;) 然后是config，这里注意 assetsPublicPath不是 ./,// config/index.js 123456789const path = require("path")module.exports = &#123; build: &#123; index: path.resolve(__dirname, "../base/index.html"), assetsRoot: path.resolve(__dirname, ".."), assetsSubDirectory: "base/static", assetsPublicPath: "/", &#125;&#125; 然后是插件的配置，是放在 prod中的，因为只有build的时候会用// build/webpack.prod.conf.js 123456789101112131415161718192021const path = require('path')const config = require('../config')const PrerenderSPAPlugin = require('prerender-spa-plugin')const Renderer = PrerenderSPAPlugin.PuppeteerRendererconst webpackConfig = merge(baseWebpackConfig, &#123;new PrerenderSPAPlugin(&#123; staticDir: config.build.assetsRoot, outputDir: path.join(config.build.assetsRoot, 'base'), indexPath: config.build.index, // 对应路由文件的path routes: [ '/', '/BigData', '/CompanyHonor' ], renderer: new Renderer(&#123; headless: false, // 无桌面系统去掉 renderAfterDocumentEvent: 'render-event' &#125;) &#125;)&#125;) 注意了，如果你的项目是部署在linux/centOS之类没有桌面的系统，需要把 headless:false去掉，如果centOS报没有找到lib的错，请参考 issue-200 的解决办法。另外注意上面一个 renderAfterDocumentEvent:’render-event’了么，这个意思是在 render-event事件触发之后执行prerender，这个事件我们在main.js中mounted钩子触发// src/main.js 123456789import Vue from 'vue'import App from './App'new Vue(&#123; el: '#app', render: h =&gt; h(App), mounted() &#123; document.dispatchEvent(new Event('render-event')) &#125;&#125;) 还有个配置要注意下在 build/utils.js 中的 ExtractTextPlugin.extract 的 publicPath，否则一些vue中引用的资源会找不到// build/utils.js 12345ExtractTextPlugin.extract(&#123; use: loaders, fallback: 'vue-style-loader', // publicPath: '../../'&#125;) 这时候执行 npm run build 就可以生成刚刚配置在 PrerenderSPAPlugin 插件中 routes 中的页面 html 了，这过程中会一闪而过的短暂打开 chromium 浏览器，不用管。最后生成的目录树： 12345678910│ index.html├─BigData│ index.html├─CompanyHonor│ index.html└─static├─css├─fonts├─img└─js 最后如果希望进一步优化生成出来页面的 SEO，可以配合 vue-meta-info 这个网上有很多文章，就不赘述了 3.3 nginx配置顺便贴一下nginx配置 123456789101112server &#123; listen 80; server_name localhost; root /nginx-1.14.0/html; error_page 500 502 503 504 /50x.html; location ~ ^/base/ &#123; try_files $uri $uri/ /base/index.html; &#125; location = /50x.html &#123; root html; &#125;&#125; 网上的帖子大多深浅不一，甚至有些前后矛盾，在下的文章都是学习过程中的总结，如果发现错误，欢迎留言指出~ 参考： Vue.js 服务器端渲染指南 Vue 服务端渲染 &amp; 预渲染 vue-cli v3, can’t get it to work.. issue #215 unable to start Puppeteer. Failed to launch … issue #200 When assetsPublicPath is set, the… issue #176 vue.js vue-router history模式路由，域名二级目录子目录nginx配置 处理 Vue 单页面 Meta SEO的另一种思路]]></content>
  </entry>
  <entry>
    <title><![CDATA[多网站项目的 CSS 架构]]></title>
    <url>%2F2019%2F07%2F26%2Fyuque%2F%E5%A4%9A%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E7%9A%84%20CSS%20%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[[译] 多网站项目的 CSS 架构 原文地址：CSS Architecture for Multiple Websites 原文作者：Elad Shechter 译文出自：掘金翻译计划 本文永久链接：github.com/xitu/gold-m… 译者：Baddyo 校对者：xionglong58，lgh757079506 多网站项目的 CSS 架构 CSS 架构 —— 第三部分 复杂的 CSS 架构，可不是你在科班里能学到的东西。我在互联网行业的第四份工作，是在我国一家领先的媒体新闻公司中任职一名 CSS/HTML 专家，我的主要职责就是开发可重用的、可扩展的、用于多网站的 CSS 架构。 在本文中，我将与大家分享我在构建多网站架构领域中积累的知识和经验。附注：如今，正规的项目都会用到 CSS 预处理器。而在本文中，我会使用 Sass 预处理器。本文是我写的讨论 CSS 架构的系列文章中的第三篇。建议大家最好先读读此系列的第二篇 —— 《CSS 架构：文件夹和文件结构》，有助于加深对本文的理解。 用层构建世界在开始开发一个大型项目之前，我们应该放眼全局，把多个网站的共同之处提炼出来。高楼大厦始于一砖一瓦，而项目的基石就是样式规格化、混入（Mixins）、通用图标以及局部模块层（元素、组件、图形逻辑、实体、页面……不一而足）等。为了使多重项目（即多个网站）正常运转，我们必须决定哪些样式是通用样式、哪些是专有样式 —— 通用样式写进基础层，而专有样式写在与其对应的层中。这是一条充满摸索和碰壁的实践之路。每当思考的角度发生变化，我们都需要逐层地挪动样式代码，直到我们觉得顺眼为止，这都是家常便饭了。理解了这项原则后，我们就可以开始着手构建作为基础的全局层了。这个全局层是整个多重项目（多个网站）的起始点。下面的示例图向我们演示了彼时我司的项目需求。 基础层要保持轻量，其中只包含 CSS 初始化、基本的 SASS mixins、通用图标、通用字体（如需）以及功能类，如果某些网格布局适用于所有网站，就将其作为通用网格添加到基础层中。在 _partials.scss 层（元素、组件等）中，我们主要用到的是 _elements.scss 层，该层中包含诸如通用弹窗、通用表单和通用标题等此类局部模块。我们应该在基础样式中添加的是所有（或者大多数）底层样式共有的部分。（更多关于文件夹和文件结构的细节，参见我的上一篇文章） 如何组织多个层在我们的架构中，每个层都至少包含三个文件：两个私有文件（局部样式文件和配置文件，称之为私有是因为它们不会被编译成一个 CSS 文件）和一个公共文件（本层的主文件）。每层的配置文件 _config.scss 通常包含变量。_local.scss 文件则包含内容样式，为当前层充当控制器或者包管理器的角色。而第三个文件（layer-name.scss）会调用前二者。layer-name.scss 文件： 123@import "config";@import "local";复制代码 另外一个我们要给自己定下的原则就是，尽可能把每个文件都拆分成尽可能小的部分（小文件）。这个原则会让重构非常方便。在每一层中，都要保证只编译 layer-name.scss 文件，即使某些层代表的是一个“虚拟项目”（如上面示例图中的“基础层框架”）。对于不会被编译成单独文件的私有文件，我们用一个下划线（_）作为其文件名的前缀。这里的下划线代表着此文件不能单独存在。注意：当导入私有文件时，我们书写其文件名时可以不必带上前缀下划线。层架构示例： 文件夹结构长这样： 12345678910sass/ | |- base-layer/ |- config/ |- local/ |- _config.scss |- _local.scss |- base-layer.css (编译后的层样式) |- base-layer.scss复制代码 继承假设我们想要从基础层开始创建一个项目。我们需要根据 base-layer 文件夹的内部结构，用新项目的名称照猫画虎地克隆一套出来。在后续例子中，我们把这个新项目称为 inherited-project。提示：把所有的层目录和项目目录都放在 Sass 的根目录中。该项目至少包含一个 _config.scss 文件、一个 _local.scss 文件和此层的核心 Sass 文件 —— 在本例中即为 inherited-project.scss。所有的层和项目都位于 Sass 的根目录中。 123456789101112131415161718sass/ | |- base-layer | |- config/ | |- local/ | |- _config.scss | |- _local.scss | |- base-layer.css (编译后的层样式) | |- base-layer.scss | |- inherited-project |- config/ |- local/ |- _config.scss |- _local.scss |- inherited-project.css (编译后的层样式) |- inherited-project.scss复制代码 项目 inherited-project 的配置文件引入了 base-layer 中的配置文件。这样一来，我们就能增加新变量或者覆写上层（base-layer）中的已有变量了。以下为 inherited-project/_config.scss 的一个例子： 12345/*加载 base-layer 配置信息 */@import &quot;../base-layer/config.scss&quot;;/** 局部的 Config 层 (按需添加或覆写变量)**/@import &quot;config/directions.scss&quot;;复制代码 内容样式文件 inherited-project/_local.scss 亦同理： 12345678/* 导入 base-layer 局部组件 */@import "../base-layer/local.scss";/* 局部字体 */@import "local/font-almoni.scss";/* 局部组件 */@import "local/elements.scss";@import "local/components.scss";复制代码 如果要创建的新层既有通用样式又有独特样式，那么从 base-layer 文件夹继承基础层样式再合适不过了。这一层会创建一个名为 inherited-project.css 的 CSS 文件。 在内部层中覆写变量使用“层”的方式覆写变量非常简单。比方说在基础层中有一个名为 $base-color 的变量，其值为 blue（$base-color: blue;）。要想覆写此变量，就需要在局部文件 _config.scss 中更新它的值。现在，所有使用该变量的组件 —— 不论是继承于基础层还是定义于局部层 —— 都会更新对应变量的的颜色值。 Global Story 全局某些模块并非在所有层中都会用到，因此如果你在基础层中定义它们，其他项目就会导入冗余代码。为了解决这个问题，我走了另一条路线，采用了全局模块的概念。这个概念是说，把仅用于某些层的模块放置于一个新的根目录（_partials）中，这个新的根目录位于所有层之外。然后，任何层都可以从全局目录 _partials 中导入所需模块。下图展示了将模块分离的例子： 每一层都可以按需从全局目录 _partials 中调用一个或多个模块。全局目录 _partials 示例： 123456sass/ | |- _partials/ |- base-layer/ |- inherited-project/复制代码 从 _partials 导入模块的 local.scss 文件： 1234567/* 导入 base-layer 中的局部组件 */@import "../base-layer/local.scss";/* 局部组件 */@import "local/partials.scss";/* 添加全局模块 */@import "../_partials/last-connection";复制代码 些许额外忠告 组织结构要有条理。要一直记得以满足需求的方式规划项目、保持最佳结构。 别重蹈覆辙。仅用 @import 即可轻松导入另一层的组件。比如说，某些组件定义在一个“体育”项目中，而这些组件与另一个项目中的“新闻”网站有关联。那我们就可以直接把这些组件 @import 进“新闻”网站中。（网站 = 层 = 项目） 充分利用 IDE 快捷方式。选用一款便于重构的编辑器，免于导致报错或故障。 立新不可破旧。在开发和后续重构中，每次都要把所有 Sass 根文件一同编译，以免新旧脱节。总结在本文中，我向大家展示了针对多网站项目的 CSS 体系结构的构建方法，这套思想提炼于我经年积累的知识和经验。本文是系列文章 CSS 架构文章新篇的第三篇，我会每隔几周跟大家分享后续篇章。如果觉得本文有趣，欢迎在 twitter 上或者 medium 上关注我。我的 CSS 架构系列文章： 规格化 CSS 还是 CSS 重置？！ CSS 架构 —— 文件夹和文件架构 多网站项目的 CSS 架构 转自：https://juejin.im/post/5d3a58df5188251ce02ff228]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端微服务架构]]></title>
    <url>%2F2019%2F07%2F26%2Fyuque%2F%E5%89%8D%E7%AB%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[后端微服务架构已经出现很久，作为前端，是否也能够形成与后端类似的微服务、微应用的架构。于是，翻阅了一些资料，在这里总结一下：1、 前端为什么需要微服务？a) 目前大多数应用中，各模块的功能划分清晰，特别是不同页面间的功能，基本可以分割开，而类似的功能在不同的应用中也经常出现，为此，前端花了很多功夫在重复的模块上b) 对于快速变化的市场，需要短时间内出demo或产品，而微服务的存在，可以快速组合应用，应对市场需求，类似阿里飞冰的拖拽应用c) 后端的微服务往往只考虑后端应用的实际情况，很多接口提供的数据并不适合前端进行UI展示，前端需要处理大量的逻辑，以适配界面，久而久之，前端逻辑繁重，代码难于维护d) 前端需要支撑不同的终端，像移动端、PC端2、 微服务带来的好处？a) 轻耦合：使得各功能模块间耦合度降低，并且与后台之间的耦合度降低b) 高复用：单个微服务可在多个应用中使用，免去了重复开发的工作量c) 独立性：各个服务可以独立部署、独立使用、独立开发d) 与技术无关：各服务之间可以使用不同的前端技术进行开发e) 快速集成：服务可以任意组合，迅速形成新的应用，以满足需求f) 扩展性：每个服务可以独立扩展，满足业务的伸缩性3、 前端微服务架构a) 前端依据业务功能或独立组件，拆分出不同的微应用1、2…，各微应用之间高内聚、低耦合b) 微应用与后台微服务之间的通信，通过BFF层为中介，BFF把应用所需展示的数据上送，微应用不需要任何的逻辑性处理c) 微应用组合层根据需求，将所需的微应用进行组合，各微应用之间的数据通信通过Custom Event进行d) 实现方式i. Single-spa：https://github.com/CanopyTax/single-spaii. 使用路由分发iii. 使用web componentiv. 将微服务包在iframe中 前端微服务架构]]></content>
  </entry>
  <entry>
    <title><![CDATA[web离线方案]]></title>
    <url>%2F2019%2F07%2F25%2Fyuque%2Fweb%E7%A6%BB%E7%BA%BF%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[Web离线应用解决方案——ServiceWorker 什么是ServiceWorker 在介绍ServiceWorker之前，我们先来谈谈PWA。PWA (Progressive Web Apps) 是一种 Web App 新模型，并不是具体指某一种前沿的技术或者某一个单一的知识点，，这是一个渐进式的 Web App，是通过一系列新的 Web 特性，配合优秀的 UI 交互设计，逐步的增强 Web App 的用户体验。 Https环境部署 响应式设计，一次部署，可以在移动设备和 PC 设备上运行 在不同浏览器下可正常访问。 浏览器离线和弱网环境可极速访问。 可以把 App Icon 入口添加到桌面。 点击 Icon 入口有类似 Native App 的动画效果。 灵活的热更新 在PWA要求的各种能力上，关于离线环境的支持我们就需要仰赖ServiceWorker。Service workers 本质上充当Web应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。由于PWA是谷歌提出，那么对ServiceWorker，同样也提出一些能力要求： 后台消息传递 网络代理，转发请求，伪造响应 离线缓存 消息推送 在目前阶段，ServiceWorker的主要能力集中在网络代理和离线缓存上。具体的实现上，可以理解为ServiceWorker是一个能在网页关闭时仍然运行的WebWorker。 ServiceWorker的生命周期 刚才讲到ServiceWorker拥有离线能力的WebWorker，既然这么强的能力，那就需要好好管理起来。所以我们要明白ServiceWorker的生命周期，也就是它从创建到销毁的过程。在所有介绍ServiceWorker生命周期的文章中最常见的就是下面这张图。 整个过程中一个ServiceWorker会经历：安装、激活、等待、销毁的阶段。但实际上这张图我感觉并没有清晰的解释ServiceWorker的声明周期，所以我制作了下面这张图。 这张图把ServiceWorker的声明周期分为了两部分，主线程中的状态和ServiceWorker子线程中的状态。子线程中的代码处在一个单独的模块中，当我们需要使用ServiceWorker时，按照如下的方式来加载： 12345678if (navigator.serviceWorker != null) &#123; // 使用浏览器特定方法注册一个新的service worker navigator.serviceWorker.register('sw.js') .then(function(registration) &#123; window.registration = registration; console.log('Registered events at scope: ', registration.scope); &#125;);&#125; 这个时候ServiceWorker处于Parsed解析阶段。当解析完成后ServiceWorker处于Installing安装阶段，主线程的registration的installing属性代表正在安装的ServiceWorker实例，同时子线程中会触发install事件，并在install事件中指定缓存资源 12345678910111213141516171819var cacheStorageKey = 'minimal-pwa-3';var cacheList = [ '/', "index.html", "main.css", "e.png", "pwa-fonts.png"]// 当浏览器解析完sw文件时，serviceworker内部触发install事件self.addEventListener('install', function(e) &#123; console.log('Cache event!') // 打开一个缓存空间，将相关需要缓存的资源添加到缓存里面 e.waitUntil( caches.open(cacheStorageKey).then(function(cache) &#123; console.log('Adding to Cache:', cacheList) return cache.addAll(cacheList) &#125;) )&#125;) 这里使用了Cache API来将资源缓存起来，同时使用e.waitUntil接手一个Promise来等待资源缓存成功，等到这个Promise状态成功后，ServiceWorker进入installed状态，意味着安装完毕。这时候主线程中返回的registration.waiting属性代表进入installed状态的ServiceWorker。 123456/* In main.js */navigator.serviceWorker.register('./sw.js').then(function(registration) &#123; if (registration.waiting) &#123; // Service Worker is Waiting &#125;&#125;) 然而这个时候并不意味着这个ServiceWorker会立马进入下一个阶段，除非之前没有新的ServiceWorker实例，如果之前已有ServiceWorker，这个版本只是对ServiceWorker进行了更新，那么需要满足如下任意一个条件，新的ServiceWorker才会进入下一个阶段： 在新的ServiceWorker线程代码里，使用了self.skipWaiting() 或者当用户导航到别的网页，因此释放了旧的ServiceWorker时候 或者指定的时间过去后，释放了之前的ServiceWorker 这个时候ServiceWorker的生命周期进入Activating阶段，ServiceWorker子线程接收到activate事件： 12345678910111213141516171819202122232425// 如果当前浏览器没有激活的service worker或者已经激活的worker被解雇，// 新的service worker进入active事件self.addEventListener('activate', function(e) &#123; console.log('Activate event'); console.log('Promise all', Promise, Promise.all); // active事件中通常做一些过期资源释放的工作 var cacheDeletePromises = caches.keys().then(cacheNames =&gt; &#123; console.log('cacheNames', cacheNames, cacheNames.map); return Promise.all(cacheNames.map(name =&gt; &#123; if (name !== cacheStorageKey) &#123; // 如果资源的key与当前需要缓存的key不同则释放资源 console.log('caches.delete', caches.delete); var deletePromise = caches.delete(name); console.log('cache delete result: ', deletePromise); return deletePromise; &#125; else &#123; return Promise.resolve(); &#125; &#125;)); &#125;); console.log('cacheDeletePromises: ', cacheDeletePromises); e.waitUntil( Promise.all([cacheDeletePromises] ) )&#125;) 这个时候通常做一些缓存清理工作，当e.waitUntil接收的Promise进入成功状态后，ServiceWorker的生命周期则进入activated状态。这个时候主线程中的registration的active属性代表进入activated状态的ServiceWorker实例 123456/* In main.js */navigator.serviceWorker.register('./sw.js').then(function(registration) &#123; if (registration.active) &#123; // Service Worker is Active &#125;&#125;) 到此一个ServiceWorker正式进入激活状态，可以拦截网络请求了。如果主线程有fetch方式请求资源，那么就可以在ServiceWorker代码中触发fetch事件：fetch(‘./data.json’) 这时在子线程就会触发fetch事件： 1234567891011121314self.addEventListener('fetch', function(e) &#123; console.log('Fetch event ' + cacheStorageKey + ' :', e.request.url); e.respondWith( // 首先判断缓存当中是否已有相同资源 caches.match(e.request).then(function(response) &#123; if (response != null) &#123; // 如果缓存中已有资源则直接使用 // 否则使用fetch API请求新的资源 console.log('Using cache for:', e.request.url) return response &#125; console.log('Fallback to fetch:', e.request.url) return fetch(e.request.url); &#125;) )&#125;) 那么如果在install或者active事件中失败，ServiceWorker则会直接进入Redundant状态，浏览器会释放资源销毁ServiceWorker。 现在如果没有网络进入离线状态，或者资源命中缓存那么就会优先读取缓存的资源： 缓存资源更新 那么如果我们在新版本中更新了ServiceWorker子线程代码，当访问网站页面时浏览器获取了新的文件，逐字节比对 /sw.js 文件发现不同时它会认为有更新启动 更新算法open_in_new，于是会安装新的文件并触发 install 事件。但是此时已经处于激活状态的旧的 Service Worker 还在运行，新的 Service Worker 完成安装后会进入 waiting 状态。直到所有已打开的页面都关闭，旧的 Service Worker 自动停止，新的 Service Worker 才会在接下来重新打开的页面里生效。如果想要立即更新需要在新的代码中做一些处理。首先在install事件中调用self.skipWaiting()方法，然后在active事件中调用self.clients.claim()方法通知各个客户端。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 当浏览器解析完sw文件时，serviceworker内部触发install事件self.addEventListener('install', function(e) &#123; debugger; console.log('Cache event!') // 打开一个缓存空间，将相关需要缓存的资源添加到缓存里面 e.waitUntil( caches.open(cacheStorageKey).then(function(cache) &#123; console.log('Adding to Cache:', cacheList) return cache.addAll(cacheList) &#125;).then(function() &#123; console.log('install event open cache ' + cacheStorageKey); console.log('Skip waiting!') return self.skipWaiting(); &#125;) )&#125;)// 如果当前浏览器没有激活的service worker或者已经激活的worker被解雇，// 新的service worker进入active事件self.addEventListener('activate', function(e) &#123; debugger; console.log('Activate event'); console.log('Promise all', Promise, Promise.all); // active事件中通常做一些过期资源释放的工作 var cacheDeletePromises = caches.keys().then(cacheNames =&gt; &#123; console.log('cacheNames', cacheNames, cacheNames.map); return Promise.all(cacheNames.map(name =&gt; &#123; if (name !== cacheStorageKey) &#123; // 如果资源的key与当前需要缓存的key不同则释放资源 console.log('caches.delete', caches.delete); var deletePromise = caches.delete(name); console.log('cache delete result: ', deletePromise); return deletePromise; &#125; else &#123; return Promise.resolve(); &#125; &#125;)); &#125;); console.log('cacheDeletePromises: ', cacheDeletePromises); e.waitUntil( Promise.all([cacheDeletePromises] ).then(() =&gt; &#123; console.log('activate event ' + cacheStorageKey); console.log('Clients claims.') return self.clients.claim(); &#125;) )&#125;) 注意这里说的是浏览器获取了新版本的ServiceWorker代码，如果浏览器本身对sw.js进行缓存的话，也不会得到最新代码，所以对sw文件最好配置成cache-control: no-cache或者添加md5。 实际过程中像我们刚才把index.html也放到了缓存中，而在我们的fetch事件中，如果缓存命中那么直接从缓存中取，这就会导致即使我们的index页面有更新，浏览器获取到的永远也是都是之前的ServiceWorker缓存的index页面，所以有些ServiceWorker框架支持我们配置资源更新策略，比如我们可以对主页这种做策略，首先使用网络请求获取资源，如果获取到资源就使用新资源，同时更新缓存，如果没有获取到则使用缓存中的资源。代码如下： 1234567891011121314151617181920212223242526self.addEventListener('fetch', function(e) &#123; console.log('Fetch event ' + cacheStorageKey + ' :', e.request.url); e.respondWith( // 该策略先从网络中获取资源，如果获取失败则再从缓存中读取资源 fetch(e.request.url) .then(function (httpRes) &#123; // 请求失败了，直接返回失败的结果 if (!httpRes || httpRes.status !== 200) &#123; // return httpRes; return caches.match(e.request) &#125; // 请求成功的话，将请求缓存起来。 var responseClone = httpRes.clone(); caches.open(cacheStorageKey).then(function (cache) &#123; return cache.delete(e.request) .then(function() &#123; cache.put(e.request, responseClone); &#125;); &#125;); return httpRes; &#125;) .catch(function(err) &#123; // 无网络情况下从缓存中读取 console.error(err); return caches.match(e.request); &#125;) )&#125;) 注意事项 ServiceWorker是一项新能力，目前IOS平台对他的支持性并不友好，但是在安卓侧已经没有大问题。而微信平台对它的支持也不错。 依赖项： 依赖Cache API 依赖Fetch API Promise API Https环境 错误排查： install或active事件失败 非Https环境 sw.js安装路径问题 scope设置 同时这里我也为大家录制视频，可以更清晰的看到这些细节。视频地址：https://v.qq.com/iframe/player.html?vid=b05172okw7e&amp;tiny=0&amp;auto=0 转自：https://www.cnblogs.com/dojo-lzz/p/8047336.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[egg]]></title>
    <url>%2F2019%2F07%2F25%2Fyuque%2Fegg%2F</url>
    <content type="text"><![CDATA[1、安装nodejs环境，最好选用nodejs最新的LTS版本 2、创建egg的环境 npm i egg-init -g(只需要安装一次)1sudo npm install egg-init -g 如果mac下安装完提示命令不存在，那么找到bashrc文件，文件在接下来就是 https://eggjs.org/en/intro/quickstart.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[【前端词典】关于 Babel 你必须知道的]]></title>
    <url>%2F2019%2F07%2F24%2Fyuque%2F%E3%80%90%E5%89%8D%E7%AB%AF%E8%AF%8D%E5%85%B8%E3%80%91%E5%85%B3%E4%BA%8E%20Babel%20%E4%BD%A0%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84%2F</url>
    <content type="text"><![CDATA[我第一次打开搜索引擎查询关于 Babel 的资料时，出现的竟然是关于 Babel 的传说。后来我花了小一天的时间去了解这个传说（来自《旧约圣经》）。 Babel Tower 是全人类联手建造的一个建筑，人们决心合力修建一座通天高塔。因为人们心里少了对上帝的敬畏，多了为自己歌功颂德的功利。上帝不希望这个奇观建成，于是让人们分化成不同的语言，令其不能交流。之后，因为沟通不畅，工程被迫放弃，而且人类从此不再团结，因为语言不通而分化成不同部落，并由于沟通问题，经常发生战乱，因此再无力撼动上帝的权威。 了解完这个神话之后，我后面就好好的去了解了一些有关 Babel 的知识，下面就是正题。 内容已经发布在 gitHub 了，欢迎围观 Star，更多文章都在 gitHub。 什么是 Babel Babel 官方文档: https://babeljs.io/ 我们知道各个浏览器对 JavaScript 版本的支持各不相同，有很多优秀的新语法都不能直接在浏览器中运行。为了解决这个“沟通不畅”的问题，所以就有了 Babel，Babel 的出现使得我们可以无须顾忌的去使用 ES6+ 的语法。 Babel is a JavaScript compiler. 这也是为何我们必须使用 ES6+ 语法的前提条件。 如果你现在还不清楚 ES6+ 语法的话，赶快学习去吧，要不然你就只能回家继承几十亿的家产啦。 Babel 如何编译先看下面这张图：你会发现 ES6 的语法确实被编译成浏览器可以识别的版本了，你是不是也在问这是怎么做到的呢？ babel 编译的阶段 babel 总共分为三个阶段：解析，转换，生成。 我们需要知道现在 babel 本身是不具备这种转化功能，提供这些转化功能的是一个个 plugin。所以我们没有配置任何 plugin 的时候，经过 Babel 输出的代码是没有改变的。 Plugin —— transform 的载体 Babel 自 6.0 起，就不再对代码进行转换。现在只负责图中的 parse 和 generate 流程，转换代码的 transform 过程全都交给插件去做。 例子： 123// 模板字面量const name = '小生方勤';let hello = `hello $&#123;name&#125;`; 上面是一个简单的模板字面量的例子，我们清楚这个是 ES6 的新特性，在不支持 ES6 的运行平台这段代码是会报错的，所以我们需要 Babel 来将其编译成 ES5 的代码。所以我们需要如下来配置 babel： 1234567// .babelrc 文件&#123; "plugins": [ "transform-es2015-template-literals" // 转译模版字符串的 plugins ], "presets": ["env", "stage-2"]&#125; preset（即一组预先设定的插件） preset: babel 插件集合的预设，包含某些插件 plugin。显然像上面那样一个一个配置插件会非常的麻烦，为了方便，babel 为我们提供了一个配置项叫做 persets（预设）。 当前 babel 推荐使用 babel-preset-env 替代 babel-preset-es201X ,env 的支持范围更广，包含es201X 的所有语法编译，并且它可以根据项目运行平台的支持情况自行选择编译版本。 plugins 与 presets 同时存在的执行顺序 先执行 plugins 的配置项,再执行 Preset 的配置项； plugins 配置项，按照声明顺序执行； Preset 配置项，按照声明逆序执行。 列入以下代码的执行顺序为： transform-es2015-template-literals stage-2 env123456789101112// .babelrc 文件&#123; "plugins": ["transform-es2015-template-literals", // 转译模版字符串的 plugins],"presets": [["env", &#123;// 是否自动引入 polyfill，开启此选项必须保证已经安装了 babel-polyfill// “usage” | “entry” | false, defaults to false."useBuiltIns": "usage"&#125;], "stage-2"]&#125; 这里讲一讲 useBuiltIns 配置我们可能在全局引入 babel-polyfill，这样打包后的整个文件体积必然是会变大的。但是通过设置 “useBuiltIns”:”usage” 能够把 babel-polyfill 中你需要用到的部分提取出来，不需要的去除。useBuiltIns 参数说明： false: 不对 polyfills 做任何操作 entry: 根据 target 中浏览器版本的支持，将 polyfills 拆分引入，仅引入有浏览器不支持的 polyfill usage(新)：检测代码中 ES6/7/8 等的使用情况，仅仅加载代码中用到的 polyfillsBabel 相关模块简要说明了解过 Babel 的同学，是否也觉得的模块有点多呢？我开始学习的时候就有这种感觉。其实每个模块是各司其职的。babel-core（核心）这个模块是最能顾名思义的了，即 babel 的核心模块。babel 的核心 api 都在这个模块中。也就是这个模块会把我们写的 js 代码抽象成 AST 树；然后再将 plugins 转译好的内容解析为 js 代码。具体怎么工作的这里就不详细说了，因为我也不知道。babel-cli babel-cli 官方文档：https://babeljs.io/docs/en/babel-cli/ babel-cli 是一个通过命令行对 js 文件进行转换的工具。当然我们一般不会使用到这个模块，因为一般我们都不会手动去做这个工作，这个工作基本都集成到模块化管理工具中去了，比如 webpack、Rollup 等。简单使用（需要先安装 babel-cli）： babel test.js -o compiled.jsbabel-nodebabel-node 是 babel-cli 的一部分，所以它在安装 babel-cli 的时候也同时安装了。它使 ES6+ 可以直接运行在 node 环境中。babel-polyfill(内部集成了 core-js 和 regenerator)babel 对一些新的 API 是无法转换，比如 Generator、Set、Proxy、Promise 等全局对象，以及新增的一些方法：includes、Array.form 等。所以这个时候就需要一些工具来为浏览器做这个兼容。 官网的定义：babel-polyfill 是为了模拟一个完整的 ES6+ 环境，旨在用于应用程序而不是库/工具。 babel-polyfill 主要有两个缺点： 使用 babel-polyfill 会导致打出来的包非常大，很多其实没有用到，对资源来说是一种浪费。 babel-polyfill 可能会污染全局变量，给很多类的原型链上都作了修改，这就有不可控的因素存在。 因为上面两个问题，所以在 Babel7 中增加了 babel-preset-env，我们设置 “useBuiltIns”:”usage”这个参数值就可以实现按需加载 babel-polyfill 啦。 babel-runtime &amp; babel-plugin-transform-runtime 在使用 Babel6 的时候， .babelrc 文件中会使用 babel-plugin-transform-runtime，而 package.json 中的 dependencies 同时包含了 babel-runtime，因为在使用 babel-plugin-transform-runtime 的时候必须把 babel-runtime 当做依赖。 .babelrc 配置： 12345678910111213&#123; "presets": [ ["env"] ], "plugins": [ ["transform-runtime", &#123; "helpers": false, // defaults to true "polyfill": false, // defaults to true "regenerator": true, // defaults to true "moduleName": "babel-runtime" // defaults to "babel-runtime" &#125;] ]&#125; 我们在启用插件 babel-plugin-transform-runtime 后，Babel 就会使用 babel-runtime 下的工具函数，将一些浏览器不能支持的特性重写，然后在项目中使用。 babel-runtime 内部也集成了 core-js、 regenerator、helpers 等 由于采用了沙盒机制，这种做法不会污染全局变量，也不会去修改内建类的原型，所以会有重复引用的问题。现在最好的实践应该是在 babel-preset-env 设置 “useBuiltIns”: “usage”，按需引入 polyfill。 三种方案对比 方案 优点 缺点 @babel/runtime &amp; @babel/plugin-transform-runtime 按需引入, 打包体积小 不能兼容实例方法 @babel/polyfill 完整模拟 ES2015+ 环境 打包体积过大, 污染全局对象和内置的对象原型 @babel/preset-env 按需引入, 可配置性高 小生不知 -_- babel7 的一些变化 preset 的变更： 淘汰 es201x，删除 stage-x，推荐 env 如果你还在使用 es201x，官方建议使用 env 进行替换。淘汰并不是删除，只是不推荐使用。但 stage-x 是直接被删了，也就是说在 babel7 中使用 es201X 是会报错的。 包名称变化babel 7 的一个重大变化，把所有 babel-* 重命名为 @babel/*，例如： babel-cli —&gt; @babel/cli。 babel-preset-env —&gt; @babel/preset-env低版本 node 不再支持babel 7.0 开始不再支持 nodejs 0.10, 0.12, 4, 5 这四个版本，相当于要求 nodejs &gt;= 6。还有一些包从其他包独立出来的变化等等关于如何配置 Babel接下来我会专门写一篇关于开发环境配置的问题，也就是自己完成脚手架的功能，所以这里就不提如何配置 Babel 啦。]]></content>
  </entry>
  <entry>
    <title><![CDATA[性能规范缘由]]></title>
    <url>%2F2019%2F07%2F23%2Fyuque%2F%E6%80%A7%E8%83%BD%E8%A7%84%E8%8C%83%E7%BC%98%E7%94%B1%2F</url>
    <content type="text"><![CDATA[1、适用场景： 本篇文章，适用于单个/多个大型项目、拥有超过 10 个以上的前端开发的场景。 前端项目的规模不同，成本收益比也会有所差别。 通常来说，人员越多、项目复杂度越高，那么收益/成本的比值越大。 对于人数较少、项目简单的开发团队，可能有部分措施不适用，因此应该根据具体情况来选用。 2、核心思想： 【1】解决问题：前端架构的设计，应是用于解决已存在或者未来可能发生的技术问题，增加项目的可管理性、稳定性、可扩展性。 【2】人效比：对于需要额外开发工作量的事务（本文中存在一些需要一定开发量的内容），我们在决定是否去做的时候，应该考虑到两个要素：第一个是花费的人力成本，第二个是未来可能节约的时间和金钱、避免的项目风险与资损、提高对业务的支撑能力以带来在业务上可衡量的更高的价值、以及其他价值。 【3】定性和定量：架构里设计的内容，一定要有是可衡量的意义的，最好是可以定量的——即可以衡量带来的收益或减少的成本，至少是可以定性的——即虽然无法用数字阐述收益，但我们可以明确这个是有意义的，例如增加安全性降低风险。 【4】数据敏感：专门写这一条强调数据作为依据的重要性。当我们需要说服其他部门/上级管理者，以推动我们设计的内容时，只有数据——特别是跟钱有关的数据，才是最有说服力的证明。由于篇幅所限，本文很难直接给出定量的值，因此建议架构设计者，先确保项目中设计使用 2.7 里的埋点系统，根据埋点系统获取的数据，对项目效果进行定量分析，并以此写成 PPT 和其他部门/上级管理者进行协调。 3、切入角度： 分为基础层和应用层。 基础层偏基础设施建设，与业务相关性较低。 应用层更贴近用户，用于解决某一个问题。 部分两个都沾边的，根据经验划分到其中一个。 4、其他 由于已经谈到架构层级，因此很多内容，并不仅仅只属于前端领域，有很多内容是复合领域（前端、后端、运维、测试），因此需要负责架构的人，技术栈足够全面，对未来发展有足够的前瞻性。 文章的内容结构为：【项目】—&gt;【解决的问题和带来的好处】—&gt;【项目的实际意义】 一、安全管理 二、静态资源优化 三、接口访问优化首屏直出、同构接口合并 四、页面渲染速度优化 五、总结 一、安全管理 前端的安全管理，通常要依赖于后端，至于只跟单纯有关系的例如 dom.innerHTML= xxx 这种太基础，就不提了。安全管理的很难从架构设计上完全避免，但还是有一定解决方案的，常见安全问题如下：XSS 注入：对用户输入的内容，需要转码（大部分时候要 server 端来处理，偶尔也需要前端处理），禁止使用 eval 函数；https：这个显然是必须的，好处非常多；CSRF：要求 server 端加入 CSRF 的处理方法（至少在关键页面加入）；意义：减少安全漏洞，避免用户受到损失，避免遭遇恶意攻击，增加系统的稳定性和安全性。 二、静态资源优化这个 level，主要是减少静态资源的加载时间，主要包括 html、css、js 和图片文件，静态资源的加载时间是前端性能最大的瓶颈（特别是图片），现如今优化的手段也很丰富，以下简要列举几种常用的方法 合并 css、js 文件，制作雪碧图：减少 http 的请求次数，节省网络请求时间 静态资源 cdn 分发：客户端可以通过最佳的网络链路加载静态资源 js、css 文件压缩，图片压缩，gzip 压缩：减少请求返回的数据量 静态资源缓存机制 权衡 dns 的查找 本文旨在提供一个清晰的优化思路，上述优化方法不做具体的说明，网上也能搜索到很多具体的教程，也可以留言、简信一起讨论 三、接口访问优化如果第一个 level 做得好，可以保证静态资源以一个较快的速度加载出来，然而，此时情况并没有完美，依然还存在两个明显的问题：1.静态资源加载完成了，页面依然还在转菊花，用户依然还在等待。现如今 web 应用已经走过完全由 php 和 jsp 等后端脚本语言渲染界面的时代，ajax 异步加载数据的方式已经成为主流，各种前端的 mvc 框架层出不穷，先加载静态资源，在执行 js 中的 ajax 请求到后台请求数据，重新渲染界面已经是一种通行的方案，这样便出现了静态资源加载完成，页面可见，然而用户还需要等待请求数据的进度条的情况（特别是接口访问速度慢的时候）2.用户点击任意一个按钮，进度条加载了半天，也没有响应。很多复杂的功能需要并行或者串行的请求很多接口才能完成，前端的网络状况稍微差一点，给与用户的体验都极差。以上两个问题在网络情况优异，接口请求速度快的情况下都不是问题，然而终端如果是一个手机，常常连 wifi 都不能保证，3g/4g 的网络你能期待它有多快，所以优化的潜力是巨大的 首屏直出、同构对于上述的问题一，如果页面的初始化数据，在后端完成渲染，其它的用户交互使用 ajax 的方式完成，也就是传统意义上的首屏直出，就可以得到很好的解决这种介于完全后端渲染和完全 ajax 渲染的方式是一个不错的思路，但是在 node 出现之前，很多人宁愿容忍首屏加载的菊花，也不愿意使用，为什么？因为前端和后端要维护两套模板，令人抓狂node 出来之后，前后端都都可以使用 js 语言，前后端同构（前端和后台公用模板代码）使得首屏直出重新拥有了生存的土壤，所以同构直出现在常常相提并论，形同一个成语 react 在同构直出方面做得比较出众，更多相关知识，可以留言、简信讨论 接口合并一个交互需要请求多个并行或串行接口实属正常，前端使用 3g/4g 等弱网络也着实是不可抗因素，所以最好的办法就是通过接口合并的方式来提高接口访问速度后台提供的接口有其既有粒度，强行合并不合时宜，提供一个新的合并的接口也缺乏机动性（前端发现一个新的合并需求，就要求后端提供一个接口，后端有开发工作量不说，还得没完没了的发版）如果把接口合并的主动权交给前端，那情况将会好很多，前端是最接近战火的地方，最知道应该如何组合接口。基于代理服务的接口合并方案应运而生（这是本人第一个值得骄傲的原创方案，这其中还包含了 node 实现，想想还有点小鸡动~） 欢迎使用 node 实现的基于代理服务的接口合并框架，欢迎建议、拍砖，您的意见是我优化的动力 页面渲染速度优化在页面不复杂、dom 层次不深的情况下，完成以上两个 level，就已经足够了。然而在复杂的页面上，却还有很大的优化空间，页面渲染速度的优化很大的程度上依托于程序员的个人编程素质，下面简要列举几点： css 放在顶部：优先渲染 js 放在底部：避免阻塞 减少 DOM 元素数量：这个最能体现变成水平了 img 标签要设置高宽：减少重绘重排另外，新晋前端框架 vue、react，虚拟 dom 的渲染方案，在内存中进行 dom diff 比较，做到最小化的操作真实的 dom （操作真实的 dom 常常会成为性能瓶颈），能极大的提高渲染速度 使用一些页面性能分析工具给自己的页面跑分，可以帮助养成良好的编程习惯、提升编程素质，例如：WebPagetest、Yslow 总结极致的性能优化需要有清晰的 step，这是理解以上三个维度的意义所在]]></content>
  </entry>
  <entry>
    <title><![CDATA[埋点系统]]></title>
    <url>%2F2019%2F07%2F23%2Fyuque%2F%E5%9F%8B%E7%82%B9%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[GrowingIO 百度统计 腾讯移动分析 MTA]]></content>
  </entry>
  <entry>
    <title><![CDATA[性能优化篇—Webpack构建速度优化]]></title>
    <url>%2F2019%2F07%2F23%2Fyuque%2F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AF%87%E2%80%94Webpack%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[从这 25 个方面优化你的前端项目]]></title>
    <url>%2F2019%2F07%2F23%2Fyuque%2F%E4%BB%8E%E8%BF%99%2025%20%E4%B8%AA%E6%96%B9%E9%9D%A2%E4%BC%98%E5%8C%96%E4%BD%A0%E7%9A%84%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[0、前言本文作者结合几年阿里经验，从基础层设计和应用层设计两个大方面，以及版本管理、统一脚手架、灰度发布、前后端分离、Mock、多页和单页、浏览器兼容、登录系统设计（单点登录）、CDN、负载均衡、多端共用一套接口等 25 个小方面谈大型项目前端架构。 相信本文一定可以给你一个更加全面的认识。 1、综合我在2年之前，写过一篇中小型项目的前端架构浅谈。随着能力的上升，以及在阿里巴巴工作的经验，是时候写一篇大型项目的前端架构分析了。本篇文章不会更多侧重于具体技术实现，而是尝试从更高角度出发，分析为什么要这么做，这些设计能解决什么问题，成本和收益如何。由于作者能力有限，可能会有所缺漏或者部分错误，欢迎读者指出。 1.1、适用场景：本篇文章，适用于单个/多个大型项目、拥有超过10个以上的前端开发的场景。前端项目的规模不同，成本收益比也会有所差别。通常来说，人员越多、项目复杂度越高，那么收益/成本的比值越大。对于人数较少、项目简单的开发团队，可能有部分措施不适用，因此应该根据具体情况来选用。 1.2、核心思想：【1】解决问题：前端架构的设计，应是用于解决已存在或者未来可能发生的技术问题，增加项目的可管理性、稳定性、可扩展性。【2】人效比：对于需要额外开发工作量的事务（本文中存在一些需要一定开发量的内容），我们在决定是否去做的时候，应该考虑到两个要素：第一个是花费的人力成本，第二个是未来可能节约的时间和金钱、避免的项目风险与资损、提高对业务的支撑能力以带来在业务上可衡量的更高的价值、以及其他价值。【3】定性和定量：架构里设计的内容，一定要有是可衡量的意义的，最好是可以定量的——即可以衡量带来的收益或减少的成本，至少是可以定性的——即虽然无法用数字阐述收益，但我们可以明确这个是有意义的，例如增加安全性降低风险。【4】数据敏感：专门写这一条强调数据作为依据的重要性。当我们需要说服其他部门/上级管理者，以推动我们设计的内容时，只有数据——特别是跟钱有关的数据，才是最有说服力的证明。由于篇幅所限，本文很难直接给出定量的值，因此建议架构设计者，先确保项目中设计使用2.7里的埋点系统，根据埋点系统获取的数据，对项目效果进行定量分析，并以此写成PPT和其他部门/上级管理者进行协调。 1.3、切入角度：分为基础层和应用层。基础层偏基础设施建设，与业务相关性较低。应用层更贴近用户，用于解决某一个问题。部分两个都沾边的，根据经验划分到其中一个。 1.4、其他由于已经谈到架构层级，因此很多内容，并不仅仅只属于前端领域，有很多内容是复合领域（前端、后端、运维、测试），因此需要负责架构的人，技术栈足够全面，对未来发展有足够的前瞻性。文章的内容结构为：【项目】—&gt;【解决的问题和带来的好处】—&gt;【项目的实际意义】 2、基础层设计 2.1、自建Gitlab这个是基础的基础了。本不应该提的，不过考虑到我最近面试的几家公司，有的公司（人数并不少）并没有使用Gitlab，因此专门提一下，并且使用这个的难度非常低。强烈建议使用Gitlab进行版本管理，自建Gitlab难度并不大，方便管理，包括代码管理、权限管理、提交日志查询，以及联动一些第三方插件。意义：公司代码是公司的重要资产，使用自建Gitlab可以有效保护公司资产。 2.2、版本管理版本管理的几个关键点： 发布后分支锁死，不可再更改：指当例如0.0.1版本成功发布后，不可再更改0.0.1分支上的代码，否则可能会导致版本管理混乱。 全自动流程发布；指应避免开发者提交后，手动编译打包等操作，换句话说，开发人员发布后，将自动发布到预发布/生产环境。开发人员不和相关环境直接接触。实现这个需要参考下面的2.3。 多版本并存；指当例如发布0.0.2版本后，0.0.1版本的代码应仍保存在线上（例如CDN），这样当出现线上bug时，方便快速回滚到上一个版本。 意义：提高项目的可控性。 2.3、自动编译发布Jenkins这个工具用于在代码发布后，执行一系列流程，例如自动编译打包合并，然后再从Gitlab发布到CDN或者静态资源服务器。使用这个工具，可以让一般研发人员不关心代码传到Gitlab后会发生什么事情，只需要专心于开发就可以了。意义：让研发人员专心于研发，和环境、运维等事情脱钩。 2.4、纯前端版本发布纯前端版本发布分为两步： 前端发布到生产环境——此时可以通过外网链接加正确的版本号访问到新版本的代码，但页面上的资源还是旧版本； 前端通过配置工具（或者是直接更新html文件），将html中引入的资源，改为新版本。 解决的问题是：当前端需要发布新版本时，可以不依赖于后端（根据实际情况，也可以不依赖于运维）。毕竟有很多需求并不需要后端介入，单纯改个前端版本后就要后端发布一次，显然是一件非常麻烦的事情。这个需要专门的工具，用于配置版本发布，我最近就在写这个。意义：提高发布效率，降低发布带来的人员时间损耗（这些都是钱），也可以在前端版本回滚的时候，速度更快。 2.5、统一脚手架适用场景：有比较多独立中小项目。好处： 可以减少开发人员配置脚手架带来的时间损耗（特殊功能可以fork脚手架后再自行定制）； 统一项目结构，方便管理，也降低项目交接时带来的需要熟悉项目的时间； 方便统一技术栈，可以预先引入固定的组件库； 意义：提高开发人员在多个项目之间的快速切换能力，提高项目可维护性，统一公司技术栈，避免因为环境不同导致奇怪的问题。 2.6、Node中间层适用场景：需要SEO且前端使用React、vue，或前端介入后端逻辑，直接读取后端服务或者数据库的情况。 SEO：仁者见仁智者见智，虽然很多公司已经不做了，但通常认为，还是有一定意义的（特别是需要搜索引擎引流的时候），因此React或者Vue的同构是必须的。并且同构还可以降低首页白屏时间； 前端读取后端服务/数据库：好处是提高前端的开发效率和对业务的支持能力，缺点是可能导致P0级故障。 意义：让前端可以侵入后端领域，质的提升对业务的支持能力。 2.7、埋点系统强烈推荐前端做自己的埋点系统。这个不同于后端的日志系统。前端埋点系统的好处： 记录每个页面的访问量（日周月年的UV、PV）； 记录每个功能的使用量； 捕捉报错情况； 图表化显示，方便给其他部门展示； 埋点系统是前端高度介入业务，把握业务发展情况的一把利剑，通过这个系统，我们可以比后端更深刻的把握用户的习惯，以及给产品经理、运营等人员提供准确的数据依据。当有了数据后，前端人员就可以针对性的优化功能、布局、页面交互逻辑、用户使用流程。埋点系统应和业务解耦，开发人员使用时注册，然后在项目中引入。然后在埋点系统里查看相关数据（例如以小时、日、周、月、年为周期查看）意义：数据是money，数据是公司的生命线，数据是最好的武器。 2.8、监控和报警系统监控和报警系统应基于埋点系统而建立，在如以下场景时触发： 当访问量有比较大的变化（比如日PV/UV只有之前20%以下）时，自动触发报警，发送邮件到相关人员邮箱； 比如报错量大幅度上升（比如200%或更高），则触发报警； 当一段时间内没有任何访问量（不符合之前的情况），则触发报警； 每过一段时间，自动汇总访问者/报错触发者的相关信息（例如系统、浏览器版本等）； 建设这个系统的好处在于，提前发现一些不容易发现的bug（需要埋点做的比较扎实）。有一些线上bug，因为用户环境特殊，导致无法被开发人员和测试人员发现。但其中一部分bug又因为不涉及资金，并不会导致资损（因此也不会被后端的监控系统所发现），这样的bug非常容易影响项目里某个链路的正常使用。意义：提高项目的稳定性，提高对业务的把控能力。降低bug数，降低资损的可能性，提前发现某些功能的bug（在工单到来之前）。 2.9、安全管理前端的安全管理，通常要依赖于后端，至于只跟单纯有关系的例如dom.innerHTML= xxx 这种太基础，就不提了。安全管理的很难从架构设计上完全避免，但还是有一定解决方案的，常见安全问题如下： XSS注入：对用户输入的内容，需要转码（大部分时候要server端来处理，偶尔也需要前端处理），禁止使用eval函数； https：这个显然是必须的，好处非常多； CSRF：要求server端加入CSRF的处理方法（至少在关键页面加入）； 意义：减少安全漏洞，避免用户受到损失，避免遭遇恶意攻击，增加系统的稳定性和安全性。 2.10、EslintEslint的好处很多，强烈推荐使用： 降低低级bug（例如拼写问题）出现的概率； 增加代码的可维护性，可阅读性； 硬性统一代码风格，团队协作起来时更轻松； 总的来说，eslint推荐直接配置到脚手架之中，对我们提高代码的可维护性的帮助会很大。可以考虑在上传到gitlab时，硬性要求eslint校验，通过的才允许上传。意义：提高代码的可维护性，降低团队协作的成本。 2.11、灰度发布灰度发布是大型项目在发布时的常见方法，指在发布版本时，初始情况下，只允许小比例（比如1~5%比例的用户使用），若出现问题时，可以快速回滚使用老版本，适用于主链路和访问量极大的页面。好处有以下几点： 生产环境比开发环境复杂，灰度发布时可以在生产环境小范围尝试观察新版本是否可以正常运行，即使出问题，也可以控制损失。 对于大版本更新，可以先灰度一部分，观察埋点效果和用户反馈（即所谓的抢先试用版）。假如效果并不好，那么回滚到老版本也可以及时止损； 当我们需要验证某些想法或问题的时候，可以先灰度一部分，快速验证效果如何，然后查漏补缺或者针对性优化； 灰度发布通常分为多个阶段：【1】1%；【2】510%；【3】3050%；【4】全量推送（100%）。灰度发布一定要允许配置某些IP/账号访问时，可以直接访问到灰度版本。意义：降低风险，提高发布灵活度。 2.12、前后端分离这个并不是指常见的前后端分离，而是指在分配前后端管控的领域。中小项目常见的情况是后端只提供接口和让某个url指向某个html，前端负责html、css、js等静态资源。但大型项目并不建议这么做，建议前端负责除html以外的静态资源，而html交给后端处理，理由有很多： 后端进行渲染，方便统一插入一些代码和资源，例如埋点js，监控js，国际化文本资源，页面标识符等。这些通常是后端通过调用某些服务直接写入的； 当页面需要统一的头尾时（参考淘宝里我的淘宝页面），前端不应该关注这些跟当前页面无关的东西； 某些东西，如果通过html来管理，那么耦合度太高了，违背了解耦和分离的原则； 前端版本发布在后端引入某种功能模块后，可以从单独的页面控制前端发布内容，比更新html更方便，也利于灰度发布； 意义：更规范的进行页面管理，降低页面和功能的耦合度，减少复杂页面的环境配置时间。 2.13、MockMock也是常见前端系统之一，用于解决在后端接口未好时，生成返回的数据。我个人不太建议开发一个专门的系统来Mock，更好的Mock手法是直接嵌入到脚手架之中。思路如下： 当在开发环境下，访问链接通常是localhost:8000/index.html，此时加入后缀 ?debug=true； 封装好的异步请求在发现当前链接有以上标志时，认为是测试环境，访问/userinfo 时，不去读取线上的数据（因为也读取不到），去本地环境读取 src/test_ajax/userinfo.json，并将内容返回给用户； 异步请求正常拿到数据，在页面中显示； 当线上接口可以获取到数据后，从network里找到返回的数据，放入/ src/test_ajax/userinfo.json中，此时再次本地调试的话，相当于使用的是线上的真实数据。 这种处理，可以降低mock的复杂度，随时更改mock时返回的数据，比单独开发一个mock系统性价比更高。意义：在前后端并行开发时，降低沟通交流成本，方便开发完毕后直接对接。 2.14、定期备份备份是常被忽略的一件事情，但当我们遇见毁灭性场景时，缺少备份带来的损失是非常大的，常见场景： 服务器损坏，导致存在该服务器上的内容全部完蛋； 触发某致命bug或者错误操作（例如rm -f），导致文件和数据全部消失； 数据库出现错误操作或出现问题，导致用户数据、公司资产遭受严重损失； 总的来说，没人想遇见这样的场景，但我们必须考虑这种极端情况的发生，因此需要从架构层面解决这个问题。常见方法是定期备份、多机备份、容灾系统建设等。意义：避免在遭遇极端场景时，给公司带来不可估量的损失。 3、应用层设计 3.1、多页和单页除了特殊场景，通常推荐使用多页架构。理由如下： 多页项目，页面和页面之间是独立的，不存在交互，因此当一个页面需要单独重构时，不会影响其他页面，对于有长期历史的项目来说，可维护性、可重构性要高很多； 多页项目的缺点是不同页面切换时，会有一个白屏时间，但通常来说，这个时间并不长，大部分现有大公司的线上网页，都是这样的，因此认为是可以接受的； 多页项目可以单次只更新一个页面的版本，而单页项目如果其中一个功能模块要更新（特别是公共组件更新），很容易让所有页面都需要更新版本； 多页项目的版本控制更简单，如果需要页面拆分，调整部分页面的使用流程，难度也会更低； 灰度发布更友好； 之前面试的一家，采用了单页的形式，之前因为种种原因，同时采用了ng和react。由于项目历史也比较久（3年以上），结果导致目前继续维护更新的难度很大，即使想部分重构，也很麻烦。意义：降低长期项目迭代维护的难度。 3.2、以应用为单位划分前端项目在项目比较大的时候，将所有页面的前端文件放入到同一个代码仓库里，我之前参与过一家企业的前端项目开发，发现其就是这么做的。根据使用经验来看，存在很多问题： 会极大的增加代码的维护难度； 项目会变得很丑陋； 不方便权限管理，容易造成页面误更改或代码泄密； 任何人都有权利改任何他能看到的页面（在合并代码的时候，管理人员并不能确定他本次修改的页面是否是需求里他应该改的页面）； 发布成本高，即使改一个页面，也需要发布所有资源； 因此，我们应该避免这种现象的发生，个人推荐以应用为单位进行开发、发布。所谓应用即指一个业务涉及到的前后端代码，好处很多： 方便进行管理，当某个业务有需求变更时，可以只给研发人员该业务前端应用的developer权限； 在需要发布某业务时，只需要发布该业务的所属应用即可； 意义：规范项目，增加代码的安全性，降低项目维护成本。 3.3、基础组件库的建设这个蛮基础的，对于组件库的建设，不建议研发人员较少时去做这件事情，专职前端开发人数少于10人时，建议使用比较靠谱的第三方UI库，例如Antd，这样性价比更高。设计基础组件库的前提，是要求统一技术栈，这样才能最大化基础组件库的效益。组件库建议以使用以下参考标准： 使用ts； 可扩展性强； 适用程度高； 文档清楚详细； 版本隔离，小版本优化加功能，大改需要大版本更新； 和UI协调统一，要求UI交互参与进来； 总的来说，建设起来后，利大于弊，但是需要专人维护，因此还是有一定成本的。意义：统一不同/相同产品线之间的风格，给用户更好的体验，减少单次开发中写UI组件时浪费的时间和人力，提高开发效率。 3.4、技术栈统一前端有三大主流框架，还有兼容性最强jQuery，以及各种第三方库，UI框架。因此项目需求如果复杂一些，很容易形成一个大杂烩。因此前端的技术栈必须统一，具体来说，建议实现以下举措： 三大框架选型其一，团队水平一般推荐Vue、水平较好推荐React，对外项目选React或者ng； 需要兼容IE8或更老版本时，建议使用jQuery； 组件库自建或者统一选择一个固定的第三方； 一些特殊第三方库统一使用一个版本，例如需要使用地图时，固定使用高德或百度或腾讯地图； 基础设施建设应避免重复造轮子，所有团队尽量共用，并有专门的前端平_台负责统一这些东西，对于特殊需求，可以新建，但应当有说服力； 总的来说，技术栈统一的好处很多，可以有效提高开发效率，降低重复造轮子产生的成本。意义：方便招人，简化团队成员培养成本，以及提高项目的可持续性。 3.5、浏览器兼容常见的问题是IE6、7、8，以及部分小众浏览器（PC和手机）产生的奇怪问题。因此应该考虑统一解决方案，避免bug的重复产生。常见解决方案有： 配置postcss，让某些css增加兼容性前缀； 写一个wepback的loader，处理某些特殊场景； 规范团队代码，使用更稳定的写法（例如移动端避免使用fixed进行布局）； 对常见问题、疑难问题，总结解决方案并团队共享； 建议或引导用户使用高版本浏览器（比如chrome）； 意义：避免浏览器环境产生的bug，以及排查此类bug所浪费的大量时间。 3.6、内容平_台建设为了提高公司内部的沟通效率，总结经验，以及保密原因。应建设一个内部论坛+博客站点。其具备的好处如下： 可以记录公司的历史； 研发同学之间分享经验； 总结转载一些外界比较精品的文章，提高大家的眼界； 增加公司内部同学的交流，有利于公司的团队和文化建设； 对某些技术问题可以进行讨论，减少因没有达成共识带来的沟通损耗； 众所周知，大型互联网公司通常都有这样一个内部论坛和博客站点。其降低了公司的沟通和交流成本，也增加了公司的技术积累。意义：博客增强技术积累，论坛增强公司内部沟通能力。 3.7、权限管理平_台当公司内部人员较多时，应有一个专门的平_台，来管理、规范用户的权限以及可访问内容。权限管理平_台有几个特点： 必然和Server端天然高耦合度，因此需要有专门的控制模块负责处理权限问题（负责Server端开发处理，或者前端通过中间层例如Node层介入处理）； 自动化流程控制，即用户创建、申请、审批、离职自动删除，都应该是由系统推进并提醒相关人士，必要时应能触发报警； 权限应有时效性，减少永久性权限的产生； 审批流程应清晰可见，每一阶段流程应具体明确； 应与公司流程紧密结合，并且提高可修改性，方便公司后期进行流程优化； 意义：使得公司内部流程正规化、信息化。 3.8、登录系统设计（单点登录）当公司内部业务线比较复杂但相互之间的耦合度比较高时，我们应该考虑设计添加单点登录系统。具体来说，用户在一处登录，即可以在任何页面访问，登出时，也同样在任何页面都失去登录状态。SSO的好处很多： 增强用户体验； 打通了不同业务系统之间的用户数据； 方便统一管理用户； 有利于引流； 降低开发系统的成本（不需要每个业务都开发一次登录系统和用户状态控制）； 总的来说，大中型web应用，SSO可以带来很多好处，缺点却很少。意义：用户体验增强，打通不同业务之间的间隔，降低开发成本和用户管理成本。 3.9、CDN前端资源的加载速度是衡量用户体验的重要指标之一。而现实中，因为种种因素，用户在加载页面资源时，会受到很多限制。因此上CDN是非常有意义的，好处如下： 用户来自不同地区，加入CDN可以使用户访问资源时，访问离自己比较近的CDN服务器，降低访问延迟； 降低服务器带宽使用成本； 支持视频、静态资源、大文件、小文件、直播等多种业务场景； 消除跨运营商造成的网络速度较慢的问题； 降低DDOS攻击造成的对网站的影响； CDN是一种比较成熟的技术，各大云平_台都有提供CDN服务，价格也不贵，因此CDN的性价比很高。意义：增加用户访问速度，降低网络延迟，带宽优化，减少服务器负载，增强对攻击的抵抗能力。 3.10、负载均衡目前来看，负载均衡通常使用Nginx比较多，以前也有使用Apache。当遇见大型项目的时候，负载均衡和分布式几乎是必须的。负载均衡有以下好处： 降低单台server的压力，提高业务承载能力； 方便应对峰值流量，扩容方便（如举办某些活动时）； 增强业务的可用性、扩展性、稳定性； 负载均衡已经是蛮常见的技术了，好处不用多说，很容易理解。意义：增强业务的可用性、扩展性、稳定性，可以支持更多用户的访问。 3.11、多端共用一套接口目前常见场景是一个业务，同时有PC页面和H5页面，由于业务是一样的，因此应避免同一个业务有多套接口分别适用于PC和H5端。因此解决方案如下： 后端提供的接口，应该同时包含PC和H5的数据（即单独对一个存在亢余数据）； 接口应当稳定，即当业务变更时，应尽量采取追加数据的形式； 只有在单独一端需要特殊业务流程时，设计单端独有接口； 多端共用接口，是减少开发工作量，并且提高业务可维护性的重要解决方案。意义：降低开发工作量，增强可维护性。 4、总结由于各个公司具体情况不同，项目也具有特殊性，因此以上设计不可强行套入，应根据自己公司规模、项目进展、人员数量等，先添加比较重要的功能和设计。并需要考虑到长期项目的可维护性和发展需要，对部分基础设施进行提前研发设计。篇幅所限，因此无法面面俱到，只提了一些我认为比较重要的架构层面需要考虑的内容，欢迎大家补充]]></content>
  </entry>
  <entry>
    <title><![CDATA[组件库和UI库]]></title>
    <url>%2F2019%2F07%2F23%2Fyuque%2F%E7%BB%84%E4%BB%B6%E5%BA%93%E5%92%8CUI%E5%BA%93%2F</url>
    <content type="text"><![CDATA[https://github.com/weilanwl/ColorUI【小程序组件库】]]></content>
  </entry>
  <entry>
    <title><![CDATA[图片工具]]></title>
    <url>%2F2019%2F07%2F23%2Fyuque%2F%E5%9B%BE%E7%89%87%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[https://icons8.com/ https://www.easyicon.net/ https://www.iconfont.cn/ https://gka.js.org https://icomoon.io/]]></content>
  </entry>
  <entry>
    <title><![CDATA[Flutter全平台！迁移现有Flutter项目到WEB端]]></title>
    <url>%2F2019%2F07%2F22%2Fyuque%2FFlutter%E5%85%A8%E5%B9%B3%E5%8F%B0%EF%BC%81%E8%BF%81%E7%A7%BB%E7%8E%B0%E6%9C%89Flutter%E9%A1%B9%E7%9B%AE%E5%88%B0WEB%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[Flutter 是 Google推出并开源的移动应用开发框架，主打跨平台、高保真、高性能。开发者可以通过 Dart语言开发 App，一套代码同时运行在 iOS 、Android、web和桌面端。Flutter官网：&gt; https://flutter-io.cnFlutter_web是Flutter代码兼容web的实现，可以将使用Dart编写的现有Flutter代码编译成可以嵌入浏览器并部署到任何Web服务器的客户端。Our goal is to enable building applications for mobile and web simultaneously from a single codebase. However, to allow experimentation, the tech preview Flutter for web is developed in a separate namespace. So, as of today an existing mobile Flutter application will not run on the web without changes.Flutter的目标是通过单一代码库同时构建移动和Web应用程序。 但是，为了进行实验，Flutter_web是在一个单独的命名空间中开发的。 因此，截至目前，现有的移动Flutter应用程序无法在不进行更改的情况下在Web上运行。简而言之就是Flutter现在还不支持既是移动应用也是Web应用，需要自己进行迁移，但相信日子不会太远。 迁移Flutter项目到WEB端这次我们迁移的项目是flutter_challenge_googlemaps，效果图如下： 怎么做？大多数Dart代码都是共用的，需要改变的只是一些依赖和配置。首先是pubspec.yaml需要用flutter_web来替换flutter，同时移除asset和字体相关的代码。 1234567891011121314151617181920212223name: flutter_web_challenge_googlemapsenvironment: # You must be using Flutter &gt;=1.5.0 or Dart &gt;=2.3.0 sdk: &apos;&gt;=2.3.0-dev.0.1 &lt;3.0.0&apos;dependencies: flutter_web: any flutter_web_ui: anydev_dependencies: build_runner: ^1.4.0 build_web_compilers: ^2.0.0dependency_overrides: flutter_web: git: url: https://github.com/flutter/flutter_web path: packages/flutter_web flutter_web_ui: git: url: https://github.com/flutter/flutter_web path: packages/flutter_web_ui flutter_web_test: git: url: https://github.com/flutter/flutter_web path: packages/flutter_web_test 通过flutter package get更新依赖后，需要更新lib路径下dart文件中的相关引用。 1234//flutterimport &apos;package:flutter/material.dart&apos;;//flutter webimport &apos;package:flutter_web/material.dart&apos;; 差别就是将flutter替换为flutter_web而已，代码基本不用动。接下来，为了预览网页，我们需要自己创建web目录，并在目录下创建web/index.html 和 web/main.dart文件。web/index.html 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script defer src=&quot;main.dart.js&quot; type=&quot;application/javascript&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; web/main.dart 1234567import &apos;package:flutter_web_ui/ui.dart&apos; as ui;// 将flutter_web_challenge_googlemaps替换为自己的packageimport &apos;package:flutter_web_challenge_googlemaps/main.dart&apos; as app;main() async &#123; await ui.webOnlyInitializePlatform(); app.main();&#125; 至于资源文件、图片、字体等，和Flutter项目不同，这些都需要放到web\assets目录路径下，同时要记得更新代码中的相关引用。 123Image.asset(&quot;assets/logo.ong&quot;);// 需要更改为Image.asset(&quot;logo.png&quot;); 如果你有使用Material Icon的话，你需要在web/assets目录下创建FontManifest.json文件，并添加相关地址。 1234567891011[ &#123; &quot;family&quot;: &quot;MaterialIcons&quot;, &quot;fonts&quot;: [ &#123; &quot;asset&quot;: &quot;https://fonts.gstatic.com/s/materialicons/v42/flUhRq6tzZclQEJ-Vdg-IuiaDsNcIhQ8tQ.woff2&quot; &#125; ] &#125; ] 整个web目录会如下图所示: 运行项目，可以发现和移动端基本没有区别。 效果还是蛮流畅的🤙。 如果你想查看release版本，可以运行flutter pub global run webdev serve -r如果你想发布制品，则可以运行flutter pub global run webdev build这会在项目的根路径下生成一个build文件夹，里面包含可以部署到服务器上的文件，如下图所示：你可以运用gh-pages简单的将其部署到Github上，然后预览效果https://flutter-ui-challenges.github.io/flutter_web_challenge_googlemaps/#/关于如何运用gh-pages进行页面预览，可以查看此链接：&gt; https://www.cnblogs.com/MuYunyun/p/6082359.html 写在最后虽然说跨平台的项目很多的，比如weex、RN、Kotlin等等，但是真正让我体会到跨平台高效一体的体验还是Flutter，这也许就是为什么年后我一直在学习和从事Flutter开发的原因之一了。当然flutter_web还处于早期阶段，一些flutter的功能还没有完全移植过来，比如高斯模糊效果，不过Flutter1.0正式版本才到来不久，相信在不久的将来，这些全都会有。最后附上相关地址：https://github.com/flutter-ui-challenges/flutter_web_challenge_googlemaps，本文是为了方便查看所以新开了一个仓库，实际上只需要新开一个web分支就可以了。 参考文档flutter_web：https://github.com/flutter/flutter_web迁移指南：https://github.com/flutter/flutter_web/blob/master/docs/migration_guide.md]]></content>
  </entry>
  <entry>
    <title><![CDATA[Flutter配置for Mac -- VSCode]]></title>
    <url>%2F2019%2F07%2F22%2Fyuque%2FFlutter%E9%85%8D%E7%BD%AEfor%20Mac%20--%20VSCode%2F</url>
    <content type="text"><![CDATA[官方开发文档地址官方开发文档地址 Flutter下载包地址下载包git地址 VSCode下载地址自行搜索下载VSCode下载 配置Flutter-SDK1：解压压缩包，以我个人配置为例，放到文档中，并且创建一个文件夹Flutter，且把解压后的文件放入该文件夹中。2：配置环境路劲配置环境变量,使用命令行： 1`cd`到上一步的路劲 执行 1vim ~/.bash_profile 保存并退出（啥事不用干）保存之后执行如下命令 1export PATH=`pwd`/flutter/bin:$PAT 保存一下，注意如果这个文件不存在，那么就新建一个。保存完毕之后运行命令: 1source ~/.bash_profile 这个时候应该能运行flutter命令了，我们运行命令行： 1flutter -h 执行完命令后出现如下日志 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Manage your Flutter app development.Common commands: flutter create &lt;output directory&gt; Create a new Flutter project in the specified directory. flutter run [options] Run your Flutter application on an attached device or in an emulator.Usage: flutter &lt;command&gt; [arguments]Global options:-h, --help Print this usage information.-v, --verbose Noisy logging, including all shell commands executed. If used with --help, shows hidden options.-d, --device-id Target device id or name (prefixes allowed). --version Reports the version of this tool. --suppress-analytics Suppress analytics reporting when this command runs. --bug-report Captures a bug report file to submit to the Flutter team. Contains local paths, device identifiers, and log snippets. --packages Path to your &quot;.packages&quot; file. (required, since the current directory does not contain a &quot;.packages&quot; file)Available commands: analyze Analyze the project&apos;s Dart code. attach Attach to a running application. bash-completion Output command line shell completion setup scripts. build Flutter build commands. channel List or switch flutter channels. clean Delete the build/ directory. config Configure Flutter settings. create Create a new Flutter project. devices List all connected devices. doctor Show information about the installed tooling. drive Runs Flutter Driver tests for the current project. emulators List, launch and create emulators. format Format one or more dart files. help Display help information for flutter. install Install a Flutter app on an attached device. logs Show log output for running Flutter apps. make-host-app-editable Moves host apps from generated directories to non-generated directories so that they can be edited by developers. packages Commands for managing Flutter packages. precache Populates the Flutter tool&apos;s cache of binary artifacts. run Run your Flutter app on an attached device. screenshot Take a screenshot from a connected device. stop Stop your Flutter app on an attached device. test Run Flutter unit tests for the current project. trace Start and stop tracing for a running Flutter app. upgrade Upgrade your copy of Flutter.Run &quot;flutter help &lt;command&gt;&quot; for more information about a command.Run &quot;flutter help -v&quot; for verbose help output, including less commonly usedoptions. 检查环境1flutter doctor 出现日志如下 1234567891011121314151617181920212223242526272829![环境检查如下](https://upload-images.jianshu.io/upload_images/1416781-f1797dbb30e71ace.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)Doctor summary (to see all details, run flutter doctor -v):[✓] Flutter (Channel stable, v1.0.0, on Mac OS X 10.13.1 17B1003, locale zh-Hans-CN)[✗] Android toolchain - develop for Android devices ✗ Unable to locate Android SDK. Install Android Studio from: https://developer.android.com/studio/index.html On first launch it will assist you in installing the Android SDK components. (or visit https://flutter.io/setup/#android-setup for detailed instructions). If Android SDK has been installed to a custom location, set $ANDROID_HOME to that location. You may also want to add it to your PATH environment variable.[!] iOS toolchain - develop for iOS devices (Xcode 9.2) ✗ libimobiledevice and ideviceinstaller are not installed. To install with Brew, run: brew update brew install --HEAD usbmuxd brew link usbmuxd brew install --HEAD libimobiledevice brew install ideviceinstaller ✗ ios-deploy not installed. To install with Brew: brew install ios-deploy[!] Android Studio (not installed)[✓] VS Code (version 1.31.1)[✓] Connected device (1 available)! Doctor found issues in 3 categories. NOTICE:按照检测结果的说明，如果有[!] ✗ 标志，表示本行检测不通过，需要做一些设置或者安装一些软件。因为我是iOS开发者，所以只针对iOS开发体系所有看上面有提示x的所以就执行每一行提示的指令 123456789✗ libimobiledevice and ideviceinstaller are not installed. To install with Brew, run: brew update brew install --HEAD usbmuxd brew link usbmuxd brew install --HEAD libimobiledevice brew install ideviceinstaller ✗ ios-deploy not installed. To install with Brew: brew install ios-deploy 依次执行完成即可NOTICE不同用户看到信息不用，请酌情处理 到此执行已经配置完成了。 配置VSCodevscode配置如图NOTICE:注意如图上得箭头，选择放置Flutter的文件夹选择bin文件夹的路劲即可 创建新的应用 启动 VS Code 调用 View&gt;Command Palette… 输入 ‘flutter’, 然后选择 ‘Flutter: New Project’ action 输入 Project 名称 (如myapp), 然后按回车键(可能时间较长) 指定放置项目的位置，然后按蓝色的确定按钮 等待项目创建继续，并显示main.dart文件 上述命令创建一个Flutter项目，项目名为myapp，其中包含一个使用Material 组件的简单的演示应用程序。在项目目录中，您的应用程序的代码位于 lib/main.dart. 运行应用程序 确保在VS Code的右下角选择了目标设备 按 F5 键或调用Debug&gt;Start Debugging 等待应用程序启动 Flutter配置for Mac – VSCodeFlutter入门基础（一）-LabelFlutter入门基础（二）-ButtonFlutter入门基础（三）-TextFile登录页Flutter入门基础（四）-imageviewFlutter入门基础（五）-UITableViewFlutter入门基础（六）-UITableView(二)添加headerViewFlutter入门基础（七）-路由Flutter入门基础（八）-push页面跳转 如有问题可添加QQ群:234812704 欢迎各位一块学习，提高逼格！ 也可以添加洲洲哥的微信公众号]]></content>
  </entry>
  <entry>
    <title><![CDATA[Node.js内存管理和V8垃圾回收机制]]></title>
    <url>%2F2019%2F07%2F22%2Fyuque%2FNode.js%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8CV8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[快速导航 Nodejs中的GC Nodejs垃圾回收内存管理实践 内存泄漏识别 内存泄漏例子 手动执行垃圾回收内存释放 V8垃圾回收机制 V8堆内存限制 新生代与老生代 新生代空间 &amp; Scavenge 算法 老生代空间 &amp; Mark-Sweep Mark-Compact 算法 V8垃圾回收总结 内存泄漏 全局变量 闭包 慎将内存做为缓存 模块私有变量内存永驻 事件重复监听 其它注意事项 内存检测工具Nodejs中的GCNode.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，这是来自 Node.js 官网的一段话，所以 V8 就是 Node.js 中使用的虚拟机，在之后讲解的 Node.js 中的 GC 其实就是在讲 V8 的 GC。Node.js 与 V8 的关系也好比 Java 之于 JVM 的关系，另外 Node.js 之父 Ryan Dahl 在选择 V8 做为 Node.js 的虚拟机时 V8 的性能在当时已经领先了其它所有的 JavaScript 虚拟机，至今仍然是性能最好的，因此我们在做 Node.js 优化时，只要版本升级性能也会伴随着被提升。Nodejs垃圾回收内存管理实践 先通过一个 Demo 来看看在 Node.js 中进行垃圾回收的过程是怎样的？ 内存泄漏识别在 Node.js 环境里提供了 process.memoryUsage 方法用来查看当前进程内存使用情况，单位为字节 rss（resident set size）：RAM 中保存的进程占用的内存部分，包括代码本身、栈、堆。 heapTotal：堆中总共申请到的内存量。 heapUsed：堆中目前用到的内存量，判断内存泄漏我们主要以这个字段为准。 external：V8 引擎内部的 C++ 对象占用的内存。 /** * 单位为字节格式为 MB 输出 */ const format = function (bytes) { return (bytes / 1024 / 1024).toFixed(2) + &#39; MB&#39;; }; /** * 封装 print 方法输出内存占用信息 */ const print = function() { const memoryUsage = process.memoryUsage(); console.log(JSON.stringify({ rss: format(memoryUsage.rss), heapTotal: format(memoryUsage.heapTotal), heapUsed: format(memoryUsage.heapUsed), external: format(memoryUsage.external), })); } 内存泄漏例子堆用来存放对象引用类型，例如字符串、对象。在以下代码中创建一个 Fruit 存放于堆中。 // example.js function Quantity(num) { if (num) { return new Array(num * 1024 * 1024); } return num; } function Fruit(name, quantity) { this.name = name this.quantity = new Quantity(quantity) } let apple = new Fruit(&#39;apple&#39;); print(); let banana = new Fruit(&#39;banana&#39;, 20); print(); 执行以上代码，内存向下面所展示的，apple 对象 heapUsed 的使用仅有 4.21 MB，而 banana 我们对它的 quantity 属性创建了一个很大的数组空间导致 heapUsed 飙升到 164.24 MB。 $ node example.js {&quot;rss&quot;:&quot;19.94 MB&quot;,&quot;heapTotal&quot;:&quot;6.83 MB&quot;,&quot;heapUsed&quot;:&quot;4.21 MB&quot;,&quot;external&quot;:&quot;0.01 MB&quot;} {&quot;rss&quot;:&quot;180.04 MB&quot;,&quot;heapTotal&quot;:&quot;166.84 MB&quot;,&quot;heapUsed&quot;:&quot;164.24 MB&quot;,&quot;external&quot;:&quot;0.01 MB&quot;} 我们在来看下内存的使用情况，根节点对每个对象都持有引用，则无法释放任何内容导致无法 GC，正如下图所展示的 手动执行垃圾回收内存释放假设 banana 对象我们不在使用了，对它重新赋予一些新的值，例如 banana = null，看下此刻会发生什么？结果如上图所示，无法从根对象在到达到 Banana 对象，那么在下一个垃圾回收器运行时 Banana 将会被释放。让我们模拟一下垃圾回收，看下实际情况是什么样的？ // example.js let apple = new Fruit(&#39;apple&#39;); print(); let banana = new Fruit(&#39;banana&#39;, 20); print(); banana = null; global.gc(); print(); 以下代码中 –expose-gc 参数表示允许手动执行垃圾回收机制，将 banana 对象赋为 null 后进行 GC，在第三个 print 打印出的结果可以看到 heapUsed 的使用已经从 164.24 MB 降到了 3.97 MB $ node --expose-gc example.js {&quot;rss&quot;:&quot;19.95 MB&quot;,&quot;heapTotal&quot;:&quot;6.83 MB&quot;,&quot;heapUsed&quot;:&quot;4.21 MB&quot;,&quot;external&quot;:&quot;0.01 MB&quot;} {&quot;rss&quot;:&quot;180.05 MB&quot;,&quot;heapTotal&quot;:&quot;166.84 MB&quot;,&quot;heapUsed&quot;:&quot;164.24 MB&quot;,&quot;external&quot;:&quot;0.01 MB&quot;} {&quot;rss&quot;:&quot;52.48 MB&quot;,&quot;heapTotal&quot;:&quot;9.33 MB&quot;,&quot;heapUsed&quot;:&quot;3.97 MB&quot;,&quot;external&quot;:&quot;0.01 MB&quot;} 下图所示，右侧的 banana 节点没有了任何内容，经过 GC 之后所占用的内存已经被释放了。 V8垃圾回收机制 垃圾回收是指回收那些在应用程序中不在引用的对象，当一个对象无法从根节点访问这个对象就会做为垃圾回收的候选对象。这里的根对象可以为全局对象、局部变量，无法从根节点访问指的也就是不会在被任何其它活动对象所引用。 V8堆内存限制内存在服务端本来就是一个寸土寸金的东西，在 V8 中限制 64 位的机器大约 1.4GB，32 位机器大约为 0.7GB。因此，对于一些大内存的操作需谨慎否则超出 V8 内存限制将会造成进程退出。一个内存溢出超出边界限制的例子 // overflow.js const format = function (bytes) { return (bytes / 1024 / 1024).toFixed(2) + &#39; MB&#39;; }; const print = function() { const memoryUsage = process.memoryUsage(); console.log(heapTotal: ${format(memoryUsage.heapTotal)}, heapUsed: ${format(memoryUsage.heapUsed)}); } const total = []; setInterval(function() { total.push(new Array(20 * 1024 * 1024)); // 大内存占用 print(); }, 1000) 以上例子中 total 为全局变量每次大约增长 160 MB 左右且不会被回收，在接近 V8 边界时无法在分配内存导致进程内存溢出。 $ node overflow.js heapTotal: 166.84 MB, heapUsed: 164.23 MB heapTotal: 326.85 MB, heapUsed: 324.26 MB heapTotal: 487.36 MB, heapUsed: 484.27 MB heapTotal: 649.38 MB, heapUsed: 643.98 MB heapTotal: 809.39 MB, heapUsed: 803.98 MB heapTotal: 969.40 MB, heapUsed: 963.98 MB heapTotal: 1129.41 MB, heapUsed: 1123.96 MB heapTotal: 1289.42 MB, heapUsed: 1283.96 MB &lt;--- Last few GCs ---&gt; [87581:0x103800000] 11257 ms: Mark-sweep 1283.9 (1290.9) -&gt; 1283.9 (1290.9) MB, 512.1 / 0.0 ms allocation failure GC in old space requested [87581:0x103800000] 11768 ms: Mark-sweep 1283.9 (1290.9) -&gt; 1283.9 (1287.9) MB, 510.7 / 0.0 ms last resort GC in old space requested [87581:0x103800000] 12263 ms: Mark-sweep 1283.9 (1287.9) -&gt; 1283.9 (1287.9) MB, 495.3 / 0.0 ms last resort GC in old space requested &lt;--- JS stacktrace ---&gt; 在 V8 中也提供了两个参数仅在启动阶段调整内存限制大小分别为调整老生代、新生代空间，关于老生代、新生代稍后会做介绍。 –max-old-space-size=2048 –max-new-space-size=2048 当然内存也并非越大越好，一方面服务器资源是昂贵的，另一方面据说 V8 以 1.5GB 的堆内存进行一次小的垃圾回收大约需要 50 毫秒以上时间，这将会导致 JavaScript 线程暂停，这也是最主要的一方面。 新生代与老生代绝对大多数的应用程序对象的存活周期都会很短，而少数对象的存活周期将会很长为了利用这种情况，V8 将堆分为两类新生代和老生代，新空间中的对象都非常小大约为 1-8MB，这里的垃圾回收也很快。新生代空间中垃圾回收过程中幸存下来的对象会被提升到老生代空间。 新生代空间由于新空间中的垃圾回收很频繁，因此它的处理方式必须非常的快，采用的 Scavenge 算法，该算法由 C.J. Cheney 在 1970 年在论文 A nonrecursive list compacting algorithm 提出。Scavenge 是一种复制算法，新生代空间会被一分为二划分成两个相等大小的 from-space 和 to-space。它的工作方式是将 from space 中存活的对象复制出来，然后移动它们到 to space 中或者被提升到老生代空间中，对于 from space 中没有存活的对象将会被释放。完成这些复制后在将 from space 和 to space 进行互换。Scavenge 算法非常快适合少量内存的垃圾回收，但是它有很大的空间开销，对于新生代少量内存是可以接受的。 老生代空间新生代空间在垃圾回收满足一定条件（是否经历过 Scavenge 回收、to space 的内存占比）会被晋升到老生代空间中，在老生代空间中的对象都已经至少经历过一次或者多次的回收所以它们的存活概率会更大。在使用 Scavenge 算法则会有两大缺点一是将会重复的复制存活对象使得效率低下，二是对于空间资源的浪费，所以在老生代空间中采用了 Mark-Sweep（标记清除） 和 Mark-Compact（标记整理） 算法。Mark-SweepMark-Sweep 处理时分为标记、清除两个步骤，与 Scavenge 算法只复制活对象相反的是在老生代空间中由于活对象占多数 Mark-Sweep 在标记阶段遍历堆中的所有对象仅标记活对象把未标记的死对象清除，这时一次标记清除就已经完成了。看似一切 perfect 但是还遗留一个问题，被清除的对象遍布于各内存地址，产生很多内存碎片。Mark-Compact在老生代空间中为了解决 Mark-Sweep 算法的内存碎片问题，引入了 Mark-Compact（标记整理算法），其在工作过程中将活着的对象往一端移动，这时内存空间是紧凑的，移动完成之后，直接清理边界之外的内存。 V8垃圾回收总结为何垃圾回收是昂贵的？V8 使用了不同的垃圾回收算法 Scavenge、Mark-Sweep、Mark-Compact。这三种垃圾回收算法都避免不了在进行垃圾回收时需要将应用程序暂停，待垃圾回收完成之后在恢复应用逻辑，对于新生代空间来说由于很快所以影响不大，但是对于老生代空间由于存活对象较多，停顿还是会造成影响的，因此，V8 又新增加了增量标记的方式减少停顿时间。关于 V8 垃圾回收这块笔者讲的很浅只是自己在学习过程中做的总结，如果你想了解更多原理，深入浅出 Node.js 这本书是一个不错的选择，还可参考这两篇文章 A tour of V8: Garbage Collection、 Memory Management Reference.。 内存泄漏 内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。 全局变量未声明的变量或挂在全局 global 下的变量不会自动回收，将会常驻内存直到进程退出才会被释放，除非通过 delete 或 重新赋值为 undefined/null 解决之间的引用关系，才会被回收。关于全局变量上面举的几个例子中也有说明。 闭包这个也是一个常见的内存泄漏情况，闭包会引用父级函数中的变量，如果闭包得不到释放，闭包引用的父级变量也不会释放从而导致内存泄漏。一个真实的案例 — The Meteor Case-Study，2013年，Meteor 的创建者宣布了他们遇到的内存泄漏的调查结果。有问题的代码段如下 var theThing = null var replaceThing = function () { var originalThing = theThing var unused = function () { if (originalThing) console.log(&quot;hi&quot;) } theThing = { longStr: new Array(1000000).join(&#39;*&#39;), someMethod: function () { console.log(someMessage) } }; }; setInterval(replaceThing, 1000) 以上代码运行时每次执行 replaceThing 方法都会生成一个新的对象，但是之前的对象没有释放导致的内存泄漏。这块涉及到一个闭包的概念 “同一个作用域生成的闭包对象是被该作用域中所有下一级作用域共同持有的” 因为定义的 unused 使用了作用域的 originalThing 变量，因此 replaceThing 这一级的函数作用域中的闭包（someMethod）对象也持有了 originalThing 变量（** 重点：someMethod的闭包作用域和unused的作用域是共享的**），之间的引用关系就是 theThing引用了longStr和someMethod、 someMethod引用了originalThing、 originalThing又引用了上次的theThing，因此形成了链式引用。上述代码来自 Meteor blog An interesting kind of JavaScript memory leak，更多理解还可参考 Node-Interview issues #7 讨论 慎将内存做为缓存通过内存来做缓存这可能是我们想到的最快的实现方式，另外业务中缓存还是很常用的，但是了解了 Node.js 中的内存模型和垃圾回收机制之后在使用的时候就要谨慎了，为什么呢？缓存中存储的键越多，长期存活的对象也就越多,垃圾回收时将会对这些对对象做无用功。以下举一个获取用户 Token 的例子，memoryStore 对象会随着用户数的增加而持续增长，以下代码还有一个问题，当你启动多个进程或部署在多台机器会造成每个进程都会保存一份，显然是资源的浪费，最好是通过 Redis 做共享。 const memoryStore = new Map(); exports.getUserToken = function (key) { const token = memoryStore.get(key); if (token &amp;&amp; Date.now() - token.now &gt; 2 * 60) { return token; } const dbToken = db.get(key); memoryStore.set(key, { now: Date.now(), val: dbToken, }); return token; } 模块私有变量内存永驻在加载一个模块代码之前，Node.js 会使用一个如下的函数封装器将其封装，保证了顶层的变量（var、const、let）在模块范围内，而不是全局对象。这个时候就会形成一个闭包，在 require 时会被加载一次，将 exports 对象保存于内存中，直到进程退出才会回收，这个将会导致的是内存常驻，所以对一个模块的引用建议仅在头部引用一次缓存起来，而不是在使用时每次都加载，否则也会造成内存增加。 (function(exports, require, module, __filename, __dirname) { // 模块的代码实际上在这里 }); 事件重复监听在 Node.js 中对一个事件重复监听则会报如下错误，实际上使用的 EventEmitter 类，该类包含一个 listeners 数组，默认为 10 个监听器超出这个数则会报警如下所示，用于发现内存泄漏，也可以通过 emitter.setMaxListeners() 方法为指定的 EventEmitter 实例修改限制。 (node:23992) MaxListenersExceededWarning: Possible EventEmitter memory leak detected. 11 connect listeners added. Use emitter.setMaxListeners() to increase limit Cnode 论栏有篇文章分析了 Socket 重连导致的内存泄漏，参考 原生Socket重连策略不恰当导致的泄漏，还有 Node.js HTTP 模块 Keep-Alive 产生的内存泄漏，参考 Github Node Issues #714 其它注意事项在使用定时器 setInterval 时记的使用对应的 clearInterval 进行清除，因为 setInterval 执行完之后会返回一个值且不会自动释放。另外还有 map、filter 等对数组进行操作，每次操作之后都会创建一个新的数组，将会占用内存，如果单纯的遍历例如 map 可以使用 forEach 代替，这些都是开发中的一些细节，但是往往细节决定成败，每一次的内存泄漏也都是一次次的不经意间造成的。因此，这些点也是需要我们注意的。 console.log(setInterval(function(){}, 1000)) // 返回一个 id 值 [1, 2, 3].filter(item =&gt; item % 2 === 0) // [2] [1, 2, 3].map(item =&gt; item % 2 === 0) // [false, true, false]内存检测工具 node-heapdumpheapdump是一个dumpV8堆信息的工具，node-heapdumpnode-profilernode-profiler 是 alinode 团队出品的一个 与node-heapdump 类似的抓取内存堆快照的工具，node-profilerEasy-Monitor轻量级的 Node.js 项目内核性能监控 + 分析工具，https://github.com/hyj1991/easy-monitorNode.js-Troubleshooting-GuideNode.js 应用线上/线下故障、压测问题和性能调优指南手册，Node.js-Troubleshooting-GuidealinodeNode.js 性能平台（Node.js Performance Platform）是面向中大型 Node.js 应用提供 性能监控、安全提醒、故障排查、性能优化等服务的整体性解决方案。alinode 阅读推荐 Node.js Garbage Collection Explained A tour of V8: Garbage Collection 中文版 V8 之旅：垃圾回收器 Memory Management Reference. 深入浅出 Node.js 如何分析 Node.js 中的内存泄漏 公众号 “Nodejs技术栈”，专注于 Node.js 技术栈的分享 对于 Node.js 服务端研发的同学来说，关于垃圾回收、内存释放这块不需要向 C/C++ 的同学那样在创建一个对象之后还需要手动创建一个 delete/free 这样的一个操作进行 GC（垃圾回收）， Node.js 与 Java 一样，由虚拟机进行内存自动管理。但是这样并不表示就此可以高枕无忧了，在开发中可能由于疏忽或者程序错误导致的内存泄漏也是一个很严重的问题，所以做为一名合格的服务端研发工程师，还是有必要的去了解下虚拟机是怎样使用内存的，遇到问题才能从容应对。 转自：https://mp.weixin.qq.com/s/Wj_pU1DcbUzrjTr_MzF2Sg]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端路由跳转基本原理]]></title>
    <url>%2F2019%2F07%2F18%2Fyuque%2F%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[Hash 1 相关 ApiHash 方法是在路由中带有一个 #，主要原理是通过监听 # 后的 URL 路径标识符的更改而触发的浏览器 hashchange 事件，然后通过获取 location.hash 得到当前的路径标识符，再进行一些路由跳转的操作，参见 MDN location.href：返回完整的 URL location.hash：返回 URL 的锚部分 location.pathname：返回 URL 路径名 hashchange 事件：当 location.hash 发生改变时，将触发这个事件 比如访问一个路径 http://sherlocked93.club/base/#/page1，那么上面几个值分别为： 123456#https://cchains.cn/res/m/ccr/index.html#/?cid=0001&amp;bankCode=citicSeries&#123; "href":"https://cchains.cn/res/m/ccr/index.html#/?cid=0001&amp;bankCode=citicSeries", "pathname":"/res/m/ccr/index.html" "hash":"#/?cid=0001&amp;bankCode=citicSeries"&#125; 注意： 因为 Hash 方法是利用了相当于页面锚点的功能，所以与原来的通过锚点定位来进行页面滚动定位的方式冲突，导致定位到错误的路由路径，所以需要采用别的办法，之前在写 progress-catalog 这个插件碰到了这个情况。 2 实例这里简单做一个实现，原理是把目标路由和对应的回调记录下来，点击跳转触发 hashchange 的时候获取当前路径并执行对应回调，效果： 1234567891011121314151617181920212223class RouterClass &#123; constructor() &#123; // 记录路径标识符对应的cb this.routes = &#123;&#125;; // 记录hash只为方便执行cb this.currentUrl = ""; window.addEventListener("load", () =&gt; this.render()); window.addEventListener("hashchange", () =&gt; this.render()); &#125; /* 初始化 */ static init() &#123; window.Router = new RouterClass(); &#125; /* 注册路由和回调 */ route(path, cb) &#123; this.routes[path] = cb || function() &#123;&#125;; &#125; /* 记录当前hash，执行cb */ render() &#123; this.currentUrl = location.hash.slice(1) || "/"; this.routes[this.currentUrl](); &#125;&#125; 具体实现参照 CodePen如果希望使用脚本来控制 Hash 路由的后退，可以将经历的路由记录下来，路由后退跳转的实现是对 location.hash 进行赋值。但是这样会引发重新引发 hashchange 事件，第二次进入 render 。所以我们需要增加一个标志位，来标明进入 render 方法是因为回退进入的还是用户跳转 1234567891011121314151617181920212223242526272829303132333435363738394041424344class RouterClass &#123; constructor() &#123; this.isBack = false; // 记录路径标识符对应的cb this.routes = &#123;&#125;; // 记录hash只为方便执行cb this.currentUrl = ""; this.historyStack = []; //hash栈 window.addEventListener("load", () =&gt; this.render()); window.addEventListener("hashchange", () =&gt; this.render()); &#125; /* 初始化 */ static init() &#123; window.Router = new RouterClass(); &#125; /* 注册路由和回调 */ route(path, cb) &#123; this.routes[path] = cb || function() &#123;&#125;; &#125; /* 记录当前hash，执行cb */ render() &#123; if (this.isBack) &#123; // 如果是由backoff进入，则置false之后return this.isBack = false; // 其他操作在backoff方法中已经做了 return; &#125; this.currentUrl = location.hash.slice(1) || "/"; this.historyStack.push(this.currentUrl()); this.routes[this.currentUrl](); &#125; /*路由后退 */ back() &#123; this.isBack = true; this.historyStack.pop(); //移除当前hash，回退到上一个 const &#123; length &#125; = this.historyStack; if (!length) &#123; return; &#125; let prev = this.historyStack[length - 1]; //拿到要会退的目标hash location.hash = `#$&#123;prev&#125;`; this.currentUrl = prev; this.routes[prev](); //执行cb &#125;&#125; 代码实现参考 CodePen HTML5 History Api 1 相关 ApiHTML5 提供了一些路由操作的 Api，关于使用可以参看 这篇 MDN 上的文章，这里就列举一下常用 Api 和他们的作用，具体参数什么的就不介绍了，MDN 上都有 history.go(n)：路由跳转，比如n为 2 是往前移动2个页面，n为 -2 是向后移动2个页面，n为0是刷新页面 history.back()：路由后退，相当于 history.go(-1) history.forward()：路由前进，相当于 history.go(1) history.pushState()：添加一条路由历史记录，如果设置跨域网址则报错 history.replaceState()：替换当前页在路由历史记录的信息 popstate 事件：当活动的历史记录发生变化，就会触发 popstate 事件，在点击浏览器的前进后退按钮或者调用上面前三个方法的时候也会触发，参见 MDN2 实例将之前的例子改造一下，在需要路由跳转的地方使用 history.pushState 来入栈并记录 cb，前进后退的时候监听 popstate 事件拿到之前传给 pushState 的参数并执行对应 cb，因为借用了浏览器自己的 Api，因此代码看起来整洁不少 123456789101112131415161718192021222324class RouterClass &#123; constructor(path) &#123; this.routes = &#123;&#125;; // 记录路径标识符对应的cb window.history.replaceState(&#123; path &#125;, null, path); //进入状态 this.routes[path] &amp;&amp; this.routes[path](); window.addEventListener("popstate", e =&gt; &#123; const path = e.state &amp;&amp; e.state.path; this.routes[path] &amp;&amp; this.routes[path](); &#125;); &#125; /* 初始化 */ static init() &#123; window.Router = new RouterClass(location.pathname); &#125; /* 注册路由和回调 */ route(path, cb) &#123; this.routes[path] = cb || function() &#123;&#125;; &#125; /* 跳转路由，并触发路由对应回调 */ go(path) &#123; history.pushState(&#123; path &#125;, null, path); this.routes[path] &amp;&amp; this.routes[path](); &#125;&#125; Hash 模式是使用 URL 的 Hash 来模拟一个完整的 URL，因此当 URL 改变的时候页面并不会重载。History 模式则会直接改变 URL，所以在路由跳转的时候会丢失一些地址信息，在刷新或直接访问路由地址的时候会匹配不到静态资源。因此需要在服务器上配置一些信息，让服务器增加一个覆盖所有情况的候选资源，比如跳转 index.html 什么的，一般来说是你的 app 依赖的页面，事实上 vue-router 等库也是这么推介的，还提供了常见的服务器配置。]]></content>
  </entry>
  <entry>
    <title><![CDATA[chrome开发者工具各种骚技巧]]></title>
    <url>%2F2019%2F07%2F17%2Fyuque%2Fchrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E5%90%84%E7%A7%8D%E9%AA%9A%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[对于每个前端从业者来说，除了F5键之外，用的最多的另外一个键就是F12了chrome还有各种骚姿势，这个网站是：umaar.com/dev-tips/，本文分享一些实用且聪明的调试技巧。 1.曾经，在线调伪类样式困扰过你？ 2.源代码快速定位到某一行！ctrl + p 3.联调接口失败时，后台老哥总管你要response？ 4.你还一层层展开dom？Alt + Click 5.是不是报错了，你才去打断点？ 6.你是不是经常想不起来，在哪绑定事件的？ 7.你是不是打断点时还要去改代码？ 8.看dom层级的最直观的方式？ 9.查一些特定的请求，过滤器用过吗？ 10.在Elements面板调整dom结构很不方便？ 11.想知道，某图片加载的代码在哪？Initiator！！ 12.不想加载某个文件了？ 开发者工具的功能确实挺多，多得有时根本用不上，官网教程建议每个前端人员都看看：developers.google.com/web/tools/c…中文版：www.css88.com/doc/chrome-… 补充： 见评论中多人问gif制作软件是什么。搜索了一下，应该是www.techsmith.com/，看着说明，表示软件太专业。。但我用过两个小软件很不错，非常容易上手： 录屏：www.cockos.com/licecap/ 屏幕放大：docs.microsoft.com/zh-cn/sysin… 效果如下： 转自：https://juejin.im/post/5af53823f265da0b75282b0f]]></content>
  </entry>
  <entry>
    <title><![CDATA[js闭包]]></title>
    <url>%2F2019%2F07%2F17%2Fyuque%2Fjs%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[闭包的英文是Closure,一种将代码封装在一处而实现上下文独立的闭合结构，所以翻译成 闭包。翻译成闭包我觉得挺”信、雅、达”的。英文的意思大概是：a function which closes over the environment(scope) in which it was defined. 【可以引用自由变量的作用域】所以闭包就是：在一个封闭的词法作用域中，将某些自由变量包在定义它的函数中。 至于为什么不用其他名字，我一时也没有找到相关的资料。 请用自己的话简述 1. 什么是「闭包」。 2. 「闭包」的作用是什么。 「函数」和「函数内部能访问到的变量」（也叫环境）的总和，就是一个闭包。就这么简单。有的同学就疑惑了，闭包这么简单么？「我听说闭包是需要函数套函数，然后 return 一个函数的呀！」 比如这样： 1234567891011function foo()&#123; var local = 1 function bar()&#123; local++ return local &#125; return bar&#125;var func = foo()func() 这里面确实有闭包，local 变量和 bar 函数就组成了一个闭包（Closure）。 所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 为什么要函数套函数呢？是因为需要局部变量，所以才把 local 放在一个函数里，如果不把 local 放在一个函数里，local 就是一个全局变量了，达不到使用闭包的目的——隐藏变量 这也是为什么我上面要说「运行在一个立即执行函数中」。 有些人看到「闭包」这个名字，就一定觉得要用什么包起来才行。其实这是翻译问题，闭包的原文是 Closure，跟「包」没有任何关系。 所以函数套函数只是为了造出一个局部变量，跟闭包无关。 为什么要 return bar 呢？因为如果不 return，你就无法使用这个闭包。把 return bar 改成 window.bar = bar 也是一样的，只要让外面可以访问到这个 bar 函数就行了。 所以 return bar 只是为了 bar 能被使用，也跟闭包无关。 闭包的作用闭包常常用来「间接访问一个变量」。换句话说，「隐藏一个变量」。 假设我们在做一个游戏，在写其中关于「还剩几条命」的代码。如果不用闭包，你可以直接用一个全局变量： 1window.lives = 30 // 还有三十条命 这样看起来很不妥。万一不小心把这个值改成 -1 了怎么办。所以我们不能让别人「直接访问」这个变量。怎么办呢？用局部变量。但是用局部变量别人又访问不到，怎么办呢？暴露一个访问器（函数），让别人可以「间接访问」。 代码如下： 123456789101112!function()&#123; var lives = 50 window.奖励一条命 = function()&#123; lives += 1 &#125; window.死一条命 = function()&#123; lives -= 1 &#125;&#125;() 那么在其他的 JS 文件，就可以使用 window.奖励一条命() 来涨命，使用 window.死一条命() 来让角色掉一条命。看到闭包在哪了吗？ 闭包到底是什么？ 第一句是变量声明，第二句是函数声明，第三句是 console.log。每一句我都学过，为什么合起来我就看不出来是闭包？我告诉你答案，你根本不需要知道闭包这个概念，一样可以使用闭包！ 闭包是 JS 函数作用域的副产品。换句话说，正是由于 JS 的函数内部可以使用函数外部的变量，所以这段代码正好符合了闭包的定义。而不是 JS 故意要使用闭包。**很多编程语言也支持闭包，另外有一些语言则不支持闭包。只要你懂了 JS 的作用域，你自然而然就懂了闭包，即使你不知道那就是闭包！ 所谓闭包的作用如果我们在写代码时，根本就不知道闭包，只是按照自己的意图写，最后，发现满足了闭包的定义。那么请问，这算是闭包的作用吗？这个问题，留给你思考。 关于闭包的谣言 闭包会造成内存泄露？错。说这话的人根本不知道什么是内存泄露。内存泄露是指你用不到（访问不到）的变量，依然占居着内存空间，不能被再次利用起来。闭包里面的变量明明就是我们需要的变量（lives），凭什么说是内存泄露？ 这个谣言是如何来的？因为 IE。IE 有 bug，IE 在我们使用完闭包之后，依然回收不了闭包里面引用的变量。这是 IE 的问题，不是闭包的问题。参见司徒正美的这篇文章。 一个小经验编程界崇尚以简洁优雅为美，很多时候如果你觉得一个概念很复杂，那么很可能是你理解错了。 最后做个题123456789101112 function f1()&#123; var n=999; nAdd=function()&#123;n+=1&#125; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 nAdd(); result(); // 1000 在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。 为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。 这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。 使用闭包的注意点1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 12345678910111213141516171819202122232425262728293031323334353637383940var name = "The Window"; var object = &#123; name : "My Object", getNameFunc : function()&#123; console.log(this); return function()&#123; console.log(this); return this.name; &#125;; &#125; &#125;;object.getNameFunc()()//&#123;name: "My Object", getNameFunc: ƒ&#125;//Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …&#125;//"The Window"var name = "The Window"; var object = &#123; name : "My Object", getNameFunc : function()&#123; var that = this; return function()&#123; return that.name; &#125;; &#125; &#125;;object.getNameFunc()()//&#123;name: "My Object", getNameFunc: ƒ&#125;//&#123;name: "My Object", getNameFunc: ƒ&#125;//"My Object"]]></content>
  </entry>
  <entry>
    <title><![CDATA[MAC下 VScode 运行 调试OpenCV 配置（完美解决）]]></title>
    <url>%2F2019%2F07%2F17%2Fyuque%2FMAC%E4%B8%8B%20VScode%20%E8%BF%90%E8%A1%8C%20%E8%B0%83%E8%AF%95OpenCV%20%E9%85%8D%E7%BD%AE%EF%BC%88%E5%AE%8C%E7%BE%8E%E8%A7%A3%E5%86%B3%EF%BC%89%2F</url>
    <content type="text"><![CDATA[https://github.com/angel-star/vscode_OpenCV_template_for_Mac/tree/master关于OpenCV的安装我这里就不再赘述了 记得用brew并指定相关版本 安装在安装成功后记得注意看它的提示文字 文章目录 项目目录 c_cpp_properties.json launch.json settings.json task.json Makefile main.cpp 运行 调试 参考文章 在刚刚接触这个IDE的时候，用到了code-runner这款插件，然而经过多次尝试发现它只能运行单个文件，进入到设置(defaultSettings.json)当中不难发现：它的原理也就是帮我们在shell中输入命令而达到编译运行程序的目的。 1234567891011121314... // Set the executor of each language. "code-runner.executorMap": &#123; "javascript": "node", "java": "cd $dir &amp;&amp; javac $fileName &amp;&amp; java $fileNameWithoutExt", "c": "cd $dir &amp;&amp; gcc $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt", "cpp": "cd $dir &amp;&amp; g++ $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt", "objective-c": "cd $dir &amp;&amp; gcc -framework Cocoa $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt", "php": "php", "python": "python -u", "perl": "perl", ... &#125;... 但是和上篇文章MAC visual Studio Code 运行 调试c/c++ 配置（完美解决）不同，我们的程序不光要能执行以及调试单纯的算法程序，还要适用于需要引入头文件和链接库的中型甚至大型项目，那么这时候就该请出我们的神器make了，先不急 我们一点点看 项目目录下面是项目的简单目录 c_cpp_properties.json在include的过程当中如果有问题，IDE会提示你并自动生成这个文件，如果你是初学者没关系，直接在’.vscode 文件夹中创建这个文件就可以，如果是自动生成的稍作修改就可以，如果最后不行就按照我的改，我已经踩了无数的坑了，期间看过很多文章与教程，然而这是最终的版本。（当然了opencv的安装位置和编译器位置可能会不同，请各位看官自行调整，灵活一些） 小tips:在vscode的json配置文件中如果有不清楚的标签一定要把鼠标放在上面看一看说明，下同。 1234567891011121314151617181920212223242526&#123; "configurations": [ &#123; "name": "Mac", "includePath": [ "$&#123;workspaceFolder&#125;/**", "/usr/local/opt/opencv@3/include", "/usr/local/Cellar/opencv@3/3.4.5/include" ], "defines": [], "macFrameworkPath": [], "compilerPath": "/usr/bin/g++", "cStandard": "c11", "cppStandard": "c++11", "intelliSenseMode": "clang-x64", "browse": &#123; "path": [ "/usr/local/Cellar/opencv@3/3.4.5/include" ], "limitSymbolsToIncludedHeaders": true, "databaseFilename": "" &#125; &#125; ], "version": 4&#125; 参数说明：“includePath”：后期需要添加的额外头文件路径“compilerPath”: 编译器所在的文件路径 launch.json这个文件是在debug模式中需要用到并会自动生成的,稍作修改 ,注意：标签“program” 中文件后缀和自身系统有关。 123456789101112131415161718192021&#123; // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 "version": "0.2.0", "configurations": [ &#123; "name": "(lldb) Launch", "type": "cppdbg", "request": "launch", "program": "$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.out", "args": [], "stopAtEntry": true, "cwd": "$&#123;workspaceFolder&#125;", "environment": [], "externalConsole": true, "MIMode": "lldb", "preLaunchTask": "Build" &#125; ]&#125; “preLaunchTask”: “build hello world”,是默认launch.json中没有的，表示执行文件前需要的编译任务。具体的任务内容我们在task.json中定义。 settings.json此settings是工作区设置， 另外还有一个用户设置，它们之间的区别和联系等相关知识请各位读者自行了解。 123456789101112131415161718192021//settings.json&#123; "python.pythonPath": "/Users/zjx/anaconda3/bin/python3", "code-runner.executorMap": &#123; "c": "cd $dir &amp;&amp; make &amp;&amp; ./$fileNameWithoutExt &amp;&amp; make clean", "cpp": "cd $dir &amp;&amp; make &amp;&amp; ./$fileNameWithoutExt &amp;&amp; make clean" &#125;, "editor.renderWhitespace": "all", "editor.renderLineHighlight": "all", "editor.formatOnSave": true, "code-runner.runInTerminal": true, "code-runner.ignoreSelection": true, "code-runner.enableAppInsights": false, "C_Cpp.updateChannel": "Insiders", "[makefile]": &#123; "editor.insertSpaces": true &#125;, "C_Cpp.default.includePath": [ "/usr/local/Cellar/opencv@3/3.4.5/include" ]&#125; task.json首先快捷键shift+command+p 打开Tasks: Configure Tasks，选择 Create tasks.json file from templates，此时会蹦出一个下拉列表，在下拉列表中选择Others，然后稍作修改如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&#123; // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format "version": "2.0.0", "tasks": [ &#123; "label": "Build", "type": "shell", "command": "g++", "args": [ "$&#123;file&#125;", "-o", "$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.out", "-I", "/usr/local/Cellar/opencv@3/3.4.5/include/opencv", "-I", "/usr/local/Cellar/opencv@3/3.4.5/include", "-L", "/usr/local/Cellar/opencv@3/3.4.5/lib", "-l", "opencv_stitching", "-l", "opencv_superres", "-l", "opencv_videostab", "-l", "opencv_aruco", "-l", "opencv_bgsegm", "-l", "opencv_bioinspired", "-l", "opencv_ccalib", "-l", "opencv_dnn_objdetect", "-l", "opencv_dpm", "-l", "opencv_face", "-l", "opencv_fuzzy", "-l", "opencv_hfs", "-l", "opencv_img_hash", "-l", "opencv_line_descriptor", "-l", "opencv_optflow", "-l", "opencv_reg", "-l", "opencv_rgbd", "-l", "opencv_saliency", "-l", "opencv_stereo", "-l", "opencv_structured_light", "-l", "opencv_phase_unwrapping", "-l", "opencv_surface_matching", "-l", "opencv_tracking", "-l", "opencv_datasets", "-l", "opencv_dnn", "-l", "opencv_plot", "-l", "opencv_xfeatures2d", "-l", "opencv_shape", "-l", "opencv_video", "-l", "opencv_ml", "-l", "opencv_ximgproc", "-l", "opencv_xobjdetect", "-l", "opencv_objdetect", "-l", "opencv_calib3d", "-l", "opencv_features2d", "-l", "opencv_highgui", "-l", "opencv_videoio", "-l", "opencv_imgcodecs", "-l", "opencv_flann", "-l", "opencv_xphoto", "-l", "opencv_photo", "-l", "opencv_imgproc", "-l", "opencv_core", "-g" ], "group": &#123; "kind": "build", "isDefault": true &#125;, "problemMatcher": [ "$gcc" ] &#125; ]&#125; 上面那一长串究竟是怎么来的呢 在终端中输入以下命令试试 pkg-config opencv –libs —cflags 按照json格式改好了就可以写进去了，别问为啥，学。 Makefile123456789101112131415161718192021TARGET = ./mainSRCS := $(wildcard ./src/*.cpp ./*.cpp)OBJS := $(patsubst %cpp,%o,$(SRCS))CFLG = -g -Wall -I/usr/local/Cellar/opencv@3/3.4.5/include -Iinc -I./ -std=c++11LDFG = -Wl, $(shell pkg-config opencv --cflags --libs)CXX = g++$(TARGET) : $(OBJS) $(CXX) -o $(TARGET) $(OBJS) $(LDFG)%.o:%.cpp $(CXX) $(CFLG) -c $&lt; -o $@ .PHONY : cleanclean: -rm ./*.o main.cpp12345678910111213141516171819// main.cpp#include &lt;opencv2/opencv.hpp&gt;#include &lt;opencv2/highgui.hpp&gt;using namespace cv;int main(int argc, char **argv)&#123; Mat img = cv::imread(argv[1], -1); if (img.empty()) return -1; cv::namedWindow("Example1", cv::WINDOW_AUTOSIZE); cv::imshow("Example1", img); cv::waitKey(0); cv::destroyWindow("Example1"); return 0; // Mat img = imread("/Users/zjx/Desktop/123.png");c // cv::imshow("image", img); // cv::waitKey(); // return 0;&#125; 运行control + option + N 利用code-runner插件进行快速运行： Tips :对于本程序的话 ，记得传参，可以修改makefile也可以修改settings也可以编译后在终端中运行并传参，看个人喜好 调试shift + command + B 进行编译 然后 F5 启用调试 或者直接在左边调试窗口按下绿色三角按钮，相当于 编译+启动调试 ，如下图 完美解决。 转自：https://blog.csdn.net/qq_22073849/article/details/88893201]]></content>
  </entry>
  <entry>
    <title><![CDATA[JS 中提升幸福度的小技巧]]></title>
    <url>%2F2019%2F07%2F16%2Fyuque%2FJS%20%E4%B8%AD%E6%8F%90%E5%8D%87%E5%B9%B8%E7%A6%8F%E5%BA%A6%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[1. 类型强制转换 1.1 string强制转换为数字可以用 *1来转化为数字(实际上是调用 .valueOf方法)然后使用 Number.isNaN来判断是否为 NaN，或者使用 a!==a 来判断是否为 NaN，因为 NaN!==NaN 12345'32'*1 //32'ds'*1 //NaNnull*1 //0undefined*1 //NaN1*&#123;valueOf:()=&gt;'3'&#125; //3 常用： 也可以使用 +来转化字符串为数字 123456+'123' //123+'ds' // NaN+'' //0+null //0+undefined // NaN+&#123;valueOf:()=&gt;'3'&#125; //3 1.2 object强制转化为string可以使用 字符串+Object 的方式来转化对象为字符串(实际上是调用 .toString() 方法) 1'aa'+Math //"aa[object Math]" 当然也可以覆盖对象的 toString和 valueOf方法来自定义对象的类型转换： 122*&#123;valueOf:()=&gt;'3'&#125; //6'J'+&#123;toString:()=&gt;'S'&#125; //JS 《Effective JavaScript》P11：当 +用在连接字符串时，当一个对象既有 toString方法又有 valueOf方法时候，JS通过盲目使用 valueOf方法来解决这种含糊。 对象通过 valueOf方法强制转换为数字，通过 toString方法强制转换为字符串 1""+&#123;toString:()=&gt;'S',valueOf:()=&gt;'J'&#125; //J 1.3 使用Boolean过滤数组中的所有假值我们知道JS中有一些假值：false， null， 0， “”， undefined， NaN，怎样把数组中的假值快速过滤呢，可以使用Boolean构造函数来进行一次转换 123const compact =arr=&gt;arr.filter(Boolean)compact([0,1,false,2,'',3,'a','e',3,NaN,'s',34])// [1, 2, 3, "a", "e", 3, "s", 34]] 1.4 双位运算符 ~~可以使用双位操作符来替代正数的 Math.floor()，替代负数的 Math.ceil()。双否定位操作符的优势在于它执行相同的操作运行速度更快。 12Math.floor(4.9)===4 // true~~4.9===4 // true 不过要注意，对正数来说 ~~ 运算结果与 Math.floor() 运算结果相同，而对于负数来说与 Math.ceil()的运算结果相同： 1234567~~4.5 //4Math.floor(4.5) //4Math.ceil(4.5) //5~~-4.5 //-4Math.floor(-4.5) //-5Math.ceil(~~-4.5) //-4 1.5 短路运算符我们知道逻辑与 &amp;&amp;与逻辑或 ||是短路运算符，短路运算符就是从左到右的运算中前者满足要求，就不再执行后者了；可以理解为： &amp;&amp;为取假运算，从左到右依次判断，如果遇到一个假值，就返回假值，以后不再执行，否则返回最后一个真值 ||为取真运算，从左到右依次判断，如果遇到一个真值，就返回真值，以后不再执行，否则返回最后一个假值 123let param1=expr1 &amp;&amp; expr2 两者中只有一个是假值，就可以如果expr1 能转换成false则返回expr1,否则返回expr2. 因此, 在Boolean环境中使用时, 两个操作结果都为true时返回true,否则返回false. let param1=expr1 || expr2 如果expr1能转换成true则返回expr1,否则返回expr2. 因此,在boolean环境(在if的条件判断中)中使用时, 二者操作结果中只要有一个为true,返回true;二者操作结果都为false时返回false. 因此可以用来做很多有意思的事，比如给变量赋初值： 12let variable1let variable2=variable1 || 'foo' 如果variable1是真值就直接返回了，后面短路就不会被返回了，如果为假值，则会返回后面的 foo。也可以用来进行简单的判断，取代冗长的 if语句： 1let variable =param &amp;&amp; param.prop 如果 param如果为真值则返回 param.prop属性，否则返回 param这个假值，这样在某些地方防止 param为 undefined的时候还取其属性造成报错。 1.6 取整 |0对一个数字 |0可以取整，负数也同样适用， num|0 121.3 | 0 // 1-1.9 | 0 // -1 1.7 判断奇偶数 &amp;1对一个数字 &amp;1可以判断奇偶数，负数也同样适用， num&amp;1 123456const num=3!!(num&amp;1) //true!!(num%2) //true3 &amp; 1 //14 &amp; 1 //0 2. 函数 2.1 函数默认值12func=(l,m=3,n=4)=&gt;(l*m*n)func(2) //24 注意，传入参数为 undefined或者不传入的时候会使用默认参数，但是传入 null还是会覆盖默认参数。 2.2 强制参数默认情况下，如果不向函数参数传值，那么JS 会将函数参数设置为 undefined。其它一些语言则会发出警告或错误。要执行参数分配，可以使用 if语句抛出未定义的错误，或者可以利用 强制参数。 12345678910mandatory=()=&gt;&#123; throw new Error('Missing parameter!')&#125;foo=(bar=mandatory())=&gt;&#123;return bar&#125;foo() // 这里如果不传入参数，就会执行manadatory函数报出错误//报错VM6721:2 Uncaught Error: Missing parameter! at mandatory (&lt;anonymous&gt;:2:8) at foo (&lt;anonymous&gt;:1:10) at &lt;anonymous&gt;:1:1 2.3 隐式返回值返回值是我们通常用来返回函数最终结果的关键字。只有一个语句的箭头函数，可以隐式返回结果（函数必须省略大括号 {}，以便省略返回关键字）。要返回多行语句（例如对象文本），需要使用 ()而不是 {}来包裹函数体。这样可以确保代码以单个语句的形式进行求值。 123456function calcCircumference(diameter)&#123; return Math.PI*diameter;&#125;//简写为：calcCircumference=diameter=&gt; Math.PI*diameter or calcCircumference=diameter=&gt; (Math.PI*diameter) 2.4 惰性载入函数在某个场景下我们的函数中有判断语句，这个判断依据在整个项目运行期间一般不会变化，所以判断分支在整个项目运行期间只会运行某个特定分支，那么就可以考虑惰性载入函数 123456789101112131415161718192021function foo()&#123; if(a!==b)&#123; console.log('aaa') &#125;else&#123; console.log('bbb'); &#125;&#125;//优化后function foo()&#123; if(a!==b)&#123; foo=function()&#123; console.log('aaa') &#125; &#125;else&#123; foo=function()&#123; console.log('bbb') &#125; &#125; return foo();&#125; 那么第一次运行之后就会覆写这个方法，下一次再运行的时候就不会执行判断了。当然现在只有一个判断，如果判断很多，分支比较复杂，那么节约的资源还是可观的。 2.5 一次性函数跟上面的惰性载入函数同理，可以在函数体里覆写当前函数，那么可以创建一个一次性的函数，重新赋值之前的代码相当于只运行了一次，适用于运行一些只需要执行一次的初始化代码 123456789var sca=function()&#123; console.log('msg') sca=function()&#123; console.log('foo') &#125;&#125;sca() //msgsca() //foosca() //foo 3. 字符串 3.1 字符串比较时间先后比较时间先后顺序可以使用字符串： 123456789var a='2014-08-08'var b='2014-09-09'console.log(a&gt;b,a&lt;b) // false trueconsole.log('21:00'&lt;'09:10') //falseconsole.log('21:00'&lt;'9:10') //true 时间形式注意补0'21:00'.charCodeAt() //50'09:10'.charCodeAt() //48'9:10'.charCodeAt() //57 因为字符串比较大小是按照字符串从左到右每个字符的 charCode来的，但所以特别要注意时间形式注意补0 4. 数字 4.1 不同进制表示法ES6中新增了不同进制的书写格式，在后台传参的时候要注意这一点。 1234529 //10进制035 //8进制29 原来的方式0o35 //8进制29 ES6的方式0x1d //16进制290b11101 //2进度29 4.2 精确到指定位数的小数将数字四舍五入到指定的小数位数。使用 Math.round() 和模板字面量将数字四舍五入为指定的小数位数。省略第二个参数 decimals ，数字将被四舍五入到一个整数。 123456const round = (n, decimals = 0) =&gt; Number(`$&#123;Math.round(`$&#123;n&#125;e$&#123;decimals&#125;`)&#125;e-$&#123;decimals&#125;`);round(1.345,2) //1.35Math.round('1.345e2') // 135Number('135e-1') //13.5 4.3 数字补0操作有时候比如显示时间的时候有时候会需要把一位数字显示成两位，这时候就需要补0操作，可以使用 slice和string的 padStart方法 1234567const addZero1=(num,len=2)=&gt;`0$&#123;num&#125;`.slice(-len)const addZero2=(num,len=2)=&gt;`$&#123;num&#125;`.padStart(len,'0')const addZero3=(num,len=2)=&gt;`$&#123;num&#125;`.padEnd(len,'0')addZero1(9)//09addZero2(9,4) //0009addZero3(9,4) //9000 5. 数组 5.1 reduce方法同时实现map和filter假设现在有一个数列，你希望更新它的每一项（map的功能）然后筛选出一部分（filter的功能）。如果是先使用map然后filter的话，你需要遍历这个数组两次。在下面的代码中，我们将数列中的值翻倍，然后挑选出那些大于50的数。 reduce为数组中的每一个元素依次执行callback函数，不包括数组中被删除或从未被赋值的元素，接受四个参数： accumulator 累计器 currentValue 当前值 currentIndex 当前索引 array 数组12345678910const numbers=[10,20,30,40];const doubleOver50=numbers.reduce((finalList,num)=&gt;&#123; console.log(`finalList:$&#123;finalList&#125;--num:$&#123;num&#125;`); num=num*2; if(num&gt;50)&#123; finalList.push(num) &#125; return finalList;&#125;,[])doubleOver50 //[60,80] 5.2 统计数组中相同项的个数很多时候，你希望统计数组中重复出现项的个数然后用一个对象表示。那么你可以使用reduce方法处理这个数组。下面的代码将统计每一种车的数目然后把总数用一个对象表示。 123456789101112131415var cars=['BMW','Benz','Benz','Tesla','BMW','Toyota']var carsObj=cars.reduce(function(obj,name)&#123; console.log(obj,name); obj[name]=obj[name] ? ++obj[name]:1; return obj;&#125;,&#123;&#125;)&#123;&#125; "BMW"VM16806:2 &#123;BMW: 1&#125; "Benz"VM16806:2 &#123;BMW: 1, Benz: 1&#125; "Benz"VM16806:2 &#123;BMW: 1, Benz: 2&#125; "Tesla"VM16806:2 &#123;BMW: 1, Benz: 2, Tesla: 1&#125; "BMW"VM16806:2 &#123;BMW: 2, Benz: 2, Tesla: 1&#125; "Toyota"carsObj //&#123;BMW: 2, Benz: 2, Tesla: 1, Toyota: 1&#125; 5.3 使用解构来交换参数数值有时候你会将函数返回的多个值放在一个数组里。我们可以使用数组解构来获取其中每一个值。 12345let param1=1;let param2=2;[param1,param2]=[param2,param1]param1 //2param2 //1 5.4 接收函数返回的多个结果在下面的代码中，我们从/post中获取一个帖子，然后在/comments中获取相关评论。由于我们使用的是async/await，函数把返回值放在一个数组中。而我们使用数组解构后就可以把返回值直接赋给相应的变量。 1234567async function getFullPost()&#123; return await Promise.all([ fetch('/post'), fetch('/comments') ])&#125;const [post,comments]=getFullPost(); 5.5 将数组平铺到指定深度使用递归，为每个深度级别 depth 递减 1 。使用 Array.reduce() 和 Array.concat()来合并元素或数组。基本情况下， depth 等于 1 停止递归。省略第二个参数， depth 只能平铺到 1 (单层平铺) 的深度。 12345678910const flatten = (arr, depth = 1) =&gt; depth != 1 ? arr.reduce( (a, v) =&gt; a.concat(Array.isArray(v) ? flatten(v, depth - 1) : v), [] ) : arr.reduce((a, v) =&gt; a.concat(v), []);flatten([1,[2],3,4]) //[1,2,3,4]flatten([1,[2,[3,[4,5],6],7],8],2) //[1,2,3,[4,5],6,7,8] 5.6 数组的对象解构数组也可以对象解构，可以方便的获取数组的第n个值 1234const csvFileLine='1997,John Doe,US,john@doe.com,New York';const &#123;2:country,4:state&#125;=csvFileLine.split(',')country //USstate //New York 6. 对象 6.1 使用解构删除不必要属性有时候你不希望保留某些对象属性，也许是因为它们包含敏感信息或仅仅是太大了（just too big）。你可能会枚举整个对象然后删除它们，但实际上只需要简单的将这些无用属性赋值给变量，然后把想要保留的有用部分作为剩余参数就可以了。下面的代码里，我们希望删除_internal和tooBig参数。我们可以把它们赋值给internal和tooBig变量，然后在cleanObject中存储剩下的属性以备后用。 1234let &#123;_internal,tooBig,...cleanObject&#125;=&#123;el1:'1',_internal:'secret',tooBig:&#123;&#125;,el2:'2',el3:'3'&#125;cleanObject&#123;el1: "1", el2: "2", el3: "3"&#125; 6.2 在函数参数中解构嵌套对象在下面的代码中，engine是对象car中嵌套的一个对象。如果我们对engine的vin属性感兴趣，使用解构赋值可以很轻松地得到它。 123456789101112var car=&#123; model:'bmw 2018', engine:&#123; v6:true, turbo:true, vin:12345 &#125;&#125;const modelAndVIN=(&#123;model,engine:&#123;vin&#125;&#125;)=&gt;&#123; console.log(`model:$&#123;model&#125; vin:$&#123;vin&#125;`)&#125;modelAndVIN(car) //model:bmw 2018 vin:12345 7. 代码复用 7.1 Object [key]虽然将 foo.bar 写成 foo[‘bar’] 是一种常见的做法，但是这种做法构成了编写可重用代码的基础。许多框架使用了这种方法，比如element的表单验证。请考虑下面这个验证函数的简化示例： 12345678910function validate(values)&#123; if(!values.first)&#123; return false; &#125; if(!values.last)&#123; return false; &#125; return true;&#125;validate(&#123;first:'Bruce',last:'Wayne'&#125;) //true 上面的函数完美的完成验证工作。但是当有很多表单，则需要应用验证，此时会有不同的字段和规则。如果可以构建一个在运行时配置的通用验证函数，会是一个好选择。 123456789101112131415161718192021222324252627const schema=&#123; first:&#123; required:true &#125;, last:&#123; required:true &#125;&#125;for(var field in schema)&#123; console.log(field)&#125;// first lastconst validate=(schema,values)=&gt;&#123; for(field in schema)&#123; if(schema[field].required)&#123; if(!values[field])&#123; return false; &#125; &#125; &#125; return true;&#125;validate(schema,&#123;first:'Bruce'&#125;) // falsevalidate(schema,&#123;first:'Bruce',last:'Wayne'&#125;) //true 现在有了这个验证函数，我们就可以在所有窗体中重用，而无需为每个窗体编写自定义验证函数。]]></content>
  </entry>
  <entry>
    <title><![CDATA[【实例】通过 CSS自定义属性（CSS变量）和 JavaScript 实现高级CSS主题切换]]></title>
    <url>%2F2019%2F07%2F16%2Fyuque%2F%E3%80%90%E5%AE%9E%E4%BE%8B%E3%80%91%E9%80%9A%E8%BF%87%20CSS%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%EF%BC%88CSS%E5%8F%98%E9%87%8F%EF%BC%89%E5%92%8C%20JavaScript%20%E5%AE%9E%E7%8E%B0%E9%AB%98%E7%BA%A7CSS%E4%B8%BB%E9%A2%98%E5%88%87%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[在本教程中，我们将使用 CSS自定义属性（也称为CSS变量）来为简单的HTML页面实现主题切换。 我们将创建暗黑和明亮的示例主题，然后编写JavaScript 以在用户单击按钮时在两者之间切换。如果你以前没接触过，请先阅读CSS变量(自定义属性)实用指南及注意事项这篇文章就像在典型的编程语言中一样，变量用于保存或存储值。 在CSS中，它们通常用于存储颜色，字体名称，字体大小，长度单位等。然后可以在样式表中的多个位置引用和重用它们。 大多数开发人员都会引用 “CSS变量” ，但官方名称是 自定义属性。CSS自定义属性可以修改可在整个样式表中引用的变量。 以前，只有使用Sass等CSS预处理器才能实现这一点。 理解 :root 和 var()在创建动态主题示例之前，让我们了解自定义属性的基本基础知识。自定义属性 是一个名称以两个连字符（ - ）开头的属性，如 –foo。 定义后可以使用 var() 引用的变量。 让我们考虑这个例子：CSS 代码: 1234:root &#123; --bg-color: #000; --text-color: #fff;&#125; 在:root选择器中定义自定义属性意味着它们可以作用于全局文档中所有元素。:root是一个CSS伪类，它匹配文档的根元素 – 元素。它类似于 html 选择器，但具有更高的优先级。您可以在文档中的任何位置访问 :root 中的自定义属性的值：CSS 代码: 1234div &#123; color: var(--text-color); background-color: var(--bg-color);&#125; 您还可以在CSS变量中包含回退值。例如：CSS 代码: 1234div &#123; color: var(--text-color, #000); background-color: var(--bg-color, #fff);&#125; 如果未定义自定义属性，则使用其回退值代替。除了 :root 或 html 选择器之外的CSS选择器内定义的自定义属性使变量可用于匹配元素及其子元素。 CSS自定义属性与预处理器变量诸如 Sass 之类的CSS预处理器通常用于辅助前端Web开发。预处理器的其中一个有用功能就包括变量。但是Sass变量和CSS自定义属性之间有什么区别？ CSS自定义属性在现代浏览器中进行本机解析。 预处理器变量需要编译到标准CSS文件中，并且所有变量都转换为值。 JavaScript可以访问和修改自定义属性。 预处理程序变量编译一次，只有它们的最终值在客户端上可用。编写一个简单的HTML页面让我们从为项目创建一个文件夹开始：BASH 代码: 1mkdir css-variables-theming 接下来，在项目的文件夹中添加一个 index.html 文件： 12cd css-variables-themingtouch index.html 并添加以下内容：HTML 代码: 1234567891011&lt;nav class="navbar"&gt;Title&lt;/nav&gt;&lt;div class="container"&gt; &lt;div&gt; &lt;input type="button" value="Light/Dark" id="toggle-theme" /&gt; &lt;/div&gt; &lt;h2 class="title"&gt;What is Lorem Ipsum?&lt;/h2&gt; &lt;p class="content"&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry...&lt;/p&gt;&lt;/div&gt;&lt;footer&gt; Copyright 2018&lt;/footer&gt; 我们使用 标签添加一个导航栏，页脚和容器 ，容器中包含一个按钮（用于在明暗主题之间切换）和一些虚拟 Lorem Ipsum 文本。 为我们的HTML页面编写基本CSS现在让我们为页面添加样式。在 中使用内联 标记的同一文件中添加以下CSS样式：HTML 代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;style&gt;* &#123; margin: 0;&#125;html&#123; height: 100%;&#125;body&#123; height: 100%; font-family: -apple-system, BlinkMacSystemFont“Segoe UI”, “Roboto”, “Oxygen”, “Ubuntu”, “Cantarell”, “Fira Sans”, “Droid Sans”, “Helvetica Neue”,sans-serif; display: flex; flex-direction: column;&#125;nav&#123; background: hsl(350, 50%, 50%); padding: 1.3rem; color: hsl(350, 50%, 10%);&#125;.container&#123; flex: 1; background:hsl(350, 50%, 95%); padding: 1rem;&#125;p.content&#123; padding: 0.7rem; font-size: 0.7rem; color: hsl(350, 50%, 50%);&#125;.container h2.title&#123; padding: 1rem; color: hsl(350, 50%, 20%);&#125;footer&#123; background: hsl(350, 93%, 88%); padding: 1rem;&#125;input[type=button] &#123; color:hsl(350, 50%, 20%); padding: 0.3rem; font-size: 1rem;&#125;&lt;/style&gt; CSS3 HSL（色调，饱和度，亮度）表示法用于定义颜色。 色调是色环上的角度，示例使用350表示红色。 通过更改饱和度（颜色百分比）和亮度（百分比），所有页面颜色都使用不同的变化。使用HSL，我们只需更改色调值，即可轻松尝试主题的不同主色。 我们还可以使用CSS变量作为色调值，并通过更改样式表中的单个值或使用JavaScript动态更改颜色主题来切换颜色主题。这是页面的屏幕截图： 我们将这个例子放到在线的 CodePen 中演示： 演示链接 让我们使用CSS变量来保存页面中所有颜色的色调值。在 标记顶部的 :root 选择器中添加一个全局CSS变量：CSS 代码: 123:root&#123; --main-hue : 350;&#125; 接下来，我们用 -main-hue 变量替换 hsl() 颜色中的所有硬编码350值。例如，这是导航选择器：CSS 代码: 12345nav&#123; background: hsl(var(--main-hue) , 50%, 50%); padding: 1.3rem; color: hsl(var(--main-hue), 50%, 10%);&#125; 现在，如果要指定除红色以外的其他颜色，则只需将相应的值指定给 –main-hue 即可。这里有一些例子：CSS 代码: 123456:root&#123; --red-hue: 360; --blue-hue: 240; --green-hue: 120; --main-hue : var(--red-hue);&#125; 我们为红色，蓝色和绿色定义了三个自定义属性，然后将 –red-hue 变量分配给–main-hue。这是一个屏幕截图，其中包含不同值的页面 –main-hue ： CSS自定义属性提供了几个好处： 可以在单独位置定义值。 可以适当地命名该值以帮助维护和可读性。 可以使用JavaScript动态更改该值。 例如，–main-hue 可以设置为0到360之间的任何值。 使用JavaScript从一组预定义值或用户提交的hue值（它应该在0到360之间）动态设置 –main-hue 的值，我们可以为用户提供许多彩色主题的可能性。以下代码行将 –main-hue 的值设置为240（蓝色）：JavaScript 代码: 1document.documentElement.style.setProperty('--main-hue', 240); 查看以下 CodePen ，其显示了一个完整示例，允许您在红色，蓝色和绿色之间动态切换主题：他是页面的截图： 添加CSS暗黑主题现在让我们为这个页面提供一个暗黑的主题。 为了更好地控制不同实体的颜色，我们需要添加更多变量。通过页面的样式，我们可以在:root中定义对应颜色的自定义属性后，用变量替换不同选择器中的所有HSL颜色：CSS 代码: 12345678910:root&#123; /*...*/ --nav-bg-color: hsl(var(--main-hue) , 50%, 50%); --nav-text-color: hsl(var(--main-hue), 50%, 10%); --container-bg-color: hsl(var(--main-hue) , 50%, 95%); --content-text-color: hsl(var(--main-hue) , 50%, 50%); --title-color: hsl(var(--main-hue) , 50%, 20%); --footer-bg-color: hsl(var(--main-hue) , 93%, 88%); --button-text-color: hsl(var(--main-hue), 50%, 20%);&#125; 使用了自定义属性的适当名称。 例如， –nav-bg-color 是指导航背景的颜色，而 –nav-text-color是指导航前景/文本的颜色。现在复制 :root 选择器及其内容，但添加一个暗黑属性值的主题：CSS 代码: 123:root[theme='dark']&#123; /*...*/&#125; 如果将具有dark值的 theme 属性添加到 元素，则会激活此主题。我们现在可以手动插入这些变量的值，通过减少 HSL 颜色的亮度值来提供暗主题，或者我们可以使用其他技术，例如常用的 invert() 和 brightness() 等CSS滤镜调整图像的渲染，但也可以与任何其他元素一起使用。将以下代码添加到 :root[theme=’dark’]：CSS 代码: 1234567891011121314:root[theme='dark'] &#123; --red-hue: 360; --blue-hue: 240; --green-hue: 120; --main-hue: var(--blue-hue); --nav-bg-color: hsl(var(--main-hue), 50%, 90%); --nav-text-color: hsl(var(--main-hue), 50%, 10%); --container-bg-color: hsl(var(--main-hue), 50%, 95%); --content-text-color: hsl(var(--main-hue), 50%, 50%); --title-color: hsl(--main-hue, 50%, 20%); --footer-bg-color: hsl(var(--main-hue), 93%, 88%); --button-text-color: hsl(var(--main-hue), 50%, 20%); filter: invert(1) brightness(0.6);&#125; invert() 过滤器反转所选元素中的所有颜色（在这种情况下每个元素都会应用）。 可以用百分比或数字指定反转值。 值 100％ 或 1 将完全反转元素的色调，饱和度和亮度值。brightness() 滤镜使元素更亮或更暗。 值为 0 会导致完全黑色的元素。invert() 滤镜使一些元素非常明亮。 通过设置 brightness(0.6) 来降低这些要求。暗黑主题，不同程度的色调： 使用JavaScript切换主题现在，当用户点击 Dark / Light 按钮时，我们现在使用JavaScript在暗黑和高亮主题之间切换。 在 index.html 中，使用以下代码在结束 L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"width":150,"height":300,"position":"right"},"mobile":{"show":true,"scale":0.5},"react":{"opacity":0.9},"dialog":{"enable":true,"hitokoto":true},"log":false}); 之前添加内联 ：JavaScript 代码: 12345678910const toggleBtn = document.querySelector("#toggle-theme");toggleBtn.addEventListener('click', e =&gt; &#123; console.log("Switching theme"); if(document.documentElement.hasAttribute('theme'))&#123; document.documentElement.removeAttribute('theme'); &#125; else&#123; document.documentElement.setAttribute('theme', 'dark'); &#125;&#125;); document.documentElement 引用文档的根DOM元素 – 即 元素。 此代码使用 .hasAttribute() 方法检查 theme 属性是否存在，如果该属性不存在则添加 dark 值，从而导致切换到暗黑主题。 否则，它会删除该属性，从而切换到高亮主题。 使用JavaScript更改CSS自定义属性使用JavaScript，我们可以访问自定义属性并动态更改其值。 在我们的示例中，我们对亮度值进行了硬编码，但它可以动态更改。 首先，在 Dark / Light 按钮旁边的 HTML 页面中添加 slider input：HTML 代码: 1&lt;input type="range" id="darknessSlider" name="darkness" value="1" min="0.3" max="1" step="0.1" /&gt; slider 从 1 开始，允许用户将其减小到 0.3 ，步长为 0.1 。接下来，在:root[theme='dark']中为暗度值添加一个自定义属性，初始值为1 ：CSS 代码: 1234:root[theme='dark']&#123; /*...*/ --theme-darkness: 1;&#125; 将 brightness 滤镜更改为此自定义属性而不是硬编码值：CSS 代码: 1filter: invert(1) brightness(var(--theme-darkness)); 最后，添加以下代码以将 --theme-darkness 的值与 slider 值同步：JavaScript 代码: 12345const darknessSlider = document.querySelector("#darknessSlider");darknessSlider.addEventListener('change', (e)=&gt;&#123; const val = darknessSlider.value document.documentElement.style.setProperty('--theme-darkness', val);&#125;); 我们正在监听滑块的 change 事件，并使用 setProperty() 方法相应地设置 --theme-darkness 的值。我们还可以将 brightness 滤镜应用于高亮主题。 在 :root 选择器的顶部添加 --theme-darkness 自定义属性：CSS 代码: 1234:root&#123; /*...*/ --theme-darkness: 1;&#125; 然后在同一选择器的底部添加 brightness 滤镜：CSS 代码: 1234:root&#123; /*...*/ filter: brightness(var(--theme-darkness));&#125; 您可以在以下在线的 CodePen 中演示中找到此示例的完整代码：这是最后一个例子的暗黑主题的截图： 这个是高亮主题的截图： 结论在本教程中，我们已经了解了如何使用CSS自定义属性来创建主题并在它们之间动态切换。 我们使用了HSL配色方案，它允许我们指定具有色调，饱和度和亮度值的颜色以及CSS滤镜（invert 和brightness）以创建浅色主题的暗色版本。如果您想了解有关CSS主题的更多信息，请参阅以下链接进一步阅读： Using CSS custom properties (variables) HSL and HSV CSS Custom Properties and Theming Dark theme in a day 原文链接：https://www.sitepoint.com/css-theming-custom-properties-javascript/]]></content>
  </entry>
  <entry>
    <title><![CDATA[React 性能分析器介绍]]></title>
    <url>%2F2019%2F07%2F16%2Fyuque%2FReact%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%99%A8%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[注：本文翻译自 React 官方博客，并且已经更新到最新的 React 中文文档中，马上查看《介绍 React 性能分析器》React 16.5 增加了对新的开发者工具 DevTools 性能分析插件的支持。 此插件使用 React 实验性的 Profiler API 来收集有关每个组件渲染的用时信息，以便识别 React 应用程序中的性能瓶颈。 它将与我们即将推出的time slicing（时间分片） 和 suspense（悬停） 功能完全兼容。此博客文章涵盖以下主题： 分析一个应用程序的性能 查看性能数据 浏览 commits 过滤 commits 火焰图表 排序图表 组件图表 交互 发现并修复故障 没有为选定的 root 节点记录分析数据 选中的 commit 没有显示计时数据 深入视频分析一个应用程序的性能（Profiling an application）DevTools 将为支持新的 Profiler API 的应用显示 “Profiler” 选项卡： 注意：注意：react-dom 16.5+ 在 DEV 模式下支持性能分析。如果生产环境的包需要用到，你可以试用 react-dom/profiling 。 你可以在 fb.me/react-profiling 中阅读有关如何使用该包的更多信息。 “Profiler”面板初始打开将是空的。单击 record(录制) 按钮就可以开始分析：一旦开始录制，DevTools 将在每次应用程序渲染时自动收集性能信息。就像正常使用您的应用程序一样。当你想完成分析时，单击 “Stop(停止)” 按钮即可。假设您的应用程序在分析时至少渲染过一次，那么 DevTools 将显示几种查看性能数据的方法。我们将在下面逐一说明。 查看性能数据 浏览 commits（Browsing commits）从概念上讲，React 分两个阶段工作： render(渲染)阶段，确定需要对DOM进行哪些更改。在此阶段，React 调用 render 方法，然后将结果与之前的渲染进行比较。 commit(提交)阶段，是 React 做出任何更新的阶段。(对于 React DOM 来时，这是React插入，更新和删除DOM节点的时候。) React 也在这个阶段调用 componentDidMount 和 componentDidUpdate 等生命周期函数。 DevTools Profiler(分析器) 根据 commits(提交) 对性能信息进行分组。commits(提交) 显示在靠近 Profiler(分析器) 顶部的条形图中：图表中的每个条形表示单独的一次 commit(提交)，当前选定的 commit(提交) 颜色为黑色。 您可以单击条形栏（或左/右箭头按钮）以选择其他 commit(提交) 。每个条形图的颜色和高度对应于 commit(提交) 渲染所需的时间 （较高的黄色竖条比较短的蓝色竖条耗时更长）。 过滤 commits（Filtering commits）您录制的时间越长，您的应用渲染的次数就越多。 在某些情况下，您最终可能会有 很多次 的 commits(提交) 而很难轻松处理。 Profiler(分析器) 提供了一种过滤机制来帮助解决这个问题。 使用它来指定阈值，Profiler(分析器) 将隐藏所有比该值 更快 的 commits(提交) 。 火焰图表（Flame chart）火焰图表视图表示特定 commits(提交) 对应的应用的状态。 图表中的每个横条代表一个 React 组件（例如 App ，Nav ）。 横条的大小和颜色表示渲染组件及其子组件所需的时间。 （横条的宽度表示组件上次渲染时花费的时间，颜色表示当前 commits(提交) 部分所花费的时间。） 注意：横条的宽度表示在上次渲染时渲染组件（及其子组件）所需的时间。 如果组件未作为此次 commit 的一部分重新渲染，则时间表示先前的渲染。 组件越宽，渲染时间越长。横条的颜色表示组件（及其子组件）在所选 commit 中渲染的时间。 黄色组件花费更多时间，蓝色组件花费更少时间，并且灰色组件在此 commit 期间根本不渲染。 例如，上面显示的 commit 总共需要 18.4 ms 进行渲染。 Router 组件渲染是耗时是最多（耗时 18.4 ms）。 大部分时间是因为它的两个子组件，Nav（8.4ms）和 Route（7.9ms）。 剩下的时间消耗分布在剩余的子节点之间，或者组件自身的 render 方法上。您可以通过单击组件放大或缩小火焰图：单击组件就可以选择它，并在右侧面板中显示信息，其中包括其 commit 时的 props 和 state 。 您可以深入了解这些内容以了解有关组件在提交期间实际渲染的内容的更多信息：在某些情况下，选择一个组件并在 commit 之间进行切换时，还会提供有关组件渲染原因的提示：上图显示 state.scrollOffset 在两次 commit 之间发生了变化。这可能是导致 List 组件重新渲染的原因。 排序图表（Ranked chart）排序图视图表示单个 commit 。 图表中的每个横条代表一个 React 组件（例如 App ，Nav ）。 对图表进行排序，以便渲染时间最长的组件位于顶部。 注意：组件的渲染时间包括渲染其子项所花费的时间，因此渲染时间最长的组件通常靠近树的顶部。 与火焰图一样，您可以通过单击组件放大或缩小排序图表。 组件图表（Component chart）有时，在分析时需要查看特定组件的渲染次数。 组件图以柱状图的形式提供此信息。 图表中的每个竖条表示组件渲染的时间。 每个条的颜色和高度对应于组件在特定 commit中 相对于其他组件 渲染所花费的时间。上图显示 List 组件渲染了 11 次。 它还表明，每次渲染时，它都是 commits 中最“昂贵”的组件（意味着它花费的时间最长）。要查看此图表，请双击组件 或 选择组件，然后单击右侧详细信息窗格中的蓝色条形图图标。 您可以通过单击右侧详细信息窗格中的 “x” 按钮返回上一个图表。 您可以双击特定栏以查看有关该 commit 的更多信息。如果在本次分析会话期间所选组件根本未渲染，则将显示以下消息： 交互（Interactions）React 最近添加了另一个用于记录触发更新动作的API(实验中)。使用此 API 记录的 interactions 也将显示在 Profiler 中：React 最近添加了另一个用于跟踪更新原因的 实验API 。跟踪此API的 “交互（interactions）” 也将显示在 Profiler(分析器) 中：上图显示了一个跟踪四个交互（interactions）的分析会话。 每行代表一个被跟踪的交互（interactions）。 沿着行的彩色圆点表示与该交互（interactions）相关的 commit（提交 ）。你还可以从火焰图和排名图中查看为某次 commit 记录的 interaction：你可以通过单击它们，在 interaction 和 commits 之间互相切换：跟踪API仍然是新的，我们将在以后的博客文章中更详细地介绍它。 发现并修复故障 没有为选定的 root 节点记录分析数据如果您的应用程序有多个 “roots”，则在分析后可能会看到以下消息：此消息表示 “Elements” 面板中选择的 root 节点没有分析数据。在这种情况下，尝试在该面板中选择不同的 root 节点以查看该 root 节点的分析信息： 选中的 commit 没有显示计时数据有时可能会因为 commits 太快，以至于 performance.now() 还没有把相关有意义的时序信息传递给 DevTools。在这种情况下，将显示以下界面： 深入视频以下视频演示了如何使用 React Profiler(分析器) 来检测和改善实际 React 应用程序中的性能瓶颈。]]></content>
  </entry>
  <entry>
    <title><![CDATA[5个技巧让你更好的编写 JavaScript(ES6) 中条件语句]]></title>
    <url>%2F2019%2F07%2F16%2Fyuque%2F5%E4%B8%AA%E6%8A%80%E5%B7%A7%E8%AE%A9%E4%BD%A0%E6%9B%B4%E5%A5%BD%E7%9A%84%E7%BC%96%E5%86%99%20JavaScript(ES6)%20%E4%B8%AD%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[使用 JavaScript 时，我们经常需要处理很多条件语句，这里分享5个小技巧，可以让你编写更好/更清晰的条件语句。 1.使用 Array.includes 来处理多个条件我们来看看下面的例子：JavaScript 代码: 123456// conditionfunction test(fruit) &#123; if (fruit == 'apple' || fruit == 'strawberry') &#123; console.log('red'); &#125;&#125; 乍一看，上面的例子看起来似乎没什么问题。 但是，如果我们还有更多的红色水果呢？比如樱桃（cherry）和蔓越莓（cranberries）。 我们是否要用更多的 || 操作符来扩展该语句呢？我们可以使用 Array.includes 重写上面的条件语句。JavaScript 代码: 123456789function test(fruit)&#123; const redFruits=['apple','strawberry','cherry','cranberries']; if(redFruits.includes(fruit))&#123; console.log('red') &#125;&#125;test('cherry')red 我们将红色水果（条件）提取到一个数组中。这样做，可以让代码看起来更整洁。 2.减少嵌套，提前使用 return 语句让我们扩展前面的示例，再包含另外两个条件： 如果没有提供水果，抛出错误 接受水果 quantity（数量）参数，如果超过 10，则并打印相关信息。 JavaScript 代码: 1234567891011121314151617181920212223unction test(fruit, quantity) &#123; const redFruits = ['apple', 'strawberry', 'cherry', 'cranberries']; // 条件 1：fruit 必须有值 if (fruit) &#123; // 条件 2：必须为红色 if (redFruits.includes(fruit)) &#123; console.log('red'); // 条件 3：数量必须大于 10 if (quantity &gt; 10) &#123; console.log('big quantity'); &#125; &#125; &#125; else &#123; throw new Error('No fruit!'); &#125;&#125; // 测试结果test(null); // 抛出错误：No fruitstest('apple'); // 打印：redtest('apple', 20); // 打印：red，big quantity 看看上面的代码，我们有：– 1 个 if / else 语句过滤掉无效条件– 3 层 if 语句嵌套（分别是条件1,2和3）我个人遵循的一般规则是 在发现无效条件时提前 return。JavaScript 代码: 123456789101112131415161718/* 在发现无效条件时提前 return */ function test(fruit, quantity) &#123; const redFruits = ['apple', 'strawberry', 'cherry', 'cranberries']; // 条件 1：提前抛出错误 if (!fruit) throw new Error('No fruit!'); // 条件2：必须为红色 if (redFruits.includes(fruit)) &#123; console.log('red'); // 条件 3：数量必须大于 10 if (quantity &gt; 10) &#123; console.log('big quantity'); &#125; &#125;&#125; 这样做，我们可以减少一个嵌套层级。 这种编码风格很好，特别是当你的 if 语句很长时（想象一下，你需要滚动到最底部才知道那里有一个 else 语句，这样代码的可读性就变得很差了）。如果通过反转条件并提前 return ，我们可以进一步减少嵌套。 请查看下面的条件 2 ，看看我们是如何做到的：JavaScript 代码: 123456789101112131415/* 在发现无效条件时提前 return */ function test(fruit, quantity) &#123; const redFruits = ['apple', 'strawberry', 'cherry', 'cranberries']; if (!fruit) throw new Error('No fruit!'); // 条件 1：提前抛出错误 if (!redFruits.includes(fruit)) return; // 条件 2：当 fruit 不是红色的时候，提前 return console.log('red'); // 条件 3：必须是大量存在 if (quantity &gt; 10) &#123; console.log('big quantity'); &#125;&#125; 通过反转条件2的条件，我们的代码现在没有嵌套语句了。 当我们有很长的逻辑代码时，这种技巧非常有用，我们希望在条件不满足时停止下一步的处理。然而，这并不是严格的规定。问问自己，这个版本（没有嵌套）是否要比前一个版本（条件 2 有嵌套）的更好、可具可读性？对我来说，我会选择前一个版本（条件 2 有嵌套）。 这是因为： 代码简短直接，嵌套 if 更清晰 反转条件可能会引发更多的思考过程（增加认知负担） 因此，始终追求更少的嵌套，提前 return，但是不要过度。但不要过度。如果您感兴趣，这里有一篇文章和 StackOverflow 的讨论， 进一步讨论这个话题： Avoid Else, Return Early by Tim Oxley StackOverflow 上关于 if/else 代码风格的讨论 3.使用函数的默认参数 和 解构我想下面的代码可能看起来很熟悉，我们在使用 JavaScript 时总是需要检查 null / undefined 值并分配默认值：JavaScript 代码: 12345678910function test(fruit, quantity) &#123; if (!fruit) return; const q = quantity || 1; // 如果没有提供 quantity 参数，则默认为 1 console.log(`We have $&#123;q&#125; $&#123;fruit&#125;!`);&#125; // 测试结果test('banana'); // We have 1 banana!test('apple', 2); // We have 2 apple! 实际上，我们可以通过分配默认函数参数来消除变量 q 。JavaScript 代码: 12345678function test(fruit, quantity = 1) &#123; // i如果没有提供 quantity 参数，则默认为 1 if (!fruit) return; console.log(`We have $&#123;quantity&#125; $&#123;fruit&#125;!`);&#125; // 测试结果test('banana'); // We have 1 banana!test('apple', 2); // We have 2 apple! 更简单直观不是吗？ 请注意，每个函数参数都有自己的默认值。 例如，我们也可以为 fruit 分配一个默认值：function test(fruit = ‘unknown’, quantity = 1)。 注：如果你还不了解 ES6 中函数默认参数的新特性，可以查看 JavaScript 函数中默认参数 了解更多详情。 如果我们的 fruit 是一个 Object 对象怎么办？ 我们可以指定默认参数吗？JavaScript 代码: 12345678910111213function test(fruit) &#123; // 如果有值，则打印 fruit.name if (fruit &amp;&amp; fruit.name) &#123; console.log (fruit.name); &#125; else &#123; console.log('unknown'); &#125;&#125; //测试结果test(undefined); // unknowntest(&#123; &#125;); // unknowntest(&#123; name: 'apple', color: 'red' &#125;); // apple 看看上面的例子，我们想要的是如果 fruit.name 可用则打印水果名称，否则将打印 unknown 。我们可以使用默认函数参数和解构(destructing) 来避免 fruit &amp;&amp; fruit.name 这样的检查。JavaScript 代码: 12345678910// 解构 —— 只获得 name 属性// 参数默认分配空对象 &#123;&#125;function test(&#123;name&#125; = &#123;&#125;) &#123; console.log (name || 'unknown');&#125; //测试结果test(undefined); // unknowntest(&#123; &#125;); // unknowntest(&#123; name: 'apple', color: 'red' &#125;); // apple 由于我们只需要来自 fruit 的 name 属性，我们可以使用 {name} 来解构参数，然后我们可以在代码中使用 name 作为变量来取代fruit.name。我们还将空对象 {} 指定为默认值。 如果我们不这样做，你将在执行行测试时遇到test(undefined) – Cannot destructure property name of ‘undefined’ or ‘null’.(无法解析’undefined’或’null’的属性名称)。 因为 undefined中 没有 name 属性。如果您不介意使用第三方库，有几种方法可以减少空检查： 使用 Lodash get 函数 使用 Facebook 开源的 idx 库（需搭配 Babeljs） 注：如果你还不了解 ES6 中 destructure(解构) 的新特性，可以查看 https://www.html.cn/archives/tag/解构 这些文章了解更多详情。 以下是使用Lodash的示例：JavaScript 代码: 123456789// 引入 lodash 库，我们将获得 _.get()function test(fruit) &#123; console.log(_.get(fruit, 'name', 'unknown'); // 获取 name 属性，如果没有分配，则设为默认值 unknown&#125; //测试结果test(undefined); // unknowntest(&#123; &#125;); // unknowntest(&#123; name: 'apple', color: 'red' &#125;); // apple 您可以在这里 运行演示代码 。此外，如果你喜欢函数式编程（FP），您可以选择使用Lodash fp ，Lodash的函数式能版本（方法名更改为 get 或 getOr）。 4.选择 Map / Object 字面量，而不是Switch语让我们看看下面的例子，我们想根据颜色打印水果：JavaScript 代码: 1234567891011121314151617function test(color) &#123; // 使用 switch case 语句，根据颜色找出对应的水果 switch (color) &#123; case 'red': return ['apple', 'strawberry']; case 'yellow': return ['banana', 'pineapple']; case 'purple': return ['grape', 'plum']; default: return []; &#125;&#125; //测试结果test(null); // []test('yellow'); // ['banana', 'pineapple'] 上面的代码似乎没有错，但我觉得它很冗长。使用具有更清晰语法的 object 字面量可以实现相同的结果：JavaScript 代码: 12345678910// 使用对象字面量，根据颜色找出对应的水果 const fruitColor = &#123; red: ['apple', 'strawberry'], yellow: ['banana', 'pineapple'], purple: ['grape', 'plum'] &#125;; function test(color) &#123; return fruitColor[color] || [];&#125; 或者，您可以使用 Map 来实现相同的结果：JavaScript 代码: 123456789// 使用 Map ，根据颜色找出对应的水果 const fruitColor = new Map() .set('red', ['apple', 'strawberry']) .set('yellow', ['banana', 'pineapple']) .set('purple', ['grape', 'plum']); function test(color) &#123; return fruitColor.get(color) || [];&#125; Map 是 ES2015(ES6) 引入的新的对象类型，允许您存储键值对。我们是不是应该禁止使用 switch 语句呢？ 不要局限于此。 就个人而言，我尽可能使用对象字面量，但我不会设置硬规则来阻止使用 switch ，是否使用应该根据你的场景而决定。Todd Motto 有一篇文章深入地研究了 switch语句与对象字面量，你可以在 这里 阅读。 重构语法对于上面的示例，我们实际上可以使用 Array.filter 来重构我们的代码，以实现相同的结果。JavaScript 代码: 1234567891011121314const fruits = [ &#123; name: 'apple', color: 'red' &#125;, &#123; name: 'strawberry', color: 'red' &#125;, &#123; name: 'banana', color: 'yellow' &#125;, &#123; name: 'pineapple', color: 'yellow' &#125;, &#123; name: 'grape', color: 'purple' &#125;, &#123; name: 'plum', color: 'purple' &#125;]; function test(color) &#123; // 使用 Array filter ，根据颜色找出对应的水果 return fruits.filter(f =&gt; f.color == color);&#125; 总有不止一种方法可以达到相同的效果。对于这个例子我们展示了 4 种实现方法。编码很有趣！ 5. 使用 Array.every 和 Array.some 来处理全部/部分满足条件最后一个小技巧更多地是利用新的（但不是那么新的）Javascript Array函数来减少代码行。查看下面的代码，我们想检查所有水果是否都是红色的：JavaScript 代码: 1234567891011121314151617const fruits = [ &#123; name: 'apple', color: 'red' &#125;, &#123; name: 'banana', color: 'yellow' &#125;, &#123; name: 'grape', color: 'purple' &#125; ]; function test() &#123; let isAllRed = true; // 条件：所有的水果都必须是红色 for (let f of fruits) &#123; if (!isAllRed) break; isAllRed = (f.color == 'red'); &#125; console.log(isAllRed); // false&#125; 代码太长了！我们可以使用 Array.every 减少行数：JavaScript 代码: 1234567891011121314151617const fruits = [ &#123; name: 'apple', color: 'red' &#125;, &#123; name: 'banana', color: 'yellow' &#125;, &#123; name: 'grape', color: 'purple' &#125;]; function test() &#123; // 条件：是否存在红色的水果 const isAnyRed = fruits.some(f =&gt; f.color == 'red'); console.log(isAnyRed); // true&#125;fruits.some(f=&gt;&#123;console.log(f);if(f.color=='red')&#123;return f&#125;&#125;)&#123;name: "apple", color: "red"&#125;true 总结让我们一起生成更多可读代码。我希望你能在本文中学到一些新东西。就这样。编码快乐！英文原文：https://scotch.io/bar-talk/5-tips-to-write-better-conditionals-in-javascript]]></content>
  </entry>
  <entry>
    <title><![CDATA[现代 CSS 选择器指南]]></title>
    <url>%2F2019%2F07%2F16%2Fyuque%2F%E7%8E%B0%E4%BB%A3%20CSS%20%E9%80%89%E6%8B%A9%E5%99%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[https://www.html.cn/archives/10323我已经使用CSS多年了，但直到最近我还没有深入研究过关于 CSS 选择器的主题。为什么我需要学习 CSS 选择器呢？ 我们现在知道了所有的内部选择器了吗？问题是(至少对我来说是这样)随着时间的推移，很容易习惯在每个项目上使用相同的习惯的选择器集合来完成你要做的事情。因此，我自己对 CSS 选择器知识进行了深入的审查，并发现了一些有趣的内容，这些内容对我来说是新的，或者是以前我从来没有想过这些使用方式。我还发现了一些很酷的新选择器，将来可用，但还没有广泛使用。我们一起来深入研究一下各种类型的 CSS 选择器吧。 您在日常工作中已经使用了，或者本文没涉及到的 CSS 选择器技能欢迎留言告诉我。准备好提升你的 CSS 选择器技能了吗？我们一起 GO！ 组合选择器让我们从熟悉的选择器开始。组合选择器用于选择子元素和兄弟元素，并且相信大家已经使用了很长一段时间了吧。 一般子元素选择器（空格）。例如A B。 直接子元素选择器。例如 A &gt; B 。 相邻兄弟元素选择器。例如 A + B。 一般兄弟元素选择器。例如 A ~ B。 您应该熟悉相邻兄弟元素选择器 A + B ，他会选择紧跟 A 的 B 元素。但是一般兄弟元素选择器 A~B 呢？ 他将选择跟随 A 的所有兄弟 B 元素：以下是实例：See the Pen 组合选择器 Combinator Selectors by feiwen8772 (@feiwen8772) on CodePen.0第二行 New York 行被选中是因为它紧跟在第一行之后 table tbody tr:first-child + tr，并且最后两个城市被高亮显示，因为他们被一般兄弟选择器 table tbody tr:nth-child(4) ~ tr 匹配，也就是第四行之后的所有行。 属性选择器我非常喜欢属性选择器。当您需要将包含某个属性的元素与特定值匹配时，它们可以非常灵活。See the Pen Attribute Selectors #1 by David Gwyer (@dgwyer) on CodePen.0此示例演示如何选择所有复选框元素并将样式应用于其匹配标签，以使其变为粗体和蓝色。然后，我们覆盖具有特定名称的 chk2 复选框的样式，并将其匹配的标签着色为红色。 请注意其他表单元素标签如何不受影响且未应用标签样式。属性选择器不仅适用于表单元素，它们还可以定位任何元素的属性。 您可以匹配任何属性，而不仅仅是官方支持的属性。 此外，您可以检查属性是否存在，如下所示：CSS 代码: button[icon] 这匹配包含 icon 属性的 元素。它将匹配 icon 属性，无论 icon 属性是空值还是设置为特定值。 更多例子：See the Pen Attribute Selectors #2 by David Gwyer (@dgwyer) on CodePen.0第一个链接没有 target 属性，因此不匹配。 接下来的两个链接是匹配的，因为它们的 target 属性具有空值或特定值的属性。 最后，最后一个链接设置为粉红色，因为它 fluffy 属性匹配。 它的值无关紧要，只需要与 a[fluffy] 选择器相匹配即可。一个实际的例子可能是突出显示没有alt属性的图像。 此属性对于网页的可访问性来说是所必需的，因此对于SEO而言，确保所有图像元素都包含此属性非常重要。我们可以使用以下规则来实现此目的：CSS 代码: img:not([alt]) { border: 2px red dashed; } See the Pen Attribute Selectors #3 by David Gwyer (@dgwyer) on CodePen.0如果要匹配属性值的特定部分，则可以使用一些非常有用的选择器。 A[attr^=val] – 属性值以 val 开头。 A[attr|=val] – 属性值以 val 开头，或者以 val- 开头。 A[attr$=val] – 属性值以 val 结尾。 A[attr*=val] – 属性值中包含 val 。 A[attr~=val] – 匹配用空格分隔的属性值列表，并且列表中包含 val 。 以下是每个例子：See the Pen Attribute Selectors #4 by David Gwyer (@dgwyer) on CodePen.0前两个示例非常相似，不同之处是 A[attr|=val] 匹配后跟一个 - 字符串的值。 这对于匹配语言属性 lang 很有用。 例如 。使用 A[attr$=”val”] 可以轻松匹配文件扩展名，并且与 ::after 相结合你可以轻松显示匹配文件。 注意使用 attr() 方法和 content 属性将它与静态字符串连接起来。A[attr*=val] 显示了无论使用何种协议或子域，您都可以匹配特定域 mysite.com。最后，A[attr=val]，它非常适合匹配由空格分隔的值列表组成的属性中的值。 这只匹配整个单词而不是单词片段，而 *= 匹配单词片段，因此单词复数形式将不匹配。这个有点不好理解：例如某 div 元素的 categories 属性为 ，其 categories 属性用空格分隔。那么 div[categories=”table”] 将匹配各元素，还有一个特别要注意的是， 也将被匹配。而 或者 都不会被 div[categories~=”table”] 匹配。以上所有属性选择器示例都区分大小写。 但是我们有一个技巧。 如果我们在结束方括号之前插入一个 i ，我们可以启用区分大小写的匹配，这有点类似于 JavaScript 中的正则表达式匹配。See the Pen Attribute Selectors #5 by David Gwyer (@dgwyer) on CodePen.0除 Internet Explorer 和 Microsoft Edge 外，大多数主流浏览器都支持不区分大小写的匹配。 用户交互选择器如果您处理过表单样式，那么您之前无疑会遇到这些类型的伪类选择器： :enabled :disabled :checked 例如，我们可以使用 :checked 来设置一个简单的待办事项列表。See the Pen User Interface Selectors #1 by David Gwyer (@dgwyer) on CodePen.0这是非常标准的，但我们可以使用其他一些有趣的伪类。 :default 匹配一个或多个元素，这些元素是一组相关元素中的默认元素。这也可以与复位按钮类型组合使用。See the Pen User Interface Selectors #2 by David Gwyer (@dgwyer) on CodePen.0我们可以使用伪类选择器来匹配输入值是否与 CSS 直接有效，以及在提交表单之前检查是否需要任何元素。 :valid :invalid :required :optional (即不必须) See the Pen User Interface Selectors #3 by David Gwyer (@dgwyer) on CodePen.0如果您开始输入个人 email 输入字段，则必须检查有效性。 但是，工作 email 地址始终是必需的，并且需要有效检查有效性，因此不能留空。 还要注意我们可以链接伪类选择器（例如 :required:invalid ）来实现我们所需要的。接下来，如果表单元素（支持 min 和 max 属性）在范围内，我们有两个可以匹配的伪类。 :in-range :out-of-range See the Pen User Interface Selectors #4 by David Gwyer (@dgwyer) on CodePen.0同样，我们可以使用重置按钮类型来重置数字输入元素的默认值。为了完善本节，我们来看看 :read-only ，:read-write 和 :placeholder-shown 的伪类。See the Pen User Interface Selectors #5 by David Gwyer (@dgwyer) on CodePen.0使用这些可以轻松匹配只读或可写（可编辑）的元素。 匹配元素不必是表单输入字段，如示例中所示。最后，:placeholder-shown 将匹配尚未与之交互的元素，并仍显示默认占位符文本。 应谨慎使用此特定选择器，因为它尚未得到广泛支持。 结构选择器结构选择器非常强大，基于它们在DOM中的位置匹配元素。 它们使您可以灵活地将元素与CSS完全匹配，否则需要 JavaScript 执行相同的操作。这种类型的选择器与显示的选择器不同，因为其中一些选择器允许您传入参数来修改选择器的工作方式。例如：nth-child() 接收一个值，该值将匹配特定子元素相对于其父容器的值。因此，如果我们有一个项目列表，则以下选择器将匹配第三个项目：CSS 代码: ul:nth-child(3) 但是，参数不是必须是简单的数字，它可以是一个简单的表达式，而使伪类更强大。有效表达式有： ul:nth-child(2) – 匹配第 2 个子元素 ul:nth-child(4n) – 匹配每 4th 个子元素（4,8,12，…） ul:nth-child(2n + 1) – 匹配每 2n + 1 个子元素偏移一个（1,3,5，…） ul:nth-child(3n - 1) – 匹配每 3n – 1 个子元素偏移负数1（2,5,8，…） ul:nth-child(odd) – 匹配奇数元素（1,3,5，…） ul:nth-child(even) – 匹配偶数元素（2,4,6，…） 表达式变量 n 总是从零开始，因此确切地计算出哪些元素将匹配，n 从 0 开始，然后 n 为 1 ，依此类推以编译元素列表。这里还有 1 个简单而实用的小技巧，我们把 n 当做负数来用，会发生什么呢？ ul li:nth-child(-n+3) – 匹配第 1 到 第 3 个 li 子元素 （1,2,3） ul li:nth-child(-2n+6) – 匹配每 2th 个子元素，最多不超过第 8 个 li 子元素 （2,4,6，8） ul li:nth-child(n + 10):nth-child(-n + 12) – 匹配第 10 到 第 12 个 li 子元素 （10,11,12） 例如：See the Pen jXOeKY by feiwen8772 (@feiwen8772) on CodePen.0您可以将简单表达式与以下结构选择器一起使用： :nth-child() :nth-last-child() :nth-of-type() :nth-last-of-type() See the Pen Structural Selectors #1 by David Gwyer (@dgwyer) on CodePen.0:nth-last-child() 和 :nth-last-of-type() 非常类似于 :nth-child() 和 nth-of-type() ，唯一区别是 :nth-last-child() 和 :nth-last-of-type() 是从最后一个元素开始匹配，而不是第一个元素开始匹配。通过玩各种组合，您可以通过选择器获得相当多的创意。 例如，之前的示例包含选择器：CSS 代码: ul:last-of-type li:nth-last-of-type(2)::after { content: “(2nd from end)”; /* Other styles… */ } 这匹配第 2 个无序列表中最后一个列表项之后的伪元素。 如果你一直在努力解码一个复杂的选择器，那么最好从右到左阅读它，这样它就可以在逻辑上解构。下一组选择器是专用的结构选择器，因为它们只匹配特定的子元素。 您无法将表达式传递给它们以修改其行为。 :first-child :last-child :only-child :first-of-type :last-of-type See the Pen Structural Selectors #2 by David Gwyer (@dgwyer) on CodePen.0乍一看，这里有很多事情，你在使用这些类型的选择器时需要小心，因为你可能得到你没想到的结果。例如，您可能想知道为什么在 标记内的等等……文本是蓝色的。 实际上所有部分内容都是蓝色的，因为它是主 div 容器的最后一个子节点。 其他部分元素通过其他选择器覆盖自己的颜色，使单个段落变为蓝色。如果你觉得这些结构选择器还不够，或者你觉得记不住，使用起来很麻烦，那么你可以使用 Family.scss – 轻松搞定这些 :nth-child 伪类 :nth-child 否定、排除选择器CSS 否定伪类选择器 :not(X)，是以一个简单的以选择器 X 为参数的功能性标记函数，将从匹配的元素集合中排除选择器 X 所匹配的元素。选择器 X 中不能包含另外一个 :not 选择器。:not() 伪类的优先级即为它参数选择器的优先级。 可以利用这个伪类提高规则的优先级。例如， #foo:not(#bar) 和 #foo 会匹配相同的元素。 但是前者的优先级更高。但是 :not() 伪类不像其它伪类，它不会增加选择器的优先级。:not() 伪类可以将一个或多个以逗号分隔的选择器作为其参数。但是以多个以逗号分隔的选择器作为参数是实验性的，尚未广泛支持。:not() 伪类时我们得选择器组合更加灵活，我们来看一些简单应用：See the Pen :not() 伪类 by feiwen8772 (@feiwen8772) on CodePen.0上例中，.content :not(.notice) em 匹配了 .content 中所有的 em 元素，但是排除了 .content .notice 中 em 元素。我们再来看看 :not() 和其他伪类选择器结合的例子：See the Pen :not伪类 by feiwen8772 (@feiwen8772) on CodePen.0在做一个有间隔线的列表时，我们通常会去除最后一个 li 下的横线。li:not(:last-child) 表示除了最后一个 li 元素之外的所有其他 li 元素。 内容选择器这些属于用于匹配内容的一组专用选择器。我们可以立即使用的是： ::first-line ::first-letter ::selection – 兼容方案：/archives/5169 See the Pen Content Selectors #1 by feiwen8772 (@feiwen8772) on CodePen.0::first-line 和 ::first-letter 仅在应用于块级元素时才起作用。另外要小心只在特定元素上使用 ::first-letter ，否则每个段落都可能会应用。目前还没有一些令人兴奋的内容选择器，但是当它们得到支持时，它们将开启各种可能性。以下是需要注意的内容选择器列表： ::inactive-selection?—?非活动窗口内的选定内容 ::spelling-error?—?检查可编辑元素的拼写和语法 ::grammar-error?—?匹配语法错误 ::marker?—?匹配列表项标记 ::placeholder?—?匹配表单元素的 placeholder 文本样式；兼容方案：/archives/5689其他选择器我们接下来提到其他几个选择器不适合不适合归类到上面任何类别。 别担心我们差不多完成了！ 不幸的是，其中大部分是实验性的，所以你必须等待一段时间才能在生产中使用它们。:target 选择器的目标是一个 id 与当前 URL 的一部分匹配的元素。 比如下面 URL 匹配该URL页面中 id 为 part1 的元素：CSS 代码: https://css88.com#part1 我们可以将该元素应用以下样式：CSS 代码: :target { border: 1px red solid; } 其实 :target 选择器目前可以用于一些特殊的用例，欢迎查看： :target 伪类使用技巧如果你有一个很大的选择器，那么 :matches() 可以帮助简化它。例如，如果您有以下选择器：CSS 代码: nav p.content, header p.content, main p.content, sidebar p.content, footer p.content { margin: 15px; padding: 10px; } 然后可以通过 :matches() 简化，相当于：太好了！这将有助于使样式表更具可读性。接下来我们还有一个 :any-link 选择器，这个选择器是:link 和 :visited 组合的简写。 所以下面这两个选择器实际上是相同的：CSS 代码: :any-link { color: red; } :link, :visited { color: red; } 本文中最后两个选择器： :dir() :lang() 这些都与您网站的语言有关。:dir() 接受参数 ltr 或 rtl ，具体取决于您要匹配的文本的方向，目前仅 Firefox 支持。所以：:dir(rtl) 会匹配所有具有 RTL 方向内容的元素。HTML文档中的每个元素都可以使用 lang 属性设置自己的单独语言。CSS 代码: The language of this element is set to English. Η γλ?σσα αυτο? του στοιχε?ου ?χει οριστε? στα ελληνικ?. Tungumál ?essa ?áttar er sett á íslensku. 将相同的基本文本输入到三个 标记中，但将特定国家/地区添加到内容的末尾。此外，lang 属性中使用的国家代码代表相应的国家/地区。CSS 代码: :lang(en) { color: red; } :lang(el) { color: green; } :lang(is) { color: blue; } 演示：See the Pen Misc Selectors by David Gwyer (@dgwyer) on CodePen.0好消息是所有主流浏览器都支持 :lang() 选择器。 资源如果你试图查找一个选择器，或者需要深入研究CSS规范，那么你可能需要查看一些有用的资源： 当前可用的 CSS 的选择器集合 MDN Web Docs CSS Specifications Can I Use最后…我希望你会发现这篇文章很有用。 可以帮助刷新你的CSS选择器技能，并尝试各种可能性。使用纯 CSS 可以做很多很酷的事情，这在几年前是不可能实现的。对于能够在纯 CSS 中进行一些非常高级的样式和动画的设计师来说，这是令人兴奋的，并且所有人都看不到一行 JavaScript 。本文大部分内容来自：https://blog.logrocket.com/level-up-your-css-selector-skills-5d7bb45ddd37，在这篇文章的基础上做了很多内容的改进。]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript Class(类) 中的 Private(私有) 和 Public(公有) 属性]]></title>
    <url>%2F2019%2F07%2F16%2Fyuque%2FJavaScript%20Class(%E7%B1%BB)%20%E4%B8%AD%E7%9A%84%20Private(%E7%A7%81%E6%9C%89)%20%E5%92%8C%20Public(%E5%85%AC%E6%9C%89)%20%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[本文为 JavaScript Prototype(原型) 新手指南 续篇，文中 Fields 是对象属性的意思我最喜欢的 JavaScript 社区的一部分原因是每个人似乎总是问 “为什么？” 。 为什么我们要按照这种方式做事？ 一般来说，这个问题的答案需要充满理性和回顾历史背景。 但有时，答案往往更简单 – “因为我们一直以来都是这么做的。”在 上一篇文章 中，我们学习了如何在 ES5 和 ES6 中创建 JavaScript 类。 我们还讨论了如何通过构造函数向这些类的实例添加 state(状态) ，以及如何通过类的原型在实例之间共享方法。 这是一个简单的 Player类，它包含了我们讨论的有关 ES6 类的所有内容。JavaScript 代码: class Player { constructor() { this.points = 0 this.assists = 0 this.rebounds = 0 this.steals = 0 } addPoints(amount) { this.points += amount } addAssist() { this.assists++ } addRebound() { this.rebounds++ } addSteal() { this.steals++ } } 我们看看这段代码，我们能不能让它更直观一点呢？方法很好理解，都很自然。那么构造函数呢？什么是 constructor ？为什么我们必须在这里定义实例值？现在，这些问题已经有了答案，但是为什么我们不能向实例中添加 state(状态) ，就像方法那样？比如：JavaScript 代码: class Player { points = 0 assists = 0 rebounds = 0 steals = 0 addPoints(amount) { this.points += amount } addAssist() { this.assists++ } addRebound() { this.rebounds++ } addSteal() { this.steals++ } } 事实上，这是 Class Fields Declaration 提案的基础，该提案目前处于 TC-39 流程的 第3阶段 。 此提议允许您直接将实例属性添加为类的属性，而无需使用构造方法。 非常漂亮，但是如果我们看一些 React 代码，这个提案真的很棒。 这是一个典型的 React 组件。 它具有本地 state(状态) ，一些方法以及一些静态属性被添加到类中。JavaScript 代码: class PlayerInput extends Component { constructor(props) { super(props) this.state = { username: ‘’ } this.handleChange = this.handleChange.bind(this) } handleChange(event) { this.setState({ username: event.target.value }) } render() { … } } PlayerInput.propTypes = { id: PropTypes.string.isRequired, label: PropTypes.string.isRequired, onSubmit: PropTypes.func.isRequired, } PlayerInput.defaultProps = { label: ‘Username’, } 让我们看看新的 Class Fields 提议如何改进上面的代码首先，我们可以将 state(状态) 变量从构造函数中取出，并将其直接定义为类的属性（或“字段”）。JavaScript 代码: class PlayerInput extends Component { state = { username: ‘’ } constructor(props) { super(props) this.handleChange = this.handleChange.bind(this) } handleChange(event) { this.setState({ username: event.target.value }) } render() { … } } PlayerInput.propTypes = { id: PropTypes.string.isRequired, label: PropTypes.string.isRequired, onSubmit: PropTypes.func.isRequired, } PlayerInput.defaultProps = { label: ‘Username’, } 很酷，但没什么好兴奋的。 我们继续吧。 在上一篇文章中，我们讨论了如何使用 static 关键字向类本身添加静态方法。 但是，根据 ES6 类规范，这只对方法有效，对于值则无效。 这就是为什么在上面的代码中，我们必须在我们定义完 PlayerInput 之后，再在 class 外面将 propTypes 和 defaultProps 添加到 PlayerInput ，而不是在 class 体内定义他们的原因。 再说一遍，它们不能像静态方法那样直接放入 class 体内呢? 好消息是，这也包含在 Class Fields 提案中。 所以现在不仅可以在类体中定义静态方法，还可以定义静态值。 这对我们的代码意味着我们可以将 propTypes 和 defaultProps 移动到 class 体内定义。JavaScript 代码: class PlayerInput extends Component { static propTypes = { id: PropTypes.string.isRequired, label: PropTypes.string.isRequired, onSubmit: PropTypes.func.isRequired, } static defaultProps = { label: ‘Username’ } state = { username: ‘’ } constructor(props) { super(props) this.handleChange = this.handleChange.bind(this) } handleChange(event) { this.setState({ username: event.target.value }) } render() { … } } 这样代码看上去好多了，但我们仍然有丑陋的 constructor 方法和 super 调用。 同样，我们现在需要构造函数的原因是为了将 handleChange 方法绑定到恰当的上下文中。 如果我们能找到另一种方法来确保始终在恰当的上下文中调用 handleChange ，那么我们可以摆脱掉 constructor 。如果您以前使用过箭头函数，就会知道它们没有自己的 this 关键字。相反，this 关键字是按 lexically(词法) 绑定的。这是一种奇特的说法，当你在箭头函数中使用 this 关键字时，事情会按照你所期望的方式运行。利用这些知识并将其与 “Class Fields” 提案相结合起来，如果我们将 handleChange 方法替换为箭头函数呢？这看起来有点奇怪，但是通过这样做，我们可以解决绑定问题，因为，箭头函数是通过 lexically(词法) 绑定 this 的。JavaScript 代码: class PlayerInput extends Component { static propTypes = { id: PropTypes.string.isRequired, label: PropTypes.string.isRequired, onSubmit: PropTypes.func.isRequired, } static defaultProps = { label: ‘Username’ } state = { username: ‘’ } handleChange = (event) =&gt; { this.setState({ username: event.target.value }) } render() { … } } 你看上面的代码，这比我们开始的原始类要好得多，这都要感谢 “Class Fields” 提案，它将很快成为 EcmaScript 规范的一部分。从开发者体验的角度来看，Class Fields 提案优势很明显。 然而，他们有一些缺点，很少被谈论。 在上一篇文章中，我们讨论了 ES6 类实际上只是 Pseudoclassical Instantiation(伪类实例化) 模式的语法糖。也就是说，当你向类添加方法时，这就像在函数原型中添加方法一样。JavaScript 代码: class Animal { eat() {} } // 等价于 function Animal () {} Animal.prototype.eat = function () {} 这是高效的，因为 eat 定义一次并在类的所有实例之间共享。 这与 Class Fields 有什么关系？ 好吧，正如我们上面所看到的， Class Fields 被添加到实例中。 这意味着对于我们创建的每个实例，我们将创建一个新的 eat 方法。JavaScript 代码: class Animal { eat() {} sleep = () =&gt; {} } // 等价于 function Animal () { this.sleep = function () {} } Animal.prototype.eat = function () {} 请注意 sleep 如何放在实例上，而不是放在 Animal.prototype 上。这是件坏事吗？嗯，有可能。在不进行度量的情况下对性能进行宽泛的描述通常不是一个好主意。您需要在应用程序中回答的问题是，您从 Class Fields 中获得的开发人员体验是否超过了潜在的性能损失。如果你想在你的应用程序中使用我们之前谈到的任何内容，你需要使用 babel-plugin-transform-class-properties 插件。 Private(私有) 属性Class Fields 提案的另一个内容时是 “private fields (私有属性)” 。 有时，当您构建一个类时，您希望拥有不暴露给外界的私有值。 从历史上看， JavaScript 缺乏真正私有值 的能力，所以我们通过约定，用下划线标记它们。JavaScript 代码: class Car { _milesDriven = 0 drive(distance) { this._milesDriven += distance } getMilesDriven() { return this._milesDriven } } 在上面的示例中，我们依靠 Car class（类）的实例通过调用 getMilesDriven 方法来获取汽车的里程数。但是，因为没有什么能使 _milesDriven成为私有的，所以任何实例都可以访问它。JavaScript 代码: const tesla = new Car() tesla.drive(10) console.log(tesla._milesDriven) 有个奇特的（hacky）方法，就是使用 WeakMaps 可以解决这个问题，但如果存在更简单的解决方案，那将会很好。 同样，Class Fields 提案正在拯救我们。 根据提议，您可以使用 ＃ 创建私有字段。 是的，你没有看错， ＃ 。 我们来看看它对我们的代码有什么影响，JavaScript 代码: class Car { #milesDriven = 0 drive(distance) { this.#milesDriven += distance } getMilesDriven() { return this.#milesDriven } } 我们可以用速记语法更进一步简化JavaScript 代码: class Car { #milesDriven = 0 drive(distance) { #milesDriven += distance } getMilesDriven() { return #milesDriven } } const tesla = new Car() tesla.drive(10) tesla.getMilesDriven() // 10 tesla.#milesDriven // Invalid 如果您对私有属性背后的更多细节/决策感兴趣，那么这里有一篇 很好的文章。目前 有一个 PR 将私有属性添加到 Babel ，以便您可以在应用中使用它们。英文原文：https://tylermcginnis.com/javascript-private-and-public-class-fields/]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 继承和原型链]]></title>
    <url>%2F2019%2F07%2F16%2Fyuque%2FJavaScript%20%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[https://www.html.cn/archives/10396本文为 JavaScript Class(类) 中的 Private(私有) 和 Public(公有) 属性 续篇之前我们学习了如何在 ES5 和 ES6 中创建 Animal 类。我们还学习了如何使用 JavaScrip t的原型在这些类之间共享方法。查看我们在之前文章中看到的代码。ES5:JavaScript 代码:function Animal (name, energy) {this.name = namethis.energy = energy} Animal.prototype.eat = function (amount) {console.log(${this.name} is eating.)this.energy += amount} Animal.prototype.sleep = function (length) {console.log(${this.name} is sleeping.)this.energy += length} Animal.prototype.play = function (length) {console.log(${this.name} is playing.)this.energy -= length} const leo = new Animal(‘Leo’, 7)ES6:JavaScript 代码:class Animal {constructor(name, energy) {this.name = namethis.energy = energy}eat(amount) {console.log(${this.name} is eating.)this.energy += amount}sleep() {console.log(${this.name} is sleeping.)this.energy += length}play() {console.log(${this.name} is playing.)this.energy -= length}} const leo = new Animal(‘Leo’, 7)现在我们想为特定动物建一个别 class(类) 。 例如，如果我们想要开始制作一堆狗实例，该怎么办？ 这些狗有哪些属性和方法？ 嗯，类似于我们的 Animal 类，我们可以给每只狗一个 name ，一个 energy 等级，以及 eat ，sleep 和 play 的能力。 我们的 Dog 类是独一无二的，我们也可以给Dog 类一些独一无二的的属性，比如一个 breed(品种) 属性以及 bark(吠叫) 的能力。 在 ES5 中，我们的 Dog 类可能看起来像这样:JavaScript 代码:function Dog (name, energy, breed) {this.name = namethis.energy = energythis.breed = breed} Dog.prototype.eat = function (amount) {console.log(${this.name} is eating.)this.energy += amount} Dog.prototype.sleep = function (length) {console.log(${this.name} is sleeping.)this.energy += length} Dog.prototype.play = function (length) {console.log(${this.name} is playing.)this.energy -= length} Dog.prototype.bark = function () {console.log(‘Woof-Woof!’)this.energy -= .1} const charlie = new Dog(‘Charlie’, 10, ‘Goldendoodle’)你应该看出来了，我们刚刚重新创建了 Animal 类并为它添加了一些新属性。 如果我们想创建另一个动物，比如说 Cat ，那么我们必须再次创建一个 Cat 类，将 Animal 类中的所有常用逻辑复制到 Cat ，然后像 Dog 类一样添加 Cat 特定属性。 就是说，我们必须对我们创造的每一种不同类型的动物都这样做。JavaScript 代码:function Dog (name, energy, breed) {} function Cat (name, energy, declawed) {} function Giraffe (name, energy, height) {} function Monkey (name, energy, domesticated) {}这项工作似乎很浪费。 Animal 类是完美的基类。 这意味着它具有我们每只动物的共同特征。 无论我们是创造 狗，猫，长颈鹿还是猴子，它们都会有一个name ，energy 等级，以及 eat ，sleep 和 play 的能力。 那么每当我们为每个不同的动物创建单独的类时，我们是否可以利用 Animal类？ 我们来试试吧。 我将在下面再次粘贴 Animal 类以便于参考。JavaScript 代码:function Animal (name, energy) {this.name = namethis.energy = energy} Animal.prototype.eat = function (amount) {console.log(${this.name} is eating.)this.energy += amount} Animal.prototype.sleep = function (length) {console.log(${this.name} is sleeping.)this.energy += length} Animal.prototype.play = function (length) {console.log(${this.name} is playing.)this.energy -= length} function Dog (name, energy, breed) { }我们对上面的 Dog 构造函数你了解多少？首先，我们知道它需要3个参数，name, energy 和 breed。其次，我们知道它将使用 new 关键字调用，因此我们将拥有一个 this 对象。第三，我们知道我们需要利用 Animal 函数，这样任何狗的实例都会有一个name ，energy 等级，以及 eat ，sleep 和 play 的能力。第三点是有点棘手的问题。 你“利用”一个函数的方式就是调用它。 所以我们知道在 Dog 里面，我们想要调用 Animal 。 我们需要弄清楚的是我们如何在Dog 的上下文中调用 Animal。 这意味着我们想用 Dog 中的 this 关键字调用 Animal。 如果我们正确地做到了，那么 Dog 函数内部将具有 Animal 的所有属性（name ，energy）。 如果你记得 上一节我们所讨论的内容，JavaScript 中的每个函数都有一个 .call方法。.call() 是函数的一个方法，它允许你调用函数时，指定该函数的上下文。听起来正是我们所需要的。我们想在 Dog 上下文中调用 Animal 。JavaScript 代码:function Dog (name, energy, breed) {Animal.call(this, name, energy) this.breed = breed} const charlie = new Dog(‘Charlie’, 10, ‘Goldendoodle’) charlie.name // Charliecharlie.energy // 10charlie.breed // Goldendoodle知道这个，我们就已经成功一半了。你将在上面的代码中注意到，因为这一行是 Animal.call(this, name, energy)， Dog 的每个实例都将有一个 name 和 energy 属性。同样，这样做的原因是，就好像我们使用从 Dog 生成的 this 关键字运行 Animal 函数一样。在我们添加了一个name 和 energy 属性之后，我们又像往常一样添加了一个 breed 属性。请记住，这里的目标是让 Dog 的每个实例不仅具有 Animal 的所有属性，而且还具有所有方法。如果你运行上面的代码，你会注意到如果你尝试运行 charlie.eat(10) ，你将收到一个错误。目前 Dog 的每个实例都具有 Animal（name 和 energy）的属性，但我们没有做任何事情来确保他们也有方法（eat ，sleep 和 play）。让我们考虑如何解决这个问题。我们知道所有 Animal 的方法都位于 Animal.prototype 上。这意味着我们想要确保 Dog 的所有实例都可以访问Animal.prototype 上的方法。如果我们在这里使用我们的好朋友 Object.create 怎么办？如果你还记得，Object.create 允许你创建一个对象，该对象将在失败的查找中委托给另一个对象。所以在我们的例子中，我们想要创建的对象将是 Dog 的原型，而我们想要在失败的查找中委托的对象是Animal.prototype。JavaScript 代码:function Dog (name, energy, breed) {Animal.call(this, name, energy) this.breed = breed} Dog.prototype = Object.create(Animal.prototype)现在，只要在 Dog 实例上查找失败，JavaScript 就会将该查找委托给 Animal.prototype 。 如果这仍然有点模糊，请重新阅读 JavaScript Prototype(原型) 新手指南 ，其中我们讨论了 Object.create 和 JavaScript 的 原型(prototype) 。让我们一起看完整个代码，然后我们将了解发生的事情。JavaScript 代码:function Animal (name, energy) {this.name = namethis.energy = energy} Animal.prototype.eat = function (amount) {console.log(${this.name} is eating.)this.energy += amount} Animal.prototype.sleep = function (length) {console.log(${this.name} is sleeping.)this.energy += length} Animal.prototype.play = function (length) {console.log(${this.name} is playing.)this.energy -= length} function Dog (name, energy, breed) {Animal.call(this, name, energy) this.breed = breed} Dog.prototype = Object.create(Animal.prototype)现在我们已经创建了我们的基类（ Animal ）以及我们的子类（ Dog ），让我们在创建 Dog 实例时看看它的样子。JavaScript 代码:const charlie = new Dog(‘Charlie’, 10, ‘Goldendoodle’) charlie.name // Charliecharlie.energy // 10charlie.breed // Goldendoodle到目前为止没有任何花哨的东西，但让我们来看看当我们调用位于 Animal 上的方法时会发生什么。JavaScript 代码:charlie.eat(10) /* JavaScript checks if charlie has an eat property - it doesn’t. JavaScript then checks if Dog.prototype has an eat property it doesn’t. JavaScript then checks if Animal.prototype has an eat property it does so it calls it. */Dog.prototype 被检查的原因是因为当我们创建一个新的 Dog 实例时，我们使用了 new 关键字。在引擎中，为我们创建的 this 对象委托给Dog.prototype（见下面的注释）。JavaScript 代码:function Dog (name, energy, breed) {// this = Object.create(Dog.prototype)Animal.call(this, name, energy) this.breed = breed// return this}之所以检查 Animal.prototype 是因为我们用这一行覆盖了 Dog.prototype 以委托给失败的查找的 Animal.prototypeJavaScript 代码:Dog.prototype = Object.create(Animal.prototype)现在我们还没有谈到的一件事是，如果 Dog 有自己的方法呢？ 嗯，这是一个简单的解决方案。 就像 Animal 一样，如果我们想在该类的所有实例之间共享一个方法，我们将它添加到函数的原型中。JavaScript 代码:… function Dog (name, energy, breed) {Animal.call(this, name, energy) this.breed = breed} Dog.prototype = Object.create(Animal.prototype) Dog.prototype.bark = function () {console.log(‘Woof Woof!’)this.energy -= .1}非常好。我们需要做一个小小的补充。如果你不记得了请回到 JavaScript Prototype(原型) 新手指南 了解详情，我们可以通过使用 instance.constructor 来访问实例的构造函数。JavaScript 代码:function Animal (name, energy) {this.name = namethis.energy = energy} const leo = new Animal(‘Leo’, 7)console.log(leo.constructor) // Logs the constructor function正如前一篇文章中所解释的那样，“其工作原因是因为任何 Animal 实例都会在失败的查找中委托给 Animal.prototype 。 因此，当你尝试访问leo.prototype 时，leo 没有 prototype 属性，因此它会将该查找委托给 Animal.prototype ，它确实具有 constructor 属性。“我提出这个问题的原因是因为在我们的实现中，我们用一个委托给 Animal.prototype 的对象覆盖了 Dog.prototype 。JavaScript 代码:function Dog (name, energy, breed) {Animal.call(this, name, energy) this.breed = breed} Dog.prototype = Object.create(Animal.prototype) Dog.prototype.bark = function () {console.log(‘Woof Woof!’)this.energy -= .1}这意味着现在，任何打印 Dog 的实例 instance.constructor 都将获得 Animal 构造函数而不是 Dog构造函数。你可以通过运行此代码自行查看 –JavaScript 代码:function Animal (name, energy) {this.name = namethis.energy = energy} Animal.prototype.eat = function (amount) {console.log(${this.name} is eating.)this.energy += amount} Animal.prototype.sleep = function (length) {console.log(${this.name} is sleeping.)this.energy += length} Animal.prototype.play = function (length) {console.log(${this.name} is playing.)this.energy -= length} function Dog (name, energy, breed) {Animal.call(this, name, energy) this.breed = breed} Dog.prototype = Object.create(Animal.prototype) Dog.prototype.bark = function () {console.log(‘Woof Woof!’)this.energy -= .1} const charlie = new Dog(‘Charlie’, 10, ‘Goldendoodle’)console.log(charlie.constructor)请注意，即使 charlie 是 Dog 的直接实例，它也会为你提供 Animal 构造函数。同样，我们可以像上面一样了解这里发生的事情。JavaScript 代码:const charlie = new Dog(‘Charlie’, 10, ‘Goldendoodle’)console.log(charlie.constructor) /* JavaScript checks if charlie has a constructor property - it doesn’t. JavaScript then checks if Dog.prototype has a constructor property it doesn’t because it was deleted when we overwrote Dog.prototype. JavaScript then checks if Animal.prototype has a constructor property it does so it logs that. */我们该如何解决这个问题？嗯，这很简单。一旦我们覆盖它，我们就可以向 Dog.prototype 添加正确的 constructor 属性。JavaScript 代码:function Dog (name, energy, breed) {Animal.call(this, name, energy) this.breed = breed} Dog.prototype = Object.create(Animal.prototype) Dog.prototype.bark = function () {console.log(‘Woof Woof!’)this.energy -= .1} Dog.prototype.constructor = Dog此时如果我们想要创建另一个子类，比如 Cat ，我们将遵循相同的模式。JavaScript 代码:function Cat (name, energy, declawed) {Animal.call(this, name, energy) this.declawed = declawed} Cat.prototype = Object.create(Animal.prototype)Cat.prototype.constructor = Cat Cat.prototype.meow = function () {console.log(‘Meow!’)this.energy -= .1}这种具有委托给它的子类的基类的概念称为继承，它是面向对象编程（OOP）的主要部分。 如果你来自不同的编程语言，你可能已经熟悉OOP和继承了。 在 ES6 classes 之前，在 JavaScript 中，继承是一项非常艰巨的任务，正如你在上面所看到的。你现在只需要了解什么时候使用继承，以及 .call 和 Object.create， this ，和 FN.prototype 的良好组合。- 这些都是高级 JS 主题。让我们看看如何使用 ES6 类来完成同样的事情。首先，让我们回顾一下使用我们的 Animal 类从 ES5 “类” 到 ES6 类的样子。ES5:JavaScript 代码:function Animal (name, energy) {this.name = namethis.energy = energy} Animal.prototype.eat = function (amount) {console.log(${this.name} is eating.)this.energy += amount} Animal.prototype.sleep = function (length) {console.log(${this.name} is sleeping.)this.energy += length} Animal.prototype.play = function (length) {console.log(${this.name} is playing.)this.energy -= length} const leo = new Animal(‘Leo’, 7)ES6:JavaScript 代码:class Animal {constructor(name, energy) {this.name = namethis.energy = energy}eat(amount) {console.log(${this.name} is eating.)this.energy += amount}sleep() {console.log(${this.name} is sleeping.)this.energy += length}play() {console.log(${this.name} is playing.)this.energy -= length}} const leo = new Animal(‘Leo’, 7)现在我们已经将我们的 Animal 构造函数重构为 ES6 类，接下来我们需要做的是弄清楚如何重构我们的基类（ Dog ）。好消息是它更加直观。作为参考，在ES5 中，这是我们所拥有的。JavaScript 代码:function Dog (name, energy, breed) {Animal.call(this, name, energy) this.breed = breed} Dog.prototype = Object.create(Animal.prototype) Dog.prototype.bark = function () {console.log(‘Woof Woof!’)this.energy -= .1} Dog.prototype.constructor = Dog在我们进入继承之前，让我们使用 ES6 类来重构 Dog ，就像我们在之前的帖子中学到的那样。JavaScript 代码:class Dog {constructor(name, energy, breed) {this.breed = breed}bark() {console.log(‘Woof Woof!’)this.energy -= .1}}看起来很棒。现在，让我们弄清楚如何确保 Dog 继承自 Animal 。我们需要做的第一步是非常直接的。使用 ES6 类，你可以使用此语法 extend 基类JavaScript 代码:class Subclass extends Baseclass {}翻译成我们的例子，这将使我们的 Dog 类看起来像这样：JavaScript 代码:class Animal {constructor(name, energy) {this.name = namethis.energy = energy}eat(amount) {console.log(${this.name} is eating.)this.energy += amount}sleep() {console.log(${this.name} is sleeping.)this.energy += length}play() {console.log(${this.name} is playing.)this.energy -= length}} class Dog extends Animal {constructor(name, energy, breed) {this.breed = breed}bark() {console.log(‘Woof Woof!’)this.energy -= .1}}在ES5中，为了确保 Dog 的每个实例都具有name 和 energy 属性，我们使用 .call 以在 Dog 实例的上下文中调用 Animal 构造函数。 幸运的是，在 ES6 中，它更直接。 每当你扩展一个基类并且你需要调用那个基类的构造函数时，你调用 super 传递它需要的任何参数即可。 所以在我们的例子中，我们的 Dog构造函数被重构为这样:JavaScript 代码:class Animal {constructor(name, energy) {this.name = namethis.energy = energy}eat(amount) {console.log(${this.name} is eating.)this.energy += amount}sleep() {console.log(${this.name} is sleeping.)this.energy += length}play() {console.log(${this.name} is playing.)this.energy -= length}} class Dog extends Animal {constructor(name, energy, breed) {super(name, energy) // calls Animal’s constructor 1this.breed = breed }bark() {console.log(‘Woof Woof!’)this.energy -= .1}}就是这样。不使用 .call ，不使用 Object.create ，不用担心重置原型上的构造函数 – 只需 extends基类并确保调用 super 即可。JavaScript 的有趣之处在于你学到的相同模式，最后几篇文章直接融入语言本身。 以前你了解到 Array 的所有实例都可以访问 pop ，slice ，filter 等数组方法的原因是因为所有这些方法都存在于 Array.prototype 中。JavaScript 代码:console.log(Array.prototype) /*concat: ?n concat()constructor: ?n Array()copyWithin: ?n copyWithin()entries: ?n entries()every: ?n every()fill: ?n fill()filter: ?n filter()find: ?n find()findIndex: ?n findIndex()forEach: ?n forEach()includes: ?n includes()indexOf: ?n indexOf()join: ?n join()keys: ?n keys()lastIndexOf: ?n lastIndexOf()length: 0nmap: ?n map()pop: ?n pop()push: ?n push()reduce: ?n reduce()reduceRight: ?n reduceRight()reverse: ?n reverse()shift: ?n shift()slice: ?n slice()some: ?n some()sort: ?n sort()splice: ?n splice()toLocaleString: ?n toLocaleString()toString: ?n toString()unshift: ?n unshift()values: ?n values()*/你知道，所有 Object 实例都可以访问 hasOwnProperty 和 toString 等方法的原因是因为这些方法存在于 Object.prototype 上。JavaScript 代码:console.log(Object.prototype) /*constructor: ?n Object()hasOwnProperty: ?n hasOwnProperty()isPrototypeOf: ?n isPrototypeOf()propertyIsEnumerable: ?n propertyIsEnumerable()toLocaleString: ?n toLocaleString()toString: ?n toString()valueOf: ?n valueOf()*/这对你来说是一个挑战。使用上面的 Array 方法和 Object 方法列表，为什么下面的代码有效？JavaScript 代码:const friends = [‘Mikenzi’, ‘Jake’, ‘Ean’] friends.hasOwnProperty(‘push’) // false如果查看 Array.prototype ，则没有 hasOwnProperty 方法。 好吧，如果 Array.prototype 上没有 hasOwnProperty 方法，上面示例中的 friends 数组如何访问 hasOwnProperty？ 原因是因为 Array类扩展了 Object 类。 因此，在上面的示例中，当 JavaScript 看到friends 没有 hasOwnProperty 属性时，它会检查 Array.prototype 是否具有该方法。 当 Array.prototype 没有时，它会检查 Object.prototype 是否有该方法，然后再调用它。 这是我们在这篇博客文章中看到的相同过程。JavaScript 有两种类型 – 原始类型 和 引用类型 。原始类型是 boolean ， number， string，null 和 undefined 并且是不可变的。 其他所有内容都是引用类型，它们都扩展了 Object.prototype 。 这就是为什么你可以为函数和数组添加属性，这就是为什么函数和数组都可以访问 Object.prototype 上的方法。JavaScript 代码:function speak(){}speak.woahFunctionsAreLikeObjects = trueconsole.log(speak.woahFunctionsAreLikeObjects) // true const friends = [‘Mikenzi’, ‘Jake’, ‘Ean’]friends.woahArraysAreLikeObjectsToo = trueconsole.log(friends.woahArraysAreLikeObjectsToo) // true英文原文：https://tylermcginnis.com/javascript-inheritance-and-the-prototype-chain/]]></content>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript 2016,2017 和 2018 中所有新功能的示例]]></title>
    <url>%2F2019%2F07%2F16%2Fyuque%2FECMAScript%202016%2C2017%20%E5%92%8C%202018%20%E4%B8%AD%E6%89%80%E6%9C%89%E6%96%B0%E5%8A%9F%E8%83%BD%E7%9A%84%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[很难追踪 JavaScript（ECMAScript）中的新功能。 想找到有用的代码示例更加困难。因此，在本文中，我将介绍 TC39 已完成 ES2016，ES2017 和 ES2018（最终草案）提案中所有添加的 18 个功能，并展示有用的示例。这是一个很长的文章，但应该很容易阅读。 可以把它想象成 “Netflix binge reading”。但是到文章结束，我保证你将对所有这些功能有很好的了解。好的，让我们逐个讨论这些问题。 ECMAScript 2016 1.Array.prototype.includesincludes 是 Array 上的一个简单实例方法，有助于轻松查找某项元素是否在数组中（包括NaN ,与 indexOf不同）。人们想要 contains 来命名该规范，但显然 Mootools 已经使用过这个命名，所以使用了 includes。更多示例和常见问题请参见：ES2016 新特性：npm scripts : 每个前端开发都应知道的一些使用提示 2.指数运算符加法和减法等数学运算分别具有 + 和 - 等中缀运算符。与它们类似，** 中缀运算符通常用于指数运算。在 ECMAScript 2016 中，引入了 ** 代替 Math.pow 。更多示例和常见问题请参见：ES2016 新特性：求幂运算符(**) ECMAScript 2017 1.Object.values()Object.values() 是一个与 Object.keys() 类似的新函数，但返回 Object 自身属性的所有值，不包括原型链中的任何值。更多示例和常见问题请参见：ES2017 新特性：Object.entries() 和 Object.values() 2.Object.entries()Object.entries() 与 Object.keys 相关，但它不仅仅返回 keys ，而是以数组方式返回 keys 和 values 。这使得在循环中使用对象或将对象转换为 Maps 等操作变得非常简单。示例1示例2更多示例和常见问题请参见：ES2017 新特性：Object.entries() 和 Object.values() 3.字符串填充String 中添加了两个实例方法，String.prototype.padStart 和 String.prototype.padEnd – 允许将空字符串或其他字符串附加到原始字符串的开头或结尾。JavaScript 代码: ‘someString’.padStart(numberOfCharcters [,stringForPadding]); ‘5’.padStart(10) // ‘ 5’ ‘5’.padStart(10, ‘=‘) //‘====*=5’ ‘5’.padEnd(10) // ‘5 ‘ ‘5’.padEnd(10, ‘=‘) //‘5====*=’ 当我们想要对齐字符串的长度的时候，可以非常方便的使用这两个函数。 3.1 padStart 示例在下面的示例中，我们列出了不同长度的数字。我们希望前置“0”，以便所有项具有相同的 10 位数长度显示。我们可以使用 padStart(10, ‘0’) 轻松实现这一目标。 3.2 padEnd 示例当我们打印不同长度的多个项并希望正确对齐它们时，padEnd 真的很方便。下面的示例是 padEnd，padStart 和 Object.entries 组合在一起以产生漂亮输出的一个很好的现实示例。JavaScript 代码: const cars = { ‘🚙BMW’: ‘10’, ‘🚘Tesla’: ‘5’, ‘🚖Lamborghini’: ‘0’ } Object.entries(cars).map(([name, count]) =&gt; { //padEnd appends ‘ -‘ until the name becomes 20 characters //padStart prepends ‘0’ until the count becomes 3 characters. console.log(${name.padEnd(20, &#39; -&#39;)} Count: ${count.padStart(3, &#39;0&#39;)}) }); //Prints.. // 🚙BMW - - - - - - - Count: 010 // 🚘Tesla - - - - - - Count: 005 // 🚖Lamborghini - - - Count: 000 3.3 ⚠️padStart 和 padEnd 用于 Emojis 表情和其他双字节字符Emojis 和其他双字节字符使用多个字节的 unicode 表示。 所以 padStart 和 padEnd 可能无法按预期工作！⚠️例如：假设我们把字符串 heart 通过 emoji表情 ❤️ 使用 padStart 延长到十个字节，这个时候我们得到如下的输出：JavaScript 代码: //Notice that instead of 5 hearts, there are only 2 hearts and 1 heart that looks odd! ‘heart’.padStart(10, “❤️”); // prints.. ‘❤️❤️❤heart’ 这是因为 ❤️ 本身占据两个字节（\u2764\uFE0F），而 heart 本身有 5 个字节，所以我们只剩 5 个字节的位置可以填充，JS使用\u2764\uFE0F 来填充两颗心并产生 ❤️❤️ 。对于最后一个，它只使用 heart \u2764 的第一个字节产生 ❤所以我们最终得到：❤️❤️❤heartPS：你可以使用 此链接 查看 unicode 字符转换。更多示例和常见问题请参见：ES2017 新特性：字符串方法：padStart 和 padEnd 4.Object.getOwnPropertyDescriptors此方法返回给定对象的所有属性的所有详细信息（包括 getter get 和 setter set方法）。 添加它的主要动机是允许浅复制/克隆对象到另一个对象，该对象也复制 getter 和 setter 函数而不像 Object.assign。Object.assign 浅复制除原始源对象的 getter 和 setter 函数之外的所有信息。下面的示例显示了 Object.assign 和 Object.getOwnPropertyDescriptors 以及 Object.defineProperties 之间的区别，以将原始对象 Car 复制到新对象 ElectricCar 中。 你将看到，通过使用 Object.getOwnPropertyDescriptors，discount getter 和 setter 函数也会复制到目标对象中。之前…以后…JavaScript 代码: var Car = { name: ‘BMW’, price: 1000000, set discount(x) { this.d = x; }, get discount() { return this.d; }, }; // 打印 Car 对象 ‘discount’ 属性的详细信息 console.log(Object.getOwnPropertyDescriptor(Car, ‘discount’)); // 打印 .. // { // get: [Function: get], // set: [Function: set], // enumerable: true, // configurable: true // } //使用 Object.assign 将 Car 的属性复制到 ElectricCar const ElectricCar = Object.assign({}, Car); // 打印 ElectricCar 对象 ‘discount’ 属性的详细信息 console.log(Object.getOwnPropertyDescriptor(ElectricCar, ‘discount’)); // 打印 .. // { // value: undefined, // writable: true, // enumerable: true, // configurable: true // } //⚠️ 请注意，ElectricCar 对象中的 ‘discount’ 属性缺少 getter 和 setter ！👎👎 // 使用 Object.defineProperties 将 Car 的属性复制到 ElectricCar2 ， // 并使用 Object.getOwnPropertyDescriptors 提取 Car的属性 const ElectricCar2 = Object.defineProperties({}, Object.getOwnPropertyDescriptors(Car)); // 打印 ElectricCar2 对象的 ‘discount’ 属性的详细信息 console.log(Object.getOwnPropertyDescriptor(ElectricCar2, ‘discount’)); // 打印.. // { get: [Function: get], 👈🏼👈🏼👈🏼 // set: [Function: set], 👈🏼👈🏼👈🏼 // enumerable: true, // configurable: true // } // 请注意，ElectricCar2 对象中的 ‘discount’ 属性存在 getter 和 setter ！ 更多示例和常见问题请参见：ES2017 新特性：Object.getOwnPropertyDescriptors() 5.在函数参数中添加尾逗号这是一个小更新，允许我们在函数最后一个参数后面有逗号。 为什么？ 帮助使用像 git blame 这样的工具，防止添加一个参数却需要修改两行代码。以下示例显示了问题和解决方案。注意：你也可以在调用函数时使用尾逗号！更多示例和常见问题请参见：ES2017 新特性：函数参数列表和调用尾逗号 6. Async/Await到目前为止，这个特性应该是目前为止是最重要和最有用的功能。async 函数解决了回调地狱的问题，并使整个代码看起来简单。async 关键字告诉 JavaScript 编译器以不同方式处理函数。 只要到达该函数中的 await 关键字，编译器就会暂停。 它假定 await 之后的表达式返回一个 promise 并等待，直到 promise 被 resolved 或被 rejected ，然后才继续执行。在下面的示例中，getAmount 函数调用两个异步函数 getUser 和 getBankBalance。 我们可以用 Promise 做到这一点，但是使用 async await 更加优雅和简单。 6.1 Async 函数本身返回一个 Promise 。如果你正在等待 async 函数的结果，则需要使用 Promise 的 then 语法来捕获其结果。在以下示例中，我们希望使用 console.log 但不在 doubleAndAdd 中记录结果。 所以我们想等待并使用 then 语法将结果传递给console.log 。 6.2 并行调用 async/await在前面的例子中，我们调用 await 两次，但每次我们等待一秒钟（总共2秒）。相反，我们可以并行调用它，因为使用 Promise.all 并行调用 a 和 b 。 6.3 async/await 函数的错误处理使用 async/await 时，有多种方法可以处理错误。选项1-在函数中使用try catchJavaScript 代码: //Option 1 - Use try catch within the function async function doubleAndAdd(a, b) { try { a = await doubleAfter1Sec(a); b = await doubleAfter1Sec(b); } catch (e) { return NaN; //return something } return a + b; } //🚀Usage: doubleAndAdd(‘one’, 2).then(console.log); // NaN doubleAndAdd(1, 2).then(console.log); // 6 function doubleAfter1Sec(param) { return new Promise((resolve, reject) =&gt; { setTimeout(function() { let val = param * 2; isNaN(val) ? reject(NaN) : resolve(val); }, 1000); }); } 选项2-捕获(Catch) await 表达式由于每一个 await 表达式返回的都是 Promise，我们可以直接在每一行上面添加 catch。JavaScript 代码: //Option 2 - Catch errors on every await line //as each await expression is a Promise in itself async function doubleAndAdd(a, b) { a = await doubleAfter1Sec(a).catch(e =&gt; console.log(‘“a” is NaN’)); // 👈 b = await doubleAfter1Sec(b).catch(e =&gt; console.log(‘“b” is NaN’)); // 👈 if (!a || !b) { return NaN; } return a + b; } //🚀Usage: doubleAndAdd(‘one’, 2).then(console.log); // NaN and logs: “a” is NaN doubleAndAdd(1, 2).then(console.log); // 6 function doubleAfter1Sec(param) { return new Promise((resolve, reject) =&gt; { setTimeout(function() { let val = param * 2; isNaN(val) ? reject(NaN) : resolve(val); }, 1000); }); } 选项3-捕获(Catch) 整个async-await函数JavaScript 代码: //Option 3 - Dont do anything but handle outside the function //since async / await returns a promise, we can catch the whole function’s error async function doubleAndAdd(a, b) { a = await doubleAfter1Sec(a); b = await doubleAfter1Sec(b); return a + b; } //🚀Usage: doubleAndAdd(‘one’, 2) .then(console.log) .catch(console.log); // 👈👈🏼&lt;——- use “catch” function doubleAfter1Sec(param) { return new Promise((resolve, reject) =&gt; { setTimeout(function() { let val = param * 2; isNaN(val) ? reject(NaN) : resolve(val); }, 1000); }); } ECMAScript 2018 1. 共享内存和 atomics这是一个巨大的，非常先进的功能，并且是对 JS 引擎的核心增强。这个特性的主要目的是给 JavaScript 提供多线程功能，以便JS开发人员通过自己管理内存来编写高性能的并发程序，而不是让JS引擎管理内存。这是通过一种名为 SharedArrayBuffer 的新型全局对象完成的，该对象实质上将数据存储在共享内存空间中。因此，这些数据可以在主JS线程和 Web-worker 线程之间共享。之前，如果我们想在主 JS 线程和 web-worker 之间共享数据，我们必须复制数据并使用 postMessage 将其发送到另一个线程。现在，你只需使用 SharedArrayBuffer ，主线程和多个 web-worker 线程都可以立即访问数据。但是在线程之间共享内存会导致竞争条件(即多个进程同时操作一个内存)。为了帮助避免竞争条件，引入了 Atomics 全局对象。 Atomics 提供了各种方法来在线程使用其数据时锁定共享内存。它还提供了安全地更新共享内存中的此类数据的方法。建议通过某个库使用此功能，但是现在没有基于此功能构建的库。如果你有兴趣，我建议阅读： From Workers to Shared Memory?—?lucasfcosta A cartoon intro to SharedArrayBuffers?—?Lin Clark Shared memory and atomics?—?Dr. Axel Rauschmayer 2.移除了标记模板字面量的限制首先，我们需要澄清“标记模板字面量”是什么，以便我们更好地理解这个功能。在 ES2015+ 中，有一个称为标记模板文字的功能，允许开发人员自定义字符串的插值方式。 例如，在标准方式中，字符串被插入如下…在标记的字面量中，你可以编写一个函数来接收字符串字面量的硬编码部分，例如 [‘Hello’，’！’] 并且替换变量，例如 [‘Raja’] ，作为参数进入一个自定义函数（例如 greet ），并从该自定义函数返回任何你想要的内容。下面的示例显示我们的自定义 “Tag” 函数 greet，如“Good Morning” “Good afternoon”，等等，取决于当天到字符串字面量的时间，并返回自定义字符串。JavaScript 代码: //A “Tag” function returns a custom string literal. //In this example, greet calls timeGreet() to append Good //Morning/Afternoon/Evening depending on the time of the day. function greet(hardCodedPartsArray, …replacementPartsArray) { console.log(hardCodedPartsArray); //[ ‘Hello ‘, ‘!’ ] console.log(replacementPartsArray); //[ ‘Raja’ ] let str = ‘’; hardCodedPartsArray.forEach((string, i) =&gt; { if (i &lt; replacementPartsArray.length) { str += ${string} ${replacementPartsArray[i] || &#39;&#39;}; } else { str += ${string} ${timeGreet()}; //&lt;– append Good morning/afternoon/evening here } }); return str; } //��Usage: const firstName = ‘Raja’; const greetings = greetHello ${firstName}!; //����&lt;– Tagged literal console.log(greetings); //‘Hello Raja! Good Morning!’ �� function timeGreet() { const hr = new Date().getHours(); return hr &lt; 12 ? ‘Good Morning!’ : hr &lt; 18 ? ‘Good Afternoon!’ : ‘Good Evening!’; } 现在我们讨论了 “Tagged” 函数是什么，许多人想要在不同的场景下中使用此功能，例如在终端中使用命令和 HTTP 请求来编写 URI ，等等。⚠️标签字符串模版存在的问题ES2015 和 ES2016 规范不允许使用转义字符，如 \u（unicode），\x（十六进制），除非它们看起来完全像 \u00A9 或 \u{2F804} 或 \xA9 。因此，如果你有一个内部使用其他域规则（如终端规则）的 Tagged 函数，可能需要使用 \ubla123abla，而不能是 \u0049 或 \u{@F804} ，这样你会得到一个语法错误。在 ES2018 中，只要 Tagged 函数返回具有 “cooked” 属性（无效字符为 “undefined” ）的对象中的值，然后是 “raw” 属性（ 无论你想要什么）。JavaScript 代码: function myTagFunc(str) { return { “cooked”: “undefined”, “raw”: str.raw[0] } } var str = myTagFunc hi \ubla123abla; //call myTagFunc str // { cooked: “undefined”, raw: “hi \unicode” } 3. 正则表达式中的 ‘dotall’ 标记目前在RegEx中，点(“.”)可以表示任何的单一字符，但它不能与 \n ， \r，\f 等换行符匹配。 例如：JavaScript 代码: //Before /first.second/.test(‘first\nsecond’); //false 此增强功能使点运算符可以匹配任何单个字符。为了确保不会破坏任何内容，我们需要在创建RegEx时使用 \s 标记才能使其正常工作。JavaScript 代码: //ECMAScript 2018 /first.second/s.test(‘first\nsecond’); //true Notice: /s 👈🏼 以下是 提案 文档中的整体API： 4. 正则表达式捕获命名组这个增强功能带来了其他语言（如Python，Java等）的有用 RegExp 功能，称为“命名组”。这个功能允许允许正则表达式给每一个捕获组起一个名字 (?…)，然后，我们可以使用该名称轻松获取我们需要的任何群组。 4.1 基本的命名组例子在下面的例子中，我们使用 (?) (?) (?) 来为正则表达式中的不同部分分组，结果对象中会包含一个 groups 属性，其拥有 year month day 三个对象。 4.2 在正则表达式本身内使用命名组我们可以使用 \k 格式来反向引用正则表达式本身中的组。以下示例显示了它的工作原理。 4.3 在 String.prototype.replace 中使用命名组命名组也可以在 String 的 replace 方法中使用，比如用来交换一个字符串中各个部分的位置。例如，将firstName, lastName 更改为 lastName, firstName。 5. 对象的剩余属性Rest 运算符 …（三个点）允许我们提取 Object 的剩余属性。 5.1 我们可以使用展开运算符展开我们想要的属性： 5.2 或者我们借助展开运算符，移除我们不想要的属性 🔥🔥 6.展开对象的属性展开属性看起来就像 Rest 运算符，都是三个点 …，但不同之处在于你使用展开操作符来创建（重构）新对象。提示：展开（spread）运算符用于等号的右侧。剩余（Rest）运算符用在等号的左侧。 7.正则表达式后行断言(Lookbehind)这是 RegEx 的一个增强，它允许我们确保某些子字符串恰好出现在某些子字符串之前。你现在可以使用一个组 (?&lt;=…)（问号，小于，等于）来查看先行断言。此外，你可以使用 (?&lt;!…)（问号，小于，感叹号）来查看后行断言。基本上，只要-ve断言通过，这将匹配。肯定断言：假设我们要确保 # 符号存在于 winning 之前（即：#winning），并希望正则表达式只返回字符串 “winning” 。下面是我们的做法：否定断言：假设我们想要从具有 € 符号的行中提取数字，而不是 $ 。 8. RegExp Unicode属性转义提案链接：https://github.com/tc39/proposal-regexp-unicode-property-escapes编写 RegEx 以匹配各种 unicode 字符并不容易。像 \w，\W，\d 等只匹配英文字符和数字。但是其他语言中的数字如印地语，希腊语等等该怎么办呢？这就是 Unicode 属性转义的用武之地。事实证明，Unicode 为每个符号（字符）添加元数据属性，并使用它来分组或表征各种符号。例如，Unicode 数据库将所有印地语字符（??????）归为一个名为 Script 的属性，其值为 Devanagari，另一个属性为Script_Extensions，其值为 Devanagari 。所以我们可以搜索 Script=Devanagari 并获得所有印地语字符。梵文可以用于各种印度语言，如马拉地语，印地语，梵语等。从 ECMAScript 2018 开始，我们可以使用 \p 来转义字符以及 {Script = Devanagari} 以匹配所有这些印度字符。也就是说，我们可以在 RegEx 中使用：\p{Script=Devanagari} 来匹配所有梵文字符。JavaScript 代码: //The following matches multiple hindi character /^\p{Script=Devanagari}+$/u.test(‘हिन्दी’); //true //PS:there are 3 hindi characters h 同样，Unicode 数据库将 Script_Extensions（和 Script ）属性下的所有希腊字符组合为希腊语。 所以我们可以使用 Script_Extensions=Greek 或 Script=Greek 搜索所有希腊字符。也就是说，我们可以在RegEx中使用： \p{Script=Greek} 来匹配所有希腊字符。JavaScript 代码: //The following matches a single Greek character /\p{Script_Extensions=Greek}/u.test(‘π’); // true 此外，Unicode数据库在布尔属性 Emoji ，Emoji_Component， Emoji_Presentation ，Emoji_Modifier 和 Emoji_Modifier_Base 下存储各种类型的 Emojis，其属性值为 true。 因此，我们只需选择 Emoji 符号即可搜索所有表情符号。也就是说，我们可以使用：\p{Emoji}，\Emoji_Modifier 等来匹配各种 Emojis 。以下示例将使一切清楚。JavaScript 代码: //The following matches an Emoji character /\p{Emoji}/u.test(‘❤️’); //true //The following fails because yellow emojis don’t need/have Emoji_Modifier! /\p{Emoji}\p{Emoji_Modifier}/u.test(‘✌️’); //false //The following matches an emoji character\p{Emoji} followed by \p{Emoji_Modifier} /\p{Emoji}\p{Emoji_Modifier}/u.test(‘✌🏽’); //true //Explaination: //By default the victory emoji is yellow color. //If we use a brown, black or other variations of the same emoji, they are considered //as variations of the original Emoji and are represented using two unicode characters. //One for the original emoji, followed by another unicode character for the color. // //So in the below example, although we only see a single brown victory emoji, //it actually uses two unicode characters, one for the emoji and another // for the brown color. // //In Unicode database, these colors have Emoji_Modifier property. //So we need to use both \p{Emoji} and \p{Emoji_Modifier} to properly and //completely match the brown emoji. /\p{Emoji}\p{Emoji_Modifier}/u.test(‘✌🏽’); //true 最后，我们可以使用大写“P”（ \P ）转义字符,而不是小写“p”（ \p ）来否定匹配。参考: ECMAScript 2018 Proposal https://mathiasbynens.be/notes/es-unicode-property-escapes 9.Promise.prototype.finally()finally() 是一个添加到 Promise 实例的新方法。 主要考虑是允许在 resolve 或 reject 调用之后执行一些清理性质的代码。finally 被执行的时候不会被传入任何函数，并且无论什么时候都会被执行。我们来看看各种情况。 10.异步迭代这是一个非常有用的特性。 基本上它允许我们轻松创建异步代码循环！此特性添加了一个新的“for-await-of”循环，允许我们在循环中调用返回 promises（或带有一堆 promise 的 Arrays ）的异步函数。 循环会等待每个 Promise 在进行下一个循环之前 resolve 。 其他相关阅读 ES6 带来的重大特性 ES2016（ES7）的改进 ES2017（ES8）带来的重大新特性 ES2018（ES9）带来的重大新特性 探索 ES2016 与 ES2017 英文原文：https://school.geekwall.in/p/BkEFDtfoM/examples-of-everything-new-in-ecmascript-2016-2017-and-2018]]></content>
  </entry>
  <entry>
    <title><![CDATA[git操作---防遗忘]]></title>
    <url>%2F2019%2F07%2F16%2Fyuque%2Fgit%E6%93%8D%E4%BD%9C---%E9%98%B2%E9%81%97%E5%BF%98%2F</url>
    <content type="text"><![CDATA[git简介初代的命令都很简陋。你甚至都找不到一个叫 git 的命令。但它们却又都很本质，实现了 Git 功能最核心的逻辑。命令列表如下： 12345678910111213141516cat-file # 查看 object 内容，对应现在的 git cat-filecheck-files # ???checkout-cache # 从暂存区读取文件内容到工作区，对应现在的 git checkoutcommit-tree # 提交 commit，对应现在的 git commitdiff-tree # 比较两个 tree 对象的差异fsck-cache # ???init-db # 初始化 object databasels-tree # 查看 tree 对象内容，对应现在的 git ls-treemerge-base # 查找两个 commit 的最新共公 commitmerge-cache # 合并read-tree # 把 objce database 的一个 tree 对象加载到暂存区，对应现在的 git checkoutrev-tree # ???show-diff # 比较工作区和暂存区的差异，对应现在的 git diffshow-files # 查看暂存区文件列表，对应现在的 git statusupdate-cache # 将工作区文件写入暂存区，对应现在的 git addwrite-tree # 将暂存区的文件列表写入 object database，也就是生成 tree 对象 标问号的命令没有用到，也就没仔细看。大家有兴趣可以自行阅读源码。 1 为什么要有git？对于一个文件反复修改的时候，想查看自己的修改记录，就必须一个文件一个文件查找。有一个好办法就是自己记录每次修改的部分，但这样还是比较麻烦。用git就能解决这个问题，git不仅仅可以记录每次的修改说明，还能保存每一次的修改文件，并且还支持多用户协同作业（相互之间不影响）。 2 集中式和分布式（版本管理系统）集中式的版本控制系统前提是有一台中央服务器，每个工作者首先从服务器中下载自己需要的文件，然后修改好之后再上传，这样看上去挺好的，但是中央服务器一旦出问题了，那就是谁都别想干活，并且集中式版本控制系统需要联网，网速不好的时候很可能上传失败。分布式的版本控制系统是将每个工作者的电脑都可以看成一个中央处理器，每个人电脑里都有一个完整的版本库，不用联网也可以工作，所以就不存在电脑坏了就不能工作的情况，git就属于分布式的版本控制系统，接下来还会介绍很多关于git的强大。 3 安装gitLinux： 1sudo apt-get install git windows: 下载安装程序，注册一个GitHub账号 git git config –global user.name “*”git config –global user.email “*“ 4 创建版本库a. 创建一个新的文件夹，将其初始化为Git可以管理的仓库b. 将文件添加到仓库 12345git initgit add readme.txt #add也可以提交多个文件git commit -m &quot;readme file&quot; #-m后表示说明git add file1.txt file2.txt file3.txtgit commit -m &quot;add 3 file&quot; c. 对readme文件进行更改，使用git查看不同，提交修改文件 1234git status #查看此时状态git diff readme.txt #查看工作区和暂存区（add）之间的差异git add readme.txtgit commit -m &quot;first modify&quot; d. 版本操作 12345git log #查看历史记录，显示各个的版本号和HEAD指向git log --pretty=oneline #和上一条命令功能一致，只是显示更简洁git reset --hard HEAD~1 #回退上一个版本git reset --hard 1bf20 #根据commit_id来选择回退的版本git reflog #查看以往的版本命令 e. 电脑中的文件夹就是工作区，隐藏文件.git中是Git的版本库，版本库里最重要的就是暂存区，git add就是将文件添加到暂存区，git commit是将暂存区的文件提交到当前分支（master），如果修改了文件但是没有提交到暂存区那么是无法提交到master。可以通过命令查看工作区和版本库之间的区别 1git diff HEAD -- readme.txt 说明：在工作区修改文件，后提交到暂存区，最后提交到master上，那么此时的状态是没有任何修改的；如果是在工作区修改了文件，后提交到暂存区，在工作区对文件进行再一次修改但不提交，此时执行git commit只能提交第一次修改后的文件，查看状态时会显示文件已被修改f. 对于修改的文件想要回退有以下操作第一，在工作区修改，还没提交到暂存区 1git checkout -- readme.txt #将工作区文件回退到最近一次暂存区或者版本区的状态 第二，修改的文件已经提交到了暂存区 1git reset HEAD readme.txt #将暂存区的修改撤销，但是不改变工作区的修改 第三，已经提交到master 1git reset HEAD~1 #版本回退 g. 如果在工作区误删文件，可以找回 1git checkout -- test.txt #相当于将版本区的文件覆盖到工作区 如果是正常操作，同时将版本区内的文件删除 12git rm test.txtgit commit -m &quot;delete file&quot; 5 远程仓库 5.1 添加远程库查看用户主目录下的.ssh文件中是否具有id_rsa和id_rsa.pub这两个文件，如果没有，需要打开git bash创建 1ssh-keygen -t rsa -C &quot;xieyushunxysh@163.com&quot; id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人，登录GitHub添加ssh key（一个电脑对应一个key），这样之后就github就可以识别是你推送的信息了。在GitHub上创建一个文件夹用于存放推送的数据，将本地文件推送到GitHub 12git remote add origin git@github.com:dumpling-eric/git_learning.git #关联本地仓库git push -u origin master #将当前分支推送到远程，-u会将本地master和远程master关联起来 远程库的名字就是origin，这是一种默认的叫法，以后如果还需要修改，只需要本地提交即可 1git push origin master 5.2 克隆远程库对远程库进行克隆到本地 1git clone git@githun.com:dumpling-eric/testgit.git 补充：Windows下的一些指令 12type readme.txt #查看文件内容dir #相当于Linux中的ls 6 分支管理创建一个只属于自己的分支，随时提交随时更改。 6.1 创建合并分支在原本的主分支中，master指向最后提交的内容，HEAD指向master，每次提交就相当于master向前移动。创建一个分支就是新建一个dev，并且HEAD是指向dev，此时提交文件dev向前移动，而master原地不动。 12345git checkout -b dev #新建并切换到dev指针git branch #查看当前分支，当前分支前有一个“*”git add readme.txtgit commit -m &quot;branch test&quot; #提交后master上并不会显示git checkout master #切换回master 将dev与master合并，删除dev分支 123git merge dev #合并分支git branch -d dev #删除分支，如果没有合并则会报错不能删除git branch -D dev #强行删除分支 合并时使用的是fast forward模式，直接将master移动到dev处 6.2 解决冲突假设新建一个分支dev并在该分支上提交了文件，后返回到分支master上也提交了修改文件，此时两个分支合并就会发生问题，只能手动解除冲突。 12type readme.txt #查看文件会显示两个分支上的内容git log --graph --pretty=oneline --abbrev-commit #查看分支的合并情况 6.3 分支管理fast forward模式在删除分支后就会丢失分支信息，所以一般使用普通模式 1git merge --no-ff -m &quot;merge with no-ff&quot; dev no-ff表示禁用，-m后是说明commit的说明，所以普通模式就是master向前移动一位，同时dev也指向那个位置。普通模式是实际开发中常用的，在实际开发中master不轻易更改，先建一个dev分支，然后每个人新建属于自己的分支，合并内容时将自己的分支和dev分支合并，最后确定后再将dev和master合并。 6.4 bug分支假设一个场景，目前处于dev分支上，并且文件还不能提交，这个时候master分支上有一个bug必须马上处理，所以需要将dev分支存储起来，等处理好了bug之后再恢复，这就利用的Git里面的stash功能。 12345678git stash #将dev分支存储起来，接着查看status是干净的git checkout mastergit checkout -b bug-1git add readme.txtgit commit -m &quot;...&quot; #处理完buggit checkout mastergit merge --no-ff -m &quot;...&quot; bug-1git branch -d bug-1 #合并到master分支上 之后开始恢复dev分支 12345git checkout devgit stash list #查看储存的分支git stash pop #恢复最近储存的分支并删除git stash apply stash@&#123;0&#125; #恢复最近储存的分支git stash drop atash@&#123;0&#125; #删除最近储存的分支 6.5 多人协作对于远程仓库可以查看 1git remote -v 推送分支是也可以任意选择：master分支是主分支，时刻保持同步；dev分支是开发分支，所以小伙伴都在上面工作；bug分支是修复本地bug，没有必要推送到远程；feature分支根据具体情况推送。 1git push origin dev 假设一个小伙伴要在dev分支上工作，可是在默认情况下只能查看远程库的master分支，此时他就必须在本地创建和远程origin/dev分支相对应的分支 1git checkout -b dev origin/dev 当你和小伙伴都在dev分支上推送相同文件，那么会报错，解决方式是先将本地的dev和远程origin/dev分支链接起来，这样才可以将最新的提交从origin/dev上抓取下来，在本地完成合并上再推送 12git branch --set-upstream-to=origin/dev devgit pull #抓取最新的提交，方便在本地进行合并 总而言之，多人协作的工作模式如下：首先，推送自己的修改git push origin branch-name；推送失败时，表明有小伙伴已经推送了相同的文件，此时git pull抓取最新的提交文件；如果抓取不了，显示no trackiing information则说明本地分支和远程分支没有链接，使用git branch –set-upstream-to branch-name origin/branch-name;抓取下来在本地解决冲突，最后git push origin branch-name。 7 标签管理标签类似于快照，可以保存某个时刻的版本库 12345git checkout master #切换到需要打标签的分支上git tag v1.0git tag #查看标签git tag v0.9 e5e5533 #给特定的commit_id打标签git tag -a tagname -m &quot;...&quot; #给标签附上说明 本地标签可以删除 1git tag -d v0.9 标签可以推送到远程并且也可以删除 1234git push origin v1.0 #推送一个标签git push origin --tag #推送全部标签git tag -d v1.0 #删除本地标签git push origin :refs/tags/v1.0 #删除远程标签（先删除本地标签再删除远程标签） 8 码云和搭建git服务器待补充，目前用不到]]></content>
  </entry>
  <entry>
    <title><![CDATA[react学习指南]]></title>
    <url>%2F2019%2F07%2F16%2Fyuque%2Freact%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[ReactJS 或简称 React 是用于开发 Web 应用程序的前端或 GUI 的领先 JavaScript 库之一。在 Facebook 的支持下，React JS（也称为React）近年来实现了跨越式发展，并成为基于组件的 GUI 开发名副其实的库。 当我正在研究学习 React 的正确姿势时，我遇到了这个优秀的 React 开发者线路图，它概述了什么是必须要学的，什么是好的知识，以及你作为一名 React 开发人员需要学习的一些额外的知识。这个 React 开发者线路图是由 adam-golab 构建的，它概述了成为 React 开发人员可以采用的学习线路和库。 那么，如果您想知道接下来作为 React 开发人员应该学什么？ 然后这个路线图可以帮助你成为更好的 React 开发人员。但是，如果你想知道在哪里学习那些必修技能，那么别担心，我会分享了一些免费资源或者付费的在线课程，你可以学习这些技能。当然学习任何技能最好的开始都是其官网的技术文档。 2018 React 开发者线路图这里是我正在谈论的 React 开发者线路图：图谱来源: https://github.com/adam-golab/react-developer-roadmap/blob/master/roadmap-cn.png现在，让我们一步一步地浏览线路图，了解如何在2018年学习成为 React 开发人员的基本技能： 1) 基础无论你在 Web 开发中学习哪个框架或库，你都必须掌握基础知识，当我说基础知识时，我指的是 HTML ，CSS 和 JavaScript ，这三个是 Web 开发的三大支柱。 HTML它是 Web 开发人员的第一支柱和最重要的技能之一，因为它提供了网页的结构。 HTML5 基本标签 HTML5 的标签属性 HTML 语义化的重要性 HTML5 中的一些新特性 head 元素中的一些标签及属性 ，写出满足自己需求的 头部标签，可以很有效的增强页面的可用性。 CSS它是 Web 开发的第二个支柱，用于设置网页样式，使网页看起来很漂亮。如果你想学习 CSS ，你可以看看 ： css参考手册 ； css 相关的教程文章 ； CSS3 中的一些新特性； 当然还有现在炙手可热的 flexbox 布局 教程； 以及grid 布局 教程； 性能方面：重绘(repaints)与重排(reflows) JavaScript这是 Web 开发的第三个支柱，用于使您的网页具有交互性。 这也是 React 框架背后的原因，因此在尝试学习 React JS 之前，您应该了解 JavaScript 并掌握它。如果您想从头学习 JavaScript ，我建议： 熟悉基本的语法， 看看 JavaScript 完全手册（2018版） 。 掌握 DOM 以及 BOM 相关的基本知识，建议买本书看看，系统学习； 掌握 JavaScript 中的一些术语以及经典机制，比如 ： 闭包 作用域和 this 上下文 原始值和引用值 变量和函数提升(Hoisting) JavaScript 设计模式 JavaScript 中的原型 DOM事件模型（事件冒泡，捕获） promises，async/await 函数 函数式编程 不可变数据结构（immutable） 继承 Modules（模块） … 现在 JavaScript 基本都使用 ES6 规范写的，所以你必须了解 ES6 新特性； AJAX (XHR) 请求； 基本的 JavaScript 调试 以上是入门基础，很多人虽然能做项目完成工作，但是对于这些基础肯能了解不多，这样往往很容易触碰到天花板。个人认为作为一个前端开发工程师，这些基础概念，基本知识都应该很好的掌握。虽然学习概念性东西有点枯燥，但是当你真正了解这些的时候，你会觉得学什么都得心应手，融汇贯通。前端的大门也随之为你敞开。 2）一般开发技能无论您是前端开发人员还是后端开发人员，甚至是全栈软件工程师，都无关紧要。 您必须了解一些在编程世界中生存的一般开发技能，以下是其中一些的列表： 2.1）学习 GIT您必须在 2018 年完全了解 Git。尝试在 GitHub 上创建一些仓库，与其他人共享您的代码，并学习如何从您喜欢的 IDE 下载Github 上的代码。这里有一份 git – 简明指南 可以作为你最简入门。 2.2）了解 HTTP(S) 协议如果您想成为一名 Web 开发人员，那么了解 HTTP 并掌握它是绝对必要的。我不是要求您阅读规范，但您至少应该熟悉常见的 HTTP 请求方法，如 GET，POST，PUT，PATCH，DELETE，OPTIONS 以及 HTTP / HTTPS 的工作原理。 2.3）学习终端 terminal虽然前端开发人员学习 Linux 或终端并不是强制性的，但我强烈建议你熟悉终端，配置你的shell（bash，zsh，csh）等。如果你想学习终端和 bash 那么我建议你去看看 终端使用初级教程。 2.4）算法和数据结构好吧，这又是一般编程技巧之一，不管是成为 React 开发人员或其他程序员都需要这个。要学习数据结构和算法，您可以阅读一些书籍或加入一个好的课程，如 【专题课】前端面试防虐指南——算法篇。而且，如果您喜欢的课程不仅仅是课程，那么每个开发人员都应该阅读 10本算法书籍清单。 2.5）学习设计模式就像算法和数据结构一样，学习设计模式以成为 React Developer 并不是必须的，但是通过学习它将为自己创造一个美好的世界。首先来看看什么是设计模，式并了解 JavaScript 中的常用的几种设计模式。 然后你可以再买书看看，这项技能是编程经验总结，不会过时。以上 基础部分 和 一般开发技能 也可以作为任何其他前端框架或库（如 Angular 和 Vue.js）的学习基础。这些都是作为一名前端开发工程师的必备技能。 3）学习 React JS现在，我们切入正题。 你必须学习 React ，学习它成为一名 React 开发人员。 学习React的最佳地点是官方网站，这里有 React 最新的中文文档 ，但作为初学者，它对您来说可能是至关重要的。假如你看中文文档一下子摸不着头脑，我建议你先看看这两篇文章作为你最简入门： React入门教程 – 概述和实际演练（React官方推荐的入门教程） React 教程：2018年学习 React.js 的综合指南 ，通过实例讲解 React 最重要的部分和知识点。 入门后建议你看看 构建 React 应用的基础知识，以及官方文档中的一些细节知识： React 教程：如何使用 webpack 4 和 Babel 构建 React 应用(2018) React 文档 中的一些细节以及 React 官方入门教程：简介 React 再深入一点你必须学习： React 组件模式 React 教程：函数作为子组件(Function as Child Components),即 渲染回调(Render Callback) React 教程：深入理解 React 高阶组件（Higher Order Component，简称：HOC） 当然 React 周边一些非常有用的库，比如：Redux，MobX，React-Router等等，也是非常必要的，我们将在后面详细说明。 4）学习构建工具如果你想成为一名专业的 React 开发人员，那么你应该花一些时间熟悉一下你将作为 web 开发人员使用的工具，比如内置工具，单元测试工具，调试工具等。首先，本路线图中提到了一些构建工具：Package Managers npm yarn pnpm Task Runners npm scripts gulp Webpack, 中文文档 Rollup Parcel 顺便说一下，学习所有这些工具并不重要，对于初学者来说，只需学习 npm 和 Webpack 应该足够了。 一旦您对 Web 开发和 React 生态有了更多的了解，您就可以探索其他工具了。如果您想学习 Webpack ，那么 【专题课】从0到1深度理解webpack 是一个很好的开始。 5）样式（Styling）如果您的目标是成为像 React 开发人员这样的前端开发人员，那么了解一些 样式（Styling）相关的知识非常有必要。 线路图中提到了很多东西，比如： CSS 预处理 Sass/SCSS PostCSS Less Stylus CSS 框架 Bootstrap Materialize、MaterialUI、Material Design Lite Bulma Semantic UI CSS 架构 BEM CSS Modules Atomic OOCSS SMACSS SUITCSS CSS in JS Styled Components Radium Emotion JSS Aphrodite 看到蒙了是吧，这么多东西？不用担心，你不必学会每一样技能，根据你团队情况和个人喜好，每种学习一样就好，其他都类似，掌握应该不难。 6）State(状态) 管理这是 React 开发人员关注的另一个重要领域。注：很多人都说 React 其实很简单，只要懂得 2 件事情，就是 Prop(属性) 和 State(状态)，可见 State(状态) 管理 的重要性。 路线图提到了要掌握的以下概念和框架： Component State / Context API Redux 异步 actions (副作用) Redux Thunk Redux Better Promise Redux Saga Redux Observable 数据持久化 Redux Persist Redux Phoenix Redux Form MobX 如果这对你来说太多了的话，我建议你首先只关注 Redux ，因为 Redux 是目前应用最广泛的 React 状态（State）管理库，等有了一定的经验之后再学习其他内容。 7）类型检查由于 JavaScript 是一种弱类型语言，弱（或松散）类型的语言不强制执行对象的类型。这允许更多的灵活性，但是又将类型安全和类型检查拒之门外。所以编译器无法捕捉这些与类型相关的 bug 。随着应用程序的增长，您可以通过类型检查捕获大量错误，特别是如果您可以使用 JavaScript 扩展语言(如 Flow 或 TypeScript ) 来对整个应用程序进行类型检查的话。但即使你不使用它们，React 也有一些 内置的类型检查功能 ，学习它们可以帮助你尽早发现 bug 。TypeScript 如今增长势头很猛，并且 TypeScript 也可以编写 Angular 和 Vue 等应用，所以我认为 TypeScript 值得我们学习。 8）表单除了类型检查之外，还可以学习像 Redux Form 这样的表单助手，它提供了在 Redux 中管理表单状态的最佳方法。除了Redux Form之外，您还可以查看： Formik Formsy Final Form 9）路由组件是 React 功能强大的声明性编程模型的核心，而路由组件是任何应用程序的重要组成部分。React-Router 提供了一组导航组件，这些组件与您的应用程序以声明方式组合。无论您是希望为Web应用程序设置可收藏的 URL 还是在 React Native 中导航的可组合方式，React Router 都可以在 React 渲染的任何位置工作。除了 React-Router 之外，您还可以查看： Router5 Redux-First Router Reach Router 10）API 客户端当今，您很少会去构建一个独立的 GUI ，相反，您将有更多机会使用 REST 和 GraphQL 等API构建与其他应用程序通信的应用。值得庆幸的是，React 开发人员可以使用许多API客户端，以下是它们的列表： REST Fetch SuperAgent axios GraphQL Apollo Relay urql REST API 方面，国内目前很多人使用 Axios，理由也很简单，它确实简单好用，再加上 Vue2.0之后，尤大大推荐大家用 axios 。Axios 本质上也是对原生 XHR 的封装，和 jQuery Ajax 类似，只不过它是Promise 的实现版本，符合最新的 ES 规范，从它的官网上可以看到它有以下几条特性： 从 node.js 创建 http 请求 支持 Promise API 客户端支持防止CSRF 提供了一些并发请求的接口（重要，方便了很多的操作） Fetch API（ES6+）执行对 REST API 的 HTTP请求，提供了一个获取资源的接口（包括跨域）。任何使用过 XMLHttpRequest 的人都能轻松上手，但新的API提供了更强大和灵活的功能集。Fetch 提供了对 Request 和 Response （以及其他与网络请求有关的）对象的通用定义。使之今后可以被使用到更多地应用场景中：无论是service workers、Cache API、又或者是其他处理请求和响应的方式，甚至是任何一种需要你自己在程序中生成响应的方式。它还提供了一种定义，将 CORS 和 HTTP 原生的头信息结合起来，取代了原来那种分离的定义。实际工作中，很多前端开发工程师觉得 Fetch API 使用起来不是很方便，而且代码丑陋，其实只是我们平常没用太多跟底层的东西。Fetch API 的优势主要优势也在于它更加底层： 更加底层，提供的API丰富（request, response） 脱离了XHR，是ES规范里新的实现方式 GraphQL 方面推荐 Apollo 。Apollo 客户端是我的最爱，它提供了一种使用GraphQL构建客户端应用程序的简便方法。 该客户端旨在帮助您快速构建一个使用GraphQL获取数据并可与任何JavaScript前端一起使用的 UI 。 11）实用程序库（Utility Libraries）这些库使您的工作更轻松。 React 开发人员可以使用许多实用程序库，如下所示： Lodash 、Underscore.js Moment classnames Numeral RxJS Ramda 我不建议你学习所有这些，线路图也是如此建议的。如果你仔细观察 Lodash ，Moment 和 Classnames 是用黄色的，说明你应该从这几个开始学习。 12）测试注意，这是 React 开发人员的一项重要技能，经常被忽视，但如果你想比其他开发人员更牛逼，那么你应该学习一些测试库。 此外，您还拥有用于单元测试，集成测试和端到端测试的库。以下是路线图中提到的库列表： 单元测试 Jest Enzyme Sinon Mocha Chai AVA Tape 端到端测试 Selenium, Webdriver Cypress Puppeteer Cucumber.js 集成测试 Karma 您可以更具你们团队或你个人喜好学习所需的库，但是如果你刚开始学习这一块内容的话，我建议你使用 Jest 。 当然 Mocha 也受到很多开发者的青睐，但是学习曲线相对较陡，但这也说明了它可以提供更好的灵活性和可扩展性。 13）国际化这是开发前端的另一个重要主题，帮助你的应用可以在全球使用。 您可能需要支持 日本，中国，西班牙和其他欧洲国家的本地 GUI 版本和语言包。线路图建议您学习以下技术： React Intl React i18next 这两个库都提供了 React 组件和 API 来格式化日期，数字和字符串，包括复数和处理翻译。 14）服务器端渲染您应该知道服务器端渲染和客户端渲染之间的区别，在讨论支持使用 React 的服务器端渲染的库之前，请先弄清楚他们直接的区别。好吧，在客户端渲染中，您的浏览器会下载一个最小的HTML页面。 然后它渲染 JavaScript 并将内容填充到其中。在服务器端呈现的情况下，React组件在服务器上呈现，输出的HTML内容将传递到客户端或浏览器。线路图建议遵循服务器端渲染： Next.js After.js Rogue 但是，我建议只学习 Next.js 应该足够了。 15）静态站点生成器Gatsby.js 是一个现代静态站点生成器。 您可以使用 Gatsby 创建个性化的网站。 它们将您的数据与 JavaScript 相结合，并创建格式良好的HTML内容。React 官网就是用 Gatsby.js 生成的。例如：React 中文文档 16）后端框架集成React on Rails 将 Rails 与 Facebook 的 React 前端框架（服务器渲染）集成在一起。 它提供 Server 渲染，通常用于SEO爬虫索引和UX性能，而不是 rails/webpacker 提供的。 17）移动端应用这是学习 React 真正有好处的另一个领域，因为 React Native 正迅速成为用 JavaScript 开发原生移动应用程序外观和体验的标准方法。线路图建议您学习以下库： React Native Cordova/Phonegap 但是，我认为，只要学习 React Native 就足够了。 18）桌面端应用还有一些基于 React 的框架来构建像 React Native Windows 这样的桌面 GUI，它允许您使用 React 构建本机 UWP 和 WPF 应用程序。线路图建议使用以下库： Proton Native Electron React Native Windows 我个人推荐使用 Electron ，还是比较简单方便的，其他我也没用过，还要进一步探索。 如果你已经掌握了 React ，你可以看一下它们。 19）虚拟现实如果您有兴趣构建基于虚拟现实的应用程序，那么您还有一些像 React 360 这样的框架，它允许您使用React 创建 360° 全景体验和VR体验。 如果您对该领域感兴趣，可以进一步探索 React 360 。 小结这就是2018年的 React 学习线路图。 它确实非常全面，很有可能你在2018年剩下的时间里都不会学到所有这些，但不要担心，所有的技术在2019年仍然有效，你可以放心地将它用作2018年的React 学习线路图。]]></content>
  </entry>
  <entry>
    <title><![CDATA[js异步发展的流程]]></title>
    <url>%2F2019%2F07%2F15%2Fyuque%2Fjs%E5%BC%82%E6%AD%A5%E5%8F%91%E5%B1%95%E7%9A%84%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021Function.prototype.before=function(callback)&#123; let self=this; return function()&#123; callback(); self.apply(self,arguments) &#125;&#125;function fn(val)&#123; console.log('有一定的功能了',val);&#125;let newFn=fn.before(()=&gt;&#123; console.log('在函数执行之前执行这段...')&#125;)newFn()// 在函数执行之前执行这段...// 有一定的功能了 undefinednewFn(1)// 在函数执行之前执行这段...// 有一定的功能了 1]]></content>
  </entry>
  <entry>
    <title><![CDATA[原生App项目集成flutter混合开发详细指南]]></title>
    <url>%2F2019%2F07%2F12%2Fyuque%2F%E5%8E%9F%E7%94%9FApp%E9%A1%B9%E7%9B%AE%E9%9B%86%E6%88%90flutter%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[方案选择目前主流的混合开发方案有两种集成方式：源码集成： 也就是谷歌官方提供的方案[github.com/flutter/flu…]产物集成： Flutter项目单独开发，开发完成后发布成aar包或者iOS的framework形式，原生项目依赖flutter输出的制品即可。具体可以参考闲鱼的文章两种方式各有优劣，其实产物集成更好一些，不过即使是进行产物集成，也需要弄懂源码集成的方式，因为当有很多和原生交互的功能进行开发的时候，源码集成的方式可以直接调试会方便很多。根据目前我们的情况：1.参与人员都要进行flutter开发、2.持续发布和构建我可以修改控制我们现在这个项目选择了源码集成的方式。 为原生项目集成flutter整个的集成方案是参考谷歌方法：[github.com/flutter/flu…]，但是有一些不一样，我是创建了一个flutter项目后，在原生的项目中使用git submodule的形式进行管理的。 1.创建flutter module project我们假定已经有了原生的项目Native-iOS和Native-Android；现在我们需要创建我们的flutter项目。 把我们的flutter的channel切换到master(master分支下是flutter的preview版本)flutter channel master 创建flutter模块的项目flutter create -t module {moduleName}我这里创建一个flutter的模块项目叫flutter_module 1234567891011➜ flutter create -t module flutter_moduleCreating project flutter_module... flutter_module/test/widget_test.dart (created) ... ... flutter_module/.idea/workspace.xml (created)Running &quot;flutter packages get&quot; in flutter_module... 7.2sWrote 12 files.All done!Your module code is in flutter_module/lib/main.dart.复制代码 创建成功后我们可以看一下目录结构 12345678910111213141516171819➜ flutter_module git:(master) ✗ tree -L 2 -a.├── .android│ ├── Flutter│ ├── app│ ├── ...├── .gitignore├── .ios│ ├── Config│ ├── Flutter│ ├── ...│ └── Runner.xcworkspace├── lib│ └── main.dart├── pubspec.lock├── pubspec.yaml└── test └── widget_test.dart复制代码 在flutter的模块项目中包含有一个隐藏的.android和.ios目录这个目录下是可运行的Android和iOS项目，我们的flutter代码还是在lib下编写，注意在.android和.ios目录下都有一个Flutter目录，这个是我们flutter的库项目了。也就是Android用来生成aar，iOS用来生产framework的库。如果我们用flutter create xxx 生成的纯flutter项目是没有这个Flutter目录的。 把该项目使用git管理起来，稍后我们要在native项目中以子模块的形式添加进去。 12345➜ cd flutter_module➜ git initInitialized empty Git repository in /Users/zhiqiangdeng/Documents/ProjectSource/FlutterProject/flutter_module/.git/➜ flutter_module git:(master) ✗复制代码 初始化git仓库后我们先编辑一下项目下的.gitignore文件，当前这个文件是把项目下的–.ios和.android忽略掉的。这个两个项目我们需要跟踪一下，大家可以去github上找一下iOS和Android的gitignore模版文件，然后添加到这个两个目录中，然后把顶层目录的文件作出如下修改，删除.android和.ios添加.ios/Flutter/Generated.xcconfig.gitignore文件: 1234-.android/-.ios/+.ios/Flutter/Generated.xcconfig复制代码 上面的内容做一些更正，不需要编辑.gitignore文件使用自动生成的即可。.android和.ios目录在每次执行flutter packages get命令会自动生成（团队其他成员拉取代码后没有.android和.ios执行一下flutter packages get即可） 提交你的flutter模块项目到你的git服务器(我提交到github上了[github.com/zakiso/flut…]大家可以参考)123git remote add origin &#123;你的flutter module的仓库地址&#125;git push origin master复制代码 2.给iOS项目集成flutter1.进入我们原生的iOS项目根目录中，为它添加一个git submodule，把我们的flutter项目拉取下来. 123git submodule add &#123;你的flutter module的仓库地址&#125;git submodule update复制代码 2.在项目的Podfile文件中添加下面的代码，在每次执行pod install会运行podhelper.rb 12345678910platform :ios, &apos;8.0&apos;use_frameworks!target &apos;MyApp&apos; do pod &apos;AFNetworking&apos;, &apos;~&gt; 2.6&apos; xxxxend#添加如下两行代码，路径修改为我们的fluter module的路径flutter_application_path = &apos;./flutter-module-demo&apos; eval(File.read(File.join(flutter_application_path, &apos;.ios&apos;, &apos;Flutter&apos;, &apos;podhelper.rb&apos;)), binding)复制代码 3.打开Xcode关闭bitcode配置Build Settings-&gt;Build Options-&gt;Enable Bitcode4.添加编译脚本，打开Xcode在 Build Phases中添加New Run Script Phase在里面填入如下脚本 123&quot;$FLUTTER_ROOT/packages/flutter_tools/bin/xcode_backend.sh&quot; build&quot;$FLUTTER_ROOT/packages/flutter_tools/bin/xcode_backend.sh&quot; embed复制代码 5.项目的配置完成现在需要生成一些配置文件a. 进入原生项目的flutter模块目录中执行flutter packages get命令b. 回到原生项目根目录执行pod install 1234567891011121314151617➜ cd flutter-module-demo➜ flutter-module-demo git:(master) flutter packages getRunning &quot;flutter packages get&quot; in flutter-module-demo... 0.4s➜ flutter-module-demo git:(master) cd ..➜ FlutterNativeiOS git:(master) ✗ pod installAnalyzing dependenciesFetching podspec for `Flutter` from `./flutter-module-demo/.ios/Flutter/engine`Fetching podspec for `FlutterPluginRegistrant` from `./flutter-module-demo/.ios/Flutter/FlutterPluginRegistrant`Downloading dependenciesUsing AFNetworking (2.6.3)Installing Flutter (1.0.0)Installing FlutterPluginRegistrant (0.0.1)Generating Pods projectIntegrating client projectSending statsPod installation complete! There are 3 dependencies from the Podfile and 3 total pods installed.复制代码 到此为止我们的原生项目就已经集成好了flutter项目了。5.在原生项目中使用flutter，下面以swift项目为例修改AppDelegate.swift:注意AppDelegate是集成自FlutterAppDelegate 123456789101112131415import UIKitimport Flutterimport FlutterPluginRegistrant // Only if you have Flutter Plugins.@UIApplicationMainclass AppDelegate: FlutterAppDelegate &#123; var flutterEngine : FlutterEngine?; // Only if you have Flutter plugins. override func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool &#123; self.flutterEngine = FlutterEngine(name: &quot;io.flutter&quot;, project: nil); self.flutterEngine?.run(withEntrypoint: nil); GeneratedPluginRegistrant.register(with: self.flutterEngine); return super.application(application, didFinishLaunchingWithOptions: launchOptions); &#125;&#125;复制代码 修改Controller代码 123456789101112131415import UIKitimport Flutterclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() let button = UIButton(type:UIButtonType.custom) ... self.view.addSubview(button) &#125; @objc func handleButtonAction() &#123; let flutterEngine = (UIApplication.shared.delegate as? AppDelegate)?.flutterEngine; let flutterViewController = FlutterViewController(engine: flutterEngine, nibName: nil, bundle: nil)!; self.present(flutterViewController, animated: true, completion: nil) &#125;复制代码 RUN….3.iOS项目集成过程梳理整个的集成过程其实总得来说是如下三个步骤：1.将flutter项目放入原生项目的文件夹下2.在podfile中添加podhelper.rb配置3.在Xcode的build phases添加&quot;$FLUTTER_ROOT/packages/flutter_tools/bin/xcode_backend.sh&quot;iOS编译脚本。其中podhelper.rb文件位于我们flutter模块项目的.ios/Flutter/podhelper.rb下，大家查看它的源码可以发现，它有下面几个作用：1.把Flutter（flutterEngine）和FlutterPluginRegistrant两个库用pod给原生项目导入进入2.如果flutter项目有用到flutter plugin插件，把插件用pod导入3.导入Generated.xcconfig的相关配置信息，在podhelper.rb同级别的目录下还有一个Generated.xcconfig文件，这个文件在使用flutter create xx、flutter run xxx、flutter packages get命令的时候如果该文件不存在则会生成这个文件。这个文件内容如下：123456789// This is a generated file; do not edit or check into version control.FLUTTER_ROOT=/Users/zhiqiangdeng/.flutter_wrapper/1.2.2-pre.43FLUTTER_APPLICATION_PATH=/Users/zhiqiangdeng/Documents/ProjectSource/XcodeProject/lianhua-order-iOS/order-check-module-flutterFLUTTER_TARGET=lib/main.dartFLUTTER_BUILD_DIR=buildSYMROOT=$&#123;SOURCE_ROOT&#125;/../build/iosFLUTTER_BUILD_NAME=1.0.0FLUTTER_BUILD_NUMBER=1复制代码 他记录了当前flutter sdk的目录位置，以及版本号，还有项目模块的目录位置。这个文件的内容在执行pod install的时候会被写入到xcode build setting中，在执行完pod install之后，可以在原生项目根目录使用xcodebuild -showBuildSettings|grep flutter 查看相关的信息。最后一步就是运行程序，运行程序的时候在Build phase添加了xcode_backend.sh该脚本会使用到上面pod install给xcode build setting设置的那些环境变量，然后找到项目目录生成AppFramework。 4.给原生Android项目集成FlutterAndroid的文章很多，这里不再详细描述了1.在原生Android项目中添加子模块，将上面创建的flutter module项目拉取到原生安卓项目中 123git submodule add &#123;你的flutter module的仓库地址&#125;git submodule update复制代码 2.在根目录的settings.gradle中添加如下配置12345setBinding(new Binding([gradle: this])) evaluate(new File( &apos;&#123;xxxxx你的flutter module目录&#125;/.android/include_flutter.groovy&apos; )) 复制代码 3.在原生项目的app目录下的build.gradle文件中添加Flutter库的依赖1234dependencies &#123; implementation project(&apos;:flutter&apos;)&#125;复制代码 4.在原生代码中集成flutter跳转到flutter页面我使用了一个新的Activity进行跳转。具体可以参看源码 12345678910Button open = findViewById(R.id.openBtn);open.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(); intent.setClass(MainActivity.this, MyFlutterActivity.class); startActivity(intent); &#125;&#125;);复制代码 1234567891011121314151617181920212223public class MyFlutterActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_flutter); final FlutterView flutterView = Flutter.createView( this, getLifecycle(), &quot;route1&quot; ); final FrameLayout layout = findViewById(R.id.flutter_container); layout.addView(flutterView); final FlutterView.FirstFrameListener[] listeners = new FlutterView.FirstFrameListener[1]; listeners[0] = new FlutterView.FirstFrameListener() &#123; @Override public void onFirstFrame() &#123; layout.setVisibility(View.VISIBLE); &#125; &#125;; flutterView.addFirstFrameListener(listeners[0]); &#125;&#125;复制代码 5.团队中其他同事协同开发 拉取项目源码git clone xxxxx{项目地址} 初始化项目中的子模块git submodule init &amp;&amp; git submodule update 执行flutter packages get (有时候可能出现无法运行可以进入.ios和.android中分别执行pod install 和 gradle assembleDebug,或者flutter build ios,flutter build apk等命令构建一次) Run… Android从原生跳到Flutter模块的黑屏问题，在网上看到很多说设置透明主题的但是没有用，后来看到一种先隐藏显示，等待渲染好第一帧后才显示flutter页面的方法。这里要注意一点要在布局中先把flutter的Container布局设置为InVisible状态，不要使用Gone，用gone的话是不显示也不渲染，用InVisible不显示但是会渲染界面占位置，等待渲染完成后再设置为Visible即可。 6.flutter的版本管理在我们的开发过程中遇到了一个问题，就是各个开发者使用的flutter sdk版本不一致，导致一些库无法运行，在网上也遇到有相同问题的人，提出了模仿gradle wrapper来做一个flutter_wrapper的思路。于是我根据自己的需要写了一个flutter_wrapper的小工具。它的主要作用是统一开发人员的本地flutter环境。使用说明 在你的项目根目录中执行命令下载脚本curl -O https://raw.githubusercontent.com/zakiso/flutterw/master/flutterw &amp;&amp; chmod 755 flutterw 下载好脚本后在根目录中使用./flutterw init该命令会收集你当前系统中的flutter版本，并将相关信息写入flutter_wrapper.properties文件中，团队中所有成员都会以该版本号做为该项目的标准版本 将flutterw文件和flutter_wrapper.properties文件添加到git中提交到仓库里 其他成员拉取代码后在项目中使用flutter命令的地方使用./flutterw代替，如果使用ide请选择home目录下对应版本的sdk包 flutterw做了什么？ 使用flutterw的时候会获取当前目录下的flutter_wrapper.properties文件中的版本号 去用户的${HOME}/flutter_wrapper/{版本号}/ 目录下查找是否有该版本sdk 如果没有该版本sdk会下载下来，然后使用该目录下的sdk执行命令 注意事项如果flutter版本是preview的版本是直接使用master的最新代码来管理的。大家可以查看源码很简单，根据自己的需要定制。项目demo我已经传到github中：有遇到问题的可以参考项目源码 原生Android集成Flutter项目： github.com/zakiso/flut… 原生iOS集成Flutter项目： github.com/zakiso/flut… Flutter模块项目： github.com/zakiso/flut… Flutter_Wrapper: github.com/zakiso/flut…最后： 我们整个项目都是使用git进行管理的，虽然每个开发者都需要安装flutter环境，但是对于小团队来说成本并不高，加上flutter_wrapper也保证了版本的一致性。iOS开发者可以在原来的iOS项目中开发flutter的项目，Android开发者可以在原android项目中开发flutter，flutter开发者也可以自己单独开发flutter项目，这种方式其实对于开发者来说也是很方便的。Everything 用flutter开发的一款App，把记账本日记本，行程，待办等等都装进一个App里everythings.app/转自：https://juejin.im/post/5c6eba82518825626b76f0eb]]></content>
  </entry>
  <entry>
    <title><![CDATA[常用的判断技巧]]></title>
    <url>%2F2019%2F07%2F11%2Fyuque%2F%E5%B8%B8%E7%94%A8%E7%9A%84%E5%88%A4%E6%96%AD%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[1、 用于整数的奇偶性判断 一个整数a, a &amp; 1 这个表达式可以用来判断a的奇偶性。二进制的末位为0表示偶数，最末位为1表示奇数。使用a%2来判断奇偶性和a &amp; 1是一样的作用，但是a &amp; 1要快好多。 123var a=3,b=6;a&amp;1 //1b&amp;1 //0 2、 判断n是否是2的正整数冪 (!(n&amp;(n-1)) )&amp;&amp; n 举个例子：如果n = 16 = 10000， n-1 = 1111那么：10000&amp; 1111———-** 0再举一个例子：如果n = 256 = 100000000， n-1 = 11111111那么：100000000&amp;11111111————–0好！看完上面的两个小例子，相信大家都有一个感性的认识。从理论上讲，如果一个数a他是2的正整数幂，那么a 的二进制形式必定为1000…..（后面有0个或者多个0），那么结论就很显然了。 1234567var a=n=&gt;(!(n&amp;(n-1)) )&amp;&amp; na(16) //16a(13) //falsea(2) //2a(4) //4a(5) //falsea(1) //1 3、 统计n中1的个数 朴素的统计办法是：先判断n的奇偶性，为奇数时计数器增加1，然后将n右移一位，重复上面步骤，直到移位完毕。朴素的统计办法是比较简单的，那么我们来看看比较高级的办法。 举例说明，考虑2位二进制数 n=11，里边有2个1，先提取里边的偶数位10，奇数位01，把偶数位右移1位，然后与奇数位相加，因为每对奇偶位相加的和不会超过“两位”，所以结果中每两位保存着数n中1的个数；相应的如果n是四位整数 n=0111，先以“一位”为单位做奇偶位提取，然后偶数位移位（右移1位），相加；再以“两位”为单位做奇偶提取，偶数位移位（这时就需要移2位），相加，因为此时没对奇偶位的和不会超过“四位”，所以结果中保存着n中1的个数，依次类推可以得出更多位n的算法。整个思想类似分治法。在这里就顺便说一下常用的二进制数：0xAAAAAAAA=101010101010101010101010101010100x55555555 = 1010101010101010101010101010101（奇数位为1，以1位为单位提取奇偶位） 0xCCCCCCCC = 110011001100110011001100110011000x33333333 = 110011001100110011001100110011（以“2位”为单位提取奇偶位） 0xF0F0F0F0 = 111100001111000011110000111100000x0F0F0F0F = 1111000011110000111100001111（以“8位”为单位提取奇偶位） 0xFFFF0000 =111111111111111100000000000000000x0000FFFF = 1111111111111111（以“16位”为单位提取奇偶位） 例如：32位无符号数的1的个数可以这样数： 举个例子吧，比如说我的生日是农历2月11，就用211吧，转成二进制：n = 11010011计算n = ((n &amp; 0xAAAAAAAA) &gt;&gt; 1) + (n &amp; 0x55555555);得到 n = 10010010计算n = ((n &amp; 0xCCCCCCCC) &gt;&gt; 2) + (n &amp; 0x33333333);得到 n = 00110010计算n = ((n &amp; 0xF0F0F0F0) &gt;&gt; 4) + (n &amp; 0x0F0F0F0F);得到 n = 00000101 —————–à无法再分了，那么5就是答案了。 12345678910111213141516171819var count_one=n=&gt;&#123; //0xAAAAAAAA，0x55555555分别是以“1位”为单位提取奇偶位 n = ((n &amp; 0xAAAAAAAA) &gt;&gt; 1) + (n &amp; 0x55555555); //0xCCCCCCCC，0x33333333分别是以“2位”为单位提取奇偶位 n = ((n &amp; 0xCCCCCCCC) &gt;&gt; 2) + (n &amp; 0x33333333); //0xF0F0F0F0，0x0F0F0F0F分别是以“4位”为单位提取奇偶位 n = ((n &amp; 0xF0F0F0F0) &gt;&gt; 4) + (n &amp; 0x0F0F0F0F); //0xFF00FF00，0x00FF00FF分别是以“8位”为单位提取奇偶位 n = ((n &amp; 0xFF00FF00) &gt;&gt; 8) + (n &amp; 0x00FF00FF); //0xFFFF0000，0x0000FFFF分别是以“16位”为单位提取奇偶位 n = ((n &amp; 0xFFFF0000) &gt;&gt; 16) + (n &amp; 0x0000FFFF); return n;&#125;count_one(211) //5 4、对于正整数的模运算（注意，负数不能这么算） 先说下比较简单的：乘除法是很消耗时间的，只要对数左移一位就是乘以2，右移一位就是除以2，传说用位运算效率提高了60%。乘2^k众所周知： n&lt;&lt;k。所以你以后还会傻傻地去敲25664的结果10264吗？直接2566&lt;&lt;4就搞定了，又快又准确。 除2^k众所周知： n&gt;&gt;k。 那么 mod 2^k 呢？（对2的倍数取模）*n&amp;((1&lt;&lt;k)-1)用通俗的言语来描述就是,对2的倍数取模，只要将数与2的倍数-1做按位与运算即可。好！方便理解就举个例子吧。思考：如果结果是要求模2^k时，我们真的需要每次都取模吗？ 在此很容易让人想到快速幂取模法。快速幂取模算法**经常做题目的时候会遇到要计算 a^b mod c 的情况，这时候，一个不小心就TLE了。那么如何解决这个问题呢？位运算来帮你吧。 首先介绍一下秦九韶算法：(数值分析讲得很清楚) 把一个n次多项式f(x) = a[n]x^n+a[n-1]x^(n-1)+……+a[1]x+a[0]改写成如下形式： f(x) = a[n]x^n+a[n-1]x^(n-1))+……+a[1]x+a[0] = (a[n]x^(n-1)+a[n-1]x^(n-2)+……+a[1])x+a[0] = ((a[n]x^(n-2)+a[n-1]x^(n-3)+……+a[2])x+a[1])x+a[0] =. ….. = (……((a[n]x+a[n-1])x+a[n-2])x+……+a[1])x+a[0]. 求多项式的值时，首先计算最内层括号内一次多项式的值，即 v[1]=a[n]x+a[n-1] 然后由内向外逐层计算一次多项式的值，即 v[2]=v[1]x+a[n-2] v[3]=v[2]x+a[n-3] …… v[n]=v[n-1]x+a[0]这样，求n次多项式f(x)的值就转化为求n个一次多项式的值。 好！有了前面的基础知识，我们开始解决问题吧 由(a ×b) mod c=( (a mod c) × b) mod c.我们可以将 b先表示成就：b = a[t] × 2^t + a[t-1]× 2^(t-1) + …… + a[0] × 2^0. (a[i]=[0,1]).这样我们由 a^b mod c = (a^(a[t] × 2^t + a[t-1]× 2^（t-1） + …a[0] × 2^0) mod c.然而我们求 a^( 2^(i+1) ) mod c=( (a^(2^i)) mod c)^2 mod c .求得。具体实现如下：使用秦九韶算法思想进行快速幂模算法，简洁漂亮 // 快速计算 (a ^ p) % m 的值 // 快速计算 (a ^ p) % m 的值int64 FastM(int64 a, int64 p, __int64 m){if (p == 0) return 1;int64 r = a % m;__int64 k = 1;while (p &gt; 1){if ((p &amp; 1)!=0){k = (k * r) % m;}r = (r * r) % m;p &gt;&gt;= 1;}return (r * k) % m;} http://acm.pku.edu.cn/JudgeOnline/problem?id=3070 5、计算掩码比如一个截取低6位的掩码：0×3F用位运算这么表示：(1&lt;&lt; 6) - 1这样也非常好读取掩码，因为掩码的位数直接体现在表达式里。按位或运算很简单，只要a和b中相应位出现1，那么a|b的结果相应位也为1。就不多说了。6、子集 枚举出一个集合的子集。设原集合为mask，则下面的代码就可以列出它的所有子集：]]></content>
  </entry>
  <entry>
    <title><![CDATA[颜色工具]]></title>
    <url>%2F2019%2F07%2F11%2Fyuque%2F%E9%A2%9C%E8%89%B2%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[ColorHexa RGB颜色值与十六进制颜色码转换工具https://www.sioe.cn/yingyong/yanse-rgb-16/ Flutter Color一个颜色由四个通道组成：红、绿、蓝和alpha通道 12345678910@override Widget build(BuildContext context) &#123; return new RotationTransition( turns: _animation, child: new Container( width: 200.0, height: 200.0, color: const Color(0xFFFF0000), //第一个0xff表示透明度100%,后面的6位代表颜色； )); &#125; 0xFFFF0000以0x开始的数据表示16进制，计算机中每位的权为16，即（16进制)10 = (10进制)1×16备注：这里的0是数字0，不是字母O！ 编程中，我们常用的还是10进制0x16进制]]></content>
  </entry>
  <entry>
    <title><![CDATA[Flutter for Web介绍]]></title>
    <url>%2F2019%2F07%2F09%2Fyuque%2FFlutter%20for%20Web%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[如何评价 Flutter for Web？针对 Web 的 Flutter 框架的技术预览版：https://flutter.dev/webGithub 仓库：https://https://github.com/flutter/flutter_webter_web示例程序：https://https://flutter.github.io/samples/ Flutter for Web架构图https://dart.dev/tutorials/web/get-started 1.安装 Dart12$ pub global activate webdev$ pub global activate stagehand 2.安装 webdev 和 stagehand:Stagehand- A Dart project generator 12$ pub global activate webdev$ pub global activate stagehand 3.创建一个wep app1234mkdir quickstartcd quickstartstagehand web-simplepub get 获取包 4.运行app12webdev servewebdev serve --auto restart 加入了热重新加载 如果觉得webdev serve –auto restart 太麻烦，可以尝试 flutter pub global run webdev serve –auto restart 5.打包发布1webdev build flutter项目和flutter web项目的不同 s/]]></content>
  </entry>
  <entry>
    <title><![CDATA[函数组件与类有什么区别？]]></title>
    <url>%2F2019%2F07%2F09%2Fyuque%2F%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E4%B8%8E%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[原文链接： overreacted.ioReact 函数组件与 React 类有什么区别？规范有段时间给出的答案是，类能提供更多的属性访问功能（例如 state ）。借助 Hooks 的话，这点是毫无疑问的。可能你听说过其中一种的性能更好，到底是哪一种呢？ 然而许多此类评判基准都是 不全面的 ，因此我会很谨慎从中的总结出结论 。性能好坏主要取决于代码实现的功能而不是你选择函数还是类的实现方式。我们研究发现，尽管两者的优化策略稍微c有点 不一样，但它们的性能差异是可以忽略的。此外我们不推荐 重写你的组件，除非你有其他的原因并且不介意当吃螃蟹的人。Hooks 还算是新功能 (就像 2014 年的 React), 而且有的“最佳做法”教程还未采用。那我们该怎么办呢，React 函数和类的有根本的区别吗？当然，它们的核心思想是不一样的.。在这篇文章中，我将会着眼于它们最大的区别函数组件自从 2015 年 被介绍 后一直存在，但总被忽视： 函数组件捕获渲染值。 让我们看看这是什么意思。 注意：本文对函数组件或类的评价。我只是在描述这两种编程模式在 React 中的区别。关于如果更广泛得使用函数组件，请参考 Hooks FAQ. 请思考以下组件。 1234567891011function ProfilePage(props) &#123; const showMessage = () =&gt; &#123; alert(&apos;Followed &apos; + props.user); &#125;; const handleClick = () =&gt; &#123; setTimeout(showMessage, 3000); &#125;; return ( &lt;button onClick=&#123;handleClick&#125;&gt;Follow&lt;/button&gt; );&#125; 这里有一个按钮，通过 setTimeout 模拟网络请求，然后弹出一个确认框。例如，如果 ‘props.user’ 是’Dan’，点击按钮3秒后会显示’Follow Dan’。如此简单。(注意，以上的例子用箭头函数还是函数声明都没关系。’function handleClick()’ 也能完全实现同样的功能。)我们如何用类来实现同样的功能呢？ 直接的转换就是这样: 1234567891011class ProfilePage extends React.Component &#123; showMessage = () =&gt; &#123; alert(&apos;Followed &apos; + this.props.user); &#125;; handleClick = () =&gt; &#123; setTimeout(this.showMessage, 3000); &#125;; render() &#123; return &lt;button onClick=&#123;this.handleClick&#125;&gt;Follow&lt;/button&gt;; &#125;&#125; 这两段代码通常都被认为是等价的。人们常常能够不受限制的在这两种模式间进行重构，却没有注意到它们的含义。然而，这两段代码有细微的差别 仔细看看，发现了吗？说实话，我观察了一段时间才发现。如果你想亲自发现的话，这里有个在线例子 作为预告 本文剩余部份解释它们的区别，以为这些区别的重要性。 继续之前，我想强调下，我所描述的区别与 React Hooks 没有任何关系。以上的例子都没有用到 Hooks 呢！这些都是关于 React 中组件函数与类的差别。如果你打算在 React 应用中大量使用函数组件，你可能会希望了解这些差别。 我们将通过 React 应用中一个普遍的 bug 来说明它们的差别。打开这个 沙盒例子 ，里面有个当前配置文件选择器，和上面两个 ProfilePage — 分别渲染一个 Follow 按钮。尝试一下顺序操作: 点击 其中一个 Follow 按钮。 改变 3 秒内选择其它配置文件。 阅读 警告框文字。 你会发现一个神奇得区别: ProfilePage 函数组件, 外 Dan 的配置文件点击 Follow。 然后导航到 Sophie 的配置文件，弹出的警告仍然是 ‘Followed Dan’。 ProfilePage 类, 则会弹出 ‘Followed Sophir ‘: 在这个例子里，第一种行为才是正确的。如果我关注了一个人，然后导航到另一个人的配置文件，我的组件不应该弄混我所关注的。 这里类的实现很明显是不对的。(尽管你应该 关注 Sophie though.) 那么为什么我们的类组件会这样呢？让我们仔细看看类组件里的showMessage 方法: 1234class ProfilePage extends React.Component &#123; showMessage = () =&gt; &#123; alert(&apos;Followed &apos; + this.props.user); &#125;; 这个类方法读取的是this.props.user. Props 在 React 中是不可变的，因此它们从未改变。 然而， this _变了_，而且一直都是可变的。确实，类的核心就是 this 。React 自身是不断得变化的，所以你能够获得最新的 render 和生命周期方法。因此，如果我们触发请求的时候，重渲染了组件，this.props 将会改变。导致showMessage 读取到的 user 来自 “太新” 的props。这里发现了一个关于用户界面的有趣观察。如果说 UI 是当前应用程序概念化的 state，事件处理器是渲染结果的一部分 — 就像视觉输出一样。那么我们的事件处理器 “属于” 带有特定 props 和 state 的特定 render。然而，设置超时回调读取 this.props Our showMessage 打破了这个关联。回调不再与任何指定的 render “捆绑”，因此 “丢失了” 正确的 props。 从 this 读取的信息切断了这种联系。 如果不存在函数组件。 我们如何解决这个问题？我们希望有某些办法 “修复” render 与正确的 props 之间的联系， 使得 showMessage回调执行时读取到他们。props 在某些地方丢失了。其中一种方法是在事件早期就读取 this.props ，然后将它明确的传递给 timeout 的完成时处理器: 123456789101112class ProfilePage extends React.Component &#123; showMessage = (user) =&gt; &#123; alert(&apos;Followed &apos; + user); &#125;; handleClick = () =&gt; &#123; const &#123;user&#125; = this.props; setTimeout(() =&gt; this.showMessage(user), 3000); &#125;; render() &#123; return &lt;button onClick=&#123;this.handleClick&#125;&gt;Follow&lt;/button&gt;; &#125;&#125; 这是 有效的。然而，这种方法会是代码变得累赘并且随着时间推移容易出错。如果我们需要更多的 prop 怎么办？如果我们需要访问 state 呢？ 如果 showMessage 调用其它方法，并且该方法需要读取 this.props.something 或者 this.state.something，我们又会遇到同样的问题。 导致我们必须将 this.props 和 this.state 作为参数传递给每一个在 showMessage 中调用到的方法。这样做会破坏类的效率。 同时也难以记忆和执行，这就是为什么人们经常需要处理 bug 的原因。将 alert 内嵌到 handleClick 也不能解决最大的问题。我们希望构建的代码是能够由多个方法组成，同时能够读取到调用时所关联的 render 对应的 props 和 state。这个问题并不只存在 React 中 — 你可以用任何一个 UI 库重构这个例子，将数据存放在一个像this. 的易变对象中将方法绑定到构造函数中能解决吗？ 123456789101112131415class ProfilePage extends React.Component &#123; constructor(props) &#123; super(props); this.showMessage = this.showMessage.bind(this); this.handleClick = this.handleClick.bind(this); &#125; showMessage() &#123; alert(&apos;Followed &apos; + this.props.user); &#125; handleClick() &#123; setTimeout(this.showMessage, 3000); &#125; render() &#123; return &lt;button onClick=&#123;this.handleClick&#125;&gt;Follow&lt;/button&gt;; &#125;&#125; 不，这样不能解决任何问题。记住，这个问题是我们读取 this.props 太晚了 — 而不是我们使用的语法有问题！然而，如果我们使用 JavaScript 的闭包，就没有这个问题了。通常会避免使用闭包，是因为 很难 确定易变变量的值。但是在 React 中，props 和 state 都是不可变的！ (或者至少是强烈建议不要改变。) 这就消除了闭包最大的绊脚石。这意味着，如果关闭了特定 render的 props 或者 state，你依然可以正确的获取到它们: 1234567891011121314class ProfilePage extends React.Component &#123; render() &#123; // Capture the props! const props = this.props; // Note: we are *inside render*. // These aren&apos;t class methods. const showMessage = () =&gt; &#123; alert(&apos;Followed &apos; + props.user); &#125;; const handleClick = () =&gt; &#123; setTimeout(showMessage, 3000); &#125;; return &lt;button onClick=&#123;handleClick&#125;&gt;Follow&lt;/button&gt;; &#125;&#125; 你能够 “捕获到” 当时 render 的 props:这种方式能确保任何的内部代码 (包括 showMessage) 都能 得到指定 render 的 props。React 再也不会 “动我们的奶酪了”。我们能够在内部添加各种想要辅助函数，并且它们都能捕获到正确的 props 和 state。 闭包拯救了我们！ 上面的例子 是正确的，但看起来很奇怪。如果一个类将方法定义在 render 里而不是使用类方法的意味着什么？的确，我们可以通过移除类这个 “壳” 以简化代码: 1234567891011function ProfilePage(props) &#123; const showMessage = () =&gt; &#123; alert(&apos;Followed &apos; + props.user); &#125;; const handleClick = () =&gt; &#123; setTimeout(showMessage, 3000); &#125;; return ( &lt;button onClick=&#123;handleClick&#125;&gt;Follow&lt;/button&gt; );&#125; 像上面，依然能够捕获到 props — React 将它们作为参数传递。 不像 this， props不会被 React 改变。如果在函数定义内解构 props就更明显了: 12345678910function ProfilePage(&#123; user &#125;) &#123; const showMessage = () =&gt; &#123; alert(&apos;Followed &apos; + user); &#125;; const handleClick = () =&gt; &#123; setTimeout(showMessage, 3000); &#125;; return ( &lt;button onClick=&#123;handleClick&#125;&gt;Follow&lt;/button&gt; );&#125; 当父组件用不同的 props 渲染 ProfilePage， React 会再次调用 ProfilePage 函数。但我们已经触发的点击事件处理器还是“属于”之前的拥有自己 user 值的 render，showMessage 调用时会读取这个值。 它们都完好无损。这就是为什么，函数组件的 例子，点击 Follow Sophie 的配置文件，再选择 Sunil 仍然弹出 ‘Followed Sophie’ 的原因:这表现是正确的。 (尽管你可能是想 follow Sunil too!) 现在我们明白 了React 中函数组件和类的最大区别了: 函数组件能够捕获渲染过的值。 通过 Hooks，同样的原理也适用于 state。 思考一下例子: 123456789101112131415161718function MessageThread() &#123; const [message, setMessage] = useState(&apos;&apos;); const showMessage = () =&gt; &#123; alert(&apos;You said: &apos; + message); &#125;; const handleSendClick = () =&gt; &#123; setTimeout(showMessage, 3000); &#125;; const handleMessageChange = (e) =&gt; &#123; setMessage(e.target.value); &#125;; return ( &lt;&gt; &lt;input value=&#123;message&#125; onChange=&#123;handleMessageChange&#125; /&gt; &lt;button onClick=&#123;handleSendClick&#125;&gt;Send&lt;/button&gt; &lt;/&gt; );&#125; (这里有个 在线例子.)然而这不是一个很好的消息应用程序 UI，但也说明了同样的观点：如果我发送了特定的消息，组件不应该弄混实际发送的消息。该函数组件的 message 捕获到的 state “属于” 浏览器触发点击事件处理器时的 render。 因此 message 被设置为我点击 “Send” 时 input 的值。 我们知道了 React 中的函数默认会捕获 props 和 state。 但是如果我们 希望 读取最新的，而不是属于特定 render 的 props 或者 state 时怎么办？ 如果我们希望 “读取将来的数据呢”?在类中，你能够通过读取this.props 或者 this.state 做到这些，因为 this 自身是可变的。React 改变了它。在函数组件中，你也可以拥有一个被所有组件 render 共享的可变值。 它就是 “ref”: 12345function MyComponent() &#123; const ref = useRef(null); // You can read or write `ref.current`. // ...&#125; 然而你必须自己管理它。A ref 与实例属性一样 。它是进入可变世界的安全舱。你可能熟悉 “DOM refs”，但 ref 的概念更广泛。它仅仅是一个能够让你放置东西的盒子。视觉上，this.something 和something.current一样。实际上它们概念上也是一样的。默认情况下，React 在函数组件里不会为最新的 props 或者 state 创建 refs。而大多数情况下你也不需要它们，为它们赋值是白费功夫的。 但你可以手动跟踪这些值: 1234567891011function MessageThread() &#123; const [message, setMessage] = useState(&apos;&apos;); const latestMessage = useRef(&apos;&apos;); const showMessage = () =&gt; &#123; alert(&apos;You said: &apos; + latestMessage.current); &#125;; const handleSendClick = () =&gt; &#123; setTimeout(showMessage, 3000); &#125;; const handleMessageChange = (e) =&gt; &#123; setMessage(e.target.value); latestMessage.current = e.target.value; &#125;; 如果我们在showMessage里读取 message ，我们将会看到按下发送按钮时的消息。但当我们读取 latestMessage.current，我们得到的是最新的值， —即使在按下发送按钮后继续输入。你可以自行比较这 两个 示例 的差别。 ref 是一种 “退出” 渲染一致性的方法，在某些情况下能够用得上。通常，你应该避免在渲染时读取或者设置 refs，因为它们是可变的。我们希望保持渲染的可预测性。 然而，如果我们希望得到特定 prop 或者 state 的最新值，手动更新 ref 会很麻烦。 我们可以使用 effect 来自动更新: 1234567function MessageThread() &#123; const [message, setMessage] = useState(&apos;&apos;); // Keep track of the latest value. const latestMessage = useRef(&apos;&apos;); useEffect(() =&gt; &#123; latestMessage.current = message; &#125;); const showMessage = () =&gt; &#123; alert(&apos;You said: &apos; + latestMessage.current); &#125;; (这里有个 示例。)我们在 effect 内部 赋值，那么 ref 的值只会在 DOM 更新后改变。这样确保了我们的变化不会破坏如 Time Slicing 和 Suspense 等依赖于可中断渲染的特性。通常情况下不需要这样使用 ref。 捕获 props 或者 state 是更好的选择。 不过, 使用imperative APIs能够很方便的解决 intervals 和订阅这类问题。请记住，你能跟踪任一值，如 — 一个 prop，一个 state 变量，整个 props 对象,，甚至是一个函数。这种方式能够很方便的优化像useCallback频繁变化这种情况。不过，使用 reducer往往是 更好的解决方式. (未来的一个博客主题！) 本文中，我们研究了类中常见的 bug，以及如果使用闭包修复。然而，你可能会注意到，当你尝试使用指定的依赖数组来优化 Hooks 时，会遇到由闭包未更新导致的 bug。那么闭包是问题所在吗？我不这么认为。正如我们上面看到的，闭包确实帮助我们 修复了 这个难以发现的问题。同样的，在并发模式下使用闭包能更容易编写正确的代码。因为组件内部逻辑屏蔽了渲染过的 props 和 state。目前为止我所见过的情况， “旧闭包” 问题都是由于错误的假设 “函数是不会变化的”或者 “props 永远保持不变”导致的。 事实并非如此，我希望本文有助于澄清。函数更新时会覆盖它们的 props 和 state — 因此它们的标识也同样重要。这不是 bug，是函数组件的一个特性。函数不应该被如 useEffect 或者 useCallback的“依赖数组”排除在外， (通常是通过useReducer 或者 the useRef来解决以上问题 — 接下来将分析如何选择它们。)当我们的 React 代码主要使用函数编写时，我们需要调整对 优化代码 以及 会随着时间变化的值的认识。正如 Fredrik 所说: 至今为止我所发现的应用 hook 最好的中心思想是 ”代码想任一值一样，任何时候都能改变”。 函数也不例外。在 React 的学习材料中普及需要点时间。它需要对类的认识做些调整。我希望这篇文章能够你以新的眼光看待类。React 函数总是能捕获到它们需要的值 — 现在我们明白了其中的原因。它们是完全不同的精灵。 转自：https://www.zcfy.cc/article/how-are-function-components-different-from-classes]]></content>
  </entry>
  <entry>
    <title><![CDATA[是时候开始使用 CSS 自定义属性了]]></title>
    <url>%2F2019%2F07%2F09%2Fyuque%2F%E6%98%AF%E6%97%B6%E5%80%99%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8%20CSS%20%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E4%BA%86%2F</url>
    <content type="text"><![CDATA[原文链接： www.smashingmagazine.com在今天，css预加载已经成为了前端开发的一个标准。预加载的一个主要优势就是可以让你使用变量。它可以让你避免复制黏贴你的代码，并且简化了开发和重构。我们用预加载来存储颜色、字体偏好，布局的细节——几乎是我们在css里面用到的所有东西。但是预加载的变量有一些使用上的限制： 你不能动态的改变他们。 他们不能认出DOM结构。 他们不能用JavaScript读取和改变。 为了解决这样或那样的问题，社区发明了CSS自定义属性。本质上这看上去和实现起来就像CSS变量。并且他们的实现方式就像他们的名字一样。自定义属性为前端开发打开了新的大门。 深入阅读: A Detailed Introduction To Custom Elements Houdini: Maybe The Most Exciting Development In CSS You’ve Never Heard Of Turn Your AMP Up To 11: Everything You Need To Know About Google’s Accelerated Mobile Pages A Better iOS Architecture: A Deep Look At The Model-View-Controller Pattern申明和使用自定义属性的语法在你开始学习心得预处理器或者框架的使用通常的问题是你必须学习新的语法。每一种预处理器都使用不同的方法申明变量。通常使用一个保留字符作为开始——举个例子，Sass的$、LESS的@。CSS自定义属性同样也是用保留字符 --来引入声明。但是好处是你只需要学一遍语法就能在所有浏览器上使用。你可能会问，“为什么不使用已经有的语法？”这是有原因的。简单来说这提供了一种在任何预处理器中使用自定义属性的方式。在这种方式下我们可以使用自定义属性，预处理器也不会编译他们，所以这些属性会直接输出到编译后的CSS中。并且你也可以重复使用预处理器变量在源文件中，这个我稍后会细说。（关于这个名字：因为他们的想法和目标非常相似，有些时候自定义属性被叫做CSS变量，尽管正确名称叫CSS自定义属性，往下读你就会明白为什么这个名字是最正确的。）所以要声明一个变量来代替常用的CSS属性，就像color或者padding，用--连接一个自定义名称属性就可以：1234.box&#123; --box-color: #4d4e53; --box-padding: 0 10px;&#125; 属性的值可以是任何有效的CSS值：颜色、字符串、布局甚至是表达式。这里是有效的自定义属性的例子： 12345678910111213:root&#123; --main-color: #4d4e53; --main-bg: rgb(255, 255, 255); --logo-border-color: rebeccapurple; --header-height: 68px; --content-padding: 10px 20px; --base-line-height: 1.428571429; --transition-duration: .35s; --external-link: &quot;external link&quot;; --margin-top: calc(2vh + 20px); /* Valid CSS custom properties can be reused later in, say, JavaScript. */ --foo: if(x &gt; 5) this.width = 10;&#125; 以防万一你不知道什么是:root匹配，在HTML里他就等同与html标签，但是具有更高的特异性。自定义属性和其他的CSS属性一样是动态的、级联的。这意味着他们能在任何时候被改变是由浏览器来进行的。为了使用自定义的变量，你需要使用var()CSS函数，并且提供属性参数： 12345678.box&#123; --box-color:#4d4e53; --box-padding: 0 10px; padding: var(--box-padding);&#125;.box div&#123; color: var(--box-color);&#125; 声明和用例var()函数有一个非常便利的提供默认值的方法。如果你不确信自定义属性已经被定义并且需要一个默认值，函数的第二个参数用来作为默认值的: 123456.box&#123; --box-color:#4d4e53; --box-padding: 0 10px; /* 10px is used because --box-margin is not defined. */ margin: var(--box-margin, 10px);&#125; 你可能会希望在声明新的变量的时候能重复使用已有的变量值： 1234567.box&#123; /* The --main-padding variable is used if --box-padding is not defined. */ padding: var(--box-padding, var(--main-padding)); --box-text: &apos;This is my box&apos;; /* Equal to --box-highlight-text:&apos;This is my box with highlight&apos;; */ --box-highlight-text: var(--box-text)&apos; with highlight&apos;;&#125; 运算：+，-，*，/既然我们习惯使用预处理器和其他语言，我们也希望在处理变量的时候能使用基本运算。为了达到这个目的，CSS提供了calc()函数，作用当自定义属性的值被改变的时候浏览器会重新计算表达式： 1234567:root&#123; --indent-size: 10px; --indent-xl: calc(2*var(--indent-size)); --indent-l: calc(var(--indent-size) + 2px); --indent-s: calc(var(--indent-size) - 2px); --indent-xs: calc(var(--indent-size)/2);&#125; 特别是当你想用一个没有单位的值得时候，就需要使用calc()函数： 1234567:root&#123; --spacer: 10;&#125;.box&#123; padding: var(--spacer)px 0; /* DOESN&apos;T work */ padding: calc(var(--spacer)*1px) 0; /* WORKS */&#125; 作用域和继承在讨论CSS自定义属性的作用域之前，我们先来回顾一下JavaScript和预处理器的作用域。这样就能更好的认识他们之间的区别。我们知道在JavaScript中如果在函数中使用var关键字声明变量，那么他的作用域就在函数里面。同样的我们可以使用let和const关键字，但他们的作用域相对于变量的块作用域。在JavaScript中闭包(closure)是一个可以访问外部函数变量的函数——作用域链。闭包有三个作用域链： 它自己的作用域（即 变量定义在大括号中） 外部函数的变量 全局变量 (View large version)预处理器也是相同的，让我们用Sass来举个例子。因为这大概是今天最流行的预处理器了。在Sass中有两种类型的变量：当前作用域变量(local) 和 全局变量。一个全局变量能被申明在选择器和构造器（比如mixin）外，其他的变量就是当前作用域变量。任何嵌套的代码块都可以访问封闭变量（如JavaScript）。(View large version)这意味着在Sass中变量的作用域完全依赖代码的嵌套结构。然而CSS自定义属性完全和其他的CSS属性一样使用级联方式默认继承。当然你也不能在CSS中定义一个在选择器外的属于全局的自定义属性变量，因为这不是有效的CSS。自定义属性的全局作用域实际上就是:root的作用域，这里面定义的属性就是全局的。让我们用已知的语法知识和Sass的例子来创建一个使用原生的CSS自定义属性的例子，首先是HTML： 1234567global&lt;div class=&quot;enclosing&quot;&gt; enclosing &lt;div class=&quot;closure&quot;&gt; closure &lt;/div&gt;&lt;/div&gt; 然后是CSS: 1234567891011:root &#123; --globalVar: 10px;&#125;.enclosing &#123; --enclosingVar: 20px;&#125;.enclosing .closure &#123; --closureVar: 30px; font-size: calc(var(--closureVar) + var(--enclosingVar) + var(--globalVar)); /* 60px for now */&#125; 在CODEPEN中查看代码 css-custom-properties-time-to-start-using 1 by Serg Hospodarets (@malyw) on CodePen. 对自定义属性的更改将立即应用于所有实例到目前为止我们还没有看出他和Sass变量有什么区别。然而让我们重新给变量赋值：在Sass中，是无效的： 123456.closure &#123; $closureVar: 30px; // local variable font-size: $closureVar +$enclosingVar+ $globalVar; // 60px, $closureVar: 30px is used $closureVar: 50px; // local variable&#125; 在CODEPEN中查看代码 css-custom-properties-time-to-start-using 3 by Serg Hospodarets (@malyw) on CodePen.但是在CSS中计算的值改变了。因为font-size的值因为--closureVar值得改变重新计算了： 123456.enclosing .closure &#123; --closureVar: 30px; font-size: calc(var(--closureVar) + var(--enclosingVar) + var(--globalVar)); /* 80px for now, --closureVar: 50px is used */ --closureVar: 50px;&#125; 在CODEPEN中查看代码 css-custom-properties-time-to-start-using 2 by Serg Hospodarets (@malyw) on CodePen.这是第一个非常大的区别：如果你对自定义属性重新赋值，浏览器会重新计算所有的变量和calc()表达式。 预处理器不能识别DOM结构假如我们想在除了class是highlighted的div上使用默认的font-size下面是 HTML代码： 123456&lt;div class=&quot;default&quot;&gt; default&lt;/div&gt;&lt;div class=&quot;default highlighted&quot;&gt; default highlighted&lt;/div&gt; 让我们使用CSS自定义属性： 12345678.highlighted &#123; --highlighted-size: 30px;&#125;.default &#123; --default-size: 10px; /* Use default-size, except when highlighted-size is provided. */ font-size: var(--highlighted-size, var(--default-size));&#125; 因为第二个div元素使用了highlighted类，在highlighted类上的属性就提供给这个元素了。在这里就意味着，--hightlighted-size: 30px被提供了。是的font-size的属性被重新赋值了。一切都是这么直截了当的运行：在CODEOPEN上查看代码 css-custom-properties-time-to-start-using 4 by Serg Hospodarets (@malyw) on CodePen.接下来让我们尝试使用Sass来实现同样的例子： 12345678910111213.highlighted &#123; $highlighted-size: 30px;&#125;.default &#123; $default-size: 10px; /* Use default-size, except when highlighted-size is provided. */ @if variable-exists(highlighted-size) &#123; font-size: $highlighted-size; &#125; @else &#123; font-size: $default-size; &#125;&#125; 结果显示他们都使用默认字体大小：在CODEOPEN上查看代码 css-custom-properties-time-to-start-using 5 by Serg Hospodarets (@malyw) on CodePen.这是因为所有的Sass的计算和进程都发生在编译过程中，所以理所当然的他不知道DOM结构，所以依赖代码结构。如你所见自定义属性在变量作用域和通常的css级联样式上具有优势。并且能够识别DOM结构。和普通的CSS属性使用相同的语法规则。第二个例外是CSS自定义属性能动态的识别DOM结构 CSS关键字和all属性CSS自定义属性遵守与常规CSS自定义属性相同的规则。这意味着您可以为其分配任何常见的CSS关键字： inherit 此CSS关键字应用元素的父对象的值。 initial 这将应用CSS规范中定义的初始值（空值，或在某些CSS自定义属性的情况下）。 unset 在自定义属性中，如果属性是继承的，则应用继承的值，如果属性是初始化的值，则引用初始化值。 revert 这会将该属性重置为用户代理样式表建立的默认值（在CSS自定义属性的情况下为空值）。以下是例子： 123456.common-values&#123; --border: inherit; --bgcolor: initial; --padding: unset; --animation: revert;&#125; 我们来看另外一个例子。假设你想构建一个组件，并且想要确保没有其他样式或自定义属性被无意中应用（在这种情况下，通常会使用模块化的CSS解决方案）。现在还有另一种方法：使用allCSS属性。这个简写将重置所有CSS属性。与CSS关键字一起，我们可以执行以下操作： 123.my-wonderful-clean-component&#123; all: initial;&#125; 这会为我们的组件重置所有的样式：不幸的是，all关键字不会重置自定义属性。关于是否添加 -- 前缀，这将重置所有CSS自定义属性，正在进行讨论。所以在将来，一个完整的重置会是这样的： 1234.my-wonderful-clean-component&#123; --: initial; /* reset all CSS custom properties */ all: initial; /* reset all other CSS styles */&#125; CSS自定义属性用例有许多自定义属性使用的方式，在这里我会展示他们中最有趣的部分。 模拟不存在的CSS规则这些CSS变量的名称是自定义属性，那为什么我们不能用它来模拟不存在的CSS属性？有很多比如translateX/Y/Z,background-repeat-x/y(仍然不能跨浏览器兼容)，box-shadow-color。让我们试着模拟最后一个属性。在这个例子里当hover的时候我们改变box-shadow的颜色。我们只想遵循DRY规则（不要重复你自己），所以我们只是改变它的颜色，而不是在：hover部分重复box-shadow的整个值。（变量的改变会重新计算var()和calc()） 12345678.test &#123; --box-shadow-color: yellow; box-shadow: 0 0 30px var(--box-shadow-color);&#125;.test:hover &#123; --box-shadow-color: orange; /* Instead of: box-shadow: 0 0 30px orange; */&#125; 在CODEOPEN上查看代码 Emulating “box-shadow-color” CSS property using CSS Custom Properties by Serg Hospodarets (@malyw) on CodePen. 颜色主题自定义属性有一个最常用的用例就是应用程序中的颜色主题。自定义属性就是用来解决这类问题的。所以，让我们为一个组件提供一个简单的颜色主题（应用程序可以遵循相同的步骤）。这是button组件的代码： 12345678.btn &#123; background-image: linear-gradient(to bottom, #3498db, #2980b9); text-shadow: 1px 1px 3px #777; box-shadow: 0px 1px 3px #777; border-radius: 28px; color: #ffffff; padding: 10px 20px 10px 20px;&#125; 我们假设要反转颜色主题。第一步是将所有颜色变量扩展到CSS自定义属性并重写我们的组件。重写后的代码： 12345678910111213141516.btn &#123; --shadow-color: #777; --gradient-from-color: #3498db; --gradient-to-color: #2980b9; --color: #ffffff; background-image: linear-gradient( to bottom, var(--gradient-from-color), var(--gradient-to-color) ); text-shadow: 1px 1px 3px var(--shadow-color); box-shadow: 0px 1px 3px var(--shadow-color); border-radius: 28px; color: var(--color); padding: 10px 20px 10px 20px;&#125; 这有我们需要的一切。使用它，我们可以将颜色变量重写为反转值，并在需要时应用它们。例如，我们可以添加全局inverted类（例如，body元素），并在应用颜色时更改颜色： 123456body.inverted .btn&#123; --shadow-color: #888888; --gradient-from-color: #CB6724; --gradient-to-color: #D67F46; --color: #000000;&#125; 以下是一个演示，您可以在其中单击一个按钮来添加和删除全局类：demo在CODEOPEN中查看代码 css-custom-properties-time-to-start-using 9 by Serg Hospodarets (@malyw) on CodePen.如果不重复代码，在CSS预处理器中无法实现此行为。使用预处理器，您将始终需要覆盖实际的值和规则，这往往会导致额外的CSS。使用CSS自定义属性，解决方案可以尽可能的干净，复制黏贴是可以避免的。因为只需要对变量进行重新赋值。 在JavaScript中使用自定义属性以前，要将数据从CSS发送到JavaScript，我们经常不得不采取技巧，通过CSS输出中的纯JSON编写CSS值，然后从JavaScript读取它。现在，我们可以轻松地使用JavaScript中的CSS变量进行交互，使用众所周知的.getPropertyValue()和.setProperty()方法读取和写入它们，这些方法用于通常的CSS属性: 1234567891011121314151617181920212223/*** Gives a CSS custom property value applied at the element* element &#123;Element&#125;* varName &#123;String&#125; without &apos;--&apos;** For example:* readCssVar(document.querySelector(&apos;.box&apos;), &apos;color&apos;);*/function readCssVar(element, varName)&#123; const elementStyles = getComputedStyle(element); return elementStyles.getPropertyValue(`--$&#123;varName&#125;`).trim();&#125;/*** Writes a CSS custom property value at the element* element &#123;Element&#125;* varName &#123;String&#125; without &apos;--&apos;** For example:* readCssVar(document.querySelector(&apos;.box&apos;), &apos;color&apos;, &apos;white&apos;);*/function writeCssVar(element, varName, value)&#123; return element.style.setProperty(`--$&#123;varName&#125;`, value);&#125; 假设我们有一系列的媒体查询值 1234.breakpoints-data &#123; --phone: 480px; --tablet: 800px;&#125; 因为我们只想在JavaScript中重用它们 - 例如，在Window.matchMedia()中，我们可以轻松地从CSS中获取它们 1234const breakpointsData = document.querySelector(&apos;.breakpoints-data&apos;);// GETconst phoneBreakpoint = getComputedStyle(breakpointsData) .getPropertyValue(&apos;--phone&apos;); 为了展示如何从JavaScript分配自定义属性，我创建了一个交互式3D CSS 立方体demo，以响应用户操作。这不是很难我们只需要添加一个简单的背景，然后放置五个立方体面与transform属性的相关值：translateZ（），translateY（），rotateX（）和rotateY（）。为了提供正确的视角，我向页面添加了以下内容： 12345678910#world&#123; --translateZ:0; --rotateX:65; --rotateY:0; transform-style:preserve-3d; transform: translateZ(calc(var(--translateZ) * 1px)) rotateX(calc(var(--rotateX) * 1deg)) rotateY(calc(var(--rotateY) * 1deg));&#125; 唯一缺少的是交互性。当鼠标移动时，演示应该更改X和Y视角（–rotateX和-rotateY），当鼠标滚动（–translateZ）时应该放大和缩小）。这是JavaScript的诀窍： 1234567891011121314151617// EventsonMouseMove(e) &#123; this.worldXAngle = (.5 - (e.clientY / window.innerHeight)) * 180; this.worldYAngle = -(.5 - (e.clientX / window.innerWidth)) * 180; this.updateView();&#125;;onMouseWheel(e) &#123; /*…*/ this.worldZ += delta * 5; this.updateView();&#125;;// JavaScript -&gt; CSSupdateView() &#123; this.worldEl.style.setProperty(&apos;--translateZ&apos;, this.worldZ); this.worldEl.style.setProperty(&apos;--rotateX&apos;, this.worldXAngle); this.worldEl.style.setProperty(&apos;--rotateY&apos;, this.worldYAngle);&#125;; 现在，当用户移动鼠标时，演示会更改视图。您可以通过移动鼠标并使用鼠标滚轮放大和缩小来检查：demo在CODEOPEN中查看代码 css-custom-properties-time-to-start-using 10 by Serg Hospodarets (@malyw) on CodePen.基本上，我们只是更改了CSS自定义属性的值。其他（旋转和放大和缩小）都是由CSS完成的。提示：调整CSS自定义属性值的最简单方法之一就是在CSS生成的内容中显示其内容（在简单的情况下，例如使用字符串），以便浏览器将自动显示当前应用的值： 123body:after &#123; content: &apos;--screen-category : &apos;var(--screen-category);&#125; 您可以在纯CSS演示（无HTML或JavaScript）中查看。 （调整窗口大小，查看浏览器会自动反映更改后的CSS自定义属性值。） 浏览器支持主流浏览器都支持了CSS自定义属性:(View large version)这意味着你可以自己开始使用它们。如果您需要支持旧版浏览器，您可以学习语法和使用示例，并考虑并行切换或使用CSS和预处理器变量的可能方法。当然，我们需要能够检测CSS和JavaScript中的支持，以便提供回退或增强功能。这很容易对于CSS，您可以使用带有虚拟功能查询的@supports条件： 123456@supports ( (--a: 0)) &#123; /* supported */&#125;@supports ( not (--a: 0)) &#123; /* not supported */&#125; 在JavaScript中，您可以使用与CSS.supports（）静态方法相同的虚拟自定义属性： 1234567const isSupported = window.CSS &amp;&amp; window.CSS.supports &amp;&amp; window.CSS.supports(&apos;--a&apos;, 0);if (isSupported) &#123; /* supported */&#125; else &#123; /* not supported */&#125; 我们看到，CSS自定义属性在每个浏览器中仍然不可用。知道这一点，您可以通过检查它们是否受支持来逐步增强您的应用程序。例如，您可以生成两个主要的CSS文件：一个具有CSS自定义属性，另一个没有它们，其中属性是内联的（我们将在稍后讨论一些方法）。默认加载第二个。然后，如果支持自定义属性，只需检查JavaScript并切换到增强版本即可: 123&lt;!-- HTML --&gt;&lt;link href=&quot;without-css-custom-properties.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;all&quot; /&gt; 1234567// JavaScriptif(isSupported)&#123; removeCss(&apos;without-css-custom-properties.css&apos;); loadCss(&apos;css-custom-properties.css&apos;); // + conditionally apply some application enhancements // using the custom properties&#125; 这只是一个例子。往下看，有更好的选择。 如何开始使用它们针对最近的一项调查，Sass已经成为了开发社区中预处理器的最佳选择。所以，让我们考虑开始使用CSS自定义属性或使用Sass为他们做准备的方法。我们有一些观点。 1. 手动检查代码支持手动检查代码中自定义属性是否支持的方法的一个优点是如果它可行我们就可以直接用它（不要忘记我们已经切换到Sass）： 123456789101112$color: red;:root &#123; --color: red;&#125;.box &#123; @supports ( (--a: 0)) &#123; color: var(--color); &#125; @supports ( not (--a: 0)) &#123; color: $color; &#125;&#125; 这种方法确实有许多缺点，其中不仅仅是代码变得复杂，而且复制和粘贴变得很难维护。 2. 使用自动转换CSS的插件PostCSS生态系统今天提供了几十个插件。它们中的几个在生成的CSS输出中处理自定义属性（内联值），并使它们工作，假设您仅提供全局变量（即，您只声明或更改：根选择器中的CSS自定义属性），因此它们的值可以轻松内联。其中一个例子就是postcss-custom-properties这个插件提供了几个优点：它使语法工作;它与PostCSS的所有基础设施兼容;并且不需要太多的配置。但是有一些缺点。该插件需要您使用CSS自定义属性，因此您没有准备项目以从Sass变量切换的路径。此外，您将无法对转换进行很多控制，因为在Sass被编译为CSS之后完成。最后，插件不提供很多调试信息。 3. css-vars Mixin我开始在我大多数项目里使用CSS自定义属性并且尝试了很多策略： 用cssnext从Sass切换到PostCSS . 从Sass变量切换到纯CSS自定义属性 在Sass中使用CSS变量来检测是否支持它们。 通过这些经验，我开始寻找一个可以满足我的标准的解决方案： 它应该很容配合Sass来使用 应该直接使用，并且语法必须尽可能接近原生的CSS自定义属性。 将CSS输出从内联值切换到CSS变量应该很容易。 熟悉CSS自定义属性的团队成员将能够使用该解决方案。 应该有一种方法有使用变量的调试信息。 因此，我创建了css-vars，一个Sass mixin，可以在Github上找到。使用它，你就可以使用CSS自定义属性语法。 使用 css-vars Mixin声明变量，使用的mixin如下： 12345678$white-color: #fff;$base-font-size: 10px;@include css-vars(( --main-color: #000, --main-bg: $white-color, --main-font-size: 1.5*$base-font-size, --padding-top: calc(2vh + 20px))); 使用这些变量，用var()函数： 123456body &#123; color: var(--main-color); background: var(--main-bg, #f00); font-size: var(--main-font-size); padding: var(--padding-top) 0 10px;&#125; 这为您提供了一种从一个地方（从Sass）控制所有CSS输出并开始熟悉语法的方法。此外，您可以使用mixin重用Sass变量和逻辑。当您想要支持的所有浏览器都使用CSS变量时，您需要做的就是添加： 1`$css-vars-use-native: true;` 而不是调整生成的CSS中的变量属性，mixin将开始注册自定义属性，并且var()实例将转到生成的CSS而不进行任何转换。这意味着您将完全切换到CSS自定义属性，并具有我们讨论的所有优点。如果你想打开有用的调试信息，如下： 1`$css-vars-debug-log: true;` 这会给你 当变量没有被定义却被使用的日志 变量被重复定义的日志 当默认值代替了未定义变量值的日志 结束语现在你对CSS自定义属性有了更多的了解，包括语法、优势、一些有用的例子还有如何在JavaScript中进行交互你需要知道如何确认他们是否被支持，他们和CSS预处理器的变量有什么区别，以及如何在浏览器支持之前开始使用原生的CSS变量。这是开始使用CSS自定义属性并为浏览器支持做准备的最佳时机。(rb, vf, al, il)]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSS 与 JS 动画的底层机制 + 如何优化它们的性能]]></title>
    <url>%2F2019%2F07%2F09%2Fyuque%2FCSS%20%E4%B8%8E%20JS%20%E5%8A%A8%E7%94%BB%E7%9A%84%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6%20%2B%20%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E5%AE%83%E4%BB%AC%E7%9A%84%E6%80%A7%E8%83%BD%2F</url>
    <content type="text"><![CDATA[原文链接： blog.sessionstack.com转载：https://www.zcfy.cc/article/under-the-hood-of-css-and-js-animations-how-to-optimize-their-performance 这是致力于探索 JavaScript 及其组件的系列文章中的第 13 篇。在找寻与介绍这些核心组件的过程中，我们也分享了我们在开发SessionStack时的一些规则（SessionStack 是一个用来帮助用户实时发现与重现其应用弱点的 JavaScript 应用，因此非常注重鲁棒性与高性能。）如果你没看过之前的文章，可以看一下这里： 引擎、运行时、调用栈的介绍 Google’s V8 引擎内部 + 如何写优化过代码的5个贴士 内存管理 + 处理 4 种常见的内存泄漏 异步编程中的 event loop + 5 个写更好的 async/await 的方法 深入了解 WebSockets 和 HTTP/2与SSE +如何选择正确的方法 对 WebAssembly 的比较 + 为什么在某些情况下，它比JavaScript更好 Web Workers 的组成 + 5 个使用场景 Service Workers 的生命周期与使用场景 Web 推送通知的机制 使用 MutationObserver 来追踪 DOM 变化 渲染引擎与优化性能小贴士 在网络层之下 + 如何提高网络层的性能与安全性概览正如大家所知，动画在创建引人注目的 web 应用程序中扮演着重要的角色。随着用户越来越多地将注意力转移到用户体验上，企业开始意识到完美无缺、令人愉快的用户体验的重要性，web应用程序变得越来越重，并具有更动态的UI。这一切都需要更复杂的动画，以便在在用户的整个使用过程中更流畅地进行状态转换 —— 今天，这甚至被认为不是什么特别的事情。用户正变得越来越高级，默认情况下，他们期望具有快速响应和交互性棒的用户界面。然而，让你的界面动起来并不一定是简单的。什么交互需要动画，什么时候应该动画，动画应该有什么样的感觉，这些都是棘手的问题。JavaScript 动画 vs CSS 动画创建web动画的两种主要方法是使用JavaScript和CSS，两者本身没有对与错。所以这种 PK 完全取决于你想实现什么。CSS 动画想让屏幕上东西动起来的话，最简单的方法就是 CSS 动画。我们从一个小例子开始：把一个元素在 X 和 Y 轴上都位移 50px，通过 CSS transition 来设置一个 1000ms 的动画当 move class 被添加上时，transform 值被改变，运动开始了除了过渡时间（transition duration），还有一个 缓动（easing） 选项，这就完成了动画了。我们将会在下面进一步介绍缓动如果您像上面的代码片段一样创建单独的CSS类来管理动画，那么您可以使用JavaScript来切换每个动画。如果你有以下元素:然后你可以使用JavaScript来切换每个动画的开关:上面的代码片段获取box类的所有元素，并添加move类以触发动画。这样做会给你的应用提供很好的平衡。您可以专注于使用JavaScript管理状态，并简单地在目标元素上设置适当的类，让浏览器处理动画。然后，您可以侦听元素上的transitionend事件，但前提是您能够放弃对Internet Explorer旧版本的支持：侦听在转换结束时触发的转换事件，如下所示：除了使用CSS转换，您还可以使用CSS动画（animation），这允许您对单个动画关键帧（keyframes）、持续时间和迭代（iterations）有更多的控制。 关键帧用于指示浏览器在给定的点上CSS属性需要具有哪些值，并填补空白。 让我们看一个例子:这是它的样子(quick demo)—— https://sessionstack.github.io/blog/demos/keyframes/使用CSS动画，您可以将定义动画与元素本身分离开，并使用animation-name属性选择所需的动画。CSS动画有时还需要加供应商前缀，在Safari、Safari Mobile和Android中使用-webkit。Chrome、Opera、Internet Explorer和Firefox都没有前缀。许多工具可以帮助您创建所需CSS的前缀版本，允许您在源文件中编写无前缀版本。 JavaScript 动画与使用CSS转换或动画相比，使用JavaScript创建动画更加复杂，但它通常会为开发人员提供更强大的功能。JavaScript动画是作为代码的一部分编写的。您还可以将它们封装在其他对象中。要重新创建前面描述的CSS转换，可以用 JavaScript 这么搞：默认情况下，Web动画只修改元素的表示。如果您想让您的对象保持在它被移动到的位置，那么您应该在动画完成时修改它的底层样式。这就是为什么我们在上面的例子中监听 finish 事件，并设置 box.style。将属性转换为相等的translate(150px, 200px)，这与动画执行的第二个转换相同。使用JavaScript动画，您可以在每一步完全控制元素的样式。这意味着您可以减慢动画、暂停动画、停止动画、反转动画，并根据需要操作元素。如果您正在构建复杂的、面向对象的应用程序，这尤其有用，因为这时你往往需要对动画有一个更好的封装。 缓动是什么？更自然的动效能让用户对你的web应用程序感到更舒服，从而带来更好的用户体验。在大自然中，其实没有什么东西是从一点线性地移动到另一点的。事实上，因为我们不是在真空中，会有不同的因素导致物体在我们周围的物理世界中运动时会加速或减速。人类的大脑天生就期待这种运动，所以当你在为网络应用程序制作动画时，你应该充分理解这一点。有一些术语你需要理解: “ease in” — 这是一个开始缓慢，然后加速的运动。 “ease out” —这是一个开始很快，然后减速的运动 这两者可以组合在一起，例如 “ease in out”.缓动让你的动画看起来更自然。 缓动的关键词CSS转换和动画允许您选择您想要使用的缓动类型。有不同的关键字影响缓动效果。你也可以完全定制自己的缓动动画。下面是一些你可以在CSS中使用的缓动关键字： linear（线性） ease-in（加速） ease-out（减速） ease-in-out（先加速后减速） 让我们把它们通读一遍，看看它们到底是什么意思。 Linear 动画没有任何缓动效果的动画称为线性（linear）动画。下面是线性变化的示意图：随着时间的推移，值均匀变大。线性运动时，物体往往会看起来不自然。一般来说，你应该避免线性运动。这是一个线性动画的简单实现: 减速(Ease-out) 动画正如前面提到的，与线性动画相比，缓动会使动画开始得更快，而在最后会变慢。它的示意图是这样的：一般来说，对于UI工作来说，减速缓动效果最好，因为快速的开始会给动画一种响应的感觉，而结尾的慢速则可以理解为是运动末尾的自然效果。有很多方法可以达到放松效果，但最简单的是CSS中的 easy-out 关键字: 1transition: transform 500ms ease-out; 加速(Ease-in)动画这与减速（ease-out）动画相反——开始慢，结束快。这是示意图：与减速缓动动画相比，加速缓动动画会给人一种不寻常的感觉，因为它们启动缓慢，会产生一种无响应的感觉。结束时运动很快也会让用户产生一种奇怪的感觉，因为现实世界中的物体在趋于停止时往往会减速。要使用加速缓动动画，与使用减速缓动与线性动画一样，你可以用如下关键字： 1transition: transform 500ms ease-in; （先加速后减速）Ease-in-out 动画这个动画是加速动画和减速动画的结合。示意图如下：不要让动画持续时间太长，因为这会让你的 UI 看起来像是没有响应。要使用先加速后减速动画, 可以使用如下关键字： 1transition: transform 500ms ease-in-out; 自定义缓动您可以定义自己的缓动曲线，以更好的控制缓动效果。事实上， ease-in, ease-out, linear, ease 关键字都是在 贝塞尔曲线（Bézier curves） 预定义好的, 这三个关键字对应的曲线在 CSS transitions specification 与 Web Animations specification 都有详细的说明 贝塞尔曲线（Bézier curves）让我们看看贝塞尔曲线的是怎么工作的。一条贝塞尔曲线需要四个值，或者更准确地说，它需要两对数字。每一对描述了贝塞尔曲线控制点的X和Y坐标。Bezier曲线的起始点坐标为(0,0)，结束点坐标为(1,1)。这两个控制点的X值必须在[0,1]范围内，而虽然规范没有明确具体是多少，但每个控制点的Y值是可以超过[0,1]限制的。即使每个控制点的X和Y值稍有变化，也会得到完全不同的曲线。让我们来看看两幅贝塞尔曲线的图形，这两幅曲线上的点虽然距离很近，但坐标不同。再看这个：如你所见，这两张图大相径庭。第一个控制点有(0.045,0.183)的向量差，第二个控制点有(-0.427，-0.054)的向量差。第二个曲线的CSS是这样的: 1transition: transform 500ms cubic-bezier(0.465, 0.183, 0.153, 0.946); 前两个数字是第一个控制点的X和Y坐标，后两个数字是第二个控制点的X和Y坐标。 性能优化动画应该保持60fps，否则会对用户体验造成负面影响。和世界上的其他事物一样，动画也不是没有代价的。动画的一些属性要比其他属性代价更小一些。例如，动画元素的宽度和高度会改变其几何形状，并可能导致页面上的其他元素移动或改变大小。这个过程称为布局。我们在之前的一篇文章中更详细地讨论了布局和渲染。通常，您应该避免动画的属性触发 reflow 或 repaint。对于大多数现代浏览器，这意味着将动画限制在了 opacity 和 transform 上。 Will-change您可以使用will-change通知浏览器您打算更改元素的属性。这允许浏览器在进行更改之前进行最适当的优化。但是，不要过度使用will-change，因为这样做会导致浏览器浪费资源，从而导致更多的性能问题。为 transforms 和 opacity 添加 will-change 如下所示: 123.box &#123; will-change: transform, opacity;&#125; 这项特性在 Chrome、Firefox和Opera 中都支持的很好。 在 JavaScript 与 CSS 中的选择你可能已经预料到了——这个问题没有正确答案。你只需要记住以下几件事： 基于css的动画，以及原生支持的Web动画，通常在名为“合成线程”的线程上处理。它不同于浏览器的“主线程”，在“主线程”中执行样式、布局、绘制和JavaScript。这意味着，如果浏览器在主线程上运行一些昂贵的任务，这些动画可以继续运行而不会被中断。 transforms 与 opacity 的变化，在很多情况下，也可以被合成线程来处理。 如果任何动画触发了 repaint 、reflow 或两者，则需要“主线程”来完成工作。无论动画基于CSS，还是基于 JavaScript，都是如此，repaint 或 reflow 的开销可能大过你的 CSS 和 JavaScript 执行逻辑，从而使动画本身变得毫无意义。 选择合适的东西来制作动画很棒的动画可以为你的用户添加乐趣和互动性。你可以对你喜欢的任何东西(无论宽度、高度、位置、颜色或背景)加动画，但你需要注意潜在的性能瓶颈。选择不当的动画会对用户体验产生负面影响，因此动画需要有效而适度。动画越少越好。动画只是为了让你的用户体验感觉自然，但不要过度动画。 使用动画来支持交互不要因为你能做就去做动画。相反，你的目的是使用巧妙的动画来加强用户交互。要避免你的动画不必要地打断或阻碍了用户活动。 避免动画的那些昂贵属性唯一比动画放置不当更糟的是那些导致页面卡顿的动画。这种类型的动画会让用户非常不爽。在SessionStack中使用动画非常简单。一般来说，我们遵循上面提到的实践，但是由于UI的复杂性，我们也有更多使用动画的场景。SessionStack必须将终端用户在浏览web应用程序时遇到问题时发生的一切重建为视频。为此，SessionStack 仅利用我们的库在会话期间收集的数据：用户事件、DOM更改、网络请求、异常、调试消息等。我们的播放器经过高度优化，能够正确呈现和使用收集到的所有数据，以便从视觉和技术角度对终端用户的浏览器及其中发生的一切进行像素级的完美模拟。为了确保复制的感觉是自然的，特别是在用户会话又长又重的情况下，我们使用动画来适当地指示加载/缓冲，并遵循关于如何实现它们的最佳实践，这样我们就不会占用太多CPU时间，让 event loop 保持空闲来呈现会话。如果你愿意，有一个免费的计划 试一试 sessionstack. 资源 https://developers.google.com/web/fundamentals/design-and-ux/animations/css-vs-javascript https://developers.google.com/web/fundamentals/design-and-ux/animations/ https://developers.google.com/web/fundamentals/design-and-ux/animations/animations-and-performance]]></content>
  </entry>
  <entry>
    <title><![CDATA[Flutter macOS 开发环境搭建笔记]]></title>
    <url>%2F2019%2F07%2F09%2Fyuque%2FFlutter%20macOS%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本文主要记录在 macOS 系统上搭建 Flutter 开发环境的过程，以及遇到的问题和解决办法，供大家参考。 1. 系统环境Flutter 同时支持在 Windows、macOS、Linux 等主流操作系统上进行开发，如下图所示：本文的环境搭建主要参考了官方的 Get started 教程，同时你也可以在 Flutter 中文网 或者 Flutter 中文开发者论坛 查阅相关中文翻译文档。我们这里进行实践的操作系统信息为： macOS Mojave 10.14 (64-bit) 2. 安装 Flutter 和 Dart SDK 2.1 网络环境在安装之前，先插个题外话，由于众所周知的原因，Google 提供的服务在中国大陆一直都是无法访问或者速度很慢，所以在下载一些资源时，我们通常需要翻墙或者选择一个与官方同步的可信的镜像站点作为替代。不过，Flutter 官方也很贴心地专门为中国用户写了一个教程，如何更快的下载资源、搭建环境以及执行 flutter 相关命令： Using Flutter in China 2.2 获取 Flutter根据 Flutter SDK Archive 页面的介绍，我们可以选择安装三种不同版本的 Flutter，分别如下： Dev channel：开发版本 Beta channel：测试版本 Master channel：最新版本，直接从 GitHub repo 中克隆获取最新的 SDK。 由于 Flutter 目前还没正式发布 Release 版本，所以我们建议选择相对比较稳定 Beta 版 SDK。在本文撰写的时候，最新的为 v0.10.2-beta，下载地址如下： https://storage.googleapis.com/flutter_infra/releases/beta/macos/flutter_macos_v0.10.2-beta.zip 但由于这个 URL 在国内下载特别慢（400+ MB），根据 Using Flutter in China 介绍，我们可以改成如下国内镜像地址进行下载，替换前缀为 https://storage.flutter-io.cn 即可： https://storage.flutter-io.cn/flutter_infra/releases/beta/macos/flutter_macos_v0.10.2-beta.zip2.3 安装 Flutter我们把上述下载的 flutter_macos_v0.10.2-beta.zip 拷贝到 $HOME/Flutter/ 目录下（可自行选择任意其他目录），然后进行解压： 12 $ cd ~/Flutter$ unzip ./flutter_macos_v0.10.2-beta.zip 此时，flutter 命令就在解压后的 flutter/bin 目录下。比如在我们这里，其完整路径为：$HOME/Flutter/flutter/bin/flutter。接下来，我们需要把 flutter 命令所在目录添加到系统的 PATH 变量中，方便后续在任何终端直接使用，而不用切换到特定目录。我们可直接在命令行中执行 export PATH=$PATH:$HOME/Flutter/flutter/bin，不过该命令只能在当前的终端窗口暂时设置 PATH 变量，关闭终端后就失效了。因此，要想永久地将 Flutter 添加到 PATH 中，需要在 $HOME 用户目录下的 .bashrc、.bash_profile 或者 .vimrc 等文件中（不同系统终端环境可能会不太一样）添加如上命令。由于我的 macOS 的终端环境使用的是 ZSH，所以我需要在 $HOME/.zshrc 文件中进行添加。此外，对于国内用户在使用 flutter 命令时，同样地，我们需要切换镜像源以加快速度，节省时间。根据文档，需要为此设置两个环境变量：PUB_HOSTED_URL 和 FLUTTER_STORAGE_BASE_URL，然后再运行 Flutter 命令行工具。这里推荐 Flutter 官方中文社区的镜像如下，当然我们可以选择其他的源。 12 export PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 综上，这里我们需要在 $HOME/.zshrc 文件中添加如下几行命令： 2.4 Dart SDK我们知道，Flutter 使用 Dart 语言进行开发应用程序，为了方便起见，我们下载的 Flutter SDK 已经同时包含了 Dart SDK，放在下面目录中： flutter/bin/cache/dart-sdk 3. 平台设置/编译环境在添加完 flutter 命令到 PATH 后，我们可以打开终端，在命令行中执行 flutter doctor，进行检查相关工具或者配置是否完整，我们第一次运行时，可能会得到如下图信息：我们看到一堆问题，接下来，我们只要根据上述结果和建议，一步步进行完善配置就好了。此外，macOS 支持为 iOS 和 Android 开发 Flutter 应用程序，所以我们同时也需要先完成这两个平台的相关编译环境配置，以便能够构建并运行第一个 Flutter Demo。 3.1 iOS 配置 安装 Xcode 9.0+ 或更新版本； 设置 iOS 模拟器； 安装 Homebrew、Cocoapod、Carthage 等 iOS 开发必要工具； 安装 iOS 真机调试工具： 12345 $ brew update$ brew install –HEAD usbmuxd$ brew link usbmuxd$ brew install –HEAD libimobiledevice$ brew install ideviceinstaller ios-deploy PS：如果你安装上述工具出行错误，请参考这个 issues，先卸载 usbmuxd 和 libimobiledevice 后重新安装，加上 –HEAD。 3.2 Android 配置 下载安装 Android Studio，然后启动根据“安装向导”进行相关初始化配置； 设置你的 Android 设备 设置 Android 模拟器 更详细的教程请参考官方 Platform setup，或者上述相关中文翻译文档。 4. 配置 IDE接下来我们需要配置一下 Flutter 的集成开发环境（IDE），以方便我们进行开发和调试。我们可以使用任何文本编辑器与命令行工具来构建 Flutter 应用程序。但这里推荐在 Android Studio、IntelliJ 或 VS Code 等优秀的编辑器上添加 Flutter 开发插件，即可获得代码自动补全，语法高亮，Widget 编辑助手，运行和调试的支持等一系列实用的功能。 4.1 命令行 创建工程 Create a new Flutter project in the specified directory. 1 flutter create 连接设备 List all connected devices. 1 flutter devices 运行工程 Run your Flutter application on an attached device or in an emulator. 1 flutter run [options] 4.2 Visual Studio CodeVS Code 是一个轻量级编辑器，支持 Flutter 运行和调试。 安装 VS Code 我们可以在这里下载并安装最新版本的 VS Code，本文安装的版本为 1.29.0 安装 Flutter 和 Dart 插件 启动 VS Code，在菜单栏中选择 View（查看）-&gt; Command Palette…（命令面板…），输入 ‘install’，然后选择 Extensions: Install Extension 安装扩展，接着在搜索框输入 ‘flutter’， 在搜索结果列表中选择 ‘Flutter’，点击 Install（安装），同时会自动安装 ‘Dart’ 依赖，最后重启 VS Code 即可生效。 验证配置 打开 View（查看）-&gt; Command Palette…（命令面板…），输入 ‘doctor’，然后选择 Flutter: Run Flutter Doctor，进行检查：查看 OUTPUT 窗口中的输出是否有问题，并按建议解决即可。至此，VS Code 的 Flutter 开发环境搭建好了。 4.3 Android StudioAndroid Studio 为 Flutter 提供了更加完整的 IDE 体验，毕竟它们都是 Google 的“亲儿子”。 安装 Android Studio 我们可以在这里下载并安装最新版本的 Android Studio（推荐 3.0+ 或更高版本），本文安装的版本为 3.2.1，此外 Android Studio 依赖 Java 环境，我们这里安装的 JDK 版本如下： Java 8 Update 191 (1.8.0_191-b12) 当然，我们也可以选择使用 IntelliJ IDEA。 安装 Flutter 和 Dart 插件 启动 Android Studio，打开插件设置（在 macOS 上为 Preferences -&gt; Plugins），然后选择 Browse repositories… 按钮，搜索 Flutter 插件，点击 Install（安装）此时会自动提示安装 Dart 插件，点击 Yes 接受即可。最后，重启 Android Studio，Flutter 开发环境就搭建好了。 4.4 大功告成当我们完成上面所有开发环境的配置，并通过 USB 连接上真机设备或者打开 iOS/Android 模拟器，然后再执行 flutter doctor 可得到如下结果，一切 OK 了： 5. Hello World这部分我们简单介绍一下如何创建一个 Flutter 的 Hello World 工程。上面提到，我们可以使用命令行、VS Code 或者 Android Studio/IntelliJ 等作为开发环境，综合比较，我们推荐 Android Studio。启动 Android Studio，如下图，选择 Start a new Flutter project（或者在菜单栏选择 File -&gt; New Flutter Project）接下来，我们可以参考官方的 Test drive 教程以及 Android Studio 的向导，创建工程，然后编译运行，并体验 Flutter 的热重载（Hot Reload），详见上述教程，我们这里不再赘述。这里需要注意的是，当我们在 Android Studio 创建新的 Flutter 工程，或者打开一个已有的 Flutter 工程时，可能会提示没有配置 Flutter 或者 Dart SDK 环境，如下图：此时，我们需要打开 Android Studio 的偏好设置（Preferences），手动配置相关路径。首先选择 Preferences -&gt; Languages &amp; Frameworks -&gt; Flutter，填写 Flutter SDK path，如下图所示，我们这里填写的路径为 $HOME/Flutter/flutter（取决于你 Flutter 的安装路径）：同样地，在左侧选中 Dart，然后填写 Dart SDK path，如下图，我们这里填写的路径为 $HOME/Flutter/flutter/bin/cache/dart-sdk（取决于你 Flutter 的安装路径）： 6. Flutter 相关资源 Flutter 官网：https://flutter.io/ Flutter GitHub 项目：https://github.com/flutter/flutter Flutter 社区中文资源（官方）：https://flutter-io.cn/ Flutter 中文网：https://flutterchina.club/ Flutter 中文开发者论坛：http://flutter-dev.cn/ Flutter 中文文档：http://doc.flutter-dev.cn/ Flutter 中文 CodeLabs：https://codelabs.flutter-io.cn/ Flutter 示例项目：https://itsallwidgets.com/ https://github.com/Solido/awesome-flutter https://github.com/awesome-tips/flutter-resources 转自：https://kangzubin.com/flutter-dev-env/]]></content>
  </entry>
  <entry>
    <title><![CDATA[10个流行的JavaScript面试题]]></title>
    <url>%2F2019%2F07%2F05%2Fyuque%2F10%E4%B8%AA%E6%B5%81%E8%A1%8C%E7%9A%84JavaScript%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1.如何理解 JS 中的this关键字？JS 初学者总是对 this 关键字感到困惑，因为与其他现代编程语言相比，JS 中的这this关键字有点棘手。 “this” 一般是表示当前所在的对象，但是事情并没有像它应该的那样发生。JS中的this关键字由函数的调用者决定，谁调用就this就指向哪个。如果找不到调用者，this将指向windows对象。来几个粟子第一个例子很简单。 调用 test对象中的 func()，因此func() 中的’this’指向的是 test 对象，所以打印的 prop 是 test 中的 prop，即 42。 12345678var test = &#123; prop: 42,func: function()&#123; return this.prop;&#125;, &#125;;console.log (test.func()); // 42复制代码 如果我们直接调用getFullname函数，第二个例子将打印出&#39;David Jones&#39;，因为此时 this 找不到调用者，所以默认就为 window 对象，打印的 fullname 即是全局的。 1234567891011121314var fullname = ‘David Jones’var obj =&#123;fullname: ‘Colin Brown’,prop:&#123; fullname:’Aurelio Deftch’, getFullname: function()&#123; return this.fullname; &#125; &#125;&#125;var test = obj.prop.getFullnameconsole.log(test()) // David Jonesobj.prop.getFullname() // ‘Aurelio Deftch’ 复制代码 2. 由于 this 关键字很混乱，如何解决这个问题有很多方法可以解决这个问题; 但是，无论你选择哪种解决方案，最重要的是要知道你决定让 this 指向哪个对象。一旦你弄清楚了this指向的对象，你就可以直接将它改成对象名。 否则，使用bind，call，apply函数也可以解决问题。 3.什么是闭包当我第一次解释闭包时，我常说函数中的函数;但是，它没有正确地描述闭包的确切含义。闭包是在另一个作用域内创建一个封闭的词法范围。它通常会自动返回来生成这个词法环境。这个环境由创建闭包时在作用域内的任何局部变量组成。它就像一个微型工厂，用这些原料生产出具有特定功能的产品。 123456789function add(n)&#123; var num = n return function addTo(x)&#123; return x + num &#125;&#125;addTwo = add(2)addTwo(5) 复制代码 闭包的另一个应用是创建私有变量和方法。JavaScript不像Java那样可以很好地支持oop。在JS中没有明确的方法来创建私有方法，但是闭包可以私有方法。 4.解释一下变量的提升变量的提升是JavaScript的默认行为，这意味着将所有变量声明移动到当前作用域的顶部，并且可以在声明之前使用变量。初始化不会被提升，提升仅作用于变量的声明。 1234var x = 1console.log(x + '——' + y) // 1——undefinedvar y = 2复制代码 5. JavaScript如何处理同步和异步情况尽管JavaScript是一种只有一个调用堆栈的单线程编程语言，但它也可以使用一个称为事件循环(event loop)的机制来处理一些异步函数。从基本级别了解JavaScript如何工作是理解JS如何处理异步的关键部分。如图所示，调用堆栈是定位函数的位置。一旦函数被调用，函数将被推入堆栈。然而，异步函数不会立即被推入调用堆栈，而是会被推入任务队列(Task Queue)，并在调用堆栈为空后执行。将事件从任务队列传输到调用堆栈称为事件循环。 6. 如何理解事件委托在DOM树上绑定事件监听器并使用JS事件处理程序是处理客户端事件响应的典型方法。 从理论上讲，我们可以将监听器附加到HTML中的任何DOM元素，但由于事件委派，这样做是浪费而且没必要的。** 什么是事件委托？这是一种让父元素上的事件监听器也影响子元素的技巧。 通常，事件传播（捕获和冒泡**）允许我们实现事件委托。 冒泡意味着当触发子元素（目标）时，也可以逐层触发该子元素的父元素，直到它碰到DOM绑定的原始监听器（当前目标）。 捕获属性将事件阶段转换为捕获阶段，让事件下移到元素; 因此，触发方向与冒泡阶段相反。 捕获的默认值为false。 7. 如何理解高阶函数JavaScript中的一切都是对象，包括函数。我们可以将变量作为参数传递给函数，函数也是如此。我们调用接受和或返回另一个函数称为高阶函数的函数。 8. 如何区分声明函数和表达式函数123456789// 声明函数function hello() &#123; return "HELLO"&#125; // 表达式函数 var h1 = function hello() &#123; return "HELLO"&#125;复制代码 两个函数将在不同的时期定义。在解析期间定义声明，在运行时定义表达式;因此，如果我们控制台打印 h1，它将显示HELLO。 9.解释原型继承是如何工作的JavaScript不是一种面向对象的友好编程语言，但它仍然使用继承的思想来实现依赖关系，并使用许多内置函数使其灵活使用。了解原型继承的工作原理将使你很好地理解JavaScript知识，从而避免概念上的误用。最好在大脑中描绘一下JavaScript的整个机制，以了解原型继承。JavaScript中有一个超级对象，所有对象都将从中继承。 &#39;__ proto__&#39;指向的对象的Prototype内部属性。 原型(prototype )包含一个构造函数，使对象能够从中创建实例。 __proto__始终存在于对象中，并且分层指向它所属的原型，直到null，这称为原型链。 10. 解释一下严格模式(strict mode)严格模式用于标准化正常的JavaScript语义。严格模式可以嵌入到非严格模式中，关键字 ‘use strict’。使用严格模式后的代码应遵循JS严格的语法规则。例如，分号在每个语句声明之后使用。 交流干货系列文章汇总如下，觉得不错点个Star，欢迎 加群 互相学习。 github.com/qq449245884… 链接：https://juejin.im/post/5d0976c66fb9a07efa091bcf]]></content>
  </entry>
  <entry>
    <title><![CDATA[js教程]]></title>
    <url>%2F2019%2F07%2F04%2Fyuque%2Fjs%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[JS 教程 JS 教程 JS 简介 JS 使用 JS 输出 JS 语句 JS 语法 JS 注释 JS 变量 JS 运算符 JS 算数 JS 赋值 JS 数据类型 JS 函数 JS 对象 JS 事件 JS 字符串 JS 字符串方法 JS 数字 JS 数字方法 JS 数组 JS 数组方法 JS 数组排序 JS 数组迭代 JS 日期 JS 日期格式 JS 日期获取方法 JS 日期设置方法 JS 数学 JS 随机 JS 逻辑 JS 比较 JS 条件 JS Switch JS Loop For JS Loop While JS Break JS 类型转换 JS 位运算 JS 正则表达式 JS 异常 JS 作用域 JS Hoisting JS 严格模式 JS this 关键词 JS Let JS Const JS 调试 JS 样式指南 JS 最佳实践 JS 错误 JS 性能 JS 保留词 JS 版本 JS 版本 ES5 JS 版本 ES6 JS JSON JS 表单 JS 表单 JS 表单 API JS 对象 JS 对象定义 JS 对象属性 JS 对象方法 JS 对象访问器 JS 对象构造器 JS 对象原型 JS ECMAScript 5 JS 函数 JS 函数定义 JS 函数参数 JS 函数调用 JS 函数 Call JS 函数 Apply JS 闭包 JS HTML DOM DOM 简介 DOM 方法 DOM 文档 DOM 元素 DOM HTML DOM CSS DOM 动画 DOM 事件 DOM 事件监听程序 DOM 导航 DOM 节点 DOM 集合 DOM 节点列表 JS Browser BOM JS Window JS Screen JS Location JS History JS Navigator JS 弹出框 JS Timing JS Cookies JS AJAX AJAX 简介 AJAX XMLHttp AJAX 请求 AJAX 响应 AJAX XML 文件 AJAX PHP AJAX ASP AJAX 数据库 AJAX 应用程序 AJAX 实例 JS JSON JSON 简介 JSON 语法 JSON vs XML JSON 数据类型 JSON 解析 JSON 字符串化 JSON 对象 JSON 数组 JSON PHP JSON HTML JSON JSONP JS vs jQuery jQuery 选择器 jQuery HTML jQuery CSS jQuery DOM JS 实例 JS 实例 JS HTML DOM JS HTML 输入 JS HTML 对象 JS HTML 事件 JS Browser JS 测验 JS 参考手册 JavaScript 对象 HTML DOM 对象 建站手册 网站构建 万维网联盟 (W3C) 浏览器信息 网站品质 语义网 职业规划 网站主机 关于 W3School 帮助 W3School 广告刊例 JavaScript 特殊字符 你可以在 JavaScript 中使用反斜杠来向文本字符串添加特殊字符。 插入特殊字符反斜杠用来在文本字符串中插入省略号、换行符、引号和其他特殊字符。请看下面的 JavaScript 代码：var txt=”We are the so-called &quot;Vikings&quot; from the north.”document.write(txt)在 JavaScript 中，字符串使用单引号或者双引号来起始或者结束。这意味着上面的字符串将被截为：We are the so-called。要解决这个问题，就必须把在 “Viking” 中的引号前面加上反斜杠 ()。这样就可以把每个双引号转换为字面上的字符串。var txt=”We are the so-called \&quot;Vikings\&quot; from the north.”document.write(txt)现在 JavaScript 就可以输出正确的文本字符串了：We are the so-called “Vikings” from the north。这是另一个例子：document.write (“You \&amp; me are singing!”) 上面的例子会产生以下输出：You &amp; me are singing!下面的表格列出了其余的特殊字符，这些特殊字符都可以使用反斜杠来添加到文本字符串中： 代码 输出 \‘ 单引号 \“ 双引号 \&amp; 和号 \\ 反斜杠 \n 换行符 \r 回车符 \t 制表符 \b 退格符 \f 换页符 JavaScript 参考手册 JavaScript 实例 JavaScript 测验]]></content>
  </entry>
  <entry>
    <title><![CDATA[从头开始创建一个 React 应用]]></title>
    <url>%2F2019%2F07%2F04%2Fyuque%2F%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%20React%20%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[并不详细介绍 React 的写法。主要内容是：如何从无到有，创建并运行起来一个 React 应用。 React 简介一句话介绍： React 是用于构建用户界面的 JavaScript 库。针对的是 View 层。虽然 React 只是视图层的一个 Library，但并非开箱即用。React 使用了很多较新的语法和关键字，浏览器并不完全支持。要使用 React 就必须将这些内容做一下处理。这样才能在浏览器下运行起来我们创建的 React 应用。 create-react-appReact 官方提供了一个脚手架用于初始化React项目，使用 create-react-app 可以简化手动设置流程。 官方网站的 Tutorial 也是以此为例。 123456789# 安装 create-react-app 并创建 my-app 项目$ npm install -g create-react-app$ create-react-app my-app# 或者# npm版本在5.2.0+ 可以使用 npx 命令，简洁 $ npx create-react-app my-app# 进入项目目录，启动项目$ cd my-app$ npm start 执行命令结束后信息使用 create-react-app ，你只需要执行命令之后等待安装完依赖，就可以创建一个已经配置好的 React 应用程序，并可以基于此开始你的项目开发。这对新手无疑是很友好的。如果你希望在老项目中引入 React，或着探究 React 到底是怎么运行起来的。那就需要自己动手来配置了。我们使用 Babel 和 Webpack 来解决这个问题。 新建项目我们先使用 npm init 和 git init 来初始化一个项目，然后增加下面三个文件夹： 1234.+-- dist+-- public+-- src 在 public 目录中，存放所有静态资源。其中需要新建一个 index.html 文件，并写入如下内容（下面的HTML内容拷贝自 React 官方文档，并做了一些非常小的修改）： 12345678910111213141516&lt;!-- sourced from https://raw.githubusercontent.com/reactjs/reactjs.org/master/static/html/single-file-example.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt; &lt;title&gt;React Starter&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;noscript&gt; You need to enable JavaScript to run this app. &lt;/noscript&gt; &lt;script src=&quot;../dist/bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 需要注意的是上面内容的第十行（为什么没有行数。。。假装有），也就是 1&lt;div id=&quot;root&quot;&gt;&lt;/div&gt; 这是 React 应用通过JS插入 DOM 结构的根节点。它会在配置 React 入口文件的时候用到。还有第十四行 引入了一个名为 bundle 的 js 文件。 1&lt;script src=&quot;../dist/bundle.js&quot;&gt;&lt;/script&gt; 这是 React 通过 webpack 打包后最终输出的文件，名字随意。不过本教程中我们使用 bundle。现在我们已经配置好了 HTML 内容。接下来还有更多配置。首先，为了保证我们编写的 React 代码可以编译为浏览器可执行的代码，我们需要使用 Babel做编译工作。 Babel这里解释一下 Babel 起到什么作用：为了更好的在模块化开发，避免模板和组件分离，减少复杂性。 React 使用 JSX 语法，将 HTML 模板直接嵌入到了 JS 代码里面，这样就做到了模板和组件关联。但是 JS 不支持这种包含 HTML 的语法，所以需要通过工具将 JSX 编译输出成 JS 代码才能使用。而 Babel 就是我们使用的 编译 工具（不仅转换JSX，还有 ES6+ 语法等）关于 Babel 的安装和配置可以查看我之前的一篇笔记：在此处，我们需要安装： 1$ npm install --save-dev babel-core@6.26.0 babel-cli@6.26.0 babel-preset-env@1.6.1 babel-preset-react@6.24.1 因为后续会用到 webpack 。所以此处安装了 babel-core。而这个包也正是主要用来转换我们 React 代码的 Babel 包。然后在项目根目录下创建 .babelrc， 配置如下： 123&#123; &quot;presets&quot;: [&quot;env&quot;, &quot;react&quot;]&#125; env 和 react 预设集分别用于转换 ES6+ 和 React 代码。Babel 就这么简单带过，实际内容也不是很难，比较好理解。 Webpack如果对 webpack 没有概念，需要先去了解一下。一些关于 webpack 的入门内容也可以查看我的另一篇学习笔记：配置 webpack。我们需要安装如下依赖包： 1npm install --save-dev webpack@4.6.0 webpack-cli@2.0.14 webpack-dev-server@3.1.3 style-loader@0.21.0 css-loader@0.28.11 babel-loader@7.1.4 其中 webpack-dev-server 是为了方便开发过程，将我们的项目在未打包前运行在一个开发服务器上，并且可以配置 修改代码后重新加载页面，这样可以在浏览器中即时反馈代码的修改。style-loader css-loader babel-loader 用于加载处理打包过程中 css 和 js 等文件。其中 babel-loader 将 webpack 和之前安装的 babel 结合起来，将 JSX 语法的 js 文件转化后再打包。 安装之后在项目根目录下创建 webpack.config.js 文件，配置如下： 12345678910111213141516171819202122232425262728293031const path = require(&quot;path&quot;);const webpack = require(&quot;webpack&quot;);const bundlePath = path.resolve(__dirname, &quot;dist/&quot;);module.exports = &#123; entry: &quot;./src/index.js&quot;, module: &#123; rules: [ &#123; test: /\.(js|jsx)$/, exclude: /(node_modules|bower_components)/, loader: &apos;babel-loader&apos;, options: &#123; presets: [&apos;env&apos;] &#125; &#125;, &#123; test: /\.css$/, use: [ &apos;style-loader&apos;, &apos;css-loader&apos; ] &#125; ] &#125;, resolve: &#123; extensions: [&apos;*&apos;, &apos;.js&apos;, &apos;.jsx&apos;] &#125;, output: &#123; publicPath: bundlePath, filename: &quot;bundle.js&quot; &#125;, devServer: &#123; contentBase: path.join(__dirname,&apos;public&apos;), port: 3000, publicPath: &quot;http://localhost:3000/dist&quot; &#125;, plugins: [ new webpack.HotModuleReplacementPlugin() ]&#125;; 此处不再详解每个配置项。补充一下之前学习笔记中没有提到的内容。rules 下的 exclude 字段：用来配置需要排除（不去这些目录下寻找 test 字段正则匹配的文件）的目录或文件resolve 字段：指定 webpack 可以解析哪些拓展名的文件，配置后可以在 文件引入时不带拓展名。devServer 字段： 配置开发服务器，指定服务在本地运行的端口、根目录、静态资源实际目录等。最后 plugins 字段里，我们加入了一个 Hot Module Replacement 插件的实例。这个用于 热更新，避免每次代码修改后刷新页面。 两个保证 React 运行起来的工具到此就配置完成了。接下来就是 React 方面的配置。 React安装 react 和 react-dom： 1$ npm install --save react@16.3.2 react-dom@16.3.2 安装完成后，我们需要在 src 目录下新建一个 React 应用程序的入口文件 index.js。我们需要在这个文件中告诉 React 在哪里插入你想渲染的页面。这个文件十分简单，不过也可以做更多配置。 1234567import React from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;import App from &quot;./App.js&quot;;ReactDOM.render( &lt;App /&gt;, document.getElementById(&quot;root&quot;)); ReactDOM.render是一个函数，它会告诉 React 渲染什么以及在哪里渲染它：此处我们渲染了一个名 App 组件（接下来会创建这个组件）。渲染的位置是 ID 为 ‘root’ 的DOM元素。还记得前面我们单独提到的 public/index.html 文件中的第十行。也就是这个 div 元素： 1&lt;div id=&quot;root&quot;&gt;&lt;/div&gt; 这就是 React 要渲染的位置。现在我们在相同的 src 目录下创建 App.js 文件，并插入如下代码（如果你使用 create-react-app 脚手架，此部分应该很熟悉）： 123456789101112import React, &#123; Component&#125; from &quot;react&quot;import &quot;./App.css&quot;class App extends Component&#123; render()&#123; return( &lt;div className=&quot;App&quot;&gt; &lt;h1&gt; Hello, World! &lt;/h1&gt; &lt;/div&gt; ) &#125;&#125;export default App 我们看到这里使用 import 引入了一个 css 文件。我们之前使用 webpack 做了相应的配置，所以可以将 css 文件当做模块引入进来（当然也可以使用scss，相应的配置webpack就好）。接下来在 src 目录下继续创建 App.css文件，并插入如下代码： 1234.App &#123; margin: 1rem; font-family: Arial, Helvetica, sans-serif;&#125; 最后你的目录将会是这样的： 1234567891011.+-- public| +-- index.html+-- src| +-- App.css| +-- App.js| +-- index.js+-- .babelrc+-- package-lock.json+-- package.json+-- webpack.config.js 到此我们手动完成了整个 React 项目从无到有的创建。现在可以使用 webpack-dev-server –mode development 命令来运行这个项目。不过我建议将这个命令配置到 package.json 中，使用 npm start 命令启动项目。你可能会发现 执行命令以后 dist 文件夹下并没有内容产生。那是因为 devServer 生成的文件会直接放在内存中运行，当服务关闭时，这些文件就随之消失了。如果需要生成打包后的文件，可以配置一个 npm 的 build 命令为：webpack –mode production这样执行 npm run build 后就可以在 dist 文件夹下看到文件了。 总结在我是个特别新的新手的时候，我只会使用各种框架提供的 CLI 来创建一个新的项目。一度对各种概念很是疑惑，不得其解。通过对 babel 、webpack 等工具了解、使用之后，算是对这一套东西在脑子里有了一个粗浅的系统概念。整个配置过程并不复杂，不过涉及了两个工具可能会让新手疑惑。而且这些配置仅仅是支撑起 React 运行起来，还有更多深入的配置需要学习和探索。 参考文章：Creating a React App… From Scratch —— Jedai SaboteurTutorial —— React Create React App 中文文档]]></content>
  </entry>
  <entry>
    <title><![CDATA[create-react-app创建的项目中registerServiceWorker.js文件的作用]]></title>
    <url>%2F2019%2F07%2F04%2Fyuque%2Fcreate-react-app%E5%88%9B%E5%BB%BA%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%B8%ADregisterServiceWorker.js%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[使用React官方的脚手架工具create-react-app创建的项目，目录中会存在registerServiceWorker.js这个文件，这个文件的作用是什么呢？这个文件可以使用也可以不使用，使用它可以使你的react项目变成一个PWA（Progressive Web Application）, 也就是说，在线上，只要访问过一次你的网站，下一次即使没有网络，这个应用依然可以被访问。当然，它的好处不仅这么一点点，在移动端打开项目时，如果你用的是chrome或者firefox这样的高级浏览器，浏览器会给你的页面不太一样的显示，你的网页看起来会更像原生App，实际上体验也更爽。在项目的public目录下，存在一个manifest.json文件，你可以在这里对你的网页做一些配置，当用户访问网页，生成一个网页的桌面快捷方式时，会以这个文件中的内容作为图标和文字的显示内容。配置好manifest.json, 使用registerServiceWorker.js，用户完全可以把你的网页快捷方式放到桌面上，因为你的网页此时支持离线访问，所以用起来和原生app的体验很接近。大家可以做这样一个试验： 创建一个项目 运行npm run build 然后在本地开一个服务器，把build目录中的内容放在服务器的根目录下 通过localhost的域名访问服务器 访问过一次之后，断掉网络，重新访问 你会发现，即使没有网络，这个时候依然可以访问你的应用。需要注意的是，只有打包生成线上版本的react项目时，registerServiceWorker.js才会有效。本地开发时，这个文件没什么效果，因为如果本地开发使用这个文件，有可能会因为缓存造成调试问题。还需要注意的是，项目在本地，通过localhost域名访问，支持http协议。如果真正放到线上，如果想让registerServiceWorker.js生效，服务器必须采用https协议，这也是为什么很多同学本地测试好用，线上就不好用的原因。registerServiceWorker.js中的这些功能，并不是React所独创的内容，而是React对PWA的一个实现，PWA未来的发展前景不错，从扩展视野角度也值得大家一看，如果你想了解更多，可以访问PWA的官方手册，这里讲解了PWA底层关于serviceWorker很多的内容，非常有趣：https://codelabs.developers.google.com/codelabs/your-first-pwapp/#0codelabs.developers.google.com发布于 2018-02-08React渐进式网络应用程序（PWA）]]></content>
  </entry>
  <entry>
    <title><![CDATA[RxJS]]></title>
    <url>%2F2019%2F07%2F04%2Fyuque%2FRxJS%2F</url>
    <content type="text"><![CDATA[官网github地址：https://github.com/ReactiveX/rxjs 异步复杂度要到什么程度才需要用到Rxjs？给大家介绍一个很直观的网站，用动画的方式演示了大部分Rxjs的Operator的执行过程，以及功能相似的Operator之间的比较。https://reactive.how/RxJS至于event,就像以前Jquery至于dom，lodash/underscore至于data。现在Jquery和lodash/underscore可以完全ES6+代替了。 用具体的实现例子去实现 RxJS, 原文地址 An Animated Intro to RxJS | CSS-Tricks hi 我也是初学者 来分享一点自己的心得1. 从【能解决什么问题】开始学习rx到底是解决什么问题，是怎么解决得更好等等，来建立对rx的基本认识途径: 百度，google，stackoverflow搜索2. 从【一个简单可运行的demo】开始学习rx基本用法途径-1: Hello RxJS系列（分享自知乎网）知乎专栏作者@太狼 途径-2: githun搜索rx demo3. 【官网】开始学习rx 基本几大概念，api和用法等。最好每个api都动手做一做，下面分享的第二个网站有每个api的效果图。(我有些是边翻译边看哈哈)分享-1: rx5.x官网http://reactivex.io/rxjs/manual/overview.html分享-2: api效果图网RxJS - Javascript library for functional reactive programming.4. 【进阶】学习更多实际用途与基本原理途径：angular2表单监控，angular2 http等5. 【实战】开始用rxjs动手做个完整项目或者在根据项目情况中考虑加入rx完 构建流式应用—RxJS详解原文地址最近在 Alloyteam Conf 2016 分享了《使用RxJS构建流式前端应用》，会后在线上线下跟大家交流时发现对于 RxJS 的态度呈现出两大类:有用过的都表达了 RxJS 带来的优雅编码体验，未用过的则反馈太难入门。所以，这里将结合自己对 RxJS 理解，通过 RxJS 的实现原理、基础实现及实例来一步步分析，提供 RxJS 较为全面的指引，感受下使用 RxJS 编码是怎样的体验。 目录 常规方式实现搜索功能 RxJS · 流 Stream RxJS 实现原理简析 观察者模式 迭代器模式 RxJS 的观察者 + 迭代器模式 RxJS 基础实现 Observable Observer RxJS · Operators Operators ·入门 一系列的 Operators 操作 使用 RxJS 一步步实现搜索功能 总结 常规方式实现搜索做一个搜索功能在前端开发中其实并不陌生，一般的实现方式是：监听文本框的输入事件，将输入内容发送到后台，最终将后台返回的数据进行处理并展示成搜索结果。 var text = document.querySelector('#text'); text.addEventListener('keyup', (e) =>{ var searchText = e.target.value; // 发送输入内容到后台 $.ajax({ url: search.qq.com/${searchText}, success: data => { // 拿到后台返回数据，并展示搜索结果 render(data); } }); });上面代码实现我们要的功能，但存在两个较大的问题： 多余的请求当想搜索“爱迪生”时，输入框可能会存在三种情况，“爱”、“爱迪”、“爱迪生”。而这三种情况将会发起 3 次请求，存在 2 次多余的请求。 已无用的请求仍然执行一开始搜了“爱迪生”，然后马上改搜索“达尔文”。结果后台返回了“爱迪生”的搜索结果，执行渲染逻辑后结果框展示了“爱迪生”的结果，而不是当前正在搜索的“达尔文”，这是不正确的。 减少多余请求数，可以用 setTimeout 函数节流的方式来处理，核心代码如下 var text = document.querySelector('#text'), timer = null; text.addEventListener('keyup', (e) =>{ // 在 250 毫秒内进行其他输入，则清除上一个定时器 clearTimeout(timer); // 定时器，在 250 毫秒后触发 timer = setTimeout(() => { console.log('发起请求..'); },250) })已无用的请求仍然执行的解决方式，可以在发起请求前声明一个当前搜索的状态变量，后台将搜索的内容及结果一起返回，前端判断返回数据与当前搜索是否一致，一致才走到渲染逻辑。最终代码为 var text = document.querySelector('#text'), timer = null, currentSearch = ''; text.addEventListener(&apos;keyup&apos;, (e) =&gt;{&lt;br /&gt; clearTimeout(timer)&lt;br /&gt; timer = setTimeout(() =&gt; {&lt;br /&gt; // 声明一个当前所搜的状态变量&lt;br /&gt; currentSearch ＝ &apos;书&apos;; var searchText = e.target.value;&lt;br /&gt; $.ajax({&lt;br /&gt; url: `search.qq.com/${searchText}`,&lt;br /&gt; success: data =&gt; {&lt;br /&gt; // 判断后台返回的标志与我们存的当前搜索变量是否一致&lt;br /&gt; if (data.search === currentSearch) {&lt;br /&gt; // 渲染展示&lt;br /&gt; render(data);&lt;br /&gt; } else {&lt;br /&gt; // ..&lt;br /&gt; }&lt;br /&gt; } &lt;br /&gt; });&lt;br /&gt; },250)&lt;br /&gt; })&lt;br /&gt;&lt;/script&gt;&lt;br /&gt;上面代码基本满足需求，但代码开始显得乱糟糟。我们来使用 RxJS 实现上面代码功能，如下&lt;br /&gt;var text = document.querySelector(&apos;#text&apos;);&lt;br /&gt;var inputStream = Rx.Observable.fromEvent(text, &apos;keyup&apos;)&lt;br /&gt; .debounceTime(250)&lt;br /&gt; .pluck(&apos;target&apos;, &apos;value&apos;)&lt;br /&gt; .switchMap(url =&gt; Http.get(url))&lt;br /&gt; .subscribe(data =&gt; render(data));&lt;br /&gt;可以明显看出，**基于 RxJS 的实现，代码十分简洁！** RxJS · 流 StreamRxJS 是 Reactive Extensions for JavaScript 的缩写，起源于 Reactive Extensions，是一个基于可观测数据流在异步编程应用中的库。RxJS 是 Reactive Extensions 在 JavaScript 上的实现，而其他语言也有相应的实现，如 RxJava、RxAndroid、RxSwift 等。学习 RxJS，我们需要从可观测数据流(Streams)说起，它是 Rx 中一个重要的数据类型。流是在时间流逝的过程中产生的一系列事件。它具有时间与事件响应的概念。下雨天时，雨滴随时间推移逐渐产生，下落时对水面产生了水波纹的影响，这跟 Rx 中的流是很类似的。而在 Web 中，雨滴可能就是一系列的鼠标点击、键盘点击产生的事件或数据集合等等。 RxJS 基础实现原理简析对流的概念有一定理解后，我们来讲讲 RxJS 是怎么围绕着流的概念来实现的，讲讲 RxJS 的基础实现原理。RxJS 是基于观察者模式和迭代器模式以函数式编程思维来实现的。 观察者模式观察者模式在 Web 中最常见的应该是 DOM 事件的监听和触发。 订阅：通过 addEventListener 订阅 document.body 的 click 事件。 发布：当 body 节点被点击时，body 节点便会向订阅者发布这个消息。 document.body.addEventListener('click', function listener(e) { console.log(e);},false); document.body.click(); // 模拟用户点击将上述例子抽象模型，并对应通用的观察者模型 迭代器模式迭代器模式可以用 JavaScript 提供了 Iterable Protocol 可迭代协议来表示。Iterable Protocol 不是具体的变量类型，而是一种可实现协议。JavaScript 中像 Array、Set 等都属于内置的可迭代类型，可以通过 iterator 方法来获取一个迭代对象，调用迭代对象的 next 方法将获取一个元素对象，如下示例。var iterable = [1, 2]; var iterator = iterableSymbol.iterator; iterator.next(); // => { value: "1", done: false}iterator.next(); // => { value: "2", done: false} iterator.next(); // => { value: undefined, done: true}元素对象中：value 表示返回值，done 表示是否已经到达最后。遍历迭代器可以使用下面做法。var iterable = [1, 2];var iterator = iterableSymbol.iterator; while(true) { let result; try { result = iterator.next(); // { observer.next(2); observer.complete(); return () => console.log('disposed');}); 创建 ObserverObserver 可以声明 next、err、complete 方法来处理流的不同状态。var Observer = Rx.Observer.create( x => console.log('Next:', x), err => console.log('Error:', err), () => console.log('Completed'));最后将 Observable 与 Observer 通过 subscribe 订阅结合起来。var subscription = Observable.subscribe(Observer);RxJS 中流是可以被取消的，调用 subscribe 将返回一个 subscription，可以通过调用 subscription.unsubscribe() 将流进行取消，让流不再产生。看了起来挺复杂的？换一个实现形式：// @Observables 创建一个 Observablesvar streamA = Rx.Observable.of(2); // @Observer streamA$.subscribe(Observer)streamA.subscribe(v => console.log(v));将上面代码改用链式写法，代码变得十分简洁：Rx.Observable.of(2).subscribe(v => console.log(v)); RxJS · Operators 操作 Operators 操作·入门Rx.Observable.of(2).subscribe(v => console.log(v));上面代码相当于创建了一个流(2)，最终打印出2。那么如果想将打印结果翻倍，变成4，应该怎么处理呢？方案一?： 改变事件源，让 Observable 值 X 2Rx.Observable.of(2 * 2 /* console.log(v));方案二?： 改变响应方式，让 Observer 处理 X 2Rx.Observable.of(2).subscribe(v => console.log(v * 2 / v * 2) / console.log(v));map 操作跟数组操作的作用是一致的，不同的这里是将流进行改变，然后将新的流传出去。在 RxJS 中，把这类操作流的方式称之为 Operators(操作)。RxJS提供了一系列 Operators，像map、reduce、filter 等等。操作流将产生新流，从而保持流的不可变性，这也是 RxJS 中函数式编程的一点体现。关于函数式编程，这里暂不多讲，可以看看另外一篇文章 《谈谈函数式编程》到这里，我们知道了，流从产生到最终处理，可能经过的一些操作。即 RxJS 中 Observable 将经过一系列 Operators 操作后，到达 Observer。Operator1 Operator2Observable ----|-----------|-------> Observer 一系列的 Operators 操作RxJS 提供了非常多的操作，像下面这些。Aggregate,All,Amb,ambArray,ambWith,AssertEqual,averageFloat,averageInteger,averageLong,blocking,blockingFirst,blockingForEach,blockingSubscribe,Buffer,bufferWithCount,bufferWithTime,bufferWithTimeOrCount,byLine,cache,cacheWithInitialCapacity,case,Cast,Catch,catchError,catchException,collect,concatWith,Connect,connect_forever,cons,Contains,doAction,doAfterTerminate,doOnComplete,doOnCompleted,doOnDispose,doOnEach,doOnError,doOnLifecycle,doOnNext,doOnRequest,dropUntil,dropWhile,ElementAt,ElementAtOrDefault,emptyObservable,fromNodeCallback,fromPromise,fromPublisher,fromRunnable,Generate,generateWithAbsoluteTime,generateWithRelativeTime,Interval,intervalRange,into,latest (Rx.rb version of Switch),length,mapTo,mapWithIndex,Materialize,Max,MaxBy,mergeArray,mergeArrayDelayError,mergeWith,Min,MinBy,multicastWithSelector,nest,Never,Next,Next (BlockingObservable version),partition,product,retryWhen,Return,returnElement,returnValue,runAsync,safeSubscribe,take_with_time,takeFirst,TakeLast,takeLastBuffer,takeLastBufferWithTime,windowed,withFilter,withLatestFrom,zipIterable,zipWith,zipWithIndex关于每一个操作的含义，可以查看官网进行了解。operators 具有静态（static）方法和实例（ instance）方法，下面使用 Rx.Observable.xx 和 Rx.Observable.prototype.xx 来简单区分，举几个例子。Rx.Observable.ofof 可以将普通数据转换成流式数据 Observable。如上面的 Rx.Observable.of(2)。Rx.Observable.fromEvent除了数值外，RxJS 还提供了关于事件的操作，fromEvent 可以用来监听事件。当事件触发时，将事件 event 转成可流动的 Observable 进行传输。下面示例表示：监听文本框的 keyup 事件，触发 keyup 可以产生一系列的 event Observable。var text = document.querySelector('#text');Rx.Observable.fromEvent(text, 'keyup') .subscribe(e => console.log(e));Rx.Observable.prototype.mapmap 方法跟我们平常使用的方式是一样的，不同的只是这里是将流进行改变，然后将新的流传出去。上面示例已有涉及，这里不再多讲。Rx.Observable.of(2) .map(v => 10 * v) .subscribe(v => console.log(v));Rx 提供了许多的操作，为了更好的理解各个操作的作用，我们可以通过一个可视化的工具 marbles 图 来辅助理解。如 map 方法对应的 marbles 图如下箭头可以理解为时间轴，上面的数据经过中间的操作，转变成下面的模样。Rx.Observable.prototype.mergeMapmergeMap 也是 RxJS 中常用的接口，我们来结合 marbles 图(flatMap(alias))来理解它上面的数据流中，产生了新的分支流(流中流)，mergeMap 的作用则是将分支流调整回主干上，最终分支上的数据流都经过主干的其他操作，其实也是将流中流进行扁平化。Rx.Observable.prototype.switchMapswitchMap 与 mergeMap 都是将分支流疏通到主干上，而不同的地方在于 switchMap 只会保留最后的流，而取消抛弃之前的流。除了上面提到的 marbles，也可以 ASCII 字符的方式来绘制可视化图表，下面将结合 Map、mergeMap 和 switchMap 进行对比来理解。 123456789@Map @mergeMap @switchMap ↗ ↗ ↗ ↗-A------B--&gt; a2 b2 a2 b2 -2A-----2B-&gt; / / / / / / / / a1 b1 a1 b1 / / / / -A-B-----------&gt; -A-B----------&gt; --a1-b1-a2-b2--&gt; --a1-b1---b2--&gt; mergeMap 和 switchMap 中，A 和 B 是主干上产生的流，a1、a2 为 A 在分支上产生，b1、b2 为 B 在分支上产生，可看到，最终将归并到主干上。switchMap 只保留最后的流，所以将 A 的 a2 抛弃掉。Rx.Observable.prototype.debounceTimedebounceTime 操作可以操作一个时间戳 TIMES，表示经过 TIMES 毫秒后，没有流入新值，那么才将值转入下一个操作。RxJS 中的操作符是满足我们以前的开发思维的，像 map、reduce 这些。另外，无论是 marbles 图还是用 ASCII 字符图这些可视化的方式，都对 RxJS 的学习和理解有非常大的帮助。 使用 RxJS 一步步实现搜索示例RxJS 提供许多创建流或操作流的接口，应用这些接口，我们来一步步将搜索的示例进行 Rx 化。使用 RxJS 提供的 fromEvent 接口来监听我们输入框的 keyup 事件，触发 keyup 将产生 Observable。var text = document.querySelector('#text');Rx.Observable.fromEvent(text, 'keyup') .subscribe(e => console.log(e));这里我们并不想输出事件，而想拿到文本输入值，请求搜索，最终渲染出结果。涉及到两个新的 Operators 操作，简单理解一下： Rx.Observable.prototype.pluck('target', 'value')将输入的 event，输出成 event.target.value。 Rx.Observable.prototype.mergeMap()将请求搜索结果输出回给 Observer 上进行渲染。 var text = document.querySelector('#text');Rx.Observable.fromEvent(text, 'keyup') .pluck('target', 'value') // Http.get(url)) // render(data))上面代码实现了简单搜索呈现，但同样存在一开始提及的两个问题。那么如何减少请求数，以及取消已无用的请求呢？我们来了解 RxJS 提供的其他 Operators 操作，来解决上述问题。 Rx.Observable.prototype.debounceTime(TIMES)表示经过 TIMES 毫秒后，没有流入新值，那么才将值转入下一个环节。这个与前面使用 setTimeout 来实现函数节流的方式有一致效果。 Rx.Observable.prototype.switchMap()使用 switchMap 替换 mergeMap，将能取消上一个已无用的请求，只保留最后的请求结果流，这样就确保处理展示的是最后的搜索的结果。 最终实现如下，与一开始的实现进行对比，可以明显看出 RxJS 让代码变得十分简洁。var text = document.querySelector('#text');Rx.Observable.fromEvent(text, 'keyup') .debounceTime(250) // Http.get(url)) // render(data)) 总结本篇作为 RxJS 入门篇到这里就结束，关于 RxJS 中的其他方面内容，后续再拎出来进一步分析学习。RxJS 作为一个库，可以与众多框架结合使用，但并不是每一种场合都需要使用到 RxJS。复杂的数据来源，异步多的情况下才能更好凸显 RxJS 作用，这一块可以看看民工叔写的《流动的数据——使用 RxJS 构造复杂单页应用的数据逻辑》 相信会有更好的理解。附:RxJS(JavaScript) https://github.com/Reactive-Extensions/RxJSRxJS(TypeScript ) https://github.com/ReactiveX/rxjs查看更多文章 >>https://github.com/joeyguo/blog]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSS 实现类似原生效果的 1px 边框]]></title>
    <url>%2F2019%2F07%2F03%2Fyuque%2FCSS%20%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BC%BC%E5%8E%9F%E7%94%9F%E6%95%88%E6%9E%9C%E7%9A%84%201px%20%E8%BE%B9%E6%A1%86%2F</url>
    <content type="text"><![CDATA[一.使用border-image实现类似iOS7的1px底边iOS7已经发布有一段时间，扁平化设计风格有很多值得称赞的地方，其中有很多设计细节都是值得研究的。首先，来看下面iOS设置的截图中的border：从上面的截图可以看到iOS7的设计是非常精细的，border是一根非常细的线。这篇文章将说明如何使用border-image实现iOS7的border效果。在看下面的内容之前，需要先了解devicePixelRatio和border-image，不熟悉的同学请自行脑补： 设备像素比devicePixelRatio简单介绍 CSS3 border-image详解、应用及jQuery插件border属性实现效果我们在实现border时通常都是使用border属性，如下：12345.border-1px &#123; border-width: 1px 0; border-style: solid; border-color: #333;&#125; 显示效果对比：上面这张图片可以看到，在手机上border无法达到我们想要的效果。这是因为devicePixelRatio特性导致，iPhone的devicePixelRatio==2，而border-width: 1px描述的是设备独立像素，所以，border被放大到物理像素2px显示，在iPhone上就显得较粗。 使用border-image属性实现物理1px通常手机端的页面设计稿都是放大一倍的，如：为适应iphone retina，设计稿会设计成640*960的分辨率，图片按照2倍大小切出来，在手机端看着就不会虚化，非常清晰。同样，在使用border-image时，将border设计为物理1px，如下：样式设置： 12345.border-image-1px &#123; border-width: 1px 0px; -webkit-border-image: url("border.png") 2 0 stretch; border-image: url("border.png") 2 0 stretch;&#125; 显示效果对比：这里在手机上的效果和iOS7已经非常接近了。样例：http://maxzhang.github.com/examples/border1px/index.htmlNote: border.png也可以直接使用的base64替代 1234.border-image-1px &#123; border-width: 1px 0px; -webkit-border-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAAECAYAAABP2FU6AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKTWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28AAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0ST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaOWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHiwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryMAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0lYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHiNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYAQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6cwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBiewhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1cQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqOY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hMWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgohJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSUEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/pdLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Yb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7OUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsbdi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83MDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxrPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1U27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H08PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+Hvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsGLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjgR2yIuB9pGZkX+X0UKSoyqi7qUbRTdHF09yzWrORZ+2e9jvGPqYy5O9tqtnJ2Z6xqbFJsY+ybuIC4qriBeIf4RfGXEnQTJAntieTE2MQ9ieNzAudsmjOc5JpUlnRjruXcorkX5unOy553PFk1WZB8OIWYEpeyP+WDIEJQLxhP5aduTR0T8oSbhU9FvqKNolGxt7hKPJLmnVaV9jjdO31D+miGT0Z1xjMJT1IreZEZkrkj801WRNberM/ZcdktOZSclJyjUg1plrQr1zC3KLdPZisrkw3keeZtyhuTh8r35CP5c/PbFWyFTNGjtFKuUA4WTC+oK3hbGFt4uEi9SFrUM99m/ur5IwuCFny9kLBQuLCz2Lh4WfHgIr9FuxYji1MXdy4xXVK6ZHhp8NJ9y2jLspb9UOJYUlXyannc8o5Sg9KlpUMrglc0lamUycturvRauWMVYZVkVe9ql9VbVn8qF5VfrHCsqK74sEa45uJXTl/VfPV5bdra3kq3yu3rSOuk626s91m/r0q9akHV0IbwDa0b8Y3lG19tSt50oXpq9Y7NtM3KzQM1YTXtW8y2rNvyoTaj9nqdf13LVv2tq7e+2Sba1r/dd3vzDoMdFTve75TsvLUreFdrvUV99W7S7oLdjxpiG7q/5n7duEd3T8Wej3ulewf2Re/ranRvbNyvv7+yCW1SNo0eSDpw5ZuAb9qb7Zp3tXBaKg7CQeXBJ9+mfHvjUOihzsPcw83fmX+39QjrSHkr0jq/dawto22gPaG97+iMo50dXh1Hvrf/fu8x42N1xzWPV56gnSg98fnkgpPjp2Snnp1OPz3Umdx590z8mWtdUV29Z0PPnj8XdO5Mt1/3yfPe549d8Lxw9CL3Ytslt0utPa49R35w/eFIr1tv62X3y+1XPK509E3rO9Hv03/6asDVc9f41y5dn3m978bsG7duJt0cuCW69fh29u0XdwruTNxdeo94r/y+2v3qB/oP6n+0/rFlwG3g+GDAYM/DWQ/vDgmHnv6U/9OH4dJHzEfVI0YjjY+dHx8bDRq98mTOk+GnsqcTz8p+Vv9563Or59/94vtLz1j82PAL+YvPv655qfNy76uprzrHI8cfvM55PfGm/K3O233vuO+638e9H5ko/ED+UPPR+mPHp9BP9z7nfP78L/eE8/sl0p8zAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAcSURBVHjaBMEBDQAADMMgckv1r20H1WxzoNoPAER9BjAKc4kUAAAAAElFTkSuQmCC") 2 0 stretch;&#125; 使用 CSS3 transform 实现1234567891011121314151617181920212223242526272829.border-1px &#123; position: relative;&#125;.border-1px:after &#123; position: absolute; content: ''; top: -50%; bottom: -50%; left: -50%; right: -50%; -webkit-transform: scale(0.5); transform: scale(0.5); border-top: 1px solid #666; border-bottom: 1px solid #666;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[流程图绘制]]></title>
    <url>%2F2019%2F07%2F03%2Fyuque%2F%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%BB%98%E5%88%B6%2F</url>
    <content type="text"><![CDATA[https://roadmap.sh/frontend]]></content>
  </entry>
  <entry>
    <title><![CDATA[Egret Developer游戏开发]]></title>
    <url>%2F2019%2F07%2F03%2Fyuque%2FEgret%20Developer%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[http://developer.egret.com/cn/https://www.egret.com/products/microclient.htmlhttp://developer.egret.com/cn/github/egret-docs/Engine2D/projectConfig/cmdManual/index.html命令行手册]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端跨框架跨平台框架]]></title>
    <url>%2F2019%2F07%2F02%2Fyuque%2F%E5%89%8D%E7%AB%AF%E8%B7%A8%E6%A1%86%E6%9E%B6%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[http://omijs.org https://github.com/Tencent/omi https://uniapp.dcloud.io/ 桌面应用程序：使用 JavaScript, HTML 和 CSS 构建跨平台的桌面应用pomotroidhttps://github.com/Splode/pomotroidhttps://electronjs.org/apps/pomotroid移动端：[flutter](https://flutter.dev/)**]]></content>
  </entry>
  <entry>
    <title><![CDATA[webpack学习]]></title>
    <url>%2F2019%2F07%2F02%2Fyuque%2Fwebpack%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[http://webpack.github.io/analyse/https://webpack.js.org/]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端数据库]]></title>
    <url>%2F2019%2F07%2F02%2Fyuque%2F%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[pouchdb :https://pouchdb.com/]]></content>
  </entry>
  <entry>
    <title><![CDATA[流程图]]></title>
    <url>%2F2019%2F07%2F02%2Fyuque%2F%E6%B5%81%E7%A8%8B%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[Roadmap：产品蓝图如何设计https://roadmap.sh]]></content>
  </entry>
  <entry>
    <title><![CDATA[LAVAS基于 Vue.js 的 PWA 解决方案]]></title>
    <url>%2F2019%2F07%2F02%2Fyuque%2FLAVAS%E5%9F%BA%E4%BA%8E%20Vue.js%20%E7%9A%84%20PWA%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[https://lavas.baidu.com/ 基于 Vue.js 的 PWA 解决方案 帮助开发者快速搭建 PWA 应用，解决接入 PWA 的各种问题]]></content>
  </entry>
  <entry>
    <title><![CDATA[React知识点综合运用实例]]></title>
    <url>%2F2019%2F07%2F02%2Fyuque%2FReact%E7%9F%A5%E8%AF%86%E7%82%B9%E7%BB%BC%E5%90%88%E8%BF%90%E7%94%A8%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[https://www.imooc.com/learn/971]]></content>
  </entry>
  <entry>
    <title><![CDATA[基于实例的 React16 傻瓜课程]]></title>
    <url>%2F2019%2F07%2F02%2Fyuque%2F%E5%9F%BA%E4%BA%8E%E5%AE%9E%E4%BE%8B%E7%9A%84%20React16%20%E5%82%BB%E7%93%9C%E8%AF%BE%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[https://www.imooc.com/learn/1045]]></content>
  </entry>
  <entry>
    <title><![CDATA[React 16实现订单列表及评价功能]]></title>
    <url>%2F2019%2F07%2F02%2Fyuque%2FReact%2016%E5%AE%9E%E7%8E%B0%E8%AE%A2%E5%8D%95%E5%88%97%E8%A1%A8%E5%8F%8A%E8%AF%84%E4%BB%B7%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[https://www.imooc.com/learn/1061]]></content>
  </entry>
  <entry>
    <title><![CDATA[React16.8+Next.js+Koa2开发Github全栈项目]]></title>
    <url>%2F2019%2F07%2F02%2Fyuque%2FReact16.8%2BNext.js%2BKoa2%E5%BC%80%E5%8F%91Github%E5%85%A8%E6%A0%88%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[https://www.imooc.com/topic/fullstack]]></content>
  </entry>
  <entry>
    <title><![CDATA[nodejs]]></title>
    <url>%2F2019%2F07%2F02%2Fyuque%2Fnodejs%2F</url>
    <content type="text"><![CDATA[https://www.imooc.com/topic/nodejs Node.js实例教程https://coding.imooc.com/class/320.html 前端晋升全栈工程师必备课程 Node.js 从零开发web server博客项目 基于 Node.js 的前端代码检查工具http://fecs.baidu.com/ https://eggjs.org/]]></content>
  </entry>
  <entry>
    <title><![CDATA[React]]></title>
    <url>%2F2019%2F07%2F02%2Fyuque%2FReact%2F</url>
    <content type="text"><![CDATA[https://www.imooc.com/topic/webframe优秀的人 就要用优秀的Web前端框架 steamer-reacthttps://github.com/steamerjs/steamer-react/tree/dev]]></content>
  </entry>
  <entry>
    <title><![CDATA[React高级教程之高阶组件]]></title>
    <url>%2F2019%2F07%2F02%2Fyuque%2FReact%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B%E4%B9%8B%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[https://www.imooc.com/learn/1075 https://www.imooc.com/video/18267 高阶组件 高阶组件介绍高阶组件的定义及原理高阶组件在项目中的常见应用通用高阶组件如何封装 高阶函数基本概念（High Order Component,HOC） 高阶组件就是接受一个组件作为参数并返回一个新组件的函数 高阶组件是一个函数，并不是组件函数可以作为参数被传递1setTimeOut(()=&gt;&#123;console.log(1)&#125;,1000) 函数可以作为返回值输出12345function foo(x)&#123; return function()&#123; return x; &#125;&#125; 高阶组件不是一个组件 高阶组件应用 代理方式的高阶组件返回的新组件类直接继承自React.Component类，新组件扮演的角色传入参数组件的一个代理，在新组件的render函数中，将被包裹的组件渲染出来，除了高阶组件自己要做的工作，其余功能全部转手给了被包裹的组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139A.jsx/* *代理方式的高阶组件 */import React, &#123; Component &#125; from "react";export default title =&gt; WrappedComponent =&gt; class A extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; inputvalue: "" &#125;; &#125; onInputChange = e =&gt; &#123; this.setState(&#123; inputvalue: e.target.value &#125;); &#125;; refc(instance) &#123; //instance是WrappedComponent的实例 console.log(instance); // instance.getName &amp;&amp; console.log(instance.getName()); &#125; render() &#123; const &#123; age, ...otherProps &#125; = this.props; const newProps = &#123; inputvalue: this.state.inputvalue, onInput: this.onInputChange &#125;; return ( &lt;div className="a-container"&gt; &lt;div className="header"&gt; &lt;div&gt;&#123;title&#125;&lt;/div&gt; &lt;div&gt;×&lt;/div&gt; &lt;/div&gt; &lt;div className="content"&gt; 我是高阶组件A &lt;WrappedComponent sex=&#123;"男"&#125; &#123;...otherProps&#125; ref=&#123;this.refc.bind(this)&#125; &#123;...newProps&#125; /&gt; &lt;/div&gt; &lt;/div&gt; ); &#125; &#125;;B.jsximport React, &#123; Component &#125; from "react";import A from "./A";// import D from "./D";// @Dclass B extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; value: "" &#125;; &#125; changeInput(e, parame) &#123; console.log(e.target.value, parame); this.setState(&#123; value: e.target.value &#125;); &#125; getName() &#123; return "我是B组件"; &#125; render() &#123; return ( &lt;div&gt; 我是组件B &lt;br /&gt; &lt;input type="text" &#123;...this.props&#125; /&gt; &lt;br /&gt; &lt;input type="text" value=&#123;this.state.value&#125; onChange=&#123;e =&gt; &#123; this.changeInput(e, "wfc"); &#125;&#125; /&gt; &lt;br /&gt; 我的名字叫:&#123;this.props.name&#125; &lt;br /&gt; 我的年龄是:&#123;this.props.age&#125; &lt;br /&gt; 我的性别是：&#123;this.props.sex&#125; &lt;img src=&#123;require("../images/B.jpg")&#125; alt="" /&gt; &lt;/div&gt; ); &#125;&#125;export default A("提示")(B);// export default B;C.jsximport React, &#123; Component &#125; from "react";import A from "./A";@A("警告")class C extends Component &#123; getName() &#123; return "我是C组件"; &#125; render() &#123; return ( &lt;div&gt; &lt;input type="text" &#123;...this.props&#125; /&gt; &lt;img src=&#123;require("../images/C.jpg")&#125; alt="" /&gt; &lt;/div&gt; ); &#125;&#125;export default C;App.jsimport React from "react";import B from "./components/B";import C from "./components/C";import "./App.css";function App() &#123; return ( &lt;div className="App"&gt; &lt;B name=&#123;"张三"&#125; age=&#123;18&#125; /&gt; &lt;C /&gt; &lt;/div&gt; );&#125;export default App; 继承方式的高阶组件采用继承关联作为参数的组件和返回的组件，假如传入的组件参数是WrappedComponent,那么返回的组件就直接继承自WrappedComponent 操纵prop 操纵生命周期函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970D.jsx/* * 继承方式的高阶函数组件 */import React from "react";const modifyPropsHOC = WrappedComponent =&gt; class NewComponent extends WrappedComponent &#123; componentWillMount() &#123; console.log("我是修改后的生命周期"); &#125; render() &#123; const element = super.render(); const newStyle = &#123; color: element.type === "div" ? "red" : "green" &#125;; const newProps = &#123; ...this.props, style: newStyle &#125;; return React.cloneElement( element, newProps, element.props.children ); &#125; &#125;;export default modifyPropsHOC;E.jsximport React, &#123; Component &#125; from "react";import D from "./D";@Dclass E extends Component &#123; componentWillMount() &#123; console.log("我是原始生命周期"); &#125; render() &#123; return &lt;div&gt;我是div&lt;/div&gt;; &#125;&#125;export default E;F.jsximport React, &#123; Component &#125; from "react";import D from "./D";@Dclass F extends Component &#123; render() &#123; return &lt;p&gt;我是P&lt;/p&gt;; &#125;&#125;export default F;App.jsimport React from "react";import E from "./components/E";import F from "./components/F";import "./App.css";// const BComponent = A(B);function App() &#123; return ( &lt;div className="App"&gt; &lt;E /&gt; &lt;F /&gt; &lt;/div&gt; );&#125;export default App; 高阶组件显示名12345678910111213141516171819202122232425262728293031323334353637/** * @description 继承方式的高阶函数组件 * @author wfc * @date 2019-07-05 * @param &#123;*&#125; WrappedComponent * @returns */import React from "react";const modifyPropsHOC = WrappedComponent =&gt; class NewComponent extends WrappedComponent &#123; static displayName = `NewComponent($&#123;getDispalyName( WrappedComponent )&#125;)`; componentWillMount() &#123; console.log("我是修改后的生命周期"); &#125; render() &#123; const element = super.render(); const newStyle = &#123; color: element.type === "div" ? "red" : "green" &#125;; const newProps = &#123; ...this.props, style: newStyle &#125;; return React.cloneElement( element, newProps, element.props.children ); &#125; &#125;;//高阶组件显示名function getDispalyName(WrappedComponent) &#123; console.log(WrappedComponent); return WrappedComponent.displayName || WrappedComponent.name || "Component";&#125;export default modifyPropsHOC; 高阶组件实战项目搭建 1.create-react-app tabbar 2.Tabbar静态布局实现去https://www.iconfont.cn/搜图标 添加图标到项目 1234567891011121314151617181920212223242526272829303132333435363738tabbar/index.jsimport React, &#123; Component &#125; from "react";import "./index.css";const tarbarArr = [ &#123; img: "icon-home", text: "首页" &#125;, &#123; img: "icon-fenlei_", text: "分类" &#125;, &#123; img: "icon-gouwuche", text: "购物车" &#125;, &#123; img: "icon-yonghu", text: "用户" &#125;];export default class index extends Component &#123; render() &#123; return ( &lt;div className="tabbar"&gt; &lt;div className="tabbar-content"&gt; &#123;tarbarArr.map((v, i) =&gt; ( &lt;div key=&#123;i&#125; className="tarbar-item"&gt; &lt;div className=&#123;`iconfont $&#123;v.img&#125;`&#125; /&gt; &lt;div className=""&gt;&#123;v.text&#125;&lt;/div&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125; 3.Tabbar绑定点击事件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657tabbar/index.jsimport React, &#123; Component &#125; from "react";import "./index.css";const tarbarArr = [ &#123; img: "icon-home", text: "首页" &#125;, &#123; img: "icon-fenlei_", text: "分类" &#125;, &#123; img: "icon-gouwuche", text: "购物车" &#125;, &#123; img: "icon-yonghu", text: "用户" &#125;];export default class index extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; index: 0 &#125;; &#125; itemChange = i =&gt; &#123; this.setState(&#123; index: i &#125;); &#125;; render() &#123; return ( &lt;div className="tabbar"&gt; &lt;div className="tabbar-content"&gt; &#123;tarbarArr.map((v, i) =&gt; ( &lt;div key=&#123;i&#125; className=&#123;`tarbar-item$&#123; this.state.index === i ? " active" : "" &#125;`&#125; onClick=&#123;() =&gt; &#123; this.itemChange(i); &#125;&#125; &gt; &lt;div className=&#123;`iconfont $&#123;v.img&#125;`&#125; /&gt; &lt;div className=""&gt;&#123;v.text&#125;&lt;/div&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125; 4.Tabbar添加路由react-router 1234567891011121314151617181920router.jsimport React from "react";import &#123; BrowserRouter, Route, Switch &#125; from "react-router-dom";// const Home = () =&gt; &lt;div&gt;home&lt;/div&gt;;import Home from './pages/home';import Category from "./pages/category";import Car from "./pages/car";import User from "./pages/user";export default () =&gt; ( &lt;BrowserRouter&gt; &lt;Switch&gt; &lt;Route path="/home" component=&#123;Home&#125; /&gt; &lt;Route path="/category" component=&#123;Category&#125; /&gt; &lt;Route path="/car" component=&#123;Car&#125; /&gt; &lt;Route path="/user" component=&#123;User&#125; /&gt; &lt;/Switch&gt; &lt;/BrowserRouter&gt;); 5.Tabbar添加路由切换12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364tabbar/index.jsimport React, &#123; Component &#125; from "react";import &#123; Link &#125; from "react-router-dom";import "./index.css";const tarbarArr = [ &#123; img: "icon-home", text: "首页", link: "/home" &#125;, &#123; img: "icon-fenlei_", text: "分类", link: "/category" &#125;, &#123; img: "icon-gouwuche", text: "购物车", link: "/car" &#125;, &#123; img: "icon-yonghu", text: "用户", link: "/user" &#125;];export default class index extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; index: 0 &#125;; &#125; itemChange = i =&gt; &#123; this.setState(&#123; index: i &#125;); &#125;; render() &#123; return ( &lt;div className="tabbar"&gt; &lt;div className="tabbar-content"&gt; &#123;tarbarArr.map((v, i) =&gt; ( &lt;Link to=&#123;v.link&#125; key=&#123;i&#125; className=&#123;`tarbar-item$&#123; this.state.index === i ? " active" : "" &#125;`&#125; onClick=&#123;() =&gt; &#123; this.itemChange(i); &#125;&#125; &gt; &lt;div className=&#123;`iconfont $&#123;v.img&#125;`&#125; /&gt; &lt;div className=""&gt;&#123;v.text&#125;&lt;/div&gt; &lt;/Link&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125; 6.其它页面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687pages/home.jsimport React, &#123; Component &#125; from "react";import Tabbar from "../components/tabbar";export default class home extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;img className="bg" src=&#123;require("../static/images/home.jpg")&#125; alt="" /&gt; &lt;Tabbar /&gt; &lt;/div&gt; ); &#125;&#125;car.js category.js user.js 以此类推tabbar/index.jsimport React, &#123; Component &#125; from "react";import &#123; Link &#125; from "react-router-dom";import "./index.css";const tarbarArr = [ &#123; img: "icon-home", text: "首页", link: "/home" &#125;, &#123; img: "icon-fenlei_", text: "分类", link: "/category" &#125;, &#123; img: "icon-gouwuche", text: "购物车", link: "/car" &#125;, &#123; img: "icon-yonghu", text: "用户", link: "/user" &#125;];export default class index extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; index: 0 &#125;; &#125; itemChange = i =&gt; &#123; this.setState(&#123; index: i &#125;); &#125;; render() &#123; const url = window.location.href; return ( &lt;div className="tabbar"&gt; &lt;div className="tabbar-content"&gt; &#123;tarbarArr.map((v, i) =&gt; ( &lt;Link to=&#123;v.link&#125; key=&#123;i&#125; className=&#123;`tarbar-item$&#123; url.indexOf(v.link) &gt; -1 ? " active" : "" // this.state.index === i ? " active" : "" &#125;`&#125; onClick=&#123;() =&gt; &#123; this.itemChange(i); &#125;&#125; &gt; &lt;div className=&#123;`iconfont $&#123;v.img&#125;`&#125; /&gt; &lt;div className=""&gt;&#123;v.text&#125;&lt;/div&gt; &lt;/Link&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125; 因为每个页面都加了tabbar，判断条件必须编程url，不然不准。 7.使用高阶组件改写Tabbar编写高阶组件1.实现一个普通组件2.将普通组件使用函数包裹 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293tabbar/index.jsimport React, &#123; Component &#125; from "react";import &#123; Link &#125; from "react-router-dom";import "./index.css";const tarbarArr = [ &#123; img: "icon-home", text: "首页", link: "/home" &#125;, &#123; img: "icon-fenlei_", text: "分类", link: "/category" &#125;, &#123; img: "icon-gouwuche", text: "购物车", link: "/car" &#125;, &#123; img: "icon-yonghu", text: "用户", link: "/user" &#125;];const Tabbar = WrappedComponent =&gt; class Tabbar extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; index: 0 &#125;; &#125; itemChange = i =&gt; &#123; this.setState(&#123; index: i &#125;); &#125;; render() &#123; const url = window.location.href; return ( &lt;React.Fragment className="tabbar-container"&gt; &lt;div className="tabbar-children"&gt; &lt;WrappedComponent /&gt; &lt;/div&gt; &lt;div className="tabbar"&gt; &lt;div className="tabbar-content"&gt; &#123;tarbarArr.map((v, i) =&gt; ( &lt;Link to=&#123;v.link&#125; key=&#123;i&#125; className=&#123;`tarbar-item$&#123; url.indexOf(v.link) &gt; -1 ? " active" : "" &#125;`&#125; onClick=&#123;() =&gt; &#123; this.itemChange(i); &#125;&#125; &gt; &lt;div className=&#123;`iconfont $&#123;v.img&#125;`&#125; /&gt; &lt;div className=""&gt;&#123;v.text&#125;&lt;/div&gt; &lt;/Link&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; &lt;/React.Fragment&gt; ); &#125; &#125;;export default Tabbar;// pages/home.jsimport React, &#123; Component &#125; from "react";import Tabbar from "../components/tabbar";class Home extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;img className="bg" src=&#123;require("../static/images/home.jpg")&#125; alt="" /&gt; &lt;/div&gt; ); &#125;&#125;export default Tabbar(Home);car.js category.js user.js一次类推 总结回顾高阶组件概述高阶组件实现高阶组件应用高阶组件使用出现的问题高阶组件实战回顾与总结]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端JavaScript面试技巧]]></title>
    <url>%2F2019%2F07%2F02%2Fyuque%2F%E5%89%8D%E7%AB%AFJavaScript%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[https://coding.imooc.com/class/115.html 揭秘一线互联网企业前端JavaScript高级面试https://coding.imooc.com/class/190.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[基于TypeScript从零重构axios]]></title>
    <url>%2F2019%2F07%2F02%2Fyuque%2F%E5%9F%BA%E4%BA%8ETypeScript%E4%BB%8E%E9%9B%B6%E9%87%8D%E6%9E%84axios%2F</url>
    <content type="text"><![CDATA[https://coding.imooc.com/class/330.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[React劲爆新特性Hooks 重构去哪儿网火车票PWA]]></title>
    <url>%2F2019%2F07%2F02%2Fyuque%2FReact%E5%8A%B2%E7%88%86%E6%96%B0%E7%89%B9%E6%80%A7Hooks%20%E9%87%8D%E6%9E%84%E5%8E%BB%E5%93%AA%E5%84%BF%E7%BD%91%E7%81%AB%E8%BD%A6%E7%A5%A8PWA%2F</url>
    <content type="text"><![CDATA[https://coding.imooc.com/class/348.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[React服务器渲染原理解析与实践]]></title>
    <url>%2F2019%2F07%2F02%2Fyuque%2FReact%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[https://coding.imooc.com/class/276.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[ES6零基础教学 解析彩票项目]]></title>
    <url>%2F2019%2F07%2F02%2Fyuque%2FES6%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E5%AD%A6%20%E8%A7%A3%E6%9E%90%E5%BD%A9%E7%A5%A8%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[https://coding.imooc.com/class/98.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[Javascript 设计模式系统讲解与应用]]></title>
    <url>%2F2019%2F07%2F02%2Fyuque%2FJavascript%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%B2%E8%A7%A3%E4%B8%8E%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[https://coding.imooc.com/class/255.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[koa]]></title>
    <url>%2F2019%2F07%2F01%2Fyuque%2Fkoa%2F</url>
    <content type="text"><![CDATA[https://coding.imooc.com/class/178.htmlKoa2框架从0开始构建预告片网站随着 ES6/7 的普及推广，Koa2 框架也逐步走入大小公司一线工程师的视野，作为即将在前端工作中占据一席之地的框架，Koa2 学习势在必行。这一次 Scott 老师通过完整的网站项目，以及足够篇幅的源码解读，为你讲解 Koa2 框架的原理、实战项目中的作用，以及与其他三方库框架的结合使用姿势，小伙伴们不要错过哦！ 遇到的问题 koa框架到底为我们做了什么 他的内部到底是什么样子 他向下一直到Nodejs底层，到底是怎么处理事件循环的 一个异步的HTTP过程，到底是怎么进行的 课程概况 做什么？开发一个可以实时更新的预告片网站 哪些功能网站首页、网站首页播放窗口、网站播放详情页、网站详情、同类推荐、网站后台登录、网站后台管理列表等 技术栈Koa2+Nodejs+MongoDB+Puppeteer+Parcel+AntDesign 第1章 2018年的编程姿势 第2章 ES6/7必会的语法特性 第3章 解读Koa2框架源码及API 第4章 Koa2/Koa1/Express 的框架对比 第5章 快速搭建一个Koa2静态资源网站 第6章 利用Puppeteer+子进程爬取高难度数据 第7章 彩蛋篇 - 学习Nodejs底层知识 第8-12章 全程实战开发预告片网站 第13章 项目优化及Parcel编译打包 第14章 课程回顾总结 课程收获 从0开始掌握一个网站的开发历程 从表象的API调用掌握到框架内核底层原理 掌握Nodejs事件循环/单线程/异步IO等诸多概念 会在Nodejs中使用模版引擎 会使用Pupeteer爬取高难度网站数据 会使用Parcel对Bootstrap多页静态网站进行打包 会使用Parcel对AntDesign单页万盏进行打包 会在Koa2中使用MongoDB数据库 会掌握如何在Koa2项目中进行MVC设计与API分层]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端构建]]></title>
    <url>%2F2019%2F07%2F01%2Fyuque%2F%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[browserify 使用browserify-shime来加载第三方类库homebrew 使用coffeescript和Es6来优化代码]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端性能优化]]></title>
    <url>%2F2019%2F07%2F01%2Fyuque%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[基础知识认知http://www.imooc.com/learn/580 Web前端性能优化https://coding.imooc.com/class/130.html 2018 前端性能优化清单本文主要考量客户端性能、服务器端和网络性能，内容框架来自 Yahoo Developer Network，包含 7 个类别共 35 条前端性能优化最佳实践，在此基础上补充了一些相关或者更符合主流技术的内容。同时，建议关注及时更新的 Google 性能优化指南。目录： 页面内容 减少 HTTP 请求数 减少 DNS 查询 避免重定向 缓存 Ajax 请求 延迟加载 预先加载 减少 DOM 元素数量 划分内容到不同域名 尽量减少 iframe 使用 避免 404 错误 服务器 使用 CDN 添加 Expires 或 Cache-Control 响应头 启用 Gzip 配置 Etag 尽早输出缓冲 Ajax 请求使用 GET 方法 避免图片 src 为空 Cookie 减少 Cookie 大小 静态资源使用无 Cookie 域名 CSS 把样式表放在 中 不要使用 CSS 表达式 使用 替代 @import 不要使用 filter JavaScript 把脚本放在页面底部 使用外部 JavaScript 和 CSS 压缩 JavaScript 和 CSS 移除重复脚本 减少 DOM 操作 使用高效的事件处理 图片 优化图片 优化 CSS Sprite 不要在 HTML 中缩放图片 使用体积小、可缓存的 favicon.ico 移动端 保持单个文件小于 25 KB 打包内容为分段（multipart）文档 前端性能的一个重要指标是页面加载时间，不仅事关用户体验，也是搜索引擎排名考虑的一个因素。 来自 Google 的数据表明，一个有 10 条数据 0.4 秒能加载完的页面，变成 30 条数据 0.9 秒加载完之后，流量和广告收入下降 90%。 Google Map 首页文件大小从 100KB 减小到 70-80KB 后，流量在第一周涨了 10%，接下来的三周涨了 25%。 亚马逊的数据表明：加载时间增加 100 毫秒，销量就下降 1%。 以上数据更说明「加载时间就是金钱」，前端优化主要围绕提高加载速度进行。 页面内容 减少 HTTP 请求数Web 前端 80% 的响应时间花在图片、样式、脚本等资源下载上。浏览器对每个域名的连接数是有限制的，减少请求次数是缩短响应时间的关键。通过简洁的设计减少页面所需资源，进而减少 HTTP 请求，这是最直接的方式，前提是你的 Boss、设计师同事不打死你。所以，还是另辟蹊径吧： 合并 JavaScript、CSS 等文件； 服务器端（CDN）自动合并 基于 Node.js 的文件合并工具一抓一大把 使用CSS Sprite：将背景图片合并成一个文件，通过background-image和background-position控制显示； Sprite Cow Spritebox 逐步被 Icon Font 和 SVG Sprite 取代。 Image Map：合并图片，然后使用坐标映射不同的区域（演示）。 缺点：仅适用于相连的图片；设置坐标过程乏味且易出错；可访性问题。不推荐使用这种过时的技术。 Inline Assets：使用 Data URI scheme 将图片嵌入 HTML 或者 CSS 中；或者将 CSS、JS、图片直接嵌入 HTML 中。 会增加文件大小，也可能产生浏览器兼容及其他性能问题（有待整理补充）。 未来的趋势是使用内嵌 SVG。 内容分片，将请求划分到不同的域名上。 HTTP/2 通过多路复用大幅降低了多个请求的开销。通过数据分帧层，客户端和服务器之间只需要建立一个 TCP 连接，即可同时收发多个文件，而且，该连接在相当长的时间周期内保持打开（持久化），以便复用。HTTP/2 的新特性意味着上述优化实践不再适用，但考虑到客户端对 HTTP/2 的支持覆盖程度，还需根据实际数据权衡。 减少 DNS 查询用户输入 URL 以后，浏览器首先要查询域名（hostname）对应服务器的 IP 地址，一般需要耗费 20-120 毫秒 时间。DNS 查询完成之前，浏览器无法从服务器下载任何数据。基于性能考虑，ISP、局域网、操作系统、浏览器都会有相应的 DNS 缓存机制。 IE 缓存 30 分钟，可以通过注册表中 DnsCacheTimeout 项设置； Firefox 混存 1 分钟，通过 network.dnsCacheExpiration 配置； （TODO：补充其他浏览器缓存信息） 首次访问、没有相应的 DNS 缓存时，域名越多，查询时间越长。所以应尽量减少域名数量。但基于并行下载考虑，把资源分布到 2 个域名上（最多不超过 4 个）。这是减少 DNS 查询同时保证并行下载的折衷方案。 避免重定向HTTP 重定向通过 301/302 状态码实现。 123HTTP/1.1 301 Moved PermanentlyLocation: http://example.com/newuriContent-Type: text/html 客户端收到服务器的重定向响应后，会根据响应头中 Location 的地址再次发送请求。重定向会影响用户体验，尤其是多次重定向时，用户在一段时间内看不到任何内容，只看到浏览器进度条一直在刷新。有时重定向无法避免，在糟糕也比抛出 404 好。虽然通过 HTML meta refresh 和 JavaScript 也能实现，但首选 HTTP 3xx 跳转，以保证浏览器「后退」功能正常工作（也利于 SEO）。 最浪费的重定向经常发生、而且很容易被忽略：URL 末尾应该添加 / 但未添加。比如，访问 http://astrology.yahoo.com/astrology 将被 301 重定向到 http://astrology.yahoo.com/astrology/（注意末尾的 /）。如果使用 Apache，可以通过 Alias 或 mod_rewrite 或 DirectorySlash 解决这个问题。 网站域名变更：CNAME 结合 Alias 或 mod_rewrite 或者其他服务器类似功能实现跳转。 缓存 Ajax 请求Ajax 可以提高用户体验。但「异步」不意味着「及时」，优化 Ajax 响应速度提高性能仍是需要关注的主题。最重要的的优化方式是缓存响应结果，详见 添加 Expires 或 Cache-Control 响应头。以下规则也关乎 Ajax 响应速度： 启用 Gzip 减少 DNS 查询 压缩 JavaScript 和 CSS 避免重定向 配置 Etag 前端性能优化之加载技术 延迟加载页面初始加载时哪些内容是绝对必需的？不在答案之列的资源都可以延迟加载。比如： 非首屏使用的数据、样式、脚本、图片等； 用户交互时才会显示的内容。 遵循「渐进增强」理念开发的网站：JavaScript 用于增强用用户体验，但没有（不支持） JavaScript 也能正常工作，完全可以延迟加载 JavaScript。 延迟渲染将首屏以外的 HTML 放在不渲染的元素中，如隐藏的 ，或者 type 属性为非执行脚本的 标签中，减少初始渲染的 DOM 元素数量，提高速度。等首屏加载完成或者用户操作时，再去渲染剩余的页面内容。 预先加载预先加载利用浏览器空闲时间请求将来要使用的资源，以便用户访问下一页面时更快地响应。 无条件预先加载：页面加载完成（load）后，马上获取其他资源。以 google.com 为例，首页加载完成后会立即下载一个 Sprite 图片，此图首页不需要，但是搜索结果页要用到。 有条件预先加载：根据用户行为预判用户去向，预载相关资源。比如 search.yahoo.com 开始输入时会有额外的资源加载。 Chrome 等浏览器的地址栏也有类似的机制。 有「阴谋」的预先加载：页面即将上线新版前预先加载新版内容。网站改版后由于缓存、使用习惯等原因，会有旧版的网站更快更流畅的反馈。为缓解这一问题，在新版上线之前，旧版可以利用空闲提前加载一些新版的资源缓存到客户端，以便新版正式上线后更快的载入（好一个「心机猿」:scream:）。 「双十一」、「黑五」这类促销日来临之前，也可以预先下载一些相关资源到客户端（浏览器、App 等），有效利用浏览器缓存和本地存储，降低活动当日请求压力，提高用户体验。TODO: Prefetch 相关细节 Resource Hints Spec 页面渲染在理解真正的优化技术之前，我们需要先了解为什么需要优化？这得从浏览器的渲染引擎谈起。浏览器从获取HTML文档开始，就进入了渲染引擎的工作阶段，其目的是将网页的内容显示在浏览器屏幕上。大体可以描述为从解析HTML内容，构造DOM节点再到DOM元素布局定位最后再绘制DOM元素的这样一个过程。更加详细的内容可以参考How browser works, 要看中文的童鞋可以看这篇译文。在页面渲染的这样一个过程中，有一个关键点是如果在解析内容的过程中遇到了脚本标签，如：&lt;script src=&quot;example.js&quot;&gt;&lt;/script&gt;，浏览器就会暂停内容的解析，转而开始下载脚本。并且只有等脚本下载完并执行结束后，渲染引擎才会继续解析。那么这样一来，页面显示的时间必然会被延长。因此我们需要优化的点就是尽可能地让页面更早地被渲染出来。 脚本加载的优化要解决上面说到的脚本加载问题，通常有三种解决方案：将脚本放在HTML末尾、动态加载脚本以及异步加载脚本。最常用的应该就是将所有脚本放置在HTML文档的末尾了。这应该是每个前端刚入门时，被教的最多的。对于这个方法，这里就不多做介绍，直接上重头戏。 动态加载所谓动态加载脚本就是利用javascript代码来加载脚本，通常是手工创建script元素，然后等到HTML文档解析完毕后插入到文档中去。这样就可以很好地控制脚本加载的时机，从而避免阻塞问题。 123456function loadJS(src) &#123; const script = document.createElement('script'); script.src = src; document.getElementsByTagName('head')[0].appendChild(script);&#125;loadJS('http://example.com/scq000.js');复制代码 异步加载我们都知道，在计算机程序中同步的模式会产生阻塞问题。所以为了解决同步解析脚本会阻塞浏览器渲染的问题，采用异步加载脚本就成为了一种好的选择。利用脚本的async和defer属性就可以实现这种需求： 12&lt;script type="text/javascript" src="./a.js" async&gt;&lt;/script&gt;&lt;script type="text/javascript" src="./b.js" defer&gt;&lt;/script&gt;复制代码 虽然利用了这两个属性的script标签都可以实现异步加载，同时不阻塞脚本解析。但是使用async属性的脚本执行顺序是不能得到保证的。而使用defer属性的脚本执行顺序可以得到保证。另一方面，defer属性是在html文档解析完成后，DOMContentLoaded事件之前就会执行js。async一旦加载完js后就会马上执行，最迟不超过window.onload事件。所以，如果脚本没有操作DOM等元素，或者与DOM时候加载完成无关，直接使用async脚本就好。如果需要DOM，就只能使用defer了。这里介绍的两种方法在实际运用过程中需要权衡一下的，渲染速度变快也就意味着脚本加载时间会变长。 解决异步加载脚本的问题上面介绍的异步加载脚本并不是十分完美的。如何处理加载过程中这些脚本的互相依赖关系，就成了实现异步加载过程中所需要考虑的问题。一方面，对于页面中那些独立的脚本，如用户统计等插件就可以放心大胆地使用异步加载。而另一方面，对于那些确实需要处理依赖关系的脚本，业界已经有很成熟的解决方案了。如采用AMD规范的RequireJS,甚至有采用了hack技术（通过欺骗浏览器下载但不执行脚本)的labjs（已过时)。如果你熟悉promise的话，就知道这是在JS中处理异步的一种强有力的工具。下面以promise技术来实现处理异步脚本加载过程中de的依赖问题： 1234567891011121314151617181920212223// 执行脚本function exec(src) &#123; const script = document.createElement('script'); script.src = src; // 返回一个独立的promise return new Promise((resolve, reject) =&gt; &#123; var done = false; script.onload = script.onreadystatechange = () =&gt; &#123; if (!done &amp;&amp; (!script.readyState || script.readyState === "loaded" || script.readyState === "complete")) &#123; done = true; // 避免内存泄漏 script.onload = script.onreadystatechange = null; resolve(script); &#125; &#125; script.onerror = reject; document.getElementsByTagName('head')[0].appendChild(script); &#125;);&#125;function asyncLoadJS(dependencies) &#123; return Promise.all(dependencies.map(exec));&#125;asyncLoadJS(['https://code.jquery.com/jquery-2.2.1.js', 'https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js']).then(() =&gt; console.log('all done'));复制代码 可以看到，我们针对每个脚本依赖都会创建一个promise对象来管理其状态。采用动态插入脚本的方式来管理脚本，然后利用脚本onload和onreadystatechange(兼容性处理)事件来监听脚本是否加载完成。一旦加载完毕，就会触发promise的resovle方法。最后，针对依赖的处理，是promise的all方法，这个方法只有在所有promise对象都resolved的时候才会触发resolve方法，这样一来，我们就可以确保在执行回调之前，所有依赖的脚本都已经加载并执行完毕。 懒加载(lazyload)懒加载是一种按需加载的方式，也通常被称为_延迟加载_。主要思想是通过延迟相关资源的加载，从而提高页面的加载和响应速度。在这里主要介绍两种实现懒加载的技术：虚拟代理技术以及惰性初始化技术。 虚拟代理加载所谓虚拟代理加载，即为真正加载的对象事先提供一个代理或者说占位符。最常见的场景是在图片的懒加载中，先用一种loading的图片占位，然后再用异步的方式加载图片。等真正图片加载完成后就填充进图片节点中去。 12345678910// 页面中的图片url事先先存在其data-src属性上const lazyLoadImg = function() &#123; const images = document.getElementsByTagName('img'); for(let i = 0; i &lt; images.length; i++) &#123; if(images[i].getAttribute('data-src')) &#123; images[i].setAttribute('src', images[i].getAttribute('data-src')); images[i].onload = () =&gt; images[i].removeAttribute('data-src'); &#125; &#125;&#125;复制代码 惰性初始化惰性初始模式是在程序设计过程中常用的一种设计模式。顾名思义，这个模式就是一种将代码初始化的时机推迟（特别是那些初始化消耗较大的资源），从而来提升性能的技术。jQuery中大名鼎鼎的ready方法就用到了这项技术，其目的是为了在页面DOM元素加载完成后就可以做相应的操作，而不需要等待所有资源加载完毕后。与浏览器中原生的onload事件相比，可以更加提前地介入对DOM的干涉。当页面中包含大量图片等资源时，这个方法就显出它的好处了。在jQuery内部的实现原理上，它会设置一个标志位来判断页面是否加载完毕，如果没有加载完成，会将要执行的函数缓存起来。当页面加载完毕后，再一一执行。这样一来，就将原本应该马上执行的代码，延迟到页面加载完毕后再执行。感兴趣的可以去阅读这一部分的源码，里面还包括了浏览器兼容等处理。 选择时机选择时机：比较常见的两种 滚动条监听 事件回调（需要用户交互的地方） 当然，你也可以根据具体的业务场景选择延迟加载的时机。 滚动条监听滚动条监听，常常用在大型图片流等场景下。通过对用户滚动结束的区域进行计算，从而只加载目标区域中的资源。这样就可以实现节流的目的。 1234567891011121314151617181920212223242526272829303132333435363738// 简单的节流函数function throttle(func, wait, mustRun) &#123; var timeout, startTime = new Date(); return function() &#123; var context = this, args = arguments, curTime = new Date(); clearTimeout(timeout); // 如果达到了规定的触发时间间隔，触发 handler if(curTime - startTime &gt;= mustRun)&#123; func.apply(context,args); startTime = curTime; // 没达到触发间隔，重新设定定时器 &#125;else&#123; timeout = setTimeout(func, wait); &#125; &#125;;&#125;;// 判断元素是否在可视范围内function elementInViewport(element) &#123; const rect = element.getBoundingClientRect(); return (rect.top &gt;= 0 &amp;&amp; rect.left &gt;= 0 &amp;&amp; rect.top &lt;= (window.innerHeight || document.documentElement.clientHeight));&#125;function lazyLoadImgs() &#123; const count = 0; return function() &#123; [].slice.call(images, count).forEach(image =&gt; &#123; if(elementInViewport(elementInViewport(image))) &#123; image.setAttribute('src', image.getAttribute('data-src')); count++; &#125; &#125;); &#125;&#125;const images = document.getElementByTagName('img');// 采用了节流函数, 加载图片window.addEventListener('scroll',throttle(lazyLoadImgs(images),500,1000));复制代码 事件回调这种场景就是那些需要用户交互的地方，如点击加载更多之类的。这些资源往往通过在用户交互的瞬间（如点击一个触发按钮），发起ajax请求来获取资源。比较简单，在此不再赘述。 利用webpack实现脚本加载优化现如今，对于大型项目大家都会用上打包工具。现代化的工具使得我们不必再写那些又长又难懂的代码。针对懒加载，webpack也提供了十分友好的支持。这里主要介绍两种方式。 import()方法我们知道，在原生es6的语法中，提供了import和export的方式来管理模块。而其import关键字是被设置成静态的，因此不支持动态绑定。不过在es6的stage 3规范中，引入了一个新的方法import()使得动态加载模块成为可能。所以，你可以在项目中使用这样的代码： 1234567891011121314$('#button').click(function() &#123; import('./dialog.js') .then(dialog =&gt; &#123; //do something &#125;) .catch(err =&gt; &#123; console.log('模块加载错误'); &#125;);&#125;);//或者更优雅的写法$('#button').click(async function() &#123; const dialog = await import('./dialog.js'); //do something with dialog&#125;);复制代码 由于该语法是基于promise的，所以如果需要兼容旧浏览器，请确保在项目中使用es6-promise或者promise-polyfill。同时，如果使用的是babel，需要添加syntax-dynamic-import插件。 require.ensurerequire.ensure与import()类似，同样也是基于promise的异步加载模块的一种方法。这是在webpack 1.x时代官方提供的懒加载方案。现在，已经被import()语法取代了。为了文章的完整性，这里也做一些介绍。在webpack编译过程中，会静态地解析require.ensure中的模块，并将其添加到一个单独的chunk中，从而实现代码的按需加载。语法如下： 1require.ensure(dependencies: String[], callback: function(require), errorCallback: function(error), chunkName: String)复制代码 一个十分常见的例子是在写单页面应用的时候，使用该技术实现基于不同路由的按需加载： 123const routes = [ &#123;path: '/comment', component: r =&gt; require.ensure([], r(require('./Comment')), 'comment')&#125;];复制代码 预加载首屏加载的问题解决后，用户在具体的页面使用过程中的体验也很重要。如果能够通过预判用户的行为，提前加载所需要的资源，则可以快速地响应用户的操作，从而打造更加良好的用户体验。另一方面，通过提前发起网络请求，也可以减少由于网络过慢导致的用户等待时间。因此，“预加载”的技术就闪亮登场了。 preload规范preload 是w3c新出的一个标准。利用link的rel属性来声明相关“proload"，从而实现预加载的目的。就像这样： 1&lt;link rel="preload" href="example.js" as="script"&gt;复制代码 其中rel属性是用来告知浏览器启用preload功能，而as属性是用来明确需要预加载资源的类型，这个资源类型不仅仅包括js脚本(script)，还可以是图片(image)，css(style)，视频(media)等等。浏览器检测到这个属性后，就会预先加载资源。这个规范目前兼容性方面还不是很好，所以可以先稍微了解一下。webpack现在也已经有相关的插件，如果感兴趣的话，请移步preload-webpack-plugin。对于更加详细的技术细节，这里推荐一篇博客www.smashingmagazine.com/2016/02/pre…。 DNS Prefetch 预解析还有一个可以优化网页速度的方式是利用dns的预解析技术。同preload类似，DNS Prefetch在网络层面上优化了资源加载的速度。我们知道，针对DNS的前端优化，主要分为减少DNS的请求次数，还有就是进行DNS预先获取。DNS prefetch就是为了实现这后者。其用法也很简单，只要在link标签上加上对应的属性就行了。 12&lt;meta http-equiv="x-dns-prefetch-control" content="on" /&gt; /* 这是用来告知浏览器当前页面要做DNS预解析 */&lt;link rel="dns-prefetch" href="//example.com"&gt;复制代码 在支持该标准的浏览器上，会自动对链接中的地址域名做DNS解析缓存。不过，像Goolge、火狐这样的现代浏览器即使不设置这个属性，也能在后台做自动预解析。如果你的页面中需要大量访问不同域名的资源，可以利用这项技术加快资源的获取，从而获得更好的用户体验。需要注意的是，DNS预解析虽好，但是也不能滥用。如果对多页面重复DNS预解析，会增加DNS的查询次数。 参考资料《Javascript性能优化》bubkoo.com/2015/11/19/…2ality.com/2017/01/imp…segmentfault.com/a/119000000…perishablepress.com/3-ways-prel…www.youtube.com/watch?v=wKC… 减少 DOM 元素数量复杂的页面不仅下载的字节更多，JavaScript DOM 操作也更慢。例如，同是添加一个事件处理器，500 个元素和 5000 个元素的页面速度上会有很大区别。从以下几个角度考虑移除不必要的标记： 是否还在使用表格布局？ 塞进去更多的 仅为了处理布局问题？也许有更好、更语义化的标记。 能通过伪元素实现的功能，就没必要添加额外元素，如清除浮动。 浏览器控制台中输入以下代码可以计算出页面中有多少 DOM 元素： 1document.getElementsByTagName('*').length; 对比标记良好的的网站，看看差距是多少。 为什么不使用表格布局？ 更多的标签，增加文件大小； 不易维护，无法适应响应式设计； 性能考量，默认的表格布局算法会产生大量重绘（参见表格布局算法）。 划分内容到不同域名浏览器一般会限制每个域的并行线程（一般为 6 个，甚至更少），使用不同的域名可以最大化下载线程，但注意保持在 2-4 个域名内，以避免 DNS 查询损耗。例如，动态内容放在 csspod.com 上，静态资源放在 static.csspod.com 上。这样还可以禁用静态资源域下的 Cookie，减少数据传输，详见 Cookie 优化。更多信息参考 Maximizing Parallel Downloads in the Carpool Lane 尽量减少 iframe 使用使用 iframe 可以在页面中嵌入 HTML 文档，但有利有弊。 优点： 可以用来加载速度较慢的第三方资源，如广告、徽章； 可用作安全沙箱； 可以并行下载脚本。 缺点： 加载代价昂贵，即使是空的页面； 阻塞页面 load 事件触发； Iframe 完全加载以后，父页面才会触发 load 事件。 Safari、Chrome 中通过 JavaScript 动态设置 iframe src 可以避免这个问题。 缺乏语义。 避免 404 错误HTTP 请求很昂贵，返回无效的响应（如 404 未找到）完全没必要，降低用户体验而且毫无益处。一些网站设计很酷炫、有提示信息的 404 页面，有助于提高用户体验，但还是浪费服务器资源。尤其糟糕的是外部脚本返回 404，不仅阻塞其他资源下载，浏览器还会尝试把 404 页面内容当作 JavaScript 解析，消耗更多资源。 补充规则： 定义字符集，并放在 顶部。大多数浏览器会暂停页面渲染，直到找到字符集定义。 服务器服务器相关优化设置可参考 H5BP 相关项目： Nginx HTTP server boilerplate configs Apache HTTP server boilerplate configs IIS Web.Config Boilerplates 使用 CDN网站 80-90% 响应时间消耗在资源下载上，减少资源下载时间是性能优化的黄金发则。相比分布式架构的复杂和巨大投入，静态内容分发网络（CDN）可以以较低的投入，获得加载速度有效提升。 添加 Expires 或 Cache-Control 响应头 静态内容：将 Expires 响应头设置为将来很远的时间，实现「永不过期」策略； 动态内容：设置合适的 Cache-Control 响应头，让浏览器有条件地发起请求。 Cache-Control 头在 HTTP/1.1 规范中定义，取代了之前用来定义响应缓存策略的头（例如 Expires、Pragma）。当前的所有浏览器都支持 Cache-Control，因此，使用它就够了。鉴于静态内容和动态内容不同的缓存策略，实践中一般会把二者部署在不同的服务器（域名）以方便管理。 参考链接： HTTP 缓存 | Web Fundamentals - Google Developers H5BP - Server Configs 启用 GzipGzip 压缩通常可以减少 70% 的响应大小，对某些文件更可能高达 90%，比 Deflate 更高效。主流 Web 服务器都有相应模块，而且绝大多数浏览器支持 gzip 解码。所以，应该对 HTML、CSS、JS、XML、JSON 等文本类型的内容启用压缩。注意，图片和 PDF 文件不要使用 gzip。它们本身已经压缩过，再使用 gzip 压缩不仅浪费 CPU 资源，而且还可能增加文件体积。对于不支持的 Gzip 的用户代理，通过设置 Vary 响应头，返回为未压缩的数据： 1Vary: * 配置 EtagEtag 通过文件版本标识，方便服务器判断请求的内容是否有更新，如果没有就响应 304，避免重新下载。当然，启用 Etag 可能会导致其他问题，还需要根据具体情况做判断。（TODO：补充相关内容） 尽早输出（flush）缓冲用户请求页面时，服务器通常需要花费 200 ~ 500 毫秒来组合 HTML 页面。在此期间，浏览器处于空闲、等待数据状态。使用PHP 中的 flush() 函数，可以发送部分已经准备好的 HTML 到浏览器，以便服务器还在忙于处理剩余页面时，浏览器可以提前开始获取资源。可以考虑在 之后输出一次缓冲，HTML head 一般比较容易生成，先发送以便浏览器开始获取 里引用的 CSS 等资源。Example: 12345&lt;!-- css, js --&gt;&lt;/head&gt;&lt;?php flush(); ?&gt;&lt;body&gt;&lt;!-- content --&gt; Ajax 请求使用 GET 方法浏览器执行 XMLHttpRequest POST 请求时分成两步，先发送 Header，再发送数据。而 GET 只使用一个 TCP 数据包发送数据，所以首选 GET 方法。根据 HTTP 规范，GET 用于获取数据，POST 则用于向服务器发送数据，所以 Ajax 请求数据时使用 GET 更符合规范（GET 和 POST 对比）。IE 中最大 URL 长度为 2K，如果超出 2K，则需要考虑使用 POST 方法。 避免图片 src 为空图片 src 属性值为空字符串可能以下面两种形式出现：HTML: 1&lt;img src="" /&gt; JavaScript： 12var img = new Image(); img.src = ""; 虽然 src 属性为空字符串，但浏览器仍然会向服务器发起一个 HTTP 请求： IE 向页面所在的目录发送请求； Safari、Chrome、Firefox 向页面本身发送请求； Opera 不执行任何操作。 以上数据较老，当下主流版本可能会有改变。 空 src 产生请求的后果不容小觑： 给服务器造成意外的流量负担，尤其时日 PV 较大时； 浪费服务器计算资源； 可能产生报错。 当然，浏览器如此实现也是根据 RFC 3986 - Uniform Resource Identifiers，当空字符串作为 URI 出现时，被当成相对 URI，具体算法参见规范 5.2 节。参考链接： Empty image src can destroy your site 空的 href 属性也存在类似问题。用户点击空链接时，浏览器也会向服务器发送 HTTP 请求，可以通过 JavaScript 阻止空链接的默认的行为。 Cookie 减少 Cookie 大小Cookie 被用于身份认证、个性化设置等诸多用途。Cookie 通过 HTTP 头在服务器和浏览器间来回传送，减少 Cookie 大小可以降低其对响应速度的影响。 去除不必要的 Cookie； 尽量压缩 Cookie 大小； 注意设置 Cookie 的 domain 级别，如无必要，不要影响到 sub-domain； 设置合适的过期时间。 更多细节参考 When the Cookie Crumbles。 HTTP/2 首部压缩在客户端和服务器端使用「首部表」来跟踪和存储之前发送的键值对，对于相同的数据，不再随每次请求和响应发送。 静态资源使用无 Cookie 域名静态资源一般无需使用 Cookie，可以把它们放在使用二级域名或者专门域名的无 Cookie 服务器上，降低 Cookie 传送的造成的流量浪费，提高响应速度。 CSS 把样式表放在 中把样式表放在 中可以让页面渐进渲染，尽早呈现视觉反馈，给用户加载速度很快的感觉。这对内容比较多的页面尤为重要，用户可以先查看已经下载渲染的内容，而不是盯着白屏等待。如果把样式表放在页面底部，一些浏览器为减少重绘，会在 CSS 加载完成以后才渲染页面，用户只能对着白屏干瞪眼，用户体验极差。 不要使用 CSS 表达式CSS 表达式可以在 CSS 里执行 JavaScript，仅 IE5-IE7 支持，IE8 标准模式已经废弃。CSS 表达式超出预期的频繁执行，页面滚动、鼠标移动时都会不断执行，带来很大的性能损耗。 IE7 及更低版本的浏览器已经逐渐成为历史，忘记它吧。 使用 替代 @import对于 IE 某些版本，@import 的行为和 放在页面底部一样。所以，不要用它。 不要使用 filterAlphaImageLoader 为 IE5.5-IE8 专有的技术，和 CSS 表达式一样，放进博物馆吧。 注意：这里所说的不是 CSS3 Filter，参考文章 Understanding CSS Filter Effects JavaScript 把脚本放在页面底部浏览器下载脚本时，会阻塞其他资源并行下载，即使是来自不同域名的资源。因此，最好将脚本放在底部，以提高页面加载速度。一些特殊场景无法将脚本放到页面底部的，可以考虑 的以下属性： defer 属性； HTML5 新增的 async 属性。 使用外部 JavaScript 和 CSS外部 JavaScript 和 CSS 文件可以被浏览器缓存，在不同页面间重用，也能降低页面大小。当然，实际中也需要考虑代码的重用程度。如果仅仅是某个页面使用到的代码，可以考虑内嵌在页面中，减少 HTTP 请求数。另外，可以在首页加载完成以后，预先加载子页面的资源。 压缩 JavaScript 和 CSS压缩代码可以移除非功能性的字符（注释、空格、空行等），减少文件大小，提高载入速度。 得益于 Node.js 的流行，开源社区涌现出许多高效、易用的前端优化工具，JavaScript 和 CSS 压缩类的，不敢说多如牛毛，多入鸡毛倒是一点不夸张，如 [UglifyJS 2] (https://github.com/mishoo/UglifyJS2)、csso、cssnano 等。对于内嵌的 CSS 和 JavaScript，也可以通过 htmlmin 等工具压缩。这些项目都有 Gulp、Webpack 等流行构建工具的配套版本。 移除重复脚本重复的脚本不仅产生不必要的 HTTP 请求，而且重复解析执行浪费时间和计算资源。 减少 DOM 操作JavaScript 操作 DOM 很慢，尤其是 DOM 节点很多时。使用时应该注意： 缓存已经访问过的元素； 使用 DocumentFragment 暂存 DOM，整理好以后再插入 DOM 树； 操作 className，而不是多次读写 style； 避免使用 JavaScript 修复布局。 使用高效的事件处理 减少绑定事件监听的节点，如通过事件委托； 尽早处理事件，在 DOMContentLoaded 即可进行，不用等到 load 以后。 对于 resize、scroll 等触发频率极高的事件，应该通过 debounce 等机制降低处理程序执行频率。TODO: 补充相关内容 http://demo.nimius.net/debounce_throttle/ 图片 优化图片 YDN 列出的相关工具 缺乏易用性，建议参考以下工具。 imagemin ImageOptim TODO: PNG 终极优化； Webp 相关内容； SVG 相关内容。 PNG 终极优化： Most Effective Method to Reduce and Optimize PNG Images Clever PNG Optimization Techniques 优化 CSS Sprite 水平排列 Sprite 中的图片，垂直排列会增加图片大小； Spirite 中把颜色较近的组合在一起可以降低颜色数，理想状况是低于 256 色以适用 PNG8 格式； 不要在 Spirite 的图像中间留有较大空隙。减少空隙虽然不太影响文件大小，但可以降低用户代理把图片解压为像素图的内存消耗，对移动设备更友好。 不要在 HTML 中缩放图片不要使用 的 width、height 缩放图片，如果用到小图片，就使用相应大小的图片。 很多 CMS 和 CDN 都提供图片裁切功能。 使用体积小、可缓存的 favicon.icoFavicon.ico 一般存放在网站根目录下，无论是否在页面中设置，浏览器都会尝试请求这个文件。所以确保这个图标： 存在（避免 404）； 尽量小，最好小于 1K； 设置较长的过期时间。 对于较新的浏览器，可以使用 PNG 格式的 favicon。 参考链接： Favicons, Touch Icons, Tile Icons, etc. Which Do You Need?图片相关补充 设置图片的宽和高，以免浏览器按照「猜」的宽高给图片保留的区域和实际宽高差异，产生重绘。 移动端 移动端优化相关内容有待进一步整理补充。 保持单个文件小于 25 KB 打包内容为分段（multipart）文档 参考链接 The Psychology of Web Performance 转自：https://csspod.com/frontend-performance-best-practices/#content-http 网站性能优化—CRP为了把HTML、CSS和JavaScript转化成活灵活现、绚丽多彩的网页，浏览器需要处理一系列的中间过程，优化性能其实就是了解这个过程中发生了什么-即CRP(Critical Rendering Path，关键渲染路径)。首先，我们从头开始快速学习一下浏览器是如何显示一个简单网页的。 浏览器渲染一个网页的过程 构建对象模型 文档对象模型（DOM）1234567891011&lt;html&gt; &lt;head&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1"&gt; &lt;link href="style.css" rel="stylesheet"&gt; &lt;title&gt;Critical Path&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt; &lt;div&gt;&lt;img src="awesome-photo.jpg"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 一个普通的页面，里面包含一些文本和一张图片，浏览器是如何处理这个页面的呢？ 转换：浏览器从磁盘或网络读取HTML的原始字节，然后根据指定的文件编码格式（例如 UTF-8）将其转换为相应字符 令牌化：浏览器把字符转化成W3C HTML5 标准指定的各种确切的令牌，比如""、""以及其他在尖括号内的字符串。每个令牌都有特殊的含义以及它自己的一套规则 词法分析：生成的令牌转化为对象，这个对象定义了它们的属性及规则 DOM构建：最后，由于HTML标记定义了不同标签之间的关系（某些标签嵌套在其他标签中），创建的对象在树状的数据结构中互相链接，树状数据结构也捕获了原始标签定义的父子关系：HTML对象是body对象的父对象，body是p对象的父对象等等 上述整个流程的最终输出是文档对象模型，即这个简单网页的 "DOM"，浏览器完成页面的所有后续处理都是建立在这个DOM基础上的。 打开Chrome DevTools > Timeline，录制时间轴，上述过程对应Loading事件中的Parse HTML事件，可以查看到执行这一过程所需要的时间。 DOM树捕获了文档标记的属性及关系，但它没有告诉我们元素在渲染时是什么样子的。这是CSSOM要干的活，也就是接下来要讲的。 CSS对象模型（CSSOM）当浏览器构建上述网页DOM的时候，在head里面碰到一个link标签，这个标签引用了一个外部的CSS样式表：style.css。浏览器预测会需要这个资源来渲染页面，因此会立即发出一个该资源的请求，该请求返回以下内容： 12345body &#123; font-size: 16px &#125;p &#123; font-weight: bold &#125;span &#123; color: red &#125;p span &#123; display: none &#125;img &#123; float: right &#125; 与HTML一样，我们需要将收到的 CSS 规则转换为浏览器可以理解、能够处理的东西。因此，我们重复与处理 HTML 非常相似的过程：最终输出的是CSS对象模型，即CSSOM。想要查看CSS处理过程所花费的时间，可以在录制的时间轴中查看Rendering事件中的Recalculate Style事件：与DOM解析不同，timeline不显示单独的“Parse CSS”条目，而是在Recalculate Style事件下一同捕获CSS解析、CSSOM构建以及computed styles的递归计算。 构建渲染树、布局及绘制前面介绍了我们根据输入的HTML及CSS构建了DOM树和CSSOM树，但二者是独立的对象：DOM描述的是文档内容，CSSOM描述的是应用于文档的样式规则。浏览器会把DOM和CSSOM组合起来构建一个渲染树（Render-tree），渲染树会捕获页面上所有可见的DOM内容以及应用在每个节点上的CSSOM样式。构建渲染树的过程大致如下： 从DOM树的根节点开始，遍历每个可见的节点 某些节点不可见（例如 script 标签、meta 标签等），因为它们不会体现在渲染结果中，所以会被忽略 某些通过 CSS 隐藏的节点在渲染树中也会被忽略，比如应用了 display:none 规则的节点 为每一个可见的节点匹配并应用对应的CSSOM规则 生成有内容和计算样式的可见节点 小提示：注意visibility: hidden和display: none二者的区别。visibility: hidden只是让元素在视觉上不可见，但是元素在页面布局中仍然占据空间。而display: none则是从渲染树中删除某一个元素，不仅视觉上不可见，渲染树上也没有，更不会影响到页面的布局。 最终输出的就是一个包含了所有可见节点的内容及样式信息的渲染树。到目前为止，我们已经计算出了哪些节点是可见的以及它们的计算样式，但是我们还没有计算它们在设备视口（viewport）中的准确位置及尺寸大小——这就是布局（Layout）阶段要做的工作，也就是常说的重排（reflow）。为了计算出页面中每个对象的准确大小和位置，浏览器从渲染树的根节点开始遍历，计算页面上每个对象的几何信息。举例如下： 1234567891011&lt;html&gt; &lt;head&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1"&gt; &lt;title&gt;Critial Path: Hello world!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div style="width: 50%"&gt; &lt;div style="width: 50%"&gt;Hello world!&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 上面页面的 body 包含两个嵌套 div：第一个 div（父元素）将节点尺寸大小设置为视口宽度的 50%，第二个 div 的宽度为父元素的 50%，即视口宽度的 25%！布局过程的输出是一个“盒子模型”，它精确地捕获了每个元素在视口中的准确位置及尺寸大小：所有相对度量单位都被转换为屏幕上的绝对像素。自此，我们已经知道了哪些节点是可见的以及它们的计算样式和几何信息，然后我们就可以把这些信息传送到最后一个阶段，即把渲染树中的每一个节点都转化到屏幕上实际的像素点。这个步骤通常被称为绘制（painting）或者栅格化（rasterizing）。构建渲染树、布局与绘制所消耗的时间也可以通过timeline来查看： "Layout" 事件捕获渲染树的构建及位置、尺寸的计算 布局完成时，浏览器会触发 'Paint' 事件：将渲染树转化为屏幕上的实际像素 终于，我们的页面在设备视口中可见了。现在回顾一下浏览器执行的几个步骤： 处理 HTML 标记，构建 DOM 树 处理 CSS 标记，构建 CSSOM 树 将 DOM 树和 CSSOM 树融合成渲染树 根据渲染树进行布局，计算每个节点的几何信息 在屏幕上绘制各个节点 优化关键渲染路径即尽可能地缩短上述第 1 步到第 5 步耗费的总时间。 优化CRP 阻塞渲染的CSS在构建渲染树部分我们已了解到：CRP要求DOM和CSSOM两者融合在一起才能构建渲染树。这就导致了一个性能问题：HTML和CSS都是阻塞渲染的资源。HTML很显然，没有DOM就没有内容去渲染。CSS没有那么明显，但确实是阻塞渲染的资源。我们知道一个正常的网页如果没有引入专用的css，页面有多丑陋。当我们的网页引入了专用的css，页面一加载出来的时候就是绚丽多彩的，如果css不阻塞渲染，我们看到的很可能是这样的一个画面：页面刚加载出来的时候其丑无比，过了一会，页面又变漂亮了……既然CSS是阻塞渲染的资源，这就意味着在CSSOM构建完成之前，浏览器不会去渲染任何已处理的内容。要尽早、尽快地把CSS下载到客户端以优化首次渲染的时间。使用CSS“媒体类型”和“媒体查询”优化阻塞渲染的CSS： 123&lt;link href="style.css" rel="stylesheet"&gt;&lt;link href="print.css" rel="stylesheet" media="print"&gt;&lt;link href="other.css" rel="stylesheet" media="(min-width: 40em)"&gt; 第一条声明阻塞渲染，匹配所有情况 第二条声明只适用于打印（媒体类型），因此，页面在浏览器中首次加载时，不会阻塞渲染 第三条声明提供了媒体查询，由浏览器判断：如果条件符合，则在该样式表下载并处理完以前，浏览器会阻塞渲染 小提示：「阻塞渲染」仅是指该资源是否会阻塞浏览器的首次页面渲染。无论 CSS 是否阻塞渲染，CSS 资源都会被下载，只是说非阻塞性资源的优先级比较低而已。 阻塞解析的JavaScriptJS可以修改页面的内容、样式以及响应用户的交互，JS在DOM、CSSOM和JS执行之间引入了很多新的依赖关系，导致浏览器在处理和渲染页面上出现大幅延迟： 当浏览器遇到标签时，DOM构建会暂停，直到脚本执行完毕 JavaScript 执行会暂停，直到CSSOM准备就绪 解析器阻塞 vs. 异步 JavaScript默认情况下，JavaScript 执行会阻塞解析器：当浏览器在文档中遇到标签时，DOM构建必须暂停，浏览器把控制权移交给JS引擎，JS引擎编译并执行脚本，脚本执行完毕后再继续构建DOM。事实上，内联脚本始终会阻塞解析器，除非你编写额外的代码来延迟它们的执行。那通过引入的外联脚本呢？结果是一样的，浏览器都会暂停，然后执行脚本，脚本执行完毕之后再去处理文档的剩余部分。尽管如此，通过引入外联脚本还是有一个很大的好处。默认情况下，所有 JS 均会阻塞解析器，因为浏览器不知道脚本想在页面上做什么，因此它必须假定最糟的情况并阻塞解析器。但是，如果我们能够有个信号告知浏览器，说脚本无需在文档中引用它的确切位置被执行呢？这样一来，浏览器就会继续构建DOM，并在脚本准备就绪后执行脚本。这个信号就是async——在script标签里面添加async关键字，其有两个特性： 告诉浏览器当它碰到标签时不用阻塞DOM构建，因此浏览器会忽略脚本请求，继续解析DOM JS执行不依赖CSSOM：如果在CSSOM就绪之前脚本已经就绪，脚本可以立即执行 很显然，这将会显著提升性能！ 小提示：另一个信号是defer，关于两者的区别可以参考一下这个问题的答案defer和async的区别 分析CRP性能先定义三个用于描述CRP的词汇： 关键资源：能够阻止网页首次渲染的资源 关键路径长度：往返过程的数量，或者获取所有关键资源所需的总时间 关键字节：网页首次渲染所需的总字节数，是所有关键资源的传输文件大小总和。 demo1： 12345678910&lt;html&gt; &lt;head&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1"&gt; &lt;title&gt;Critical Path: No Style&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt; &lt;div&gt;&lt;img src="awesome-photo.jpg"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 最简单的可用网页仅由 HTML 标记组成：无 CSS、JavaScript 或其他类型的资源。要呈现此网页，浏览器必须初始化请求、等待 HTML 文档准备就绪、对其进行解析、构建 DOM，最后使其呈现在屏幕上。 1个关键资源 1个关键路径长度（假设文件很小） 5KB关键字节 T0 和 T1 之间的时间用于捕获网络传输和服务器处理时间。 在最理想的情况（HTML 文件较小）下，我们仅需一个网络往返过程即可提取整个文档（由于 TCP 传输协议的工作方式，较大的文件可能需要多个往返过程）。demo2： 12345678910&lt;html&gt; &lt;head&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt; &lt;div&gt;&lt;img src=&quot;awesome-photo.jpg&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 2个关键资源 2个或更多个关键路径长度 9KB关键字节 我们必须同时使用 HTML 和 CSS 来构建渲染树，因此 HTML 和 CSS 均为关键资源；浏览器需要一个网络往返过程来提取 HTML 文档，然后检索到的标记告知我们还需要 CSS 文件，这意味着，浏览器必须返回服务器并获取 CSS，然后才能在屏幕上呈现网页，因此，该网页最少需要两个往返过程才能显示（CSS 文件可能需要多个往返过程，重点在'最少'）；两种资源加起来的关键字节总量最多为 9 KB。demo3： 1234567891011&lt;html&gt; &lt;head&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1"&gt; &lt;link href="style.css" rel="stylesheet"&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt; &lt;div&gt;&lt;img src="awesome-photo.jpg"&gt;&lt;/div&gt; &lt;script src="app.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 3个关键资源 2个或更多个关键路径长度 11KB关键字节 我们有三个关键资源，关键字节总量最多为 11 KB，但是关键路径长度仍然是两个往返过程，因为我们可以并行传输 CSS 和 JavaScript！demo4： 如果app.js中的内容不涉及到操作DOM和CSSOM，只是一些分析类型的代码和其他不需要阻塞页面渲染的代码，则可以在中加入“async”属性： 1234567891011&lt;html&gt; &lt;head&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1"&gt; &lt;link href="style.css" rel="stylesheet"&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt; &lt;div&gt;&lt;img src="awesome-photo.jpg"&gt;&lt;/div&gt; &lt;script src="app.js" async&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 异步执行脚本有以下几项优势： 脚本再也不会阻止解析器，所以也不再是CRP的组成部分 因为没有其他关键脚本，CSS 也不需要阻止DomContentLoaded事件 DomContentLoaded事件触发得越早，其他应用逻辑执行的时间就越早 因此，经过优化的网页恢复到了具有两个关键资源（HTML 和 CSS）、具有两个往返过程的最短关键路径长度和 9 KB 的关键字节总量。demo5：如果CSS样式表仅适用于打印： 1234567891011&lt;html&gt; &lt;head&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1"&gt; &lt;link href="style.css" rel="stylesheet" media="print"&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt; &lt;div&gt;&lt;img src="awesome-photo.jpg"&gt;&lt;/div&gt; &lt;script src="app.js" async&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 因为 style.css 资源仅用于打印，所以只要DOM构建完成，浏览器就具有了渲染网页的足够信息！ 所以，该网页仅具有一个关键资源（HTML），最小关键呈现路径长度为一个往返过程和5KB的关键字节。 优化CRP常规步骤： 分析、描述关键路径：关键资源数量、字节数、关键路径长度 最小化关键资源数量：删除相应资源、延迟下载、标记为异步资源等 减少关键字节数，以减少资源下载时间（往返次数） 优化剩余关键资源的加载顺序：尽可能早的下载所有关键资源，以缩短关键路径长度 References https://developers.google.com... https://cn.udacity.com/course...]]></content>
  </entry>
  <entry>
    <title><![CDATA[npm 基本用法和实用技巧]]></title>
    <url>%2F2019%2F07%2F01%2Fyuque%2Fnpm%20%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E5%92%8C%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[基本用法 安装与升级 安装 升级 安装指定版本的 npm 常用命令 npm install npm uninstall npm update npm ls npm adduser npm init npm publish npm unpublish npm deprecate npm dist-tag npm view npm link npm conifg 工作原理 实用技巧 pacakge.json dependencies optionalDependencies peerDependencies bundledDependencies bin config .npmrc .npmignore scripts shrinkwrap cache基本用法安装与升级安装安装 Node.js 时会自动安装 npm。1nvm install 4 升级1npm install npm -g 安装指定版本的 npm1npm install npm@2 -g 常用命令 npm install 根据 package.json 文件安装依赖。 1npm install 安装指定的依赖包。 1npm install [&lt;@scope&gt;/]&lt;pkg&gt; 如果当前目录中存在 package.json 文件，则安装满足文件中版本规则的最高版本；否则安装最新版本依赖包。 安装指定版本的依赖包。 123npm install [&lt;@scope&gt;/]&lt;pkg&gt;@&lt;tag&gt;npm install [&lt;@scope&gt;/]&lt;pkg&gt;@&lt;version&gt;npm install [&lt;@scope&gt;/]&lt;pkg&gt;@&lt;version range&gt; 从本地位置安装依赖。 12npm install &lt;folder&gt;npm install &lt;tarball file&gt; 可以用 npm pack 生成 &lt;tarball file&gt; 从网络位置安装依赖。 123npm install &lt;tarball url&gt;npm install &lt;git:// url&gt;npm install &lt;github username&gt;/&lt;github project&gt; 常用参数： -g, --global：安装全局依赖，如果没有指定依赖包名，则将当前目录中的包安装至全局 -S, --save：安装依赖的同时将该依赖写入 dependencies -D, --save-dev：安装依赖的同时将该依赖写入 devDependencies -O, --save-optional：安装依赖的同时将该依赖写入 optionalDependencies -E, --save-exact：写入 package.json 时带有确切版本号 --no-optional：不安装 optional dependencies，可继承 --only={dev[elopment]|prod[uction]}：无视 NODE_ENV，只安装 devDependencies 或仅安装除了 devDependencies 之外的依赖项 --dry-run：走一遍安装的过程并报告结果，但实际上没有安装任何依赖 别名：i npm uninstall 删除一个指定的依赖包，并且完全移除为了该包而安装的任何文件 1npm uninstall [&lt;@scope&gt;/]&lt;pkg&gt;[@&lt;version&gt;]... [-S|--save|-D|--save-dev|-O|--save-optional] 常用参数：与 npm install 类似 别名：remove、rm、r、un、unlink npm update 升级所有依赖包至版本规则允许的最新版本，并安装缺失的依赖包 1npm update [&lt;pkg&gt;...] 常用参数： -g：升级全局依赖包 --dev：同时升级在 devDependencies 中的依赖包 --depth Infinity：从 npm@2.6.1 起 npm update 默认仅升级顶层依赖，使用该参数升级所有依赖包 --save：升级依赖包，同时记录升级后的版本 别名：up、upgrade npm ls 以树形结构打印依赖包及其版本 1npm ls [[&lt;@scope&gt;/]&lt;pkg&gt; ...] 常用参数： --json：以 JSON 格式输出 --long：输出额外信息 --global：输出全局依赖信息 --depth &lt;int&gt;：输出依赖树的最大深度 --prod[uction]：仅输出 dependencies 中的依赖 --dev：仅输出 devDependencies 中的依赖 别名：list、la、ll npm adduser登录 npm 1npm adduser npm init 提问，然后产生一个 package.json 文件 1npm init [-f|--force|-y|--yes] 常用参数： -f, --force, -y, --yes：使用默认的答案，不再提问 --scope &lt;scope&gt;：指定新模块的 scope，例如 mtfenpm publish 发布一个新的包，或一个包的新版本 1npm publish [&lt;tarball&gt;|&lt;folder&gt;] [--tag &lt;tag&gt;] [--access &lt;public|restricted&gt;] 如果没有 tarball 或 folder 被指定，则使用当前目录 常用参数： --tag &lt;tag&gt;：给被发布的包注册指定的 tag，如果没有该参数，则默认使用 latestnpm unpublish取消发布一个包，或一个包的某些版本1npm unpublish [&lt;@scope&gt;/]&lt;pkg&gt;[@&lt;version&gt;] npm deprecate弃用一个包，或一个包的某些版本，尝试安装这些弃用包的用户将会收到警告 1npm deprecate &lt;pkg&gt;[@&lt;version&gt;] &lt;message&gt; npm dist-tag 给一个包的某个版本注册 tag 1npm dist-tag add &lt;pkg&gt;@&lt;version&gt; [&lt;tag&gt;] 移除一个 tag 1npm dist-tag rm &lt;pkg&gt; &lt;tag&gt; 显示指定包的所有 tag 1npm dist-tag ls [&lt;pkg&gt;] npm view 显示一个包的详细信息1npm view [&lt;@scope&gt;/]&lt;name&gt;[@&lt;version&gt;] [&lt;field&gt;[.&lt;subfield&gt;]...] &lt;field&gt; 和 &lt;subfield&gt; 表示输出信息中的字段 别名：info、show、v npm link将一个本地目录中的模块符号链接至一个项目的依赖中，实现上述功能需要两步： 在模块目录中执行下面的命令，创建一个从全局依赖指向当前目录的符号链接 1npm link 12/usr/local/Cellar/nvm/0.25.4/versions/node/v4.4.4/lib/node_modules/handgrip-&gt; /Users/Dylan/handgrip 在其他目录中执行下面的命令，创建一个从局部依赖指向全局依赖的符号链接1npm link [&lt;@scope&gt;/]&lt;pkg&gt;[@&lt;version&gt;] [&lt;@scope&gt;/]&lt;pkg&gt;[@&lt;version&gt;] 所表示已经执行了第一步的模块，或其所包含的版本 1234# npm link handgrip/Users/Dylan/koalition-boilerplate/node_modules/handgrip-&gt; /usr/local/Cellar/nvm/0.25.4/versions/node/v4.4.4/lib/node_modules/handgrip-&gt; /Users/Dylan/handgrip 由于依赖通过符号链接的方式组织，在模块目录中的修改可以立即在其他目录中生效。 npm conifg 设置一个配置项 12npm config set &lt;key&gt; &lt;value&gt; [-g|--global]npm set &lt;key&gt; &lt;value&gt; [-g|--global] 如果配置项的值阙如，将采用默认值 true。 读取一个配置项 12npm config get &lt;key&gt;npm get &lt;key&gt; 删除一个配置项 1npm config delete key 列出所有的配置 1npm config list 在编辑器中打开配置文件 1npm config edit 使用 --global 来打开全局配置文件。 工作原理 下面的内容基本上翻译了 npm v3 Dependency Resolution、npm3 Duplication and Deduplication、npm3 Non-determinism 这三篇文章 npm v3 依赖解析的主要思想：尽可能地减少间接依赖安装目录的深度，最理想的情况是与直接依赖安装在同一目录下，通过这种方式来减少依赖目录的嵌套，缓解整个依赖目录层次过深的问题。（因为 Windows 中文件路径的长度不能大于 260 个字符。）🌰：假如我们有模块 A，模块 A 依赖了模块 B。 然后我们创建了已依赖模块 A 的应用 App。在执行 npm install 的时候，npm v3 会把模块 A 及其依赖模块 B 都安装在 /node_modules 目录中。（npm v2 则会把模块 B 会嵌套在模块 A 中。） 此时，我们的应用 App 又需要依赖模块 C，而模块 C 依赖了另一个版本的模块 B。 然而，由于模块 B v1.0 已经被安装在了顶层依赖目录中，模块 B v2.0 就无法安装到同一位置了。这种情况下，npm v3 将会默认采用 npm v2 的行为，将这个新的模块 B 嵌套在依赖它的模块中，也就是说，把模块 B v2.0 安装到模块 C 中。 在控制台打印出依赖树和目录树。 如果再安装一个依赖模块 B v1.0 或 v2.0 会怎么样呢？此时，我们的应用 App 又需要依赖模块 D，而模块 D 与模块 C 一样，依赖了模块 B v2.0。 由于模块 B v1.0 已经被安装在了顶层依赖目录中，模块 B v2.0 就无法安装到同一位置了。因此，尽管模块 C 中已经有了一份拷贝，模块 B v2.0 还是被安装到了模块 D 中（否则就 requrie 不到了）。 如果一个间接依赖被两个以上的包所依赖，且不能安装在顶层依赖目录中，那么这个间接依赖会被复制一份，并嵌套在直接依赖的目录中。相反地，如果一个间接依赖被两个以上的包所依赖，且被安装在顶层依赖目录中，那么这个依赖就不会被复制，而被依赖它的包所共享。🌰，我们又加了一个依赖模块 E，模块 E 与模块 A 一样，依赖了模块 B v1.0。 由于模块 B v1.0 已经安装再来顶层依赖目录中，所以不需要复制并嵌套该模块，直接安装模块 E，然后模块 E 就可以与模块 A 共享模块 B v1.0 了。 在控制台打印出依赖树和目录树。 如果我们把模块 A 升级至 v2.0，模块 A v2.0 不再依赖模块 B v1.0，而是依赖模块 B v2.0，这会怎么样呢？执行 npm install mod-a@2，npm v3 将做以下事情： 移除模块 A v1.0 安装模块 A v2.0 保留模块 B v1.0，因为模块 E 仍旧依赖它 由于模块 B v1.0 还在顶层依赖目录中，模块 B v2.0 被嵌套安装在模块 A v2.0 中 在控制台打印出依赖树和目录树。 最后，我们吧模块 E 升级至 v2.0，模块 E v2.0 同样不再依赖模块 B v1.0，而是依赖模块 B v2.0。 npm v3 将做以下事情： 移除模块 E v1.0 安装模块 E v2.0 由于没有模块依赖模块 B v1.0，移除该模块 由于顶层依赖目录中没有模块 B，在该目录中安装模块 B v2.0 在控制台打印出依赖树和目录树。 现在，模块 B v2.0 几乎出现在了每一个依赖目录中，这显然不够简洁，我们可以执行： 1npm dedupe 这条命令可以仅保留顶层依赖目录中的模块 B v2.0，而移除其他次级目录中的拷贝。在控制台打印出目录树。 我们让 App 回到刚才的一个状态： 在这个🌰中，我们的应用有以下 package.json 文件：{ “name”: “example3”, “version”: “1.0.0”, “description”: “”, “main”: “index.js”, “scripts”: { “test”: “echo &quot;Error: no test specified&quot; &amp;&amp; exit 1” }, “keywords”: [], “author”: “”, “license”: “ISC”, “dependencies”: { “mod-a”: “^1.0.0”, “mod-c”: “^1.0.0”, “mod-d”: “^1.0.0”, “mod-e”: “^1.0.0” }}如果此时运行 npm install，控制台会输出以下结果： 然后，我们再次把模块 A 升级到 v2.0，模块 A v2.0 不在依赖模块 B v1.0，而是依赖模块 B v2.0： 1npm install mod-a@2 --save 控制台输出： 此时，我们的依赖目录看起来是这样的： 而且我们得到了一个新的 package.json：{ “name”: “example3”, “version”: “1.0.0”, “description”: “”, “main”: “index.js”, “scripts”: { “test”: “echo &quot;Error: no test specified&quot; &amp;&amp; exit 1” }, “keywords”: [], “author”: “”, “license”: “ISC”, “dependencies”: { “mod-a”: “^2.0.0”, “mod-c”: “^1.0.0”, “mod-d”: “^1.0.0”, “mod-e”: “^1.0.0” }}接着，我们运行： 1npm install 控制台输出： 依赖目录变成了： 总结： 依赖目录的结构取决于依赖安装的顺序 npm install （不带参数）安装出的依赖目录结构是稳定的，因为 package.json 中依赖的排列顺序总是字典序 npm v3 需要尽可能的减少间接依赖安装目录的深度，于是不得不从树根至树叶一级一级遍历下来，寻找可用的最远祖先节点，严重延长了依赖的安装时间 实用技巧 pacakge.json dependencies版本号的写法： version: 必须匹配确切的版本号 &gt;version、&gt;=version、&lt;version、&lt;=version ~version：如果 minor 级的版本被确定的话，允许 patch 级的版本变化；否则允许 minor 级版本变化 ~1.2.3 := &gt;=1.2.3 &lt;1.3.0 ~1.2 := &gt;=1.2.0 &lt;1.3.0 ~1 := &gt;=1.0.0 &lt;2.0.0 ~0.2.3 := &gt;=0.2.3 &lt;0.3.0 ~0 := &gt;=0.0.0 &lt;1.0.0 ~1.2.3-beta.2 := &gt;=1.2.3-beta.2 &lt;1.3.0 ^version：允许版本号中不修改最左非零位及其前缀的所有版本号更高的变化 ^1.2.3 := &gt;=1.2.3 &lt;2.0.0 ^0.2.3 := &gt;=0.2.3 &lt;0.3.0 ^0.0.3 := &gt;=0.0.3 &lt;0.0.4 ^1.2.3-beta.2 := &gt;=1.2.3-beta.2 &lt;2.0.0 ^0.0.3-beta := &gt;=0.0.3-beta &lt;0.0.4 ^1.2.x := &gt;=1.2.0 &lt;2.0.0 ^0.0.x := &gt;=0.0.0 &lt;0.1.0 ^0.0 := &gt;=0.0.0 &lt;0.1.0 ^1.x := &gt;=1.0.0 &lt;2.0.0 1.2.x：1.2.0、1.2.1 等，不包括 1.3.0 * 或空：任何版本 version1 - version2：&gt;=version1 &lt;=version2 range1 || range2 tag：指定 tag file:...：本地路径 http://...、git...：网络路径 git://github.com/user/project.git#commit-ish git+ssh://user@hostname:project.git#commit-ish git+ssh://user@hostname/project.git#commit-ish git+http://user@hostname/project/blah.git#commit-ish git+https://user@hostname/project/blah.git#commit-ish user/repo#commit-ish：GitHub 仓库optionalDependenciesoptionalDependencies 中的依赖安装失败时，npm 不会停止整个安装过程。模块本身应当处理由于依赖安装失败导致依赖缺失的问题，🌰如：try { var foo = require(‘foo’) var fooVersion = require(‘foo/package.json’).version} catch (er) { foo = null}if ( notGoodFooVersion(fooVersion) ) { foo = null} // .. then later in your program .. if (foo) { foo.doFooThings()} peerDependenciespeerDependencies 表示当前模块适配其他某些模块，也就是只有当那些指定的模块被安装时，当前模块才会被安装。🌰如：{ “name”: “tea-latte”, “version”: “1.3.5”, “peerDependencies”: { “tea”: “2.x” }}表示确保模块 tea-latte 只能同模块 tea 2.x 一起安装。 如果 peerDependencies 中的模块没有被明确依赖的话，npm v2 会自动安装这些模块，但 npm v3 不会再安装这些模块，而是输出一个警告。 bundledDependenciesbundledDependencies 表示在当前模块打包或发布时，需要被置于模块内部的依赖。使用的时机： 使用的依赖不是来自于 npm，或者修改了这个依赖 使用开发者自己的项目作为依赖 希望在模块中包含一些文件bin将可执行的文件安装到 PATH 中。可能安装到的位置有：12345# global:/usr/local/opt/nvm/versions/node/v4.4.4/bin//usr/local/bin/# local:./node_modules/.bin/ 🌰：{ “bin” : { “myapp” : “./cli.js” } }当安装这个模块时，npm 会创建一个指向 cli.js 的符号链接。{ “name”: “my-program”, “version”: “1.2.5”, “bin”: “./path/to/program” }上面的写法等价于：{ “name”: “my-program”, “version”: “1.2.5”, “bin” : { “my-program” : “./path/to/program” } } configpackage.json 文件中的 config 字段可以用来设置模块脚本中可以用到的配置参数。🌰，如果一个模块有：{ “name” : “foo”, “config” : { “port” : “8080” } }那么在模块脚本（如 start）中就可以通过 process.env.npm_package_config_port，访问到这个配置。这个配置也可以被命令 npm config set foo:port 8001 覆盖。 .npmrc配置文件有： 项目配置文件（/path/to/my/project/.npmrc） 用户配置文件（~/.npmrc） 全局配置文件（/path/to/node/etc/npmrc） 内置配置文件（/path/to/npm/npmrc） 环境变量用法： 1prefix = $&#123;HOME&#125;/.npm-packages 数组用法： 12key[] = &quot;first value&quot;key[] = &quot;second value&quot; 项目配置文件和用户配置文件的权限必须设置为只能被当前用户读写（0600），否则该配置文件会被 npm 忽略 可以通过 npm config 命令来管理配置文件。常用配置项： cache：npm 本地缓存目录，默认 ~/.npm cache-max：保持缓存项目且不向 registry 检查的最长时间，单位秒，默认 Infinity，缓存中的数据不会自动删除除非执行 npm cache clean 命令 cache-min：保持缓存项目且不向 registry 检查的最短时间，单位秒，默认 10，可以置为 999999 等以尽量延长缓存生效时间 depth：npm ls 等命令中的默认深度，默认 Infinity editor：npm 默认使用的编辑器 engine-strict：如果置为 true，npm 将会拒绝安装不符合当前 Node.js 版本的模块 force：强力执行一些命令 生命周期脚本执行失败不再阻塞安装过程 发布会覆盖已经发布的版本 访问 registry 时会跳过缓存 global：全局模式 globalconfig：全局配置文件的路径 global-style：以安装全局依赖的方式安装局部依赖，只有直接依赖会被放在顶层依赖目录中 https-proxy：代理 if-present：如果置为 true，npm run-script 就不会在脚本找不到时报错 ignore-scripts：如果置为 true，npm 就不会运行 package.json 定义的脚本 init-module：指定 npm init 命令运行的模块 init-author-name：npm init 使用的默认作者名 init-author-email：npm init 使用的默认作者邮箱 init-author-url：npm init 使用的默认作者 URL init-license：npm init 使用的默认许可证 init-version：npm init 使用的默认版本号 json：npm ls 等命令输出 JSON 格式的数据 link：如果置为 true，如果全局依赖中有合适的包，安装局部依赖时将会直接链接到这个全局依赖的包；如果全局依赖中没有该包的任何版本，则全局安装这个包，并链接到局部依赖中；其他情况则在局部依赖中安装该包 long：npm ls 和 npm search 显示额外信息 message：npm version 写在 git 提交中的信息，%s 将被替换为版本号 npat：安装时运行测试 onload-script：指定一个在 npm 加载时 require() 的包，编程使用 npm 时可能会有用 only：与命令中的 --only 效果类似 optional：如果置为 false，则不安装 optionalDependencies 中的依赖 prefix：指定安装全局依赖的路径 production：如果置为 true，则开启生产模式，npm install 将不安装开发依赖，声明周期脚本运行时自动设置 NODE_ENV=&quot;production&quot; registry：指定 npm registry 的 URL rollback：移除安装失败的模块 save：与命令中的 --save 效果类似 scope：与命令中的 --scope 效果类似 shrinkwrap：如果置为 false，安装时忽略 npm-shrinkwrap.json progress：如果置为 false，不显示进度条 loglevel：设置输出日志的 level，置为 silly 可以显示全部日志 .npmignore当模块目录中存在 .gitignore 但没有 .npmignore 时，npm 将会忽略 .gitignore 中的文件。如果目录中存在 .npmignore，npm 将会根据 .npmignore 忽略文件。默认被 npm 忽略，不需要添加到 .npmignore 中的文件： .*.swp ._* .DS_Store .git .hg .npmrc .lock-wscript .svn .wafpickle-* config.gypi CVS npm-debug.log 除了 bundled dependencies 外，node_modules 中的所有文件也会被忽略。下面的文件即使添加到 .npmignore 中的文件也不会被忽略： package.json README（及其变体） CHANGELOG（及其变体） LICENSE、LICENCE scriptsnpm 支持的生命周期脚本有： prepublish: 发布模块之前执行，也在不带任何参数的局部 npm install 之前执行 publish、postpublish: 发布模块之后执行 preinstall: 安装该模块之前执行 install、postinstall: 安装该模块之后执行 preuninstall、uninstall: 移除该模块之前执行 postuninstall: 移除该模块之后执行 preversion、version: 修改模块版本号之前执行 postversion: 修改模块版本号之后执行 pretest、test、posttest: 在 test 命令的前后执行 prestop、stop、poststop: 在 stop 命令的前后执行 prestart、start、poststart: 在 start 命令的前后执行. prerestart、restart、postrestart: 在 restart 命令的前后执行，如果 restart 脚本没有提供，restart 命令将会执行 stop 脚本再执行 start 脚本 对于自定义名称的脚本，可以通过 npm run-script &lt;pkg&gt; &lt;stage&gt; 来执行，匹配名称的 pre 和 post 命令同样也会执行。 shrinkwrapnpm shrinkwrap 可以用来锁定依赖的版本号。一个使用的🌰： 我们有模块 A： { “name”: “A”, “version”: “0.0.1”, “dependencies”: { “B”: “&lt;0.1.0” }} 模块 B： { “name”: “B”, “version”: “0.0.1”, “dependencies”: { “C”: “&lt;0.1.0” }} 和模块 C： { “name”: “C”, “version”: “0.0.1”} 这三个模块都只有 0.0.1 这一个版本。此时运行 npm install A，将会得到： 123A@0.0.1`-- B@0.0.1 `-- C@0.0.1 如果模块 B 发布了 0.0.2 版本，此时运行npm install A，将会得到： 123A@0.0.1`-- B@0.0.2 `-- C@0.0.1 但是模块 A 的作者希望安装原来的版本，那么他可以运行： 1npm shrinkwrap 然后在项目目录下得到了一个npm-shrinkwrap.json文件： { “name”: “A”, “version”: “0.0.1”, “dependencies”: { “B”: { “version”: “0.0.1”, “from”: “B@&lt;0.1.0”, “resolved”: “https://registry.npmjs.org/B/-/B-0.0.1.tgz&quot;, “dependencies”: { “C”: { “version”: “0.0.1”, “from”: “C@&lt;0.1.0”, “resolved”: “https://registry.npmjs.org/C/-/C-0.0.1.tgz&quot; } } } }} npm shrinkwrap命令根据当前目录中的 node_modules 目录锁定了依赖版本号，此时再运行npm install，该命令的行为将变为： 重新构造 npm-shrinkwrap.json 中描述的依赖树，如果一个依赖项中的 resolved 字段可用，则使用该字段获取依赖，否则使用 version 字段来获取依赖 以普通的方式安装 npm-shrinkwrap.json 中缺失的依赖 添加或升级依赖包的方法： 添加或升级一个依赖包 1npm install --save &lt;pkg&gt; 升级所有依赖包 1npm install --no-shrinkwrap 注意事项： 如果 node_modules 目录中的依赖比 package.json 中定义的多或者少，npm shrinkwrap 命令将会失败 npm shrinkwrap 命令不锁定 devDependencies 中依赖的版本，即 npm-shrinkwrap.json 中不包含开发依赖；如果希望锁定开发依赖的版本，则需要在运行命令时加上 --dev 参数 shrinkwrap 不会继承，即执行过程中不会访问依赖的 npm-shrinkwrap.json 文件；但是，依赖中如果有 npm-shrinkwrap.json 文件，在安装该依赖的时就会按照这个文件来安装相关的模块到 node_modules 目录中，如果没有 npm-shrinkwrap.json 文件，开发者需要在使用 shrinkwrap 前自行确认 node_modules 目录中的依赖都是有效的；shrinkwrap 总是据当前目录中的 node_modules 目录中的内容锁定依赖版本号 cachenpm 将数据缓存在 npm config get cache 命令指定的路径中。当局部安装一个模块时，npm 会执行以下步骤： 检查缓存中的模块信息文件（.cache.json，包括 ETag 等信息）是否存在并在免检时间内 如果存在合适的缓存信息文件且没有超过免检时间，执行步骤 6 获取该模块的最新信息文件，然后计算出合适的模块版本号 如果缓存中有该版本号的模块，则执行步骤 6 下载该版本号的模块，并将其载入缓存中 取缓存中的文件，并将其安装至目标路径中 npm cache 命令的用法： 向缓存中添加指定的模块： 1234npm cache add &lt;tarball file&gt;npm cache add &lt;folder&gt;npm cache add &lt;tarball url&gt;npm cache add &lt;name&gt;@&lt;version&gt; 显示缓存中的数据： 1npm cache ls [&lt;path&gt;] 清空缓存： 1npm cache clean [&lt;path&gt;] npm 缓存的改进方案： local-npm：一个本地 npm 镜像，但是仅缓存已经安装过的模块，没有网络时自动回退到本地 npm_lazy 转自：https://github.com/theicebear/npm-basic-usage]]></content>
  </entry>
  <entry>
    <title><![CDATA[REST]]></title>
    <url>%2F2019%2F07%2F01%2Fyuque%2FREST%2F</url>
    <content type="text"><![CDATA[REST是什么？ 万维网软件架构风格 用来创建网络服务 为何叫REST Representational State Transfer Representational:数据的表现形式（JSON、XML……） State:当前状态或者数据 Transfer:数据传输 通过REST的6个限制详细了解它 客户-服务器（Client-Server） 关注点分离 服务端专注数据存储，提升了简单性 前端专注用户界面，提升了可移植性 无状态（Stateless） 所有用户会话信息都保存在客户端 每次请求必须包括所有信息，不能依赖上下文信息 服务端不用保存会话信息，提升了简单性、可靠性、可见性 缓存（Cache） 所有服务端响应都要被标为可缓存或不可缓存 减少前后端交互，提升了性能 统一接口（Uniform Interface） 接口设计尽可能统一通用，提升了简单性、可见性 接口与实现解耦，使前后端可以独立开发迭代 分层系统（Layered System） 每层只知道相邻的一层，后面隐藏的就不知道了 客户端不知道是和代理还是真实服务器通信 其他层：安全层、负载均衡、缓存层等 按需代码（Code-On-Demand可选） 客户端可以下载运行服务端传来的代码（比如JS） 通过减少一些功能，简化了客户端 RESTful API简介 什么是RESTful API？符合REST架构风格的API RESTful API 具体什么样子？基本的URI，如：https//api.github.com/users标砖HTTP方法，如GET，POST，PUT，PATCH，DELETE传输的数据媒体类型，如：JSON，XML 现实举例GET /users#获取user列表GET /users/12#查看某个具体的userPOST /users#新建一个userPUT /users/12#更新user12DELETE/users/12 #删除user12 github接口文档：https://developer.github.com/v3/repos/ GitHub API示例]]></content>
  </entry>
  <entry>
    <title><![CDATA[基于websocket的火拼俄罗斯（单机版）]]></title>
    <url>%2F2019%2F07%2F01%2Fyuque%2F%E5%9F%BA%E4%BA%8Ewebsocket%E7%9A%84%E7%81%AB%E6%8B%BC%E4%BF%84%E7%BD%97%E6%96%AF%EF%BC%88%E5%8D%95%E6%9C%BA%E7%89%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[https://www.imooc.com/learn/882]]></content>
  </entry>
  <entry>
    <title><![CDATA[基于Websocket的火拼俄罗斯（基础）]]></title>
    <url>%2F2019%2F07%2F01%2Fyuque%2F%E5%9F%BA%E4%BA%8EWebsocket%E7%9A%84%E7%81%AB%E6%8B%BC%E4%BF%84%E7%BD%97%E6%96%AF%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[https://www.imooc.com/learn/861]]></content>
  </entry>
  <entry>
    <title><![CDATA[nodejs调试]]></title>
    <url>%2F2019%2F07%2F01%2Fyuque%2Fnodejs%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[使用Inspector调试Node.js程序 Inspector介绍http://nodejs.cn/api/inspector.html 使用Inspector调试Node.js的优势 可查看当前上下文的变量 可观察当前函数调用堆栈 不侵入代码 可在暂停状态下执行指定代码 12mkdir node-debugcode node-debug 在mac中使用vscode的命令code以及使用命令行在vscode中打开文件夹使用command + shift + p，并输入shell，选择Shell Command:Install ‘code’ command in PATH,如上图。完成后，即可使用vscode的命令行 code. 如何用code命令打开文件夹1.在新窗口中打开文件夹cd到需要打开的文件夹下，然后使用code -n .上面指令中的-n 表示new window2.在原窗口中打开文件夹cd到需要打开的目录下，使用code -r .上面指令中的-r表示 reuse window至于code的其它命令，可以使用code -h查看和学习。 1234567891011let v = 0;function a(v) &#123; let v2 = 100; v += v2;&#125;function b() &#123; a(v);&#125;b(); devtoolsFrontendUrl用于谷歌浏览器调试 Inspector的构成以及原理 WebSockets服务（监听命令） Inspector协议 http://nodejs.cn/api/inspector.html HTTP服务（获取元信息） ### 激活调试 如何激活调试1node --inspect app.js 因为代码执行完了，所以没有下文了 我们接下来弄一个可以一直看的 那用express弄一个http://www.expressjs.com.cn/ 例子有了 1node app.js 关闭指定的端口号：lsof -i:端口号 kill -9 6422 为什么node –inspect app.js 不能激活**这样设置后就好了 激活调试后会发生什么 Node进程通过WebSockets监听调试信息 启动一个HTTP服务，提供元信息 如何调试没有激活的Node.js程序？ 在Linux和OSX上，可以监听到SIGUSR1发送的调试信息 调试客户端Chrome DevTools 访问chrome://inspect 点击配置按钮，确保Host和Port对应 访问元信息中的devtoolsFrontendUrl 点击绿色小图标 调试客户端-Chrome devtools 调试客户端-vscode 启动方式：按F5 这种方式适合简单的场景 配置launch.json or “打开自动附加” 添加参数后面在配置文件里面可以配置成点击调试面板，两处任意一个都行，都可以开启调试添加配置可以启动多个服务 调试动作 数据展现 Log Point RERL命令行参数介绍带领大家解读官网文档，并通过实际案例介绍；debugger调试器]]></content>
  </entry>
  <entry>
    <title><![CDATA[禁止Macoofie]]></title>
    <url>%2F2019%2F07%2F01%2Fyuque%2F%E7%A6%81%E6%AD%A2Macoofie%2F</url>
    <content type="text"><![CDATA[1.sudo su 2.ps -ef | grep Mc 3.pkill -f Mc]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端开发全面知识库]]></title>
    <url>%2F2019%2F07%2F01%2Fyuque%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%85%A8%E9%9D%A2%E7%9F%A5%E8%AF%86%E5%BA%93%2F</url>
    <content type="text"><![CDATA[前端开发全面知识库，包括HTML5，CSS3和js的基本框架知识，以及DOM和BOM操作的基础知识和一些基本工具和IDE。学习本篇，你将了解到以下知识。 核心 Core HTML5W3C HTML 5 教程W3C HTML5 Chinese Interest Group Wiki菜鸟教程 HTML5 教程 | 菜鸟教程HTML5中文门户 HTML5中国：中国最大的HTML5中文门户 - Powered by Discuz! CSS3W3C CSS教程 CSS 教程W3C CSS3教程 CSS3 教程菜鸟教程CSS教程 CSS 教程 | 菜鸟教程菜鸟教程CSS3教程 CSS3 教程 | 菜鸟教程CSS参考手册 CSS参考手册_web前端开发参考手册系列 JSW3C JavaScript 教程菜鸟教程 JavaScript 教程 | 菜鸟教程廖雪峰js教程 Home - 廖雪峰的官方网站js标准参考教程-阮一峰JavaScript 标准参考教程（alpha） jQueryW3C jQuery 教程菜鸟教程 jQuery 教程 | 菜鸟教程极客学院 jQuery教程_jQuery开发中文手册[PDF]下载-极客学院Wiki廖雪峰 http://www.liaoxuefeng.com/wiki/参考手册 jQuery API 中文文档(适用jQuery 1.0 - jQuery 3.1)参考手册 jquery 在线手册 ES6阮一峰ES6 ECMAScript 6入门极客学院 ECMAScript 6 入门-极客学院WikiJavaScript 标准参考 阮一峰JavaScript 标准参考教程（alpha） 插件parallel.js: 前后端通用的一个并行库zepto: 用于现代浏览器的兼容 jQuery 的库totoro: 稳定的跨浏览器测试工具TheaterJS: 一个用于模拟人输入状态的 JS 库stellar.js: 前端用于实现异步滚动效果的库，现已不再维护skrollr: 另一款实现一步滚动的开源库，使用人数众多，可实现各种狂拽酷炫掉渣天的前端效果，看真相Framework7: 前端框架，是开发人员可以基于 web 技术构建 IOS7 程序regulex: 用于生成 正则表达式 的可视化流程图markdown-it: 新型 Markdown 解析器，快速，支持插件multiline: 用于 Javascript 中的多行文本，类似于 Ruby 的 HERE Docscreenfull.js: 全屏插件，支持各大浏览器lunr.js: 类似于 Solr, 但是用于浏览器上的全文搜索引擎，可以为 JSON 创建索引，离线也可以使用jquery.hotkeys: jQuery 插件，用于绑定热键breach_core: Javascript 编写的 Browser (浏览器)octocard: 用于生成 Github 信息卡片的库github-cards: 用于生成 Github 信息卡片的库money.js: 轻量级货币转换库，web 和 node 皆可用accounting.js: 轻量级的数字、货币转换库javascript-algorithms: Javascript 实现的各种算法集合lazy.js: 类似于 underscore, 但是会延迟执行，某些场景下，性能会有很大的提升seajs: 前端模块加载器，解决模块化、依赖等问题jQuery-One-Page-Nav: 单页应用中一个用于处理导航栏的库js.js: Javascript 实现的 javascript JITjquery-ui: jQuery 团队开发的 UI 相关的前端库，功能强大todomvc: 分别基于 AngularJS/EmberJS/Backbone等实现的 TODO List, 帮助开发者选择前端 MVC 库localForage: Mozilla 出品，用于离线存储，基于IndexedDB, WebSQL 或者 localStorage, 提供一致的接口EventEmitter: 浏览器版的 EventEmitterjquery.serializeJSON: jQuery 插件，用于将 form 表单序列化成 JSON 数据knockout: 前端 MVVM 框架，用于开发富前端应用mermaid: 可以根据文本生成流程图，类似于 Markdown 的语法js-sequence-diagrams: 另一款可以根据文本生成流程图的库，类似于 Markdown 的语法flow: 一个用来检测 Javascript 语法错误的库， Facebook 出品zoomooz: jQuery 插件，用来处理浏览器缩放fancyBox: 一个用于放大缩小图片、Web 内容或者多媒体元素的库，优雅大方mithril.js: 轻量型前端 MVC 框架，部分使用场景下性能优于 Angular.js 和 Reactbackbone: 强大的前端 MVC 库，鼻祖级前端库，最初为了配合 Rails 来模块化前端应用，兼容性良好 (兼容到 IE6)，插件丰富，性能良好jquery.smartbanner: smartbanner 是从 IOS6 开始支持的一个新特性, 这个插件提供了对早期 IOS4/5 和 Android 的支持jquery.scrollTo: 在页面上以一个元素为起始以动画的方式移动(ScrollTo)到另一个元素， 支持回退等jScrollPane: 自定义的滚动条，让所有浏览器都显示一样的滚动条onepage-scroll: 提供类似于 iPhone6 展示页类似的效果，适用于单页应用，兼容到 IE8scrollMonitor: 前端插件用来监控元素的滚动事件(进入、退出等)，性能很好ScrollMagic: 神奇的滚动交互效果插件，可以在滚动的过程中设置各种各样的动态效果infinite-scroll: 滚动加载，滚动到最下到自动加载， Paul Irish 大神之作animatable: 仅仅依靠 border-width 和 background-position 实现的各种动态效果，看真相Fluidbox: 页面上内嵌图片的放大缩小效果，类似于 Medium 中的效果jquery-validation: jQuery 的一个插件，用于校验 Form 表单BigVideo.js: jQuery 的一个插件, 用于实现大背景(视频、图片)效果emscripten: 一款基于 LLVM, 可以将 C/C++ 转换成 Javascript 的工具，使得 Javascript 可以近乎 Native 的速度qrcode-generator: 各种语言的二维码生成工具device.js: 一个可以检测设备类型的工具，可以让我们根据不同的设备来为其定制响应的 Javascript 和 CSSjquery-qrcode: jQuery 插件，用来生成二维码Wookmark-jQuery: jQuery 的一个插件，可以用来实现瀑布流的效果isotope: 可以用来过滤、排列布局，实现美观的动态布局切换效果，Demolazysizes: 功能强大的图片延迟加载工具，可以首先加载一个低质量的图片，然后再加载高质量的图片progressbar.js: 简洁美观的进度条，扁平化pigshell: 一个由 Javascript 实现的Shell, 将互联网当做一个大的文件系统, 通过 cd/ls/cat…..等命令, 可以访问 Facebook/Twitter/Google Drive 等网络服务spectrum: Js实现的颜色选择器 (Colorpicker)jQuery.countdown: jQuery 倒计时插件summernote: WYSIWYG 富文本编辑器awesomplete: 非常轻型的一个自动补全 JS 库, 没有任何依赖, 配置简单, 美观switchery: IOS 7 上 Switch 的 JS 实现, 支持 IE8 及以上浏览器trix: Basecamp 公司出品的富文本编辑器，简洁小巧sensor.js: 在智能移动设备浏览器上，通过HTML5的api使用移动设备的功能。定位、运动、倾斜等hyhyhy: 用于创建 基于 HTML5 的 演示文稿swipebox: jQuery 插件，用于处理移动端的触摸事件FileAPI: 前端用户处理文件（拖放、多文件上传等）Sortable: 现代浏览器上用于实现元素拖拽排序的功能，支持 Meteor, AngularJS, React，不依赖 jQuerySwiper: 用于实现浏览器上的滑动切换效果，支持硬件加速matter-js: 2D 物理效果引擎，碰撞、弹跳等jQTouch: 用于辅助创建手机端的 Web 应用，支持主题、Zepto.js 等snabbt.js: 一个利用 Javascript 和 CSS transform 的 animation 库c3: 基于 D3 的图表库echarts: 企业级图表库，百度开发parallax.js: 一个用于响应智能手机 orientation 的库jQuery-Animate-Enhanced: jQuery 动画库的一个增强，用于现代浏览器wysihtml: 富文本编辑器，适用于现代浏览器slip: 一个通过滑动或者拖拽来操控列表的库evil-icons: 一个矢量图库，提供 Ruby/Node 等支持PhotoSwipe: JS 的一个图片展示库focusable: 是页面上一个元素高亮的库，有图有真相firefox.html: Firefox 在浏览器端的实现 —— HTML 版的 Firefoxjquery-mobile: jQuery 团队开发的用于辅助手机端 web app 开发的库，基于 HTML5mobile-angular-ui: 基于angularjs和bootstarp的web app开发框架interact.js: 一个适用于现代浏览器的，用于处理 手势、拖放、缩放等的库rebound-js: 实现部分物理效果，Facebook 出品basket.js: 基于 LocalStorage 的资源加载器，可以用来缓存 script 和 css, 手机端使用速度快于浏览器直接缓存iscroll: 高性能的滚动(scroll)处理库，功能强大，支持各种事件，不依赖任何的库，且插件丰富, 大众点评的手机端列表滚动就是用这个库处理的metrics-graphics: 基于 D3 的图表库，简洁、高效，Mozilla 出品accessible-html5-video-player: Paypal 出品的 Video 播放器loading: 几种 Loading 效果，基于 SVGflippant.js: 一款能够漂亮的网页元素翻转效果库，代码许久不更新，不过作为源码学习还是不错的move.js: 基于 CSS3 的前端动画框架scrollReveal.js: 使元素以非常酷帅的方式进入画布 (Viewpoint)，看 DemoModernizr: 一个用来检测 HTML5 和 CSS3 支持情况的库foundation: 另一款前端模版框架，类似于 BootstrapFlat-UI: Bootstrap 的一款主题，简洁美观iCheck: 一款漂亮的 Checkbox 插件Swipe: 非常轻量级的一个图片滑动切换效果库, 性能良好, 尤其是对手机的支持, 压缩后的大小约 5kbslick: 功能异常强大的一个图片滑动切换效果库SocialButtons: 漂亮的社交按钮sweetalert: 一个非常美观的用于替换浏览器默认 alert 的库web-animations-js: Javascript 实现的 Web Animation APIvivus: 可以动态描绘 SVG 的 JS 库, 支持多种动画plyr: 轻量, 小巧, 美观的 HTML5 视频播放器timesheet.js: 基于 HTML5 &amp; CSS3 时间表slideout: 一个非常美观的侧滑菜单 包管理工具 Package Managers NPM菜鸟教程NPM 使用介绍 NPM 使用介绍 | 菜鸟教程淘宝 NPM 镜像 淘宝 NPM 镜像npm 模块安装机制简介 npm 模块安装机制简介 - 阮一峰的网络日志npm包搜索地址 npm BowerBower中文网 BowerBower：客户端库管理工具-阮一峰 JavaScript 标准参考教程（alpha） Yarnyarn中文网 https://yarnpkg.com/zh-Hans/快速、可靠、安全的依赖管理YARN 简介 YARN 简介 编辑器 Text Editors WebStorm官网下载 Download WebStorm: The Smartest JavaScript IDE前端网破解版下载 前端工具库 - 前端网（QDFuns） VScode官网下载 Visual Studio Code - Code Editing. Redefinedvscode 插件精选 - 献给所有前端工程师vscode 插件推荐 - 献给所有前端工程师（更新与2017.3.6） SublimeText官网下载 The text editor you’ll fall in love with前端网破解版插件版下载 前端工具库 - 前端网（QDFuns）SublimeCodeIntel: Sublime Text 的代码补全工具，支持多种语言Emmet：一个用于提高开发效率的编辑器插件，前身是Zen codingSublimeLinter: 一个提供代码质量检测的插件SublimeTmpl：快速新建指定的模版文件Syntax-highlighting-for-Sass：sass代码高亮插件MarkdownEditing: Sublime Text 强大的 Markdown 扩展, 提供快捷键, 主题等ApplySyntax: 辅助检测语法插件CTags: Sublime Text Ctags 支持插件, 需要安装 ctagssublime-react: React 代码高亮 Atom官网下载 A hackable text editor for the 21st Century HBuilder官网下载 DCloud - HBuilder、5+、mui、流应用、HTML5专家 JS框架 JS Frameworks BackboneBackbone.js API中文文档Backbone.js API中文文档 AngularJs中文官方文档Angularangularjs中文网AngularJS中文网angularjs教程AngularJS中文网Angular 基础入门Angular 基础入门 - 汪磊 - 博客园angular-masonry: Masonry 的 AngularJS 插件，用于瀑布流angular-schema-form: 根据 JSON 生成响应的 Form 表单restangular: Angular 中用来处理 RESTful API 的插件，可替代 $resourceng-cordova: Cordova 常用组件的 Angular 版本angular-translate: Angular 的国际化 (I18n)ng-inspector: Chrome 插件，用于调试 Angularangularjs-style-guide: AngularJS 代码风格ngReact: React 的 Angular 插件，可以在 Angular 中使用 React Componentsmaterial: Google Material Design 效果的 Angular 实现angular-local-storage: Angular 插件, 提供了对 localStorage 的友好支持, 并对不支持的浏览器使用 cookie 优雅降级angular-filter: 一组有用的 Angular Filtersbindonce: Angular 插件, 用于减少 Watcher 的数量, 提升性能 React英文官方文档Hello World - React中文官方文档入门教程 | Reactgitbooks手册React 概览 | React 入门教程阮一峰react入门React 入门实例教程 - 阮一峰的网络日志阮一峰React Router入门React Router 使用教程React Router 中文文档React Router 中文文档react-redux 中文文档Redux 中文文档 Join the chat at https://gitter.im/camsong/redux-in-chinese阮一峰Redux 入门教程阮一峰的网络日志react: React 框架源代码react-native: Facebook 出品的使用 React 开发 IOS 原生应用的框架react-hot-loader: 实时调整 React 组件效果grunt-react: React 的 Grunt 组件, 用于将 JSX 编译成 JStouchstonejs: 基于 React 的手机应用前端框架essential-react: 基于 React, ES6, React-Router的一个应用脚手架react-router: React 路由解决方案 Vuevue官方vue.jsvuex官方Introduction · GitBookvue-router官方Introduction · GitBook UI框架 UI Frameworks Bootstrap最受欢迎的 HTML、CSS 和 JS 框架 Bootstrap 中文文档 · Bootstrap 是世界上最流行的、移动设备优先的、响应式前端开发框架。 Ionic一款接近原生的Html5移动App开发框架 会html css js就可以开发apphttp://www.ionic.wang/ FoundationFoundation 中文网 迄今为止最好的响应式前端框架Foundation中文网 | 方便更多热爱Foundation中文网框架的攻城师们分享、交流自己在前端设计、开发方面的心得。 FrozenUI移动端服务的前端框架FrozenUI - 专注于移动web的UI框架 materializecss基于Material Design的主流前端响应式框架手册 - Materialize - ?spm=5176.100239.blogcont71256.188.tjoyi2 mui最接近原生APP体验的高性能前端框架MUI-最接近原生APP体验的高性能前端框架 AntDesign和react配合的UI框架A UI Design Language eleme和vue配合的UI框架Element JS预处理 JS Preprocessors TypeScriptTypeScript 入门教程 菜鸟教程菜鸟教程 - 学的不仅是技术，更是梦想！TypeScript中文网TypeScript中文网 · TypeScript–JavaScript的超集TypeScript教程gitbookhttps://www.gitbook.com/ CoffeeScriptCoffeeScript 中文CoffeeScript 中文CoffeeScript 实用手册 极客学院CoffeeScript 教程_极客学院 Wiki 过程自动化 Process Automation GruntGrunt中文网JavaScript世界的构建工具 – Grunt中文网 Gulpgulp.js 中文网基于流的自动化构建工具。 | gulp.js 中文网gulp详细入门教程一点 | gulp详细入门教程前端构建工具gulpjs的使用介绍及技巧前端构建工具gulpjs的使用介绍及技巧 - 无双 - 博客园Gulp开发教程Gulp开发教程（翻译） - w3ctech - 中国最大的前端技术社区 模板引擎 Templating Handlebarshandlebarsjs官网Minimal Templating on SteroidsHandlebars中文文档http://www.360doc.com/content/Handlebars.js 中文文档Handlebars.js 中文文档Handlebars的使用方法文档整理Handlebars的使用方法文档整理(Handlebars.js) - 推酷 Hamlhaml官方文档haml/hamlhaml入门haml入门 - 姚攀的博客 - 博客频道 - CSDN.NET JadeJade 官方的英文文档Jade的使用_jade 教程_w3cplusJade的使用Jade的使用_jade 教程_w3cplus带你学习Jade模板引擎视频带你学习Jade模板引擎-慕课网 构建工具 Build Tools RequireJSRequireJS 英文网RequireJSRequireJS 中文网RequireJS 中文网require.js的用法-阮一峰阮一峰的网络日志 seajsseajs文档A Module Loader for the WebSeaJS从入门到原理SeaJS从入门到原理 - 推酷 Browserify官网Browserifygithubhttps://github.com/substack/node-browserify/ WebpackWebpack 中文指南介紹 | Webpack 中文指南webpack的实例VICHILY’S BLOGwebpack的入门VICHILY’S BLOG一小时包教会 —— webpack 入门指南一小时包教会 – webpack 入门指南 CSS预处理器 CSS Preprocessors Sasssass入门sass入门 - sass教程sass参考手册Sass 参考手册 | Sass 中文文档SASS用法指南-阮一峰阮一峰的网络日志 Lessless中文网Less 中文网less快速入门快速入门 | Less.js 中文文档 stylusstylus中文文档-张鑫旭stylus中文文档 “ 综述 “ 张鑫旭-鑫空间-鑫生活亲们阿里云云栖社区已开通专栏，欢迎关注阅读：我是程序员 - 知乎专栏 转自：https://zhuanlan.zhihu.com/p/25604225]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于H5页面在iPhoneX适配]]></title>
    <url>%2F2019%2F06%2F28%2Fyuque%2F%E5%85%B3%E4%BA%8EH5%E9%A1%B5%E9%9D%A2%E5%9C%A8iPhoneX%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[1. iPhoneX的介绍 屏幕尺寸我们熟知的iPhone系列开发尺寸概要如下：△ iPhone各机型的开发尺寸转化成我们熟知的像素尺寸：△ 每个机型的多维度尺寸倍图其实就是像素尺寸和开发尺寸的倍率关系，但这只是外在的表现。倍图核心的影响因素在于PPI（DPI），了解屏幕密度与各尺寸的关系有助于我们深度理解倍率的概念：《基础知识学起来！为设计师量身打造的DPI指南》iPhone8在本次升级中，屏幕尺寸和分辨率都遗传了iPhone6以后的优良传统；然而iPhone X 无论是在屏幕尺寸、分辨率、甚至是形状上都发生了较大的改变，下面以iPhone 8作为参照物，看看到底iPhone X的适配我们要怎么考虑。我们看看iPhone X尺寸上的变化： 2. iPhoneX的适配—安全区域(safe area)苹果对于 iPhone X 的设计布局意见如下： 核心内容应该处于 Safe area 确保不会被设备圆角(corners)，传感器外壳(sensor housing，齐刘海) 以及底部的 Home Indicator 遮挡。也就是说 我们设计显示的内容应该尽可能的在安全区域内； 3. iPhoneX的适配—适配方案viewport-fit 3.1 PhoneX的适配，在iOS 11中采用了viewport-fit的meta标签作为适配方案；viewport-fit的默认值是auto。 viewport-fit取值如下： auto 默认：viewprot-fit:contain;页面内容显示在safe area内 cover viewport-fit:cover,页面内容充满屏幕 viewport-fit meta标签设置(cover时) 3.2 css constant()函数 与safe-area-inset-top &amp; safe-area-inset-left &amp; safe-area-inset-right &amp; safe-area-inset-bottom的介绍 如上图所示 在iOS 11中的WebKit包含了一个新的CSS函数constant()，以及一组四个预定义的常量：safe-area-inset-left, safe-area-inset-right, safe-area-inset-top和 safe-area-inset-bottom。当合并一起使用时，允许样式引用每个方面的安全区域的大小。 3.1当我们设置viewport-fit:contain,也就是默认的时候时;设置safe-area-inset-left, safe-area-inset-right, safe-area-inset-top和 safe-area-inset-bottom等参数时不起作用的。 3.2当我们设置viewport-fit:cover时：设置如下body { padding-top: constant(safe-area-inset-top); //为导航栏+状态栏的高度 88px padding-left: constant(safe-area-inset-left); //如果未竖屏时为0 padding-right: constant(safe-area-inset-right); //如果未竖屏时为0 padding-bottom: constant(safe-area-inset-bottom);//为底下圆弧的高度 34px } 4. iPhoneX的适配—高度统计viewport-fit:cover + 导航栏&lt;br /&gt; ![](https://cdn.nlark.com/yuque/0/2019/png/263301/1561712771737-029c9ed2-c76e-4d04-be0a-57f1bedb5064.png#align=left&amp;display=inline&amp;height=936&amp;originHeight=936&amp;originWidth=517&amp;size=0&amp;status=done&amp;width=517)&lt;br /&gt; 5.iPhoneX的适配—媒体查询注意这里采用的是690px(safe area高度)，不是812px; 12345@media only screen and (width: 375px) and (height: 690px)&#123; body &#123; background: blue; &#125;&#125; 6.iphoneX viewport-fit 问题总结1.关于iphoneX 页面使用了渐变色时；如果viewport-fit:cover; 1.1在设置了背景色单色和渐变色的区别，如果是单色时会填充整个屏幕，如果设置了渐变色 那么只会更加子元素的高度去渲染；而且页面的高度只有690px高度，上面使用了padding-top:88px; body固定为： 1&lt;body&gt;&lt;div class="content"&gt;this is subElement&lt;/div&gt;&lt;/body&gt; 1.单色时： * { padding: 0; margin: 0; } body { background:green; padding-top: constant(safe-area-inset-top); //88px /padding-left: constant(safe-area-inset-left);/ /padding-right: constant(safe-area-inset-right);/ /padding-bottom: constant(safe-area-inset-bottom);/ }2.渐变色 * { padding: 0; margin: 0; } body { background:-webkit-gradient(linear, 0 0, 0 bottom, from(#ffd54f), to(#ffaa22)); padding-top: constant(safe-area-inset-top); //88px /padding-left: constant(safe-area-inset-left);/ /padding-right: constant(safe-area-inset-right);/ /padding-bottom: constant(safe-area-inset-bottom);/ } 解决使用渐变色 仍旧填充整个屏幕的方法；CSS设置如下 Designing Websites for iPhone X: Respecting the safe areas * { padding: 0; margin: 0; } html, body { height: 100%; } body { padding-top: constant(safe-area-inset-top); padding-left: constant(safe-area-inset-left); padding-right: constant(safe-area-inset-right); padding-bottom: constant(safe-area-inset-bottom); } .content { background: -webkit-gradient(linear, 0 0, 0 bottom, from(#ffd54f), to(#ffaa22)); width: 100%; height: 724px; } this is subElement 2.页面元素使用了固定定位的适配即：{position:fixed;} 2.1 子元素页面固定在底部时；使用viewport-fit:contain时;可以看到bottom:0时只会显示在安全区域内； Designing Websites for iPhone X: Respecting the safe areas * { padding: 0; margin: 0; } /html,body {/ /height: 100%;/ /}/ body { background: grey; /padding-top: constant(safe-area-inset-top);/ /padding-left: constant(safe-area-inset-left);/ /padding-right: constant(safe-area-inset-right);/ /padding-bottom: constant(safe-area-inset-bottom);/ } .top { width: 100%; height: 44px; background: purple; } .bottom { position: fixed; bottom: 0; left: 0; right: 0; height: 44px; color: black; background: green; } this is top this is bottom 2.1 子元素页面固定在底部时；使用viewport-fit:cover时;可以看到bottom:0时只会显示在安全区域内； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455* &#123; padding: 0; margin: 0;&#125;/*html,body &#123;*/ /*height: 100%;*//*&#125;*/body &#123; background: grey; padding-top: constant(safe-area-inset-top); /*padding-left: constant(safe-area-inset-left);*/ /*padding-right: constant(safe-area-inset-right);*/ /*padding-bottom: constant(safe-area-inset-bottom);*/&#125;.top &#123; width: 100%; height: 44px; background: purple;&#125;.bottom &#123; position: fixed; bottom: 0; left: 0; right: 0; height: 44px; color: black; background: green;&#125; 添加html,body {width:100%;heigth:100%} 图1： * { padding: 0; margin: 0; } html,body { height: 100%; } body { background: grey; padding-top: constant(safe-area-inset-top); padding-left: constant(safe-area-inset-left); padding-right: constant(safe-area-inset-right); padding-bottom: constant(safe-area-inset-bottom); } .top { width: 100%; height: 44px; background: purple; } .bottom { position: fixed; bottom: 0; left: 0; right: 0; height: 44px; color: black; background: green; } 图2： * { padding: 0; margin: 0; } html,body { height: 100%; } body { background: grey; padding-top: constant(safe-area-inset-top); padding-left: constant(safe-area-inset-left); padding-right: constant(safe-area-inset-right); /padding-bottom: constant(safe-area-inset-bottom);/ } .top { width: 100%; height: 44px; background: purple; } .bottom { position: fixed; bottom: 0; left: 0; right: 0; height: 44px; color: black; background: green; } 2.3 关于alertView弹框 遮罩层的解决方案 alertView document.documentElement.style.fontSize = window.screen.width / 7.5 + 'px'; * { margin: 0; padding: 0; } html,body { width: 100%; height: 100%; } body { font-size: 0.32rem; padding-top: constant(safe-area-inset-top); padding-left: constant(safe-area-inset-left); padding-right: constant(safe-area-inset-right); padding-bottom: constant(safe-area-inset-bottom); } .content { text-align: center; } .testBut { margin: 50px auto; width: 100px; height: 44px; border: 1px solid darkgray; outline:none; user-select: none; background-color: yellow; } 弹框加载 function showLoading() { UIAlertView.show({ type:"input", title:"温馨提示", //标题 content:"VIP会员即将到期", //获取新的 isKnow:false }); var xx = new UIAlertView(); console.log(xx); } L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"width":150,"height":300,"position":"right"},"mobile":{"show":true,"scale":0.5},"react":{"opacity":0.9},"dialog":{"enable":true,"hitokoto":true},"log":false}); 参考资料： iPhone X的Web设计 iPhone X适配没那么复杂，但也不是看上去这么简单 剖析 iOS 11 网页适配问题 iPhone X(10)屏幕分辨率与适配 iPhone X 适配手Q H5 页面通用解决方案 转自：https://www.cnblogs.com/lolDragon/p/7795174.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[es6-7-8-9-10]]></title>
    <url>%2F2019%2F06%2F28%2Fyuque%2Fes6-7-8-9-10%2F</url>
    <content type="text"><![CDATA[奇舞读书会─深入理解ES6]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端ppt]]></title>
    <url>%2F2019%2F06%2F28%2Fyuque%2F%E5%89%8D%E7%AB%AFppt%2F</url>
    <content type="text"><![CDATA[模版：https://ppt.baomitu.com/conference剖析CSS-Tricks,为你所用：https://ppt.baomitu.com/d/88200f75#/ 让你的网页更丝滑：https://ppt.baomitu.com/d/b267a4a3#/ js动画原理与实现：https://ppt.baomitu.com/d/4a475069#/ 如何写好JavaScript：https://ppt.baomitu.com/d/53a0a9aa#/55JavaScript语言基础：https://ppt.baomitu.com/d/832d204b#/前端开发的常用设计模式：https://ppt.baomitu.com/d/a131a277#/深入理解ES6:https://ppt.baomitu.com/d/74f8b016#/更好的数组：https://ppt.baomitu.com/d/6a24bac0#/Promise与异步编程：https://ppt.baomitu.com/d/709188c6#/JavaScript中的类：https://ppt.baomitu.com/d/4d223381#/Symbol和Symbol属性：https://ppt.baomitu.com/d/f0f88258#/CSS创意与视觉表现：https://ppt.baomitu.com/d/113a1a80#/]]></content>
  </entry>
  <entry>
    <title><![CDATA[mock]]></title>
    <url>%2F2019%2F06%2F28%2Fyuque%2Fmock%2F</url>
    <content type="text"><![CDATA[zen-mockserver mockjs]]></content>
  </entry>
  <entry>
    <title><![CDATA[UI库和发布网站库]]></title>
    <url>%2F2019%2F06%2F27%2Fyuque%2FUI%E5%BA%93%E5%92%8C%E5%8F%91%E5%B8%83%E7%BD%91%E7%AB%99%E5%BA%93%2F</url>
    <content type="text"><![CDATA[UmiJs** now库可以发布打包好的包，并能外网浏览：https://dist.wangfangcao7618.now.sh/博客：https://public.wangfangcao7618.now.sh/我的DEMO库：https://build.wangfangcao7618.now.sh/#/ Materialhttps://material.io/design/https://material-theme-builder.glitch.me/ wangEditorhttp://www.wangeditor.com/index.html基于javascript和css开发的 Web富文本编辑器， 轻量、简洁、易用、开源免费 UIleader flex 国内5款优秀的WEB前端框架 1. JX（腾讯）官网地址：http://alloyteam.github.io/JX/#homeJX 是一个类似 Google Closure Library 的 Web 前端开发框架，服务于 WebQQ 等大规模的 WebApp。JX 是模块化的非侵入式Web前端框架，开发于2008年，并于2009年开源于GoogleCode ，于2012年切换到Github。 JX 框架同时适用于 Web Page 和 Web App 项目的开发，特别适合构建和组织大规模、工业级的Web App，腾讯 WebQQ、腾讯Q+等产品都是采用JX框架开发，兼容目前所有主流浏览器。腾讯团队打造的前端开发框架JX 2. KISSY（淘宝）官网：http://docs.kissyui.com/KISSY是淘宝的前端类库，几乎在淘宝的每个页面上都能看到它的身影。 3. Tangram（百度）官网：http://tangram.baidu.com/Tangram是一款实用的JavaScript基础库，通过它可以快速构建出高度互动的Web应用程序。Tangram具有全浏览器兼容，平滑升级体验以及自由定制输出最小尺寸的特点。 4、NEJ（网易）官网：http://nej.netease.com/NEJ一个简洁，美观，真正的跨平台web前端开发框架 5、QWrap（百度）官网：http://www.qwrap.com/QWrap是百度有啊前端团队推出的一个Javascript框架，支持IE6+、Firefox、Chrome、Safari、Opera等浏览器，在BSD协议下开源发布。1. 提供jQuery一样方便的dom功能，同时又打破jQuery“专注于dom”的约束，也提供非dom的许多功能。2. 提供prototype方便的原型功能，同时又提供Javascript1.6的泛型功能，并且提供用户有选择方便与严谨的自由。3. 提供YUI2一样的静态方法库，同时又用所谓的Helper规范来做到真正的绝对静态，让组件开发者可以发布出无依赖的组件。4. 学习YUI3的use，同时又摈弃YUI3的严谨性洁癖，让use更实用。5. QWrap独创特的Helper + Wrap + Retouch + Apps设计，让QWrap有更多的灵性等待你去发现。]]></content>
  </entry>
  <entry>
    <title><![CDATA[动画库收集]]></title>
    <url>%2F2019%2F06%2F27%2Fyuque%2F%E5%8A%A8%E7%94%BB%E5%BA%93%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[Catiline.js 腾讯 AlloyTeam Svg Iconhttps://icons8.com/icons/pack/free-icons–redhttps://www.easyicon.net/https://www.flaticon.com/free-icons/sword 简单轻量的 Javascript 运动引擎 to2to Caxhttps://github.com/dntzhang/cax/blob/master/README.md 各种动画地址 GKA 合成图片工具简单的、高效的帧动画生成工具. 使用简单(仅需一行命令) 内置多种图片优化 多类生成模板，支持定制 一键制作自适应等比缩放的雪碧图动画 gka 是一款简单的、高效的帧动画生成工具，图片处理工具。只需一行命令，快速图片优化、生成动画文件，支持效果预览。 一键式: 图片文件批量序列化重命名，生成帧动画文件，支持预览 性能佳: 支持相同图片复用✓ 图片空白裁剪✓ 合图优化✓ 图片压缩✓ 图片空白拆分优化✓ 图片像素差优化✓ 多倍图适配✓ 多模板: 内置多种文件输出模板，支持自定义模板 在线官方文档：https://gka.js.orggit Demo地址：https://github.com/fangcao7618/fangcao7618.github.io/tree/gka_branch 龙骨动画Egret Developerhttp://developer.egret.com/cn/http://dragonbones.com/cn/index.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[需要知道的JS的日期的知识，都在这了]]></title>
    <url>%2F2019%2F06%2F26%2Fyuque%2F%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84JS%E7%9A%84%E6%97%A5%E6%9C%9F%E7%9A%84%E7%9F%A5%E8%AF%86%EF%BC%8C%E9%83%BD%E5%9C%A8%E8%BF%99%E4%BA%86%2F</url>
    <content type="text"><![CDATA[转自：https://juejin.im/post/5d12b308f265da1b7c612746 https://date-fns.org/ https://momentjs.com/]]></content>
  </entry>
  <entry>
    <title><![CDATA[canvas]]></title>
    <url>%2F2019%2F06%2F26%2Fyuque%2Fcanvas%2F</url>
    <content type="text"><![CDATA[canvas博客： 更优雅地基于 canvas 在前端画海报]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo主题配置优化]]></title>
    <url>%2F2019%2F06%2F20%2Fyuque%2FHexo%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1.基本信息配置 基本信息包括：博客标题.作者.描述.语言等等。 打开 站点配置文件 ，找到Site模块 title: 标题subtitle: 副标题description: 描述author: 作者language: 语言（简体中文是zh-Hans）timezone: 网站时区（Hexo 默认使用您电脑的时区，不用写） 关于 站点配置文件 中的其他配置可参考站点配置 2.菜单设置 菜单包括：首页、归档、分类、标签、关于等等 我们刚开始默认的菜单只有首页和归档两个，不能够满足我们的要求，所以需要添加菜单，打开 主题配置文件 找到Menu Settings menu:home: / || home //首页archives: /archives/ || archive //归档categories: /categories/ || th //分类tags: /tags/ || tags //标签about: /about/ || user //关于 #schedule: /schedule/ || calendar //日程表 #sitemap: /sitemap.xml || sitemap //站点地图 #commonweal: /404/ || heartbeat //公益404 看看你需要哪个菜单就把哪个取消注释打开就行了；关于后面的格式，以archives: /archives/ || archive为例：|| 之前的/archives/表示标题“归档”，关于标题的格式可以去themes/next/languages/zh-Hans.yml中参考或修改||之后的archive表示图标，可以去Font Awesome中查看或修改，Next主题所有的图标都来自Font Awesome。 3.Next主题样式设置我们百里挑一选择了Next主题，不过Next主题还有4种风格供我们选择，打开 主题配置文件 找到Scheme Settings Schemesscheme: Musescheme: Mistscheme: Piscesscheme: Gemini 4种风格大同小异，本人用的是Gemini风格，你们可以选择自己喜欢的风格。 4.侧栏设置 侧栏设置包括：侧栏位置.侧栏显示与否.文章间距.返回顶部按钮等等 打开 主题配置文件 找到sidebar字段 sidebar: Sidebar Position - 侧栏位置（只对Pisces | Gemini两种风格有效） position: left //靠左放置 #position: right //靠右放置 Sidebar Display - 侧栏显示时机（只对Muse | Mist两种风格有效） #display: post //默认行为，在文章页面（拥有目录列表）时显示 display: always //在所有页面中都显示 #display: hide //在所有页面中都隐藏（可以手动展开） #display: remove //完全移除 offset: 12 //文章间距（只对Pisces | Gemini两种风格有效） b2t: false //返回顶部按钮（只对Pisces | Gemini两种风格有效） scrollpercent: true //返回顶部按钮的百分比 5.头像设置打开 主题配置文件 找到Sidebar Avatar字段 Sidebar Avataravatar: /images/header.jpg 这是头像的路径，只需把你的头像命名为header.jpg（随便命名）放入themes/next/source/images中，将avatar的路径名改成你的头像名就OK啦！ 6.评论系统 推荐指数 优点 缺点 Valine 4 每天30000条评论，10GB的储存 作者评论无标识 来必力/livere 4 多种账号登录 评论无法导出 畅言 3 美观 必须备案域名 gitment 3 简洁 只能登陆github评论 Disqus 1 需要翻*墙 来必力2.1. 登陆 来必力 获取你的 LiveRe UID。2.2. 填写LiveRe UID到主题配置文件_config.yml 7.添加标签页 添加一个标签页面，里面包含您网站中的所有标签。参考链接 一个创建³³名为tags页面 hexo new page “tags” 编辑标签页，设置页面类型为tags。 title: All tagsdate: 2014-12-22 12:39:04type: “tags” 添加tags到主题配置文件_config.yml里： menu: home: / archives: /archives tags: /tags 详细解释： 8.添加分类页 添加一个分类页面，里面包含您网站中的所有分类。 一个创建³³名为categories页面 hexo new page “categories” 编辑分类页，设置页面类型为categories。 title: All categoriesdate: 2014-12-22 12:39:04type: “categories” 添加 categories到主题配置文件_config.yml里： menu:home: /archives: /archivescategories: /categories 详细解释： 参考截图: 9.添加萌萌哒宠物具体参考官方文档：点击跳转 1.安装模块: npm install –save hexo-helper-live2d 2.配置请向Hexo的 _config.yml 文件或主题的 _config.yml 文件中添加配置.示例: 12345678910111213141516live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: use: live2d-widget-model-wanko display: position: right width: 150 height: 300 mobile: show: true 详解: 1234567891011121314151617live2d: enable: true # enable: false scriptFrom: local # 默认 pluginRootPath: live2dw/ # 插件在站点上的根目录(相对路径) pluginJsPath: lib/ # 脚本文件相对与插件根目录路径 pluginModelPath: assets/ # 模型文件相对与插件根目录路径 # scriptFrom: jsdelivr # jsdelivr CDN # scriptFrom: unpkg # unpkg CDN # scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url tagMode: false # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中 debug: false # 调试, 是否在控制台输出日志 model: use: live2d-widget-model-wanko # npm-module package name # use: wanko # 博客根目录/live2d_models/ 下的目录名 # use: ./wives/wanko # 相对于博客根目录的路径 # use: https://cdn.jsdelivr.net/npm/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # 你的自定义 url 3.模型有许多方法来使用不同的模型: a. live2d_models子目录名称 在您博客根目录下创建一个 live2d_models 文件夹. 在此文件夹内新建名为 shizuku （模型名字）的子文件夹. 在这里应当有一个 .model.json 文件 (例如 shizuku.model.json) 将子文件夹的名称输入 _config.yml 的 model.use 中. b. 相对于博客根目录的自定义路径您可直接输入相对于博客根目录的自定义路径到 model.use 中.示例: ./wives/wanko c. npm 模块名（走这步就可以了）现有模型：https://github.com/xiazeyu/live2d-widget-models对应的模型图片：https://huaji8.top/post/live2d-plugin-2.0/模型地址npm install –save live2d-widget-model-xxx 来安装然后你就可以通过向 model.use 键入包名 (live2d-widget-model-wanko) 来使用了. 10.首页阅读全文Hexo 的 Next 主题默认是首页显示你每篇文章的全文内容，但这会使你的首页篇幅过于冗长，针对这个问题我们可以这么做：用编辑器打开themes/next 目录下的_config.yml文件找到代码： auto_excerpt: enable: false length: 150 将enable的 false改成true，length可以设定文章预览的文本长度。 11.修改背景图片在 themes/*/source/css/_custom/custom.styl 中添加如下代码： // 添加背景图 bg.jpg为图片名称body{ background:url(/images/bg.jpg); background-size:cover; background-repeat:no-repeat; background-attachment:fixed; background-position:center;} 12.实现点击出现桃心效果 在/themes/*/source/js/src下新建文件click.js，接着把以下粘贴到click.js文件中。代码如下： 1!function(e,t,a)&#123;function n()&#123;c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:"+d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+","+d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999");requestAnimationFrame(r)&#125;function o()&#123;var t="function"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement("div");a.className="heart",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement("style");a.type="text/css";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName("head")[0].appendChild(a)&#125;function s()&#123;return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 在\themes*\layout_layout.swig文件末尾添加： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/click.js"&gt;&lt;/script&gt; 13.主页文章添加边框阴影效果打开 themes/*/source/css/_custom/custom.styl ,向里面加代码: 12345678// 主页文章添加阴影效果.post &#123; margin-top: 0px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125; 14.显示当前浏览进度修改themes/*/_config.yml，把 false 改为 true： 12345# Back to top in sidebarb2t: true# Scroll percent label in b2t buttonscrollpercent: true 15.博客文章置顶安装插件 12$ npm uninstall hexo-generator-index --save$ npm install hexo-generator-index-pin-top --save 然后在需要置顶的文章的Front-matter中加上top即可：top值越大表示优先级越高 12345---title: 2018date: 2018-10-25 16:10:03top: 10--- 设置置顶标志打开：/themes/*/layout/_macro/post.swig插入以下代码即可： 12345&#123;% if post.top %&#125; &lt;i class="fa fa-thumb-tack"&gt;&lt;/i&gt; &lt;font color=000000&gt;置顶&lt;/font&gt; &lt;span class="post-meta-divider"&gt; &lt;/span&gt;&#123;% endif %&#125; 16.生成博文插入图片参考：Nuub用Typora编写Markdown的可以修改成这样就直接复制图片过去了 17.取消文章目录自动编号修改主题配置文件那里的number为false 18.修改文章底部标签的图标修改主题模板/themes/next/layout/_macro/post.swig，搜索 rel=”tag”&gt;#，将 # 换成 19.静态资源压缩在站点目录下： 12$ npm install gulp -gnpm install gulp 安装gulp插件： 12345npm install gulp-minify-css --savenpm install gulp-uglify --savenpm install gulp-htmlmin --savenpm install gulp-htmlclean --savenpm install gulp-imagemin --save 在 Hexo 站点下新建 gulpfile.js文件，文件内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445var gulp = require('gulp');var minifycss = require('gulp-minify-css');var uglify = require('gulp-uglify');var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');var imagemin = require('gulp-imagemin');// 压缩css文件gulp.task('minify-css', function() &#123; return gulp.src('./public/**/*.css') .pipe(minifycss()) .pipe(gulp.dest('./public'));&#125;);// 压缩html文件gulp.task('minify-html', function() &#123; return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest('./public'))&#125;);// 压缩js文件gulp.task('minify-js', function() &#123; return gulp.src(['./public/**/.js','!./public/js/**/*min.js']) .pipe(uglify()) .pipe(gulp.dest('./public'));&#125;);// 压缩 public/demo 目录内图片gulp.task('minify-images', function() &#123; gulp.src('./public/demo/**/*.*') .pipe(imagemin(&#123; optimizationLevel: 5, //类型：Number 默认：3 取值范围：0-7（优化等级） progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片 interlaced: false, //类型：Boolean 默认：false 隔行扫描gif进行渲染 multipass: false, //类型：Boolean 默认：false 多次优化svg直到完全优化 &#125;)) .pipe(gulp.dest('./public/uploads'));&#125;);// 默认任务gulp.task('default', [ 'minify-html','minify-css','minify-js','minify-images']); 只需要每次在执行 generate 命令后执行 gulp 就可以实现对静态资源的压缩，压缩完成后执行 deploy 命令同步到服务器： 123456hexo ggulphexo dhexo clean &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo d 20.去掉图片边框NexT主题默认会有图片边框，不太好看，我们可以把边框去掉。打开 themes\Next\source\css_custom\custom.styl，添加如下CSS代码： 12345678/* 去掉图片边框 */.posts-expand .post-body img &#123; border: none; padding: 0px;&#125;.post-gallery .post-gallery-img img &#123; padding: 3px;&#125; 21.添加 关于页面hexo new page “about” 新建一个 关于我 页面。主题的 _config.yml 文件中的 menu 中进行匹配 123456menu: home: / //主页 categories: /categories //分类 archives: /archives //归档 tags: /tags //标签 about: /about //关于 （添加此行即可） 同理于标签页和分类页 22.添加字数统计.阅读时长 统计插件 配置NexT 主题默认已经集成了文章【字数统计】.【阅读时长】统计功能，如果我们需要使用，只需要在主题配置文件 _config.yml 中打开 wordcount 统计功能即可。如下所示： 12345678# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true # 单篇 字数统计 min2read: true # 单篇 阅读时长 totalcount: false # 网站 字数统计 separated_meta: true 修改完成主题配置文件后，启动服务预览： hexo server 访问 http://localhost:4000/ 链接，如果出现字数统计和阅读时长失效的情况，一般是因为没有安装 hexo-wordcount 插件，查看 Hexo 插件： hexo –debug 安装如果没有安装 hexo-wordcount插件，先安装该插件： npm i –save hexo-wordcount Node 版本 7.6.0 之前,请安装 2.x 版本 (Node.js v7.6.0 and previous) ，安装命令如下： npm install hexo-wordcount@2 –save 安装完成后，重新执行启动服务预览就可以了。 显示文字打开post.swig文件，路径如下：/themes/next/layout/_macro/post.swig修改【字数统计】，找到如下代码： 12345678910111213&lt;span title="&#123;&#123; __('post.wordcount') &#125;&#125;"&gt; &#123;&#123; wordcount(post.content) &#125;&#125;&lt;/span&gt;添加 “字” 到 &#123;&#123; wordcount(post.content) &#125;&#125; 后面，修改后为：&lt;span title="&#123;&#123; __('post.wordcount') &#125;&#125;"&gt; &#123;&#123; wordcount(post.content) &#125;&#125; 字&lt;/span&gt;同理，我们修改【阅读时长】，修改后如下：&lt;span title="&#123;&#123; __('post.min2read') &#125;&#125;"&gt; &#123;&#123; min2read(post.content) &#125;&#125; 分钟&lt;/span&gt; 效果预览图： 23.添加社交在主题配置文件找到social，添加需要的就可以，具体如下图可以自定义图标，默认的图标都是从图标库自动匹配的，||后面的就是在图标库的图标名 24.添加站内搜索1、安装 hexo-generator-searchdb 插件 npm install hexo-generator-searchdb –save 2、打开 站点配置文件 找到Extensions在下面添加 搜索search: path: search.xml field: post format: html limit: 10000 3、打开 主题配置文件 找到Local search，将enable设置为true 25.设置文字居中这一行需要居中设置方法： 这一行需要居中 注意：简书中此方法无效 26.点击爆炸效果实现方法跟那个红心是差不多的，首先在themes/next/source/js/src里面建一个叫fireworks.js的文件，代码如下： 1"use strict";function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color="#F00",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:"linear",duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(".fireworks");if(canvasEl)&#123;var ctx=canvasEl.getContext("2d"),numberOfParticules=30,pointerX=0,pointerY=0,tap="mousedown",colors=["#FF1461","#18FF92","#5A87FF","#FBF38C"],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+"px",canvasEl.style.height=window.innerHeight+"px",canvasEl.getContext("2d").scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;"sidebar"!==e.target.id&amp;&amp;"toggle-sidebar"!==e.target.id&amp;&amp;"A"!==e.target.nodeName&amp;&amp;"IMG"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener("resize",setCanvasSize,!1)&#125;"use strict";function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color="#F00",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:"linear",duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(".fireworks");if(canvasEl)&#123;var ctx=canvasEl.getContext("2d"),numberOfParticules=30,pointerX=0,pointerY=0,tap="mousedown",colors=["#FF1461","#18FF92","#5A87FF","#FBF38C"],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+"px",canvasEl.style.height=window.innerHeight+"px",canvasEl.getContext("2d").scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;"sidebar"!==e.target.id&amp;&amp;"toggle-sidebar"!==e.target.id&amp;&amp;"A"!==e.target.nodeName&amp;&amp;"IMG"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener("resize",setCanvasSize,!1)&#125;; 打开themes/next/layout/_layout.swig,在L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"width":150,"height":300,"position":"right"},"mobile":{"show":true,"scale":0.5},"react":{"opacity":0.9},"dialog":{"enable":true,"hitokoto":true},"log":false});上面写下如下代码： 12345&#123;% if theme.fireworks %&#125; &lt;canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" &gt;&lt;/canvas&gt; &lt;script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/js/src/fireworks.js"&gt;&lt;/script&gt;&#123;% endif %&#125; 打开主题配置文件，在里面最后写下： 12# Fireworksfireworks: true 完😀 27.设置文章加密访问这里使用第三方插件Hexo-Blog-Encrypt 1)首先，你需要在站点 _config.yml 中启用该插件1234# Security##encrypt: enable: true 2)给文章添加密码：1234567891011121314---title: hello worlddate: 2016-03-30 21:18:02tags: - fdsfadsfa - fdsafsdafpassword: Mikeabstract: Welcome to my blog, enter password to read.message: Welcome to my blog, enter password to read.---Eg：password: abstract: 此处遭到了封印message: 请输入正确的密码 password: 是该博客加密使用的密码 abstract: 是该博客的摘要，会显示在博客的列表页 message: 这个是博客查看时，密码输入框上面的描述性文字 对 TOC 进行加密如果你有一篇文章使用了 TOC，你需要修改模板的部分代码。这里用 landscape 作为例子： 你可以在 hexo/themes/landscape/layout/_partial/article.ejs 找到 article.ejs。 然后找到 &lt;% post.content %&gt; 这段代码，通常在30行左右。 使用如下的代码来替代它: 1234567891011&lt;% if(post.toc == true)&#123; %&gt; &lt;div id="toc-div" class="toc-article" &lt;% if (post.encrypt == true) &#123; %&gt;style="display:none" &lt;% &#125; %&gt;&gt; &lt;strong class="toc-title"&gt;Index&lt;/strong&gt; &lt;% if (post.encrypt == true) &#123; %&gt; &lt;%- toc(post.origin, &#123;list_number: true&#125;) %&gt; &lt;% &#125; else &#123; %&gt; &lt;%- toc(post.content, &#123;list_number: true&#125;) %&gt; &lt;% &#125; %&gt; &lt;/div&gt;&lt;% &#125; %&gt;&lt;%- post.content %&gt; 28 设置首页缩略图有两种方法，自行选择。 这个需要使用进行截断，上面的内容就是显示在主页的摘要，把图片放在上面就可以了。如果是文字也会进行分割。 在编写md文章的时候在头部添加photos:，如下所示： 1234567891011---title: categories: tags:copyright: truecomments: falsedescription: date: 2017-11-09 14:33:32top:photos: - "https://i.loli.net/2019/01/19/5c42f345b6b2f.jpg" 遇见西门 JuLi距离 Next官方文档 Hexo瞎折腾系列 NIkkkki睡不醒 二次元模型 https://l2dwidget.js.org/dev.html hexo-helper-live2d live2d-widget.js29 ECharts常规做法你可能也看到了，上面的图表在我的hexo搭建的博客中可以完美展示。这个是怎么做到的呢？ 首先，如果你用的是Yelee或者类似的主题，你应该可以很简单地直接参照这个博客去做。 我也是在看上面的博客的时候遇到了问题，如果我用Yelee主题的话是很简单的可以实现上面的效果的，但是我现在更喜欢的是现在的Next主题。这两个主题的结构不一样。 安装上文说的在所用主题目录下layout_partial文件夹中不存在，更不存在head.ejs Next目录：Yelee目录： Next主题做法由此看出，如果你和我一样使用Next主题的话上面的教程不能用。需要像我这样做： 下载js首先下载ECharts的js文件：ECharts 把js文件放到next主题的\source\js\src目录下： js文件的引用然后在next\layout\文件夹下，找到_layout.swig文件，并用文本查看器打开，在下面代码: 1234567891011121314&lt;main id="main" class="main"&gt; &lt;div class="main-inner"&gt; &lt;div class="content-wrap"&gt; &lt;div id="content" class="content"&gt; &#123;% block content %&#125;&#123;% endblock %&#125; &lt;/div&gt; &#123;% include '_third-party/duoshuo-hot-articles.swig' %&#125; &#123;% include '_partials/comments.swig' %&#125; &lt;/div&gt; &#123;% if theme.sidebar.display !== 'remove' %&#125; &#123;% block sidebar %&#125;&#123;% endblock %&#125; &#123;% endif %&#125; &lt;/div&gt;&lt;/main&gt; 的前面添加： 12&lt;!-- echarts --&gt;&lt;script type="text/javascript" src="/js/src/echarts.common.min.js"&gt;&lt;/script&gt; 保存退出。 安装hexo-tag-echarts插件在博客站点目录下执行npm install hexo-tag-echarts –save。 使用范例可以简单的找个例子试下，把下面代码放到一个博客的markdown文件中即可。注意不要使用代码块！！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&#123;% echarts 400 '81%' %&#125; &#123; tooltip: &#123; trigger: 'axis', axisPointer : &#123; // 坐标轴指示器，坐标轴触发有效 type: 'shadow' // 默认为直线，可选为：'line' | 'shadow' &#125; &#125;, legend: &#123; data: ['利润', '支出', '收入'] &#125;, grid: &#123; left: '3%', right: '4%', bottom: '3%', containLabel: true &#125;, xAxis: [ &#123; type: 'value' &#125; ], yAxis : [ &#123; type: 'category', axisTick: &#123; show: false &#125;, data: ['周一', '周二', '周三', '周四', '周五', '周六', '周日'] &#125; ], series : [ &#123; name: '利润', type: 'bar', itemStyle: &#123; normal: &#123; label: &#123; show: true, position: 'inside' &#125; &#125; &#125;, data: [200, 170, 240, 244, 200, 220, 210] &#125;, &#123; name: '收入', type: 'bar', stack: '总量', itemStyle: &#123; normal: &#123; label: &#123; show: true &#125; &#125; &#125;, data: [320, 302, 341, 374, 390, 450, 420] &#125;, &#123; name: '支出', type: 'bar', stack: '总量', itemStyle: &#123; normal: &#123; label: &#123; show: true, position: 'left' &#125; &#125; &#125;, data: [-120, -132, -101, -134, -190, -230, -210] &#125; ] &#125;; &#123;% endecharts %&#125; 之后你就应该能看到我的上面的ECharts图了。 优秀的设计博客：https://clovertuan.github.io/resume/ 优秀的设计博客：https://clovertuan.github.io/resume/ 优秀的星球博客：https://tzvetkov75.github.io/demo_blog/public/2017/02/05/hello-world/ https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/#toc-heading-18 转自：https://selfishluck.top/2018/12/21/Hexo%E4%B8%BB%E9%A2%98%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE/]]></content>
  </entry>
  <entry>
    <title><![CDATA[实例篇]]></title>
    <url>%2F2019%2F06%2F20%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Eg：password:abstract: 此处遭到了封印message: 请输入正确的密码 // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('echarts6711')); // 指定图表的配置项和数据 var option = { tooltip : { trigger: 'axis', axisPointer : { // 坐标轴指示器，坐标轴触发有效 type : 'shadow' // 默认为直线，可选为：'line' | 'shadow' } }, legend: { data:['利润', '支出', '收入'] }, grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true }, xAxis : [ { type : 'value' } ], yAxis : [ { type : 'category', axisTick : {show: false}, data : ['周一','周二','周三','周四','周五','周六','周日'] } ], series : [ { name:'利润', type:'bar', label: { normal: { show: true, position: 'inside' } }, data:[200, 170, 240, 244, 200, 220, 210] }, { name:'收入', type:'bar', stack: '总量', label: { normal: { show: true } }, data:[320, 302, 341, 374, 390, 450, 420] }, { name:'支出', type:'bar', stack: '总量', label: { normal: { show: true, position: 'left' } }, data:[-120, -132, -101, -134, -190, -230, -210] } ] } // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[语雀写作自动同步部署Hexo]]></title>
    <url>%2F2019%2F06%2F20%2Fyuque%2F%E8%AF%AD%E9%9B%80%E5%86%99%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%90%8C%E6%AD%A5%E9%83%A8%E7%BD%B2Hexo%2F</url>
    <content type="text"><![CDATA[语雀和Hexo之前都有单独使用过，都很舒服，今天偶然看到一篇大佬的文章，居然可以把这两个结合起来使用，这岂不是美滋滋，爽歪歪，所以说心动不如行动，搞起来~在实施的过程中，由于自己太菜，有好多坑，搞了好长时间才搞好，不容易，写这样一个文章记录一下 一、所需环境 1.操作系统最好Linux，若在Windows中就装一下虚拟机 2.所需环境软件 Git Node.Js Hexo Ruby二、实现步骤利用Hexo+Github+Triavs-ci来实现在语雀上面写着之后自动部署到Hexo上面去，这么做只能用舒服来形容，嘻嘻！1.介绍1）Hexo要怎么来部署就不要我在这多说什么了，我的博客有这样的教程，附上我的博客地址。2）Github作为一个程序猿必备，略过，没有的，嗯哼，可以不用看了。3）Triavs-ci开源持续集成构建项目，它与jenkins有点像，可以直接用你的Github账号登录，同步你的仓库，很是方便，页面也比较简洁好看。4）yuque-hexo一个Hexo的插件，看名字就知道用来干什么的了，所以你猜的没有错，他就是用来同步语雀到Hexo的插件，这是开源插件，附上开源库地址。感谢大佬的插件。使用起来也很简单就只需要安装好在package.json配置一下就好了。还在配置一下命令，不然编译生成的时候不会同步语雀的文章，也在package.json文件中配置具体可以参考我的package.json文件2.操作流程1）配置Hexo这里简单说一下要注意的地方，具体教程网上有很多。 增加hexo-deployer-git依赖，防止部署时报错。 copynpm install –save hexo-deployer-git 增加hexo-util到dev依赖，防止travis的npm版本&lt;3,出现的Error: Cannot find module ‘hexo-util’错误。 copynpm install –save-dev hexo-util 2）配置Github 在Github上面建两个库（也不一定要两个，也可以利用两个代码分支来进行，我这里用两个仓库做栗子） 一个仓库拥来存放Hexo编译前的代码库。另一个用来存放编译后用来开启Pages的仓库。在本地创建好的Hexo可以提交到源码的仓库了。可以也把Pages的也配置好。 3）配置Travis CI 第一步我们需要有一个 Travis-CI 的账号，直接进入Travis-CI官网，用自己的Github账号授权登录即可。 然后可以看到当前账号的所有代码仓库，接下来将博客项目的状态设置为启用。 第二步创建一个部署在 Travis CI 上面的 SSH key 利用这个 SSH key 可以让 Travis CI 向我们自己的项目提交代码(也就是将博客部署到Page)。这如果你在之前部署Hexo的时候已经创建过了，就可以直接用那个公钥来添加到Github里面去，添加好之后大概就是图片上的样子。 这里提一下，有的时候你的本地向GitHub提交提交不上去，但之前还是可以的，这时候可以检查GitHub的SSH密钥这里，可能是因为安全问题，官方给你暂时冻结了这个密钥，冻结的情况下这里的Delete旁边就会多一个激活按钮，点一下就好了。 第三步加密私钥 加密密钥的时候一定要在Linux操作系统下进行，不然travis-ci之后进行解密的时候会报错，目前官方就是这样的一个BUG，暂时无解。Windows的同学可以在Linux虚拟机中把你的Hexo源码仓库clone进行下面的操作。 这里还需要Ruby来支撑，所以还需安装Ruby，有几种方式，个人推荐还是老老实实编译安装最好 下载ruby 下载最新版的 Ruby 压缩文件。请点击这里下载。也可以使用wget命令 1- 下载 Ruby 之后，解压到新创建的目录下： 12$ tar -xvzf ruby-2.2.3.tgz $ cd ruby-2.2.3 1- 现在，配置并编译源代码，如下所示： 123$ ./configure$ make$ sudo make install 装后，通过在命令行中输入以下命令来确保一切工作正常： 123$ruby -vruby 2.2.3…… 如果一切工作正常，将会输出所安装的 Ruby 解释器的版本，如上所示。如果您安装了其他版本，则会显示其他不同的版本。 安装travis（如果在国内的网络环境下建议安装之前先换源) $ gem install travis 那么之前把公钥文件配置好了，然后现在就要配置私钥文件，在 hexo 项目下面建立一个 .travis 的文件夹来放置需要配置的文件和travis的配置文件travis.yml。Windows和Linux下无法创建和创建报错可以用命令mkdir ./.travis进行创建文件夹，用命令touch ./.travis.yml来创建travis的配置文件。切换到.travis文件夹下 1![image.png](https://cdn.nlark.com/yuque/0/2019/png/240833/1552316024043-dfd7b632-8a75-4634-ad76-4cb77158b415.png#align=left&amp;display=inline&amp;height=46&amp;name=image.png&amp;originHeight=57&amp;originWidth=721&amp;size=17007&amp;status=done&amp;width=577)&lt;br /&gt;用命令行工具登录： travis login –auto 这时候会让你输入你的Github账号（邮箱）和密码，也可以使用GitHub的Token来进行登录 travis login –github-token 具体的Token –auto 然后将私钥 id_rsa 复制到 .travis 文件夹，用命令行工具进行加密： $ travis encrypt-file id_rsa –add 这时候在之前创建好的.travis.yml文件里面就会被写入一些密钥的信息，大概如此：在你的Travis的项目设置中也会出现密钥 接下来就要配置 .travis.yml 首先我们要改一下生成的解密信息，因为这个里面的in和out的文件位置是相对于本地环境来生成的，如果在Travis上面跑的时候位置会发生变化这样运行的时候就会报错，改完之后大概这样子： 为了让 git 默认连接 SSH 还要创建一个 ssh_config 文件。在 .travis 文件夹下创建一个 ssh_config 文件，输入以下内容： Host github.com User git StrictHostKeyChecking no IdentityFile ~/.ssh/id_rsa IdentitiesOnly yes 这样，当向项目 push 代码的时候 travis CI 就会根据 .travis.yml 的内容去部署我们的项目了。具体可以参考我的.travis.yml文件这里要提一下，我们在向Hexo源码仓库Push的时候不要提交本地编译生成的node_modules文件夹，不然到时候在上面跑的时候会有权限问题，npm会根据package.json上面的信息自己下模块的，所以不用当选，具体的涉及到npm的运行原理这里不提了，想了解的可以自行百度哈。** 4）配置Serverless服务目前阿里云和腾讯云都有serverless服务，免费的额度完全够用了，下面介绍一下腾讯云如何配置 创建函数 serverless 函数配置 点击完成即可，之后在配置具体函数代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;?phpfunction main_handler($event, $context) &#123; // 解析语雀post的数据 $update_title = ''; if($event-&gt;body)&#123; $yuque_data= json_decode($event-&gt;body); $update_title .= $yuque_data-&gt;data-&gt;title; &#125; // default params $repos = ''; // 你的仓库id 或 slug $token = ''; // 你travis-cide的登录token $message = date("Y/m/d").':更新啦:'.$update_title; // 你这里是更新信息可自定义 $branch = 'master'; // 你GitHub分支 // post params $queryString = $event-&gt;queryString; $q_token = $queryString-&gt;token ? $queryString-&gt;token : $token; $q_repos = $queryString-&gt;repos ? $queryString-&gt;repos : $repos; $q_message = $queryString-&gt;message ? $queryString-&gt;message : $message; $q_branch = $queryString-&gt;branch ? $queryString-&gt;branch : 'master'; echo($q_token); echo('==='); echo ($q_repos); echo ('==='); echo ($q_message); echo ('==='); echo ($q_branch); echo ('==='); //request travis ci $res_info = triggerTravisCI($q_repos, $q_token, $q_message, $q_branch); $res_code = 0; $res_message = '未知'; if($res_info['http_code'])&#123; $res_code = $res_info['http_code']; switch($res_info['http_code'])&#123; case 200: case 202: $res_message = 'success'; break; default: $res_message = 'faild'; break; &#125; &#125; $res = array( 'status'=&gt;$res_code, 'message'=&gt;$res_message ); return $res;&#125;/** @description travis api , trigger a build* @param $repos string 仓库ID、slug* @param $token string 登录验证token* @param $message string 触发信息* @param $branch string 分支* @return $info array 回包信息*/function triggerTravisCI ($repos, $token, $message='yuque update', $branch='master') &#123; //初始化 $curl = curl_init(); //设置抓取的url curl_setopt($curl, CURLOPT_URL, 'https://api.travis-ci.org/repo/'.$repos.'/requests'); //设置获取的信息以文件流的形式返回，而不是直接输出。 curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1); //设置post方式提交 curl_setopt($curl, CURLOPT_CUSTOMREQUEST, "POST"); //设置post数据 $post_data = json_encode(array( "request"=&gt; array( "message"=&gt;$message, "branch"=&gt;$branch ) )); $header = array( 'Content-Type: application/json', 'Travis-API-Version: 3', 'Authorization:token '.$token, 'Content-Length:' . strlen($post_data) ); curl_setopt($curl, CURLOPT_HTTPHEADER, $header); curl_setopt($curl, CURLOPT_POSTFIELDS, $post_data); //执行命令 $data = curl_exec($curl); $info = curl_getinfo($curl); //关闭URL请求 curl_close($curl); return $info;&#125;?&gt; 这里有几个需要获取的参数： travis登录token，在travis-ci.org 中设置界面获取： 1- 仓库ID 或 扩展名 使用findder 或者 postman 发起一个请求： https://api.travis-ci.org/owner/github用户名/repos 配置触发方式 一般会得到这么个api：https://service-8x9gl1u7-1258196125.ap-shanghai.apigateway.myqcloud.com/release/yuque-hexo 5）配置语雀配置一个仓库（公开的仓库）的webhook:可以选择所有更新触发或者主动触发，主动触发的意思即发布需要勾选一个选项才会触发webhook。具体可参见语雀文档；将serverless生成的api填入,可以在链接后面带参数： 1234567token 登录tokenrepos 仓库idmessage 提交信息branch 分支示例：https://service-8x9gl1u7-1258196125.ap-shanghai.apigateway.myqcloud.com/release/yuque-hexo?repos=xxx&amp;token=xxx&amp;message=xxx&amp;branch=xxx 如果不在链接带参数则写在serverless函数内。 6）大功告成发布或者更新一篇文章后，我们前往travis-ci,可以看到已经触发了一次构建请求：构建完成后，咱们的博客上已经妥妥的展示出来拉~ 参考资料Nero的语雀 转自：https://sunnybob.github.io/2019/01/11/%E8%AF%AD%E9%9B%80%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hexo+GithubPages%E5%8D%9A%E5%AE%A2/]]></content>
  </entry>
  <entry>
    <title><![CDATA[流量统计]]></title>
    <url>%2F2019%2F06%2F19%2Fyuque%2F%E6%B5%81%E9%87%8F%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[如果你关心自己博客的访问数据，那么集成流量统计工具自然必不可少。统计站点流量访问的平台主要推荐以下三个： Google Analysis:google.com/intl/zh-CN/a，功能强大不用多说，由于国内Google的服务用不了，所以推荐海外站点使用。 CNZZ：http://web.umeng.com/ ，中文网站统计分析平台，口碑不错，目前和友盟合并被阿里收购。 百度统计：http://tongji.baidu.com/ ，正在研究，不多做评价。 统计功能同样集成简单，我索性把三家统计都集成了，做分析对比。]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何评价「多说」即将关闭？有什么替代方案？]]></title>
    <url>%2F2019%2F06%2F19%2Fyuque%2F%E5%A6%82%E4%BD%95%E8%AF%84%E4%BB%B7%E3%80%8C%E5%A4%9A%E8%AF%B4%E3%80%8D%E5%8D%B3%E5%B0%86%E5%85%B3%E9%97%AD%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[第三方评论系统推荐这几天在网上搜集了不少第三方评论系统，做了简单测评。原文太长，所以贴个链接：第三方评论系统推荐 - 水八口记。文中提到的评论系统有： Disqus HyperComments 来必力 IntenseDebate 畅言 网易云跟帖（已停止服务） 友言 Remarkbox Vuukle Muut Vicomi Civil Comments Widget Pack Rating &amp; Comment System Facebook comments Livefyre（已停止服务） Google+ Comments（非官方） HashOver Isso Staticman Gitment Gitalk Blog Comments2 Valine hexo评论从多说迁移到disqus鉴于duoshuo系统2017年6月1号停止维护,我决定把评论系统切换到 Disqus，即使可能会丢失全部的评论数据，我还是决定和多说一刀两断。 添加disqus 评论系统可以用到的评论系统有挺多的，多说，disqus等，这里只mark下disqus，disqus 的添加跟主题有关，因为hexo自带disqus，所以添加起来非常简单，这里讲下默认的主题landscape 和 上面演示的主题next整个切换过程其实很简单，在 Disqus 注册，然后在 Settings/Admin 中新建站点，接下来就是一步一步跟着向导程序走下去。然后在主题的配置文件，主题的配置文件，主题的配置文件，重要的说三遍，在主题的配置文件_config.yml的disqus后面添加website shortname中使用的唯一的disqus识别名字，这里我使用的是zyy1217。 Step 1：进入disqus官网， 点击蓝色框中链接，给自己的网站添加disqus， Step 2：点击后，出现下图，输入网站名字。然后在第二个输入框填写自己的唯一disqus识别名称，这个名称会在后面用到，比如我这里填写的是我最常用的absea。然后点击Next按钮 Step 3：上面点击Next后就会出现下面页面，这里面会有disqus在不同博客系统上或者其他系统上对应的代码。因为hexo自带支持disqus，所以不需要这里面的代码，这个页面的内容会在其他除hexo之外的博客系统中用到，如果是hexo搭建博客disqus，可以跳过 Step 4：然后在主题的配置文件，主题的配置文件，主题的配置文件，重要的说三遍，在主题的配置文件_config.yml的disqus后面添加step 2中使用的唯一的disqus识别名字。这里我使用的是absea，还有一点一定要注意，不要再跟目录下的_config.yml对评论进行设置 | 12 | # Disqusdisqus_shortname: absea || :— | :— | Step 5：然后输入 hexo s或者hexo server 就会出现disqus的效果：关于disqus评论框的样式美化可以参考Disqus Appearance Tweak不仅如此，我们还可以区分国内与国外GIT，分别显示多说与DISQUS 转自：http://zyy1217.com/2017/05/03/hexo%E8%AF%84%E8%AE%BA%E4%BB%8E%E5%A4%9A%E8%AF%B4%E8%BF%81%E7%A7%BB%E5%88%B0disqus/ Gitment Demo https://github.com/imsun/gitment Gitment：使用 GitHub Issues 搭建评论系统本以为自己都二十好几了，早就过了折腾博客系统的年龄，然而万万没想到多说倒闭了。 综合考虑了多家评论系统以后，我最终打算自己写一个。 Gitment 是作者实现的一款基于 GitHub Issues 的评论系统。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown / GFM 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。本博客评论系统已迁移至 Gitment。虽然 Gitment 只能使用 GitHub 账号进行评论，但考虑到博客受众，这是可以接受的。 项目地址 示例页面基础使用1. 注册 OAuth Application点击此处 来注册一个新的 OAuth Application。其他内容可以随意填写，但要确保填入正确的 callback URL（一般是评论页面对应的域名，如 https://imsun.net）。你会得到一个 client ID 和一个 client secret，这个将被用于之后的用户登录。2. 引入 Gitment将下面的代码添加到你的页面： | var gitment = new Gitment({id: '页面 ID', // 可选。默认为 location.hrefowner: '你的 GitHub ID',repo: '存储评论的 repo',oauth: {client_id: '你的 client ID',client_secret: '你的 client secret',},})gitment.render('container') || :— | 注意，上述代码引用的 Gitment 将会随着开发变动。如果你希望始终使用最新的界面与特性即可引入上述代码。如果你希望引用确定版本的 Gitment，则应该使用 npm 进行安装。 | $ npm install –save gitment || :— | 关于构造函数中的更多可用参数请查看 Gitment Options 3. 初始化评论页面发布后，你需要访问页面并使用你的 GitHub 账号登录（请确保你的账号是第二步所填 repo 的 owner），点击初始化按钮。之后其他用户即可在该页面发表评论。 自定义Gitment 很容易进行自定义，你可以写一份自定义的 CSS 或者使用一个新的主题。（主题可以改变 DOM 结构而自定义 CSS 不能）比如你可以通过自定义主题将评论框放在评论列表前面： | const myTheme = {render(state, instance) {const container = document.createElement(‘div’)container.lang = “en-US”container.className = ‘gitment-container gitment-root-container’container.appendChild(instance.renderHeader(state, instance))container.appendChild(instance.renderEditor(state, instance))container.appendChild(instance.renderComments(state, instance))container.appendChild(instance.renderFooter(state, instance))return container},}const gitment = new Gitment({// …theme: myTheme,})gitment.render(‘container’) || :— | 更多自定义内容请查看文档。 其他问题 语言问题考虑到 GitHub 本身使用英文，而本项目面向用户均为 GitHub 用户，所以作者没有提供中文支持的打算。实在有需求的可以通过自定义主题支持中文。 请勿滥用在开发这个项目时我就一直有一个疑虑：我这样做有没有滥用 GitHub？为此我仔细读了 GitHub Terms of Service中 API Terms 的部分，认为自己并没有违反协议。之后我向 GitHub 发邮件询问了这一问题。GitHub 给出的回复是： We’re pleased to see you making use of the tools and resources available on GitHub. 因此本项目的确没有违反 GitHub 使用协议。但我还是想提醒使用本项目的用户，请保持克制，切勿滥用。 样式版权在项目开源前作者曾实现了一个像素级抄袭 GitHub Issues 样式的界面，但在阅读 ToS 时发现违反了 Section F，并在和 GitHub 邮件沟通的过程中确认了这一行为是侵权的。因此便改成了现在的样式。请其他想要自定义样式的用户也留意版权问题。# Gitment写个 Web Server（一）需求 这段转自：https://imsun.net/posts/gitment-introduction/ GITALK 一个基于 Github Issue 和 Preact 开发的评论插件开始使用 GITHUB 第三方评论系统推荐2多说要下线了，国内博客圈哀鸿遍野。主流博主们还好，有原生评论系统可以用，只是社交分享的时候麻烦点。最近流行起来的静态博客的博主们就不太好了，除了一部分技术帝能够“自己动手，丰衣足食”，其他吃瓜博主要么积极地到处求攻略，要么懒得折腾干脆关了评论。Bitcron 不算静态博客，也有自己的评论系统，但处女座的我嫌评论的保存方式不太整洁，所以换博初始就打定了主意使用第三方评论。根据多年的经验和体验，我选择了算是全球最大的评论系统——Disqus。但是突然某一天我被残忍告知这货已经被中国局域网长城挡住了，当时内心是极度奔溃的。本来作为一个洋应用就没什么本地化可言，现在这种局面就更指望不上适应性的提升了，心里拔凉拔凉的。好在现在能建博客的大多也都有科学上网的实力，我也不似以前那么在意和网友的互动了。有当然好，没有也无所谓了。（悄悄说，博客是写给自己的，连评论系统都是给自己用的。有空翻翻以前的文章留个言，看看进步什么的，以前就一直在日记本上这么做。）虽然我不打算换掉 Disqus，但还是本着为人民服务的精神找了一些可以替代多说的第三方评论系统，不止静态博客，理论上来说也适用于所有独立博客系统。以下注释仅代表我个人的想法，详细信息请参照官方网站说明，根据个人需求进行选择安装使用。 Disqus1https://disqus.com 作为业界的龙头老大，相信大家都已经很熟悉了。根据 Datanyze 的统计，Disqus 在全球范围内拥有继 Facebook comments 之后排名第二的占有率，大约37%1。如果不是因为一些不可言说的原因，它的占有率可能还会更大。当然 Facebook comments 也是“受害者”之一，所以单就中国地区而言，Disqus 的占有率是最大的，超过半数2。以上这些数据都来源于国外的统计，如果算上国内的评论系统，我想多说应该是当之无愧的霸主了。数据来源 Datanyze / 制图 水八口Disqus 的好处不必多言，本身就是专业做评论系统的，功能齐全，支持 ssl，响应化设计，界面美观。我还特别喜欢它的一项多说没有的功能是，可以在文章 url 改变后迁徙评论到新文章下。比如前段时间我把间隔年日记从每日一篇改为每周一篇，统合之后便把每日一篇的评论都集中到新写的每周一篇里了。当然它也是有缺点的，我认为的最主要的缺点有两个。一是无法导出/导入自家评论。后台的导出设置只是为了备份，导出的文件没法重新导入。二是没法自定义样式。不过，最大的“缺点”应该算是国内无法使用了吧。身为资深博主，科学上网当然不在话下，但是并不能要求每个读者都有这项技能。所以这也成为了是否使用 Disqus 的最大障碍。前面说了那么多，如果用不了，都成了废话。2017年7月10日更新：我找到了两种可以科学使用 Disqus 的方法，但都不能登录 Disqus，只能使用访客留言通道。也就说你的评论并不会出现在你 Disqus 的 timeline 里。同时访客留言的网址也没法写入 Disqus 后台，但在代理状态下可以显示。综上所述，对于墙内的博主来说，代理就像 WP 的原生评论一样；而对于墙外的博主来说，原生的 Disqus 看不到访客网址，影响回访效率。即便如此，能够使用已经非常难得。 使用 Typlog 提供的 Disqus 代理服务，服务器费用 $10/年，操作简单3。无评论回复邮件提醒4。 使用 fooleap 的研究成果，免费，需要支持 PHP cURL 的虚拟主机和一颗不怕折腾的心。有评论回复邮件提醒5。 HyperComments1https://www.hypercomments.com 来自俄罗斯的评论系统，使用谷歌账号注册。免费用户支持一个网站和一个管理员，对于个人博客来说足够用了。个人用户$24/年，支持一个网站和三个管理员。14天免费试用。更多请参考官网价格页面。功能暂且不说，光看这清爽的界面，作为一只颜狗，我是服气的。HyperComments 颜值在线除了耀眼的颜值，它的功能和 Disqus 大同小异，有些高阶功能需要收费。另外身在俄罗斯的小伙伴可以以短信形式收到评论回复，听着就很高大上。最后说说大家最关心的问题，现阶段国内可以使用，但是，必须使用谷歌账号才能登陆留言，所以有点悬。谢谢小F的更正：免费版后台可以设置支持游客评论。 来必力1https://livere.com 来自韩国，使用邮箱注册。不得不承认颜值也很高，准确地说应该是萌。中国地区的本地化做得很不错，甚至可以用微信登陆留言，简直热泪盈眶。就这点来看，是多说最好的替代品。同时支持的登陆方式还有：新浪微博、QQ、百度、人人、豆瓣。顺带提一下在韩文和英文模式下的登陆方式：来必力、Kakao talk、Naver、Facebook、Twitter、Instagram、Line、GitHub、Tistory、Google+、Linkedin。来必力支持国内多家社交平台登陆国内可以使用。修改评论框样式是收费项目。修改评论只有一次机会。理论上来说注册一个来必力账号，绑定各个社交网站以后，之后用社交网站登陆留言也会同步到同一个账号里6。可以设置评论分享到社交网站。点击头像会像 Disqus 一样显示侧边栏，可以看以往评论。 IntenseDebate1https://www.intensedebate.com 是 WordPress 所在的 Automattic 旗下的产品。优点是支持游客评论。国内可以用，但听说加载略慢。曾经是 Disqus 强有力的对手。既然和 WordPress 同一东家，想必反垃圾邮件的功能应该做得不错。如果有 WordPress 账户就不需要额外注册，但很多用 WP 的都可以使用原生评论，这真是个奇妙的悖论。IntenseDebate 可以以游客身份留言（上图中未开启此项功能） 畅言1http://changyan.kuaizhan.com 搜狐旗下，大牌加持，安装需要备案号。界面还算清爽，不满意的话可以自定义样式。畅言可以自定义 CSS 网易云跟帖（已停止服务）1https://gentie.163.com 感谢小F的提醒：此产品将于2017年8月1日停止服务7。网易旗下，大牌加持，支持网易账号、新浪微博和 QQ 登陆。界面有点尴尬，因为会把地址写出来，比如北京市网友，有种当年各大门户网站下的留言既视感。对于小清新的个人博客来说可能是个不能接受的大坑。网易云跟帖有着网易一贯的“风味” 友言（已停止服务）1http://www.uyan.cc 感谢荏苒的提醒，友言官网已经打不开了，谷歌后得知2017年就不能使用了。可能是最像多说的评论系统。有评论统计、最新评论插件可以使用。JiaThis（加网）旗下产品。它家有加网的分享按钮（Share this），友荐的猜你喜欢（Related posts），加上友言的评论系统，博客三件套齐活儿了。支持 QQ、新浪微博、人人、开心网账号登陆。界面很像 Disqus。友言的家族成员还有加网和友荐 Remarkbox1https://www.remarkbox.com 一位外国友人的个人项目，主打就是“Disqus 的替代品”。因为从 WP 搬到静态博客，寻找第三方评论系统时不喜欢评论里有广告，所以就自己写了一个。好像还是 beta 版，还在增加功能。在测试评论里看到了代码高亮，果然是极客的世界。界面简洁。由于是个人项目，故对未来的发展持观望态度。Remarkbox 的未来会如何？ Vuukle1http://vuukle.com 来自印度。后台感觉跟 WordPress 比较像，还能看当前在线人数。我注册了一个账号试安装了一下没成功。（所以给我留下了不靠谱的感觉。也可能是我技术不够。）界面设计不错，支持 Google+ 和 Facebook 账号登陆，也可以以游客身份留言。Vuukle 支持游客评论 Muut1https://muut.com 免费计划竟然包含了无限流量、多语言、无广告和样式修改？！我想要欢呼！更惊喜的是评论可以用 Markdown，还能 ctrl+enter 发布。支持 Facebook、Twitter、Google+、Yahoo、Windows Live、Linkedin、GitHub、Reddit、Yandex、Disqus 账号登陆。注册可以用邮箱。Demo 页面有很多格式，NY Times 样式的侧边栏评论令人惊艳。私聊功能需要付费。输入评论时可以实时预览。Muut 令人惊艳 Vicomi1http://www.vicomi.com 免费用户支持一个域名。特点是可以选择心情表情。也因此界面有些凌乱。Vicomi 是评论界的表情帝 Civil Comments1https://www.getcivil.com/comments 邮箱注册，社交网站支持 Facebook 和 Twitter。界面友好干净，无功无过。Civil 旗下还有 Civil Live 和 Civil Reviews。专注 UGC (User Generated Content) 的样子。Civil Comments 使用手册（英文） Widget Pack Rating &amp; Comment System1https://widgetpack.com/comment-system 跟 Civil Comments 类似，除了评论系统，还有 Reviews、Rating 和 Google Reviews。免费用户支持一个域名和一位管理员。使用邮箱注册。留言可以使用以下社交网站登陆：Facebook、Twitter、Google+、Linkedin、Instagram、SoundCloud、Tumblr、ВКонтакте (VK)、OK、Мой Мир、Yahoo、LiveJournal、Яндекс。从这些网站中我看出来了，这也是一家来自俄罗斯的产品。评论框内嵌星级评分，据官方称，评分会显示在谷歌的搜索结果中。支持 ssl。Widget Pack Rating &amp; Comment System Facebook comments1https://developers.facebook.com/docs/plugins/comments 如果你的朋友都在使用 Facebook，这绝对是不二选择。就好比新浪微博出了个评论系统，亲戚朋友都能方便登陆留言，评论可以点赞，还能分享到微博让更多人看到，一气呵成。当年多说能够保持绝对地位的占有率，也是靠了支持国内各个社交平台登陆的力量。 Livefyre（已停止服务）被 Adobe 收购以后就不再是独立的评论系统了。它成为 Adobe Experience Manager 的一部分，简单说来就像是简书的评论部分一样8。因为在 Datanyze 的图表上看见它排名第四，也在谷歌后找到官方的安装网站，顺利取得代码，于是我原以为它还能使用。但在测试时看到了以下信息，于是我彻底死心了。竟然也是最近的事。 Notice: Livefyre Community Comments will become read-only starting March 9, 2017 and no longer available as of April 6, 2017. To export your comments, please visit, www.livefyre.com/installation/site/export/. For more information, please see https://docs.adobe.com/docs/en/aem/livefyre-announcements.html. 面对曾经的用户，Adobe 给出了两个备用选择：Disqus 和一个 WordPress 插件。这个插件可以在 Google+、Facebook comment、Disqus 和 WordPress 原生评论中切换，对于想兼顾国内外朋友的博主来说应该是个不错的选择。 Google+ Comments（非官方）高手在民间9。 HashOver1http://tildehash.com/?page=hashover 技术小白表示看不太懂，大家可以去官网围观一下。 Isso1https://posativ.org/isso 也是技术向的，我等小白就不妄加评论了。 Staticman1https://staticman.net 顾名思义，静态评论，逼格太高了。最适合托管在 GitHub Pages 上的 Jekyll 博客。对于没有 Git 经验的我，安装手册看起来太难了。 Gitment1https://github.com/imsun/gitment 感谢Fooleap的分享，官网给出的说明是： Gitment 是作者实现的一款基于 GitHub Issues 的评论系统。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown / GFM 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。 目测非常适合 GitHub 重度用户，并且博客受众也是 GitHub 用户的人。 Gitalk1https://gitalk.github.io 感谢Liu Joey的分享，官方 GitHub 页面上对此的介绍是： Gitalk 是一个基于 Github Issue 和 Preact 开发的评论插件。 Blog Comments21https://github.com/revir/nodebb-plugin-blog-comments2 从 NodeBB 官方博客的评论插件上修改而来，支持静态博客。 Valine1https://github.com/xCss/Valine 感谢林小沐的分享，官方中文教程声称这是「一款基于Leancloud的极简风评论系统」。另有进化版可供选择。 Self-host comments in Jekyll1https://flinhong.com/2017/03/25/self-host-comments-in-jekyll-using-firebase-database 感谢flinhong分享的造轮子方法，按照大神的原话是： 感兴趣的同学也来自己动手做一个，很适合静态博客。唯一的缺点就是用的 Google 的服务，需要那啥，大家懂的。 Commento1https://gitlab.com/commento/commento 感谢fc4soda的推荐： 支持 markdown 支持匿名、层级回复 支持锁定主题 免费 go写的不需要安装依赖，还有docker版 目前作者在考虑多国语言化 缺点：- 需要自己搭建服务- 目前手动审核评论似乎只能在主帖下面，无法在管理后台统一管理 后记这篇文章写了整整一天半，信息量之大是我最初没有想到的。因为找到的很多都是收费的，所以看过的评论系统可能有现在总结出来的两倍，工程量非常浩大，好在我坚持下来了。好久没有如此专注过一件事，写完的时候心里美滋滋的。在查找 Disqus 替代品的时候发现很多国外的评论系统也消失了不少，看来当初选择了 Disqus 真是押对了宝。对于第三方评论系统来说，盈利模式非常重要。免费的评论系统一般都在说 UGC，也就是用户产生内容。如果你的网站有很多读者，一起讨论可以创造出更多的价值。简单说起来就是大家一起赚钱，或者类似粉丝经济。所以我找到了很多只面对企业客户的评论系统就一点也不意外了，毕竟普通的个人身上很难产生赢利点。而幸存下来的免费评论系统，比如 Disqus，最终也没能逃脱在评论里插入广告的魔咒，因此得罪了不少用户，即使广告费有分成。另外很多社交网络都有自己的评论系统，反正都得注册，评论也不需要门槛。这对第三方评论系统的生存也是一个冲击。在搜集资料的过程中，我还发现了一个特别的现象，就是很多收费的评论系统都有免费的 WordPress 插件。所以好好珍惜手中的 WordPress 吧。最后，还是得安利一下我的“大房东”——Bitcron。论专注写作、简洁、本地化、先进技术，多年在博客圈打拼的我觉得它都是第一名。一站式解决所有问题，比当年惊艳我们的 FarBox 走得更远了。现在它不仅仅是一个博客，甚至可以变身成任何你想要的东西，这是它的野心，也给了我们信心。当然，评论框很美是有加分的。如果你有什么更好的推荐欢迎留言告诉我，我会补充在这篇文章里。 参考网站 再见，那些年我们一起用过的多说 - 荏苒.me Are there any free alternatives to Disqus? - Quora Disqus Alternatives - tips &amp; tricks - Hugo Discussion Alternative to Disqus Needed More Than Ever - support - Hugo Discussion Hashover-PHP开源评论系统 - Orro.ro Disqus Alternatives and Similar Software - AlternativeTo.net Improving Static Comments with Jekyll &amp; Staticman | Made Mistakes 如何评价“多说”即将关闭？有什么替代方案？ - 知乎]]></content>
  </entry>
  <entry>
    <title><![CDATA[doc命令]]></title>
    <url>%2F2019%2F06%2F19%2Fyuque%2Fdoc%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[mac 杀掉占用某个端口的进程两个小命令: lsof -i :端口 kill -9 进程ID]]></content>
  </entry>
  <entry>
    <title><![CDATA[go语言]]></title>
    <url>%2F2019%2F06%2F19%2Fyuque%2Fgo%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[Go 语言中文开源图书、资料或文档–Go的开源书籍 破解方法：https://www.cnblogs.com/pig66/p/10420947.html软件安装后的路径：/Applications/GoLand.app/Contents/bin破解包：jetbrains-agent.jar GoLand2019 激活码 此教程对最新2019版本GoLand有效！！！ 本教程对windows、mac、ubuntu全系统可用 此教程实时更新，请放心使用；如果有新版本出现猪哥都会第一时间尝试激活； goland官网下载地址：http://www.jetbrains.com/goland/download/ 汉化教程 激活出问题可扫描下方二维码，加入激活群寻求帮助！两种激活方式 永久激活：推荐优先使用，永久有效 有效期激活：如果你实在激活不了又着急使用，这是备选激活方案，简单快捷一、永久激活1.下载新版破解补丁点击链接 https://pan.baidu.com/s/16ALpz_BCXjsRkpS_PtD23A 下载补丁文件 jetbrains-agent.jar 并将它放置到 goland安装目录的\bin目录下（位置可随意，放这里是怕误操作删除了破解文件）。2.进入项目界面如果你之前已经使用有效期激活过可跳过此步骤，如果你是刚下载的GoLand，则需要点击激活窗口的“Evaluate for free”免费试用，然后再创建一个空项目，这样就可以进入到GoLand的工作页面3.修改配置文件进入到项目界面后，点击GoLand最上面的菜单栏中的 “Help” -&gt; “Edit Custom VM Options …”，如果提示是否要创建文件，请点”Yes”。 在打开的vmoptions编辑窗口末行添加：-javaagent:你goland的安装目录\jetbrains-agent.jar请仔细检查补丁路径是否正确，如果错误则会出现GoLand打不开的情况，这时候可以删除用户配置目录下的goland文件夹:windwos：C:\Users\用户名&lt;br /&gt;macos：/Library/Preferences/ubuntu：/.修改完配置文件之后重启GoLand修改完配置文件之后重启GoLand修改完配置文件之后重启GoLand 4.输入激活码重启GoLand之后，点击菜单栏中的 “Help” -&gt; “Register …”，这里有两种激活方式：一、选择最后一种License server激活方式，地址填入：http://jetbrains-license-server（应该会自动填上），或者点击按钮：”Discover Server”来自动填充地址，完成激活二、如果服务器激活方式无法激活，还可以选择Activation code方式激活，复制下面激活码即可 1D00F1BDTGF-eyJsaWNlbnNlSWQiOiJEMDBGMUJEVEdGIiwibGljZW5zZWVOYW1lIjoiaHR0cHM6Ly96aGlsZS5pbyIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiJVbmxpbWl0ZWQgbGljZW5zZSB0aWxsIGVuZCBvZiB0aGUgY2VudHVyeS4iLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiV1MiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSRCIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJDIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJEQiIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJNIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiRE0iLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJBQyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRQTiIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkdPIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUFMiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlBDIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlNVIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In1dLCJoYXNoIjoiODkwNzA3MC8wIiwiZ3JhY2VQZXJpb2REYXlzIjowLCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-3OPFIX9/KSL76ctAKOwpBPCCAfUhUbucdNbtqMaTqRryvKEvrFqCKncE0eMHA2YkrcP2CtV9LKjlIXhJMqp0N821Qv1AhuIJrDMBubqiEtiqnGkcGV35DF0GzyUQaUdN6fTbZna05riHzR6yzgEzo9R3RIzCTDMQdB/0EojWM0nCBkPsLdncZeDv3+Y+VA8ZH3/BBvzwR1e0gWsT3mfT9tIvwxPuEhNrQFNOP1PZOjC8nX9h/J7ag5X3JQL1CQVi4TnEipdy0fxKbDPKTloM3Y/bA23uaW+Q/JQFBRKRR0q3FYJ1DQuSc7YmeJ7Q2IHq7u5QYz8jPZJtP6PKs6g/tQ==-MIIECDCCAfCgAwIBAgIJAI5/xwNtz47cMA0GCSqGSIb3DQEBCwUAMBgxFjAUBgNVBAMMDUpldFByb2ZpbGUgQ0EwIBcNMTgwODIzMDcwNDA3WhgPMjExODA3MzAwNzA0MDdaMBExDzANBgNVBAMMBnByb2QzeTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAOZ3WopNRg9J8k3apGYFEUGRlvkRsQnQSEz1yMKY4YWg9ElxmuF0mQRAaIj3WOl1eqTn1CXsn4vXV7GODJk9A/rCqEk960sPesWn/RVz7zo5+KazE3Y9yYtwskKxlnkFNp82Kha6dUGDSwG2lYh0Sria2ByOhgr6gmyXtC0PKqlIlTAPcBvz0MEnKTZkxfSqdiHo/meTlMRd9885vr4P52Fd9Ryxe3yVAKZSP9ZzPmRvCvgF1oGCgobZJ5d7FvTwkGt2t4pjy/RlU6FDcXNMHLk4pfJqr3lnEkAh2MbCGlGo1i6Rc6DtgISuJn2AUkrQKhI6F0U7o9e5qPEOjNkhznMCAwEAAaNaMFgwCQYDVR0TBAIwADALBgNVHQ8EBAMCBaAwHQYDVR0OBBYEFJDgSMx4XrLktYOG827wP7VULTnJMB8GA1UdIwQYMBaAFDAS51akWaJlzxC2x4yP3iAYbqtxMA0GCSqGSIb3DQEBCwUAA4ICAQBxRyfCpL7q2VurGfh9XqaC4GsGp6ut3l/rOEyc6DP148A69DRmZ7saqfZW87DcLkmcynPhyBOxdcGwtwKlR9E/+X923JeL6VPQCTY5WyJKib36vQCnoC4ELTnw1yc51v2j+MaZXjrlzBIcCUocWK14WS4iBycUwLuMszz6rJ8xluuYDKDeNcS/AjQf+yTUfDXjktHLgcE27sSEQUQ+7bpbKHkJ5xBvaupJEPX+ndj7V2eD+/sO03jgnsWVa2nky7yDXX/5KCqzL5kAA1n2t2dWSJXxpac8O2bPyRhk6dUSwzNr+IjCjHqUKIouB0nosi85Q5MaIE0pwOOSggnawpnjmL3qDnsS/n7NUcX/mF4eiNQ8cMJmKIgfS6rntKuQY2zSod+4+G0AFbiihVTnKsRf7CiJa/VniZdaGdbclT8KzRnNKJ1TrPO8rVPjg+SpvqTq75xynS08/OXCpoJ3aVeBWZJYJmheHhvJw2RiNW2P2GSIw+m6HIIsthUtvvHqdKpIaThFHAOKmw0LpPO7uGs/z/Q3un7+lqSlW7akUoSCHdiAJ4wWv+qFEgE4mq8bKtHoa9yy6FZBoORbbRTj8WkS+UvCLN5p7kZenmKYnWCzBf02O1ULpMsR5WvKCGCekSwWf3lAF9lYTL12JaFTw9iH1nSkyvcu7AoXlWI50hOhmA== 5.查看有效期当你激活完毕后，GoLand右下角会有个Registration小长条提示框，大致的内容为：You copy is Licensed to XXX意思就会告诉你：兄弟，你已经激活成功了，激活码的许可来源是：XXX。查看有效期的步骤为点击：Help-&gt;About这里可以看到你的GoLand的版本号、许可来源、有效期、以及一些环境服务器激活是没有期限的，即为永久有效 激活码激活的有效期到2089年的 二、有效期激活如果使用有效期出现问题可先加激活群寻求帮助，还可以尝试使用有效期激活！ 1.修改hosts文件将0.0.0.0 account.jetbrains.com和0.0.0.0 www.jetbrains.com添加到hosts文件最后，注意hosts文件无后缀，如果遇到无法修改或权限问题，可以采用覆盖的方法去替换hosts文件修改后请检查hosts文件是否修改，激活码无法激活的原因99.99%是因为hosts没有修改正确Windows系统hosts文件路径为：c:\windows\system32\drivers\etcLinux系统hosts文件路径为：/etc 2.复制激活码打开PyCharm选择Activation code激活，然后复制下面的激活码点击激活。此激活码有效期为2020-03-11，大家可以关注微信公众号：裸睡的猪 或扫描下方二维码，在过期之前我会在公众号中推送新的激活码哦 156ZS5PQ1RF-eyJsaWNlbnNlSWQiOiI1NlpTNVBRMVJGIiwibGljZW5zZWVOYW1lIjoi5q2j54mI5o6I5p2DIC4iLCJhc3NpZ25lZU5hbWUiOiIiLCJhc3NpZ25lZUVtYWlsIjoiIiwibGljZW5zZVJlc3RyaWN0aW9uIjoiRm9yIGVkdWNhdGlvbmFsIHVzZSBvbmx5IiwiY2hlY2tDb25jdXJyZW50VXNlIjpmYWxzZSwicHJvZHVjdHMiOlt7ImNvZGUiOiJJSSIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9LHsiY29kZSI6IkFDIiwicGFpZFVwVG8iOiIyMDIwLTAzLTEwIn0seyJjb2RlIjoiRFBOIiwicGFpZFVwVG8iOiIyMDIwLTAzLTEwIn0seyJjb2RlIjoiUFMiLCJwYWlkVXBUbyI6IjIwMjAtMDMtMTAifSx7ImNvZGUiOiJHTyIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9LHsiY29kZSI6IkRNIiwicGFpZFVwVG8iOiIyMDIwLTAzLTEwIn0seyJjb2RlIjoiQ0wiLCJwYWlkVXBUbyI6IjIwMjAtMDMtMTAifSx7ImNvZGUiOiJSUzAiLCJwYWlkVXBUbyI6IjIwMjAtMDMtMTAifSx7ImNvZGUiOiJSQyIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9LHsiY29kZSI6IlJEIiwicGFpZFVwVG8iOiIyMDIwLTAzLTEwIn0seyJjb2RlIjoiUEMiLCJwYWlkVXBUbyI6IjIwMjAtMDMtMTAifSx7ImNvZGUiOiJSTSIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9LHsiY29kZSI6IldTIiwicGFpZFVwVG8iOiIyMDIwLTAzLTEwIn0seyJjb2RlIjoiREIiLCJwYWlkVXBUbyI6IjIwMjAtMDMtMTAifSx7ImNvZGUiOiJEQyIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9LHsiY29kZSI6IlJTVSIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9XSwiaGFzaCI6IjEyMjkxNDk4LzAiLCJncmFjZVBlcmlvZERheXMiOjAsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-SYSsDcgL1WJmHnsiGaHUWbaZLPIe2oI3QiIneDtaIbh/SZOqu63G7RGudSjf3ssPb1zxroMti/bK9II1ugHz/nTjw31Uah7D0HqeaCO7Zc0q9BeHysiWmBZ+8bABs5vr25GgIa5pO7CJhL7RitXQbWpAajrMBAeZ2En3wCgNwT6D6hNmiMlhXsWgwkw2OKnyHZ2dl8yEL+oV5SW14t7bdjYGKQrYjSd4+2zc4FnaX88yLnGNO9B3U6G+BuM37pxS5MjHrkHqMTK8W3I66mIj6IB6dYXD5nvKKO1OZREBAr6LV0BqRYSbuJKFhZ8nd6YDG20GvW6leimv0rHVBFmA0w==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQAF8uc+YJOHHwOFcPzmbjcxNDuGoOUIP+2h1R75Lecswb7ru2LWWSUMtXVKQzChLNPn/72W0k+oI056tgiwuG7M49LXp4zQVlQnFmWU1wwGvVhq5R63Rpjx1zjGUhcXgayu7+9zMUW596Lbomsg8qVve6euqsrFicYkIIuUu4zYPndJwfe0YkS5nY72SHnNdbPhEnN8wcB2Kz+OIG0lih3yz5EqFhld03bGp222ZQCIghCTVL6QBNadGsiN/lWLl4JdR3lJkZzlpFdiHijoVRdWeSWqM4y0t23c92HXKrgppoSV18XMxrWVdoSM3nuMHwxGhFyde05OdDtLpCv+jlWf5REAHHA201pAU6bJSZINyHDUTB+Beo28rRXSwSh3OUIvYwKNVeoBY+KwOJ7WnuTCUq1meE6GkKc4D/cXmgpOyW/1SmBz3XjVIi/zprZ0zf3qH5mkphtg6ksjKgKjmx1cXfZAAX6wcDBNaCL+Ortep1Dh8xDUbqbBVNBL4jbiL3i3xsfNiyJgaZ5sX7i8tmStEpLbPwvHcByuf59qJhV/bZOl8KqJBETCDJcY6O2aqhTUy+9x93ThKs1GKrRPePrWPluud7ttlgtRveit/pcBrnQcXOl1rHq7ByB8CFAxNotRUYL9IF5n3wJOgkPojMy6jetQA5Ogc8Sm7RG6vg1yow== 转自：https://www.cnblogs.com/pig66/p/10420947.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[promise源码]]></title>
    <url>%2F2019%2F06%2F19%2Fyuque%2Fpromise%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[API结构图 术语 promise的执行过程了解Promise诞生的历史背景学会使用Promise解决异步回调带来的问题掌握Promise的进阶用法 异步操作的常见语法1234567document.getElementById('start').addEventListener('click',start,false);function start()&#123; //响应事件，进行响应的操作&#125;$('#start').on('click',start); 有了Node.js之后对异步的依赖进一步加剧了……无阻塞高并发 Promise详解123456789101112new Promise( //执行器 executor function(resolve,reject)&#123; // 一段耗时很长的异步操作 resolve();// 数据处理完成 reject();// 数据处理出错 &#125;).then(function A()&#123; //成功，下一步&#125;,function B()&#123; //失败，做相应处理&#125;) Promise实例一经创建，执行器立即执行 简单实例12345678console.log("here we go"); new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve("hello"); &#125;, 2000); &#125;).then(value =&gt; &#123; console.log(`$&#123;value&#125; world`); &#125;); 两步执行的范例1234567891011121314151617181920console.log("here we go"); new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve("hello"); &#125;, 2000); &#125;) .then(value =&gt; &#123; console.log(value); return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve("nihao"); &#125;, 1000); &#125;); &#125;) .then(value =&gt; &#123; console.log(`$&#123;value&#125; world`); &#125;);here we gohellonihao world 对已完成的Promise执行then123456789101112131415161718console.log("start");let promise = new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log("the promise fulfilled"); resolve("hello,world"); &#125;, 1000);&#125;);setTimeout(() =&gt; &#123; promise.then(value =&gt; &#123; console.log("value:", value); &#125;);&#125;, 0);startthe promise fulfilledvalue: hello,world 不管promise前面的状态是否完成，都会按它的队列去执行 then里不返回Promise1234567891011121314151617181920212223242526272829303132console.log("start");let promise = new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log("the promise fulfilled"); resolve("hello,world"); &#125;, 2000);&#125;) .then(value =&gt; &#123; console.log(value); console.log("everyone"); (function() &#123; console.log("比包"); return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log("Mr Lanrence"); resolve("Merry Xmas"); &#125;, 0); &#125;); &#125;)(); return false; &#125;) .then(value =&gt; &#123; console.log(value + " world"); &#125;);startthe promise fulfilledhello,worldeveryone比包false worldMr Lanrence 引出.then() .then()接受两个函数作为参数，分别代表fulfilled和rejected .then()返回一个新的Promise实例，所以它可以链式调用 当前面的Promise状态改变时，.then()根据其最终状态，选择特定的状态响应函数执行 状态响应函数可以返回新的Promise，或其他值 如果返回新的Promise,那么下一级.then()会在新Promise状态改变后执行 如果返回其它任何值，则会立刻执行下一级.then() .then()里有.then()的情况 因为.then()返回的还是Promise实例。 会等里面的.then()执行完，再执行外面的。 对于我们来说，此时最好将其展开，会更好读。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374console.log("start");let promise = new Promise(resolve =&gt; &#123; console.log("step1"); setTimeout(() =&gt; &#123; resolve("100"); &#125;, 1000);&#125;) .then(value =&gt; &#123; return new Promise(resolve =&gt; &#123; console.log("Step 1-1"); setTimeout(() =&gt; &#123; resolve(110); &#125;, 1000); &#125;) .then(value =&gt; &#123; console.log("Step 1-2"); return value; &#125;) .then(value =&gt; &#123; console.log("Step 1-3"); return value; &#125;); &#125;) .then(value =&gt; &#123; console.log(value); console.log("Step 2"); &#125;);startstep1Step 1-1Step 1-2Step 1-3110Step 2一样的效果可以这样改console.log("start");let promise = new Promise(resolve =&gt; &#123; console.log("step1"); setTimeout(() =&gt; &#123; resolve("100"); &#125;, 1000);&#125;) .then(value =&gt; &#123; return new Promise(resolve =&gt; &#123; console.log("Step 1-1"); setTimeout(() =&gt; &#123; resolve(110); &#125;, 1000); &#125;); &#125;) .then(value =&gt; &#123; console.log("Step 1-2"); return value; &#125;) .then(value =&gt; &#123; console.log("Step 1-3"); return value; &#125;) .then(value =&gt; &#123; console.log(value); console.log("Step 2"); &#125;);startstep1Step 1-1Step 1-2Step 1-3110Step 2 问题：下面的四种Promise的区别是什么 问题一 问题二 问题三（比较有欺骗性）doSomethingElse()也是一个promise 问题四 错误处理123456789101112console.log("start");new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; throw new Error("bye"); &#125;, 2000);&#125;) .then(value =&gt; &#123; console.log(value + " world"); &#125;) .then(error =&gt; &#123; console.log("Error: ", error, error.message); &#125;); 错误处理的两种做法： reject(‘错误信息’).then(null,message=&gt;{}) 123456789101112131415161718192021222324252627282930console.log("start");new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject("bye bye"); &#125;, 2000);&#125;).then( value =&gt; &#123; console.log(value + " world"); &#125;, value =&gt; &#123; console.log("Error: ", value); &#125;);一样的console.log("start");new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; // reject("bye bye"); throw new Error("bye bye"); &#125;, 2000);&#125;).then( value =&gt; &#123; console.log(value + " world"); &#125;, value =&gt; &#123; console.log("Error: ", value); &#125;); throw new Error(‘错误信息’).catch(message=&gt;{}) 123456789101112console.log("start");new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; throw new Error("bye"); &#125;, 2000);&#125;) .then(value =&gt; &#123; console.log(value + " world"); &#125;) .then(error =&gt; &#123; console.log("Error: ", error, error.message); &#125;); 推荐使用第二种，更加清晰好读，并且可以捕获前面的错误 强烈建议在所有队列最后都加上.catch(),以避免漏掉错误处理造成意想不到的问题 Promise.all 当所有子Promise都完成，该Promise完成，返回值是全部值的数组 有任何一个失败，该Promise失败，返回值是第一个失败的子Promise的结果与.map连用、实现队列 Promise.resolvepromise then里面的值，都是resolve来传递改变的 123456789101112131415161718192021222324console.log("start");Promise.resolve() .then(value =&gt; &#123; console.log("step 1", value); return Promise.resolve("Hello"); &#125;) .then(value =&gt; &#123; console.log(value, "world"); return Promise.resolve( new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve("Good"); &#125;, 2000); &#125;) ); &#125;) .then(value =&gt; &#123; console.log(value, "evening"); return Promise.resolve(&#123; then() &#123; console.log(", everyone"); &#125; &#125;); &#125;); Promise.reject目前位置就是提示报错，没有别的作用 1234567891011121314151617let promise = Promise.reject("something wrong");promise .then(() =&gt; &#123; console.log("it's ok "); &#125;) .catch(() =&gt; &#123; console.log("no,it's not ok"); return Promise.reject(&#123; then() &#123; console.log("it will be ok"); &#125;, catch() &#123; console.log("not yet"); &#125; &#125;); &#125;); Promise.race它有任意一个完成就算完成了和promise.all的区别 12345678910111213141516171819202122let p1 = new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve("1111111"); &#125;, 10000);&#125;);let p2 = new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve("2222222"); &#125;, 2000);&#125;);Promise.race([p1, p2]).then(value =&gt; &#123; console.log(value);&#125;);Promise.all([p1, p2]).then(value =&gt; &#123; console.log(value);&#125;);2222222[ '1111111', '2222222' ] 常见用法：把异步操作和定时器放在一起，如果定时器先触发，就认为超时，告知用户 把回掉包装成Promise可读性更好返回的结果可以加入任何promise队列 手撕promise源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104function Promise(executor) &#123; let self = this; // 保存成功的值和失败的原因 self.value = undefined; self.reason = undefined; // 专门存成功的回调 self.onResolvedCallbacks = []; // 专门存失败的回调 self.onRejectedCallbacks = []; // 保存一下当前这个promise的状态(promise有三个状态) self.status = "pending"; function resolve(value) &#123; if (self.status === "pending") &#123; self.value = value; self.status = "resolved"; self.onResolvedCallbacks.forEach(function(fn) &#123; fn(); &#125;); &#125; &#125; function reject(reason) &#123; if (self.status === "pending") &#123; self.reason = reason; self.status = "rejected"; self.onRejectedCallbacks.forEach(function(fn) &#123; fn(); &#125;); &#125; &#125; try &#123; executor(resolve, reject); &#125; catch (e) &#123; // 如果执行执行器时发生异常那就走到then失败的函数中 reject(e); &#125; // executor是立即执行的&#125;// 解析链式调用的 （他还要和其他的promise进行结合）function resolvePromise(x, promise2, resolve, reject) &#123; if (x === promise2) &#123; // 自己不能等待自己完成 return reject(new TypeError("循环引用")); &#125; // 如果x是一个函数 或者x是一个对象 就有可能x是一个promise if (x !== null &amp;&amp; (typeof x === "function" || typeof x === "object")) &#123; try &#123; let then = x.then; if (typeof then == "function") &#123; // 是promise then.call( x, function(y) &#123; resolve(y); &#125;, function(r) &#123; reject(r); &#125; ); &#125; else &#123; // &#123;then:123&#125; resolve(x); &#125; &#125; catch (e) &#123; // 如果x取then的时候可能会发生异常，如果有异常 reject(e); &#125; &#125; else &#123; // 普通值的情况直接成功即可 resolve(x); &#125;&#125;// then方法中需要传递两个参数 分别是成功的回调和失败的回调Promise.prototype.then = function(onFulfilled, onRejected) &#123; let self = this; // 调用then后返回一个promise let promise2 = new Promise(function(resolve, reject) &#123; if (self.status === "resolved") &#123; // 我们限制需要做的事情就是把then中成功或者失败后函数执行的结果获取到 // 看一看是不是promise 如果是promise 就让promise执行，取到最终这个promise的执行结果 ，让返回的promise 成功或者失败 // 如果x是普通值就让这个返回的promise 变成成功态 let x = onFulfilled(self.value); resolvePromise(x, promise2, resolve, reject); &#125; if (self.status === "rejected") &#123; let x = onRejected(self.reason); resolvePromise(x, promise2, resolve, reject); &#125; // executor中有异步操作，此时调用then时 处于等待态 if (self.status === "pending") &#123; self.onResolvedCallbacks.push(function() &#123; let x = onFulfilled(self.value); resolvePromise(x, promise2, resolve, reject); &#125;); self.onRejectedCallbacks.push(function() &#123; let x = onRejected(self.reason); resolvePromise(x, promise2, resolve, reject); &#125;); &#125; &#125;); return promise2;&#125;;module.exports = Promise; Promise 的状态一个 Promise 的当前状态&gt; 必须为以下三种状态中的一种：等待态（Pending）、执行态（Fulfilled）和拒绝态（Rejected）。 等待态（Pending） 处于等待态时，promise 需满足：可以迁移至执行态或拒绝态 执行态（Fulfilled） 处于执行态时，promise 需满足：不能迁移至其他任何状态，必须拥有一个不可变的终值 拒绝态（Rejected） 处于拒绝态时，promise 需满足：不能迁移至其他任何状态，必须拥有一个不可变的据因这里的不可变指的是恒等（即可用 &gt; === 判断相等），而不是意味着更深层次的不可变（ 指当 value 或 reason 不是&gt; 基本值时，只要求其引用地址相等，但属性值可被更改）。 把任意异步操作包装成 Promise Fetch async/await]]></content>
  </entry>
  <entry>
    <title><![CDATA[程序员都在 GitHub 上开源过哪些高颜值的 Markdown 客户端]]></title>
    <url>%2F2019%2F06%2F19%2Fyuque%2F%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E5%9C%A8%20GitHub%20%E4%B8%8A%E5%BC%80%E6%BA%90%E8%BF%87%E5%93%AA%E4%BA%9B%E9%AB%98%E9%A2%9C%E5%80%BC%E7%9A%84%20Markdown%20%E5%AE%A2%E6%88%B7%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[2004 年，来自美国宾夕凡尼亚州的作家 John Gruber 发明了 Markdown，让人们可以通过更加易读易写的纯文本格式来进行写作，并可以很方便的转为 HTML 或 XHTML 等文档。Markdown 自推出之后受到了许多程序员的追捧，目前基本所有主流技术社区都支持使用 Markdown 来进行创作。在 GitHub 上，也诞生了许多优秀的 Markdown 客户端，我看了二十多个项目，简单筛选过滤后，最终挑选了这 5 个高颜值、用户体验佳的 Markdown 编辑器分享给你。 Pine 优雅清新的编辑器适用平台：macOS这是一款基于 Swift 4.2 编写的 Markdown 编辑器，拥有主题定制、LaTeX 编写、自动补全、自动保存、版本控制、Touch Bar 支持等功能。lukakerr/Pine暗黑模式的主题看着特别酷炫： 通过其设置界面，你可以很方便的挑选自己喜欢的文本字体，界面主题： 目前还有以下几项特性仍在开发中，感兴趣的同学可以保持关注： 支持编辑 CSS 文件来定制 Markdown 预览效果 优化侧边栏 文件夹监听同步 上下文菜单中加入更多操作Gridea 无缝对接静态博客的编辑器适用平台：macOS、Windows这个是最近刚在微博上推荐的一个项目，作者将其产品定位为一个静态的博客写作客户端，也即是说，你可以在客户端上面写作，然后顺便将文章发布到静态博客上。getgridea/gridea 相对于其它普通的 Markdown 编辑器，它有着以下特色： 对接了 GitHub、Coding Pages 的托管服务 内置 Gitalk 和 DisqusJS 两个评论系统 支持使用 OneDrive、Dropbox 等工具进行文章同步 支持外链的封面图 从上面列举出来的几项特性可以看到，Gridea 相对于普通的 Markdown 编辑器更加强大，如果你希望写作编辑与文章同步能无缝进行，不妨试下这个编辑器。另外作者还表示，Linux 版本正在开发中，你可以保持持续关注。 Notable 无限标签编辑器适用平台：macOS、Windows、Linux这是一款基于 AGPL 协议开源的 Markdown 编辑器，由于其界面清新、代码开源而受到不少程序员喜爱。notable/notable 主要有着以下几项基础功能： 无限标签嵌套 可导入印象笔记 文章分类 模糊搜索 语法高亮 多文章编辑 多文章搜索替换 支持主流桌面平台 之前我曾写过一篇完整文章介绍了该项目，在此便不多做赘述，感兴趣的同学可看下下面这篇文章。分享一款高颜值的、代码完全开源的 Markdown 编辑器 Mark Text 多模式形态编辑器适用平台：macOS、Windows、Linux这是一款基于 MIT 协议开源的 Markdown 编辑器，支持 WYSIWYG（所见即所得）的编辑方式，致力于给你提供一个专注的写作环境。marktext/marktext 该编辑器还内置了插件功能，你可以为其添加 KaTeX 数学公式、emoji 表情等插件扩展。在你编写完成后，还可以很方便的将 Markdown 导出为 HTML 或 PDF 文件。支持的主题也非常丰富多样： 最值得一提的是，该编辑器提供了源码模式、打字机模式、专注模式等 3 种写作模式。源代码模式： 专注模式： 你可以根据自己需求来选择合适的写作模式。 MacDown 资深老牌编辑器支持平台：macOS作为一款老牌的 Markdown 编辑器，相信很多人都听过 MacDown，该编辑器的灵感来源于另一款 Markdown 编辑器 - Mou。这款编辑器相对来说年代较为久远，但也比较稳定，如果你对稳定性的追求比较高，可以体验下这块编辑器。MacDownApp/macdown 我用哪款编辑器？除了 GitHub 上一些开源的 Markdown 编辑器之外，还有一些免费但不开源的编辑器，个人常用的一款是 Typora。现在你正在查看的这篇文章，就是在 Typora 上完成排版编辑的。我比较喜欢它的原因是因为他可以自定义主题样式，编辑所见即所得，用完即走，方便快捷。对代码开源没啥要求的同学也可以体验下。a markdown editor, markdown reader. 你平时主要用哪款 Markdown 编辑器呢？欢迎在评论区留言与我们分享。 推荐阅读：华山论剑，谈谈 GitHub 上那几个开源的前端编辑器完美融合 Git 的笔记软件，了解一下？如何知道你的个人隐私是否被泄露？ 转自：https://zhuanlan.zhihu.com/p/62776921]]></content>
  </entry>
  <entry>
    <title><![CDATA[那些让人用上就戒不掉的Chrome扩展]]></title>
    <url>%2F2019%2F06%2F19%2Fyuque%2F%E9%82%A3%E4%BA%9B%E8%AE%A9%E4%BA%BA%E7%94%A8%E4%B8%8A%E5%B0%B1%E6%88%92%E4%B8%8D%E6%8E%89%E7%9A%84Chrome%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[Chrome虽然已成为国内常用浏览器之一，但像父母、长辈、女朋友等这类小白用户还是不少。所以，今天我们就来盘点一下Chrome商店里那些让人用上就戒不掉的扩展，大部分都是新手小白也能够一秒上手的工具。虽然是入门级扩展，但用户基数都高达数十万甚至百万，它们的功能极其丰富，能大幅提升上网体验，往往会让小白用户初尝便上瘾，从此再也离不开…… 1. 入门新标签页——Infinity ProInfinity新标签页算是早被业内夸过无数次的国产插件了，分为基础版和Pro版，两个版本的下载量都很高。这是一款百万用户选择的新标签页，能够自由添加网站图标，还有丰富的云端高清壁纸，支持快速访问书签、天气、笔记、待办事项、扩展管理与历史记录等（据了解开发者已申请专利）。Infinity的壁纸是真的非常好看了，右键空白处就能直接下载下来。并且，Infinity Pro版在今年又新增了文件夹功能，一个新标签页能容纳更多的常用网站，并由此实现了分类功能。开发者处理反馈的速度也很快，两个版本这么多年都保持完全免费，非常良心了，是新手和老用户都喜爱并推崇的Chrome工具之一。 2. 广告屏蔽——Adblock、Adblock Plus屏蔽广告的插件无疑是受用面最广的，因为它对于所有使用者来说，用户体验的提升是最大的。毕竟在此之前，大家都饱受各个网站的侧边广告和弹出窗口的困扰，开启广告屏蔽后清静多了。Adblock和Adblock Plus在Chrome商店里都没有太大争议，二者选一就足够了。 3. 视频广告屏蔽——广告终结者如今各个视频网站的广告都越来越丧心病狂，动辄90秒的长度简直让人生无可恋。广告终结者不仅能清除网页上浮动广告，恶意弹窗等，还能屏蔽视频广告。因为是国产的扩展，所以在国内大部分视频平台上都能使用。 4. 鼠标悬停预览图片——Imagus将鼠标悬停在链接或缩略图上，就能够直接在当前页面弹出高清大图、HTML5 视频/音频等内容。对于微博、淘宝等用户来说，在浏览多图和图片版的长微博时，Imagus是非常方便的。 5.图片批量下载——Image Downloader快速识别当前网页上的所有图片，支持一键批量下载，并且能够根据像素、尺寸等筛选图片范围。 6.视频下载插件——Video Downloader professional视频下载是很多人的需求，而在大部分视频网站上，要做到这一点都必须经历一个繁琐的过程，比如下载客户端等等。Video Downloader professional则可以直接检测页面中的所有视频文件，并提供一键下载，对新手来说也非常友好。 7.浏览器清理大师——Clean Master一键清理浏览器缓存和垃圾、保护隐私，使浏览器更快更高效，支持按时间段清理：- 清理浏览器缓存，cookies，网站存储和其他垃圾。- 清理密码，使网站不会自动登录用户的个人帐户。- 清理浏览器历史记录，其他人永远不会知道用户的浏览过的网站。- 清理所有个人信息，用户的隐私将受到保护。 无法访问chrome应用商店的朋友，可在扩展迷网站下载安装。Download Chrome Extensions From Here!extfans.com 转自：https://zhuanlan.zhihu.com/p/47642312]]></content>
  </entry>
  <entry>
    <title><![CDATA[这 10 款堪称神器的插件，让你的 Chrome 成为最好用的浏览器]]></title>
    <url>%2F2019%2F06%2F19%2Fyuque%2F%E8%BF%99%2010%20%E6%AC%BE%E5%A0%AA%E7%A7%B0%E7%A5%9E%E5%99%A8%E7%9A%84%E6%8F%92%E4%BB%B6%EF%BC%8C%E8%AE%A9%E4%BD%A0%E7%9A%84%20Chrome%20%E6%88%90%E4%B8%BA%E6%9C%80%E5%A5%BD%E7%94%A8%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%2F</url>
    <content type="text"><![CDATA[距离我 上次 推荐 Chrome 扩展已经过去了近 4 个月时间，Chrome 应用商店里又涌现出了一大批颇有潜力的实力选手。本文我将介绍 10 款近期上架的 Chrome 新扩展，从标签页到网站内容抓取再到隐私保护，它们总有一款能满足你的口味。 QlearlyQlearly 是一款有些特殊的 Chrome 新标签页扩展，你可以用它一键保存当前打开的标签页，将自己的收藏夹、喜欢的网站、暂存备用的标签页等分组收纳，并在需要时快速开启。此外，你还可以与他人协作，并分享自己的标签页组，提高自己的工作效率。你可以在 Chrome 网上应用店 免费获取 Qlearly。 Spider工作中，你可能会有批量抓取网站内容的需求：淘宝上的商品介绍、网站上的新闻标题、表格中的行列数据……如果只是单纯的复制粘贴，之后还要费心整理，想要写个爬虫又考验编程水平。这时，不妨试试 Spider，它可以一键抓取网页上的结构化数据，并导出为 JSON 和 CSV 文件，轻松高效。你可以在 Chrome 网上应用店 免费获取 Spider。 Repl.itRepl.it 是一款允许你浏览器上编程的云端 IDE，支持编译并运行包括 C、Python、JavaScript、Ruby 等在内的超过 50 种语言，无需下载，即开即用。而其第三方 Chrome 扩展，则给任意网页中的代码片段增加了一键运行按钮，省去复制到本地编译的流程。你可以在 Chrome 网上应用店 免费获取 Repl.it。 Password Checkup不论你是自己发明了一套密码策略，还是用 1Password 等应用随机生成密码，都无法避免网站后台被拖库造成的安全隐患。为了最大限度地减少这一风险，Google 于近期推出了 Password Checkup 扩展，当检测到你正在使用的用户名和密码存在于 40 亿条泄露数据库内时，自动弹出提醒，保护个人隐私。你可以在 Chrome 网上应用店 免费获取 Password Checkup。 Web Activities时间线是 Windows 10 春季创意者更新带来的最重要变化之一，允许你在一处查看所有历史活动记录，如浏览器访问过的网页、使用过的文件等。而微软近期推出的 Web Activities 扩展将这一特性带到了 Chrome，并支持多设备同步浏览记录，体验近似原生。你可以在 Chrome 网上应用店 免费获取 Web Activities。 划词小窗搜索划词翻译扩展我们见得多了，例如我此前推荐过的 沙拉查词 和 达达划词翻译 都可以在选中单词后通过悬浮小窗查询释义。而划词小窗搜索的泛用性更广一些，可以调用 Google、百度或 Bing 通过小窗搜索选中的文本，无需离开当前页面。你可以在 Chrome 网上应用店 和 GitHub 免费获取划词小窗搜索。 Simplify Gmail为了完成 KPI，Google 大刀部把广受欢迎的 Inbox 砍掉了，如果你曾是 Inbox 忠实用户，可能会对陈旧的 Gmail 界面感到不适应。为了拯救你的收件箱，前 Inbox 设计师 Michael Leggett 开发了 Simplify Gmail 扩展，重新设计了按钮和元素的摆放位置，隐藏了侧边栏，让界面更加清爽干净。你可以在 Chrome 网上应用店 免费获取 Simplify Gmail。 Google Results Previewer使用 Google 搜索时，你可能需要同时浏览对比多个结果。这时，按首页排序一路点下去就未免过于低效。而 Google Results Previewer 就可以在当前页面小窗加载鼠标悬停的链接，并支持进一步交互，提高信息检索效率。需要注意的是，由于 Google Results Previewer 无法运行 JavaScript，部分网站可能会出现加载异常或失败等情况，仍待改进。你可以在 Chrome 网上应用店 免费获取 Google Results Previewer。 NoScriptNoScript 是 Firefox 上知名的隐私保护扩展，近期移植到了 Chrome 上，作用是禁止加载 JavaScript、Flash、Silverlight 等可能收集你个人信息的脚本，让你的浏览更加安全。不过，由于 JavaScript 已然成为了网页标配，禁用后会导致大多数网站无法正常访问，需要一段时间的白名单调教后才能正常使用。你可以在 Chrome 网上应用店 免费获取 NoScript。 简易扩展简易扩展的名字相当实诚，但功能性却毫不逊色。它可以帮助你快速切换用户代理、管理多个 Cookies、监听网络请求、改写静态和动态网址等，可谓前端开发者必备。你可以在 Chrome 网上应用店 免费获取简易扩展。关联阅读：读文章、剪藏网页、新标签页增强…… 这 10 个扩展让你的 Chrome 更好用 转自：https://zhuanlan.zhihu.com/p/65606735]]></content>
  </entry>
  <entry>
    <title><![CDATA[推荐几个超好用的Chrome插件]]></title>
    <url>%2F2019%2F06%2F19%2Fyuque%2F%E6%8E%A8%E8%8D%90%E5%87%A0%E4%B8%AA%E8%B6%85%E5%A5%BD%E7%94%A8%E7%9A%84Chrome%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[远方 New Tab每天打开新页面都是一段不期而遇的旅行简单的说，每次打开一个新的标签页，都会有一张看了心情很好的风景图~ uBlock Origin比较好用的清除广告的插件，图标也很可爱记得要下origin版本哦另外一个同名的是商业公司版本，害怕会加什么蜜汁优化来看一下效果，对付广告贼多的csdn The Great Suspender自动休眠你不用的标签页，节省内存再也不用怕浏览器后台偷偷挖矿了 ~ 其实是因为实习生配的mac只有4g内存，才发现了这个插件。不过chrome每个标签页一个进程，的确很很吃内存 有道网页翻译可以根据英语水平来动态调节翻译的程度哦比如可以这样： 下面推荐点开发中常用的插件 json-viewer自动格式化显示服务器返回的json串比如豆瓣电影Top250返回的是这样的：格式化之后是这样的！ Set Character Encoding快速设置网页的编码写爬虫的时候猜不透编码？自己试一下吧，所见即所得 octotreeGitHub看代码利器！可以直接看到代码的目录结构 Vimium像vim一样操控chrome什么？你想不用鼠标浏览网页？ 满足你j k 上下滑动f 定位网页链接vim 党会感动死的吧 就先推荐这么多大家有什么好用的插件也别藏着掖着分享出出来呀~]]></content>
  </entry>
  <entry>
    <title><![CDATA[11款插件让你的Chrome成为全世界最好用的浏览器！｜ Chrome插件推荐～]]></title>
    <url>%2F2019%2F06%2F19%2Fyuque%2F11%E6%AC%BE%E6%8F%92%E4%BB%B6%E8%AE%A9%E4%BD%A0%E7%9A%84Chrome%E6%88%90%E4%B8%BA%E5%85%A8%E4%B8%96%E7%95%8C%E6%9C%80%E5%A5%BD%E7%94%A8%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%81%EF%BD%9C%20Chrome%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90%EF%BD%9E%2F</url>
    <content type="text"><![CDATA[Chrome可以说是全世界最受欢迎的浏览器了，其快速、稳定的性能，简洁的设计以及多平台同步的功能都深受用户的推崇，然而很多人成为他的忠粉还是因为它强大的拓展性！在发现了这些功能实用又不太占地的小插件之后，简直要感叹：“原来这才是Chrome的正确打开方式啊！”用对了插件，工作效率真的是蹭蹭蹭往上飙啊！下面就为大家推荐这段时间我发现的比较优质的Chrome小插件，目前一共有11款，都可以在［Chrome网上应用店］下载，当然辣，只有科学上网才能访问哦～ 照顾以前没有使用过Chrome浏览器的朋友，先说一下［Chrome网上应用店］简单来说［Chrome网上应用店］可以让你通过使用应用、扩展程序和主题背景来自定义你的Chrome，打开Chrome点击“应用”即可进入：&gt; 在搜索框中输入关键字即可找到所需的应用或者拓展程序，也可以浏览经过分类和整理的合集发现新的内容：&gt; 此外，&gt; Chrome还支持多设备同步。登录到 Chrome 后，您可以从多台计算机访问自己的应用，而无需再在自己的所有计算机上记住软件密钥或重新安装软件。Chrome上有很多优质的应用，我也还在探索中，这一次先为大家推荐小插件，点赞多的话马上来更新应用篇哦～ 1、Infinity ／ Momentum ／ Google Art Project——定义你的新标签页自定义的第一步当然是选择自定义你的新标签页，这三款插件都是用来重新定义你的新标签页的。之所以推荐三款，是因为我觉得三款真的都很棒啊，我自己使用的是第一款“Infinity ”，比较符合我的使用习惯，将三款都介绍给大家，大家可以按自己的喜好来选择：没有使用插件之前，我们打开新的标签页（BTW，打开新标签页的快捷键是command＋T），显示的界面是这样的：这个界面是比较简洁，但是对于我们快速进入工作界面或某个网页其实不是很方便，这时候我们就需要小插件啦～ 1.1 Infinity在Chrome网上应用店中搜索Infinity ，然后将它添加到Chrome：成功添加之后，当你再打开新标签页，它就变成了这样，背景壁纸可以随意更换，点击右下角的小风车就可以了，你也可以上传自己喜欢的图片：还可以点击右上角的红色＋号按钮，添加更多你需要的网址到界面：喜欢 Infinity 是因为它比较接近我的使用习惯，点击图标就可以进入目标网页，还可以方便地查看历史记录、添加待办事项、获得天气情况等等。你还可以在添加更多常用网页到界面，Infinity 将一些比较主流的网站都收录在分类里面，方便你添加。此外，** Infinity 还有一个非常方便的功能，就是管理你的Chrome上的应用和插件！是的，用插件管理插件，因为Chrome上的插件五花八门，经常不注意就下了一大推，当然我们可以通过Chrome来管理，但比较不方便，使用 Infinity 的话，我们只需要点击界面上的“应用”图标，就可以轻松管理啦。Chrome上也有专门用来管理应用和插件的插件，但我觉得既然 Infinity 就能够实现的话，就不要再下其它的啦，过多的插件还是会影响浏览器的速度的。** 1.2 Momentum相比 Infinity ，Momentum的设计更加简洁，个人觉得背景图比 Infinity 的更好看一些，四个角分别有不同的功能，但缺点是不能直接进入目标页面，放张图大家自行感受一下： 1.3 Google Art Project除了以上两款比较常见的新标签页插件，还要向喜欢艺术的朋友推荐 Google Art Project，这是Google的一个文化艺术项目，希望探索世界各地的精彩故事和馆藏，将经典和精品展示给更多的人，附上这个计划的网址，没事上去看看艺术品也很赏心悦目：https://www.google.com/culturalinstitute/beta/同样还是在Chrome应用商店搜索 “Google Art Project” 然后添加，之后你的新标签页就会变成这样啦：背景每天都会更新，这样你就可以在浏览器标签页中欣赏 Google Cultural Institute 中的艺术计划精彩作品啦，点击还可以查看更多关于画作的信息。而右下角的按钮可以让你留言一些常用网址。 2、下载管理器——管理你的下载我们从网站上下载文件时，一般来说比较倾向于可以方便地看到下载进度和结果，Safari这一点上就比较好：不过在Chrome中，我们也可以通过安装插件来实现。搜索添加“下载管理器”，在插件栏就可以看到啦：3、Adblock Plus——无用广告拦截这款插件基本上是必备啦，评价比较高，用户非常多，我个人使用体验也还是很好的，安装之后基本上屏蔽了大部分垃圾广告，节约了时间也帮助你在浏览网页时集中注意力在目标内容上。 4、OneTab——管理你打开的网页我们平时在查阅资料或者工作的时候，常常不自觉就打开了一堆网站，当你想快速地点击到你的目标网站时，会发现十分不便，而且会把眼睛搞得很累，就像下图：OneTab 就是为解决这个问题诞生的，搜索添加它之后，点击插件栏中的 OneTab 图标，这些打开的网页就被全部集合到一起啦：OneTab 还有历史纪录，方便你浏览过去时间打开的网页，因此使用它除了管理你打开的网页之外，也比较不担心会丢失有用的网页。 5、右键搜——拓展你的右键非常喜欢的一款插件，添加之后，当我们点击右键就可以看到它啦。用它选中网页上的图片，就可以用 Google 或者 百度搜索这张图片，知道图片的更多信息以及跟它相近的其它图片。而当我们选中网页上的文字的时候，我们可以方便地利用 “右键搜”翻译文字，并且可以将生成二维码！从此用二维码来表个白简直是小意思了～ 6、Awesome screenshot——注释&amp;录屏主要功能有两个，一是录屏&gt; 二是捕获整个页面或任何部分，然后对捕获的图片进行注释，可以添加矩形，圆形，箭头，线条和文字，模糊敏感信息等。 作为一款小插件来说，我觉得它已经挺厉害了，有很多朋友说，Mac自带的录屏软件还有快捷键截图也已经很方便了，但我个人觉得插件的操作路径更短些，效率不就是这么一点点提高的吗？ 7、Imagus——悬停放大图片鼠标指针悬停在链接或缩略图上时直接在当前页面的弹出视图上显示这些图片、HTML5 视频/音频和内容专辑。喜欢淘宝、微博还有各类图片网站的朋友，这个插件绝对会极大提高你们的效率，将光标停放在图片上，图片就会自动放大啦～ 8、Video Downloader professional——自动识别下载资源我们在浏览网页的时候有时候需要把网页上的视频下载下来，而这常常需要借助第三放的下载软件，过程有时候十分复杂而且在电脑上装有些软件也很烦， Video Downloader professional的功能就是帮我们省去这一过程，它会自动检测网页中的所有的视频文件，提供一键下载，简直不要太方便！ 9、新媒体管家——帐号管理&amp;图文编辑顾名思义，新媒体管家的主要功能是管理你的新媒体帐号，目前支持以下平台：使用新媒体管家，可以让你同时管理几个平台的帐号，或一个平台上的多个帐号。添加帐号之后，就可以通过新媒体管家进入相应的帐号了。比如，对于微信公众平台来说，你可以添加多个帐号，并且同时登陆，一天之内只需要扫码登陆一次，便可以直接进入后台。除此之外，对于有写微信推文需要的人，新媒体管家的作用还体现在它可以帮助你完成推文的排版和编辑！以往我们在写推文的时候，可能需要借助135编辑器或者秀米，个人觉得135的板式比较多，秀米的排版比较好，所以有时候需要同时用两个平台才可以完成编辑，而中间可能会出现两个平台格式不通用的情况，非常麻烦。有了新媒体管家之后，通过它打开微信后台，选择新建素材，你会发现编辑页面变成了这样：也就是说，你可以直接在后台选择板式、调整边距、添加emoji；新增的小功能里面，还可以让你去别的地方采集样式，然后运用到你的推文里面；搜图功能帮你省去漫天找图、下载、上传的繁琐步骤。然而我最喜欢它的功能还是“热点中心”，通过它你可以快速地获取当天的热点！目前新媒体管家为用户呈现三个平台（微信热文、头条指数、知乎精选）的热门消息，包括了当日热词。你还可以通过它搜索公众号和文章，获取时间、阅读和点赞数等信息。此外，它还有一些非常实用的功能、比如营销日历，通过它你可以提前做好营销计划的选题和排期等等 10、印象笔记——网页标注和收藏必须推荐的一个插件，以前在Safari中就一直使用的一款小插件，可以快速保存、标注和分享网页上的一切内容，包括网页正文、图片、截屏和整个网页。相信很多人已经在用了，我个人的使用体验还是非常好的，有起是它在保存网页的时候，格式保留得很完整。 11、Google翻译Google翻译做得已经非常不错了，平时翻译文献的时候用Google 翻译基本上可以有7成的正确率，自己再稍作修改就行。Google 翻译的小插件主要是方便我们在浏览网页的时候，随手翻译不认识的字词句。使用的时候只需要选中需要翻译的部分，然后点击插件栏“Google翻译”的小图标就行。 先写到这，觉得有用的话点个赞哦～也欢迎大家留言来推荐你觉得好用的Chrome插件，有新的发现我也会及时更新到文章里面！ 更多精彩也欢迎大家关注微信公众平台 ［麦客范儿］！！！日常为你推荐：Mac／iPhone使用技巧、Mac／iPhone优质软件限免消息、趣味科技短视频～ 转自：https://zhuanlan.zhihu.com/p/27196557]]></content>
  </entry>
  <entry>
    <title><![CDATA[学算法，刷 LeetCode，GitHub 上这几个项目助你一臂之力]]></title>
    <url>%2F2019%2F06%2F19%2Fyuque%2F%E5%AD%A6%E7%AE%97%E6%B3%95%EF%BC%8C%E5%88%B7%20LeetCode%EF%BC%8CGitHub%20%E4%B8%8A%E8%BF%99%E5%87%A0%E4%B8%AA%E9%A1%B9%E7%9B%AE%E5%8A%A9%E4%BD%A0%E4%B8%80%E8%87%82%E4%B9%8B%E5%8A%9B%2F</url>
    <content type="text"><![CDATA[LeetCode 是一个汇集了诸多算法题库的编程网站，许多开发者在初学算法时，都会跑到 LeetCode 网站上面刷题，也有一些开发者为了过微软、Google、Facebook 等国际大企的面试，选择刷 LeetCode 来快速提升自己的编程能力与算法能力，以便顺利通过面试。于是，刷 LeetCode 的做法开始在技术圈传播开来，程序员彼此见面聊天时也会时不时问候几句，”你今天刷 LeetCode 了吗？”。在 GitHub 上，各种语言、不同版本的 LeetCode 题解项目也慢慢多了起来。。。今天，就让我们来简单盘点一下，GitHub 上那几个比较知名的 LeetCode 项目吧。希望对那些打算学习算法，或正在刷 LeetCode 的同学有所帮助。 C++ 题解库该仓库作为 LeetCode 题解库的鼻祖，由左耳朵耗子，也即是同学们常说的耗子叔于 2014 年创建，算是 GitHub 上创建最早的 LeetCode 题解库，同时也是现在 Star 数最高的一个。该项目主要实现了 C++ 的 LeetCode 题解，非常适合广大程序员查看。http://t.cn/R75PA91 Python &amp; Java项目作者 QiYuan Gong 是东南大学的博士生，现为英特尔公司的深度学习工程师，由于受到耗子叔 C++ 题解库的启发，在 GitHub 上创建了这个以 Python 与 Java 为主的题解库。现在身边不少搞算法的朋友，都以 Python 作为首选的编程语言，相信这个库你们一定会喜欢。http://t.cn/EabmDAN Swift 题解库项目作者故胤道长毕业于卡内基梅隆大学，先后就职于 Uber、Amazon 等公司，现在 Quora 担任 iOS 工程师，同时也是 GitHub 全美前 20 名的 Swift 开源作者之一。道长在 2016 年的时候创建了该库，并于微博进行推广后开始广为人知，后续不少开发者加入了项目维护，使得更新也较为频繁。该仓库按照数据结构与公司对 LeetCode 进行了分类，使其目录结构看起来更加清晰。目前收纳的有 Google、Facebook、Snapchat 等多家公司的 LeetCode 题解。http://t.cn/Rg87FJa Go 语言题解库最近国内某个知名企业的代码泄露，为 Go 语言的推广做出了不可磨灭的贡献，因此在这里，也为大家献上一个基于 Go 语言实现的题解库，希望你在阅读某个项目源码的时候，也别忘了多学点算法。http://t.cn/Exg9mPF LeetCode for VS Code 插件我们之前写过一篇文章《装上这几个 VSCode 插件后，上班划水摸鱼不是梦》，里面就推荐过这个 LeetCode 插件。该插件由微软的一名工程师开发，并于今年春节前正式上线，装上之后，就可以在 VSCode 上愉快的刷 LeetCode，在听音乐、看小说等沙雕插件横行的时代，该插件可谓是一股清流，建议当前有在刷 VSCode 的同学装一下。http://t.cn/Rk8r2ao GitHub 上其实还有其它一些 LeetCode 题解库，但由于项目作者许久未更新，给人感觉像是弃坑逃离，所以就不将其纳入到该统计列表中啦。有兴趣的同学可以自己到 GitHub 上翻一下。知乎用户胖君说过，现在刷 LeetCode 的，主要分两个流派，一个是「龟派」，一个是「兔派」。龟派在于把每个题目做得干干净净，滴水不漏，力求把所有解法都试一遍。兔派则是非常暴力的直接硬刷，追求以快制胜，直接上来就看答案，套模板，以解题、找工作作为首要目标，不带一丁点矜持。 你是属于哪一派的呢？欢迎在评论区与我们留言分享 推荐阅读：GitHub 上有哪些项目能帮你更好的学习编程？GitHub 上的这几个项目或许能帮你学好英语 转自：https://zhuanlan.zhihu.com/p/63916811]]></content>
  </entry>
  <entry>
    <title><![CDATA[给大家推荐几个浏览器插件(不用外网也能使用google了)]]></title>
    <url>%2F2019%2F06%2F19%2Fyuque%2F%E7%BB%99%E5%A4%A7%E5%AE%B6%E6%8E%A8%E8%8D%90%E5%87%A0%E4%B8%AA%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6(%E4%B8%8D%E7%94%A8%E5%A4%96%E7%BD%91%E4%B9%9F%E8%83%BD%E4%BD%BF%E7%94%A8google%E4%BA%86)%2F</url>
    <content type="text"><![CDATA[虽然一直知道谷歌浏览器有很多插件，但并不知道还有一些这么好的插件，不知道是不是我太落后了，今天我就给大家介绍几款自己常用的插件。 如果你不知道谷歌浏览器的插件在哪里的话，只需要在谷歌浏览器右上角菜单下选择【更多工具】-【扩展程序】， 然后点击【拓展程序】就可以看到Chrome网上应用商店了 在那里就可以下载各种插件了。（不过没有外网的话是进不来这个应用商店的）。 1.谷歌浏览器必备神器：谷歌访问助手这估计是我最喜欢的一个插件吧，有了这个插件就算没有外网也可以使用谷歌搜索，登录谷歌帐号，使用谷歌翻译，进去谷歌商店等了。 本来那些插件我们都是可以在谷歌插件商店下载的，但此时你不能上外网的话，无法在谷歌商店下载这个插件，我给大家找了一个按照这个插件的教程。谷歌访问助手安装教程：https://jingyan.baidu.com/article/d2b1d102a89a925c7f37d445.html（或者在我的公众号“苦逼的码农”后台直接回复”助手”获取对应的压缩包，里面包含安装方法）按照里面的教程就可以安装谷歌访问助手了，之后的插件就可以直接在谷歌商店那里下载了。不过需要注意的是，谷歌访问助手安装之后，并不可以访问推特等网站平台。 2.去广告插件：广告终结者广告终结者，各种花式广告瞬间完虐，这个神器可以清除几乎所有的网络广告，各种网络站上的广告轻松屏蔽，什么购物广告、浮动广告、视频广告、恶意弹窗、网络跟踪统统眼不见心为净。不过我使用的比较少，不过感觉装了后那些恶心的广告确实少了挺多，我想很多人都讨厌广告，因此介绍给大家。 3.OneTab：将无数Tab合并在一个页面这个插件是用来管理网页的，有时我们会在浏览器中打开了多个页面，会导致电脑变的很卡，这个插件可以帮你暂时把网页挂起，节省95%的内存，想要打开被合并的网页时可以随时恢复。使用之后： 4.必备翻译：Imtranslator网页翻译必备神器，有时阅读英文文档时，经常遇到不认识的单词，选中需要翻译的单词，这个插件可以很方便着帮你翻译出来，而且翻译之后会把对应的中文放在旁边，不怕等下又把单词忘记了，也可以翻译整个网页，不过需要注意的是，翻译是需要电脑可以上外网的，不过假如你按照我上面说的安装了谷歌访问助手，那就可以很方便着翻译了。 5.截图必备神器：FireShot有时想要对网页进行截图时，我是经常用微信带的截图功能的，这种很不方便，经常需要登录微信，而且如果想要截整个网页时也很不方便，这个插件可以帮我们很方便着进行截图，而且还可以存储为PDF等其他格式。 6.公众号必备编辑器：壹伴这个是编辑类插件，主要是针对微信公众号编辑页面的，可以一键排版，我最喜欢这个插件的主要原因是这个插件可以帮我很方便着找到各种封面图，不用自己调尺寸比例等。而且这个插件的一键排版也是挺方便的。 7.必须掌握的编辑语法：Markdown herMarkdown现在是越来越就行了，现在很多网站平台都提供支持Markdown语法来编辑各种文本，强烈建议大家学下用Markdown语法来写文章，不过就算该网站没有提供Markdown编辑器，我们也可以直接用插件Markdown here把我们所写的文本直接Markdown渲染一下，而且我们可以自定义配置自己喜欢的css样式，不想自定义的可以网上搜，一搜一大把，自己复制过来使用。 上面这些插件就是我平时用的插件，感觉还不错，介绍给大家。日后有遇到更好的插件，再来继续介绍…哈哈….]]></content>
  </entry>
  <entry>
    <title><![CDATA[GitHub 上见过哪些奇葩的 Chrome 插件]]></title>
    <url>%2F2019%2F06%2F19%2Fyuque%2FGitHub%20%E4%B8%8A%E8%A7%81%E8%BF%87%E5%93%AA%E4%BA%9B%E5%A5%87%E8%91%A9%E7%9A%84%20Chrome%20%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Google Chrome 作为程序员最常用的一款网页浏览器，凭借其强大的插件系统而广受赞赏，程序员作为上面一批最会折腾的用户，自然也不免俗的会在上面胡乱折腾出一些沙雕插件。而这其中，有不少插件代码还开源并托管到 GitHub 上。今天抽空跟大家分享下，我曾看过的那些比较沙雕的 Chrome 插件。 Flappy Octocat2013 年，一位来自越南的独立游戏开发者发布了一款鸟类飞行游戏，Flappy Bird。之后，在短短数月内，该游戏瞬间火爆各大社交网络，成为 2014 年最受欢迎的手游之一，当时我身边不少朋友的手机上都安装了这款游戏。一款爆品的诞生，往往也伴随着一些赝品的争相模仿。Flappy Octocat，这款以 GitHub 吉祥物章鱼猫为主角所打造的小游戏便是其中之一。 该游戏由电子科技大学的一名学生所研发，通过在 Chrome 上安装这款游戏，你便可以在 GitHub 上的 commit 强愉快的玩耍章鱼猫小游戏。可以说是非常有创意了。https://github.com/chxj1992/flappy-octocat 微信秒变云笔记在上班的时候，如果不好意思打开微信，跟网友吹水聊天怎么办？没关系，装上这款插件，就可以把你电脑上的网页微信伪装成云笔记，让你神不知鬼不觉地上微信了。 伪装到这地步，可以说真的很丧心病狂了。https://github.com/YGYOOO/WeChat-Shelter 一键将 Google 转为百度如果你会用 Google 进行科学上网，而其他人不会，那相信这个声音应该时常会在你耳边响起：“咦？你是怎么能上 Google 的？”时间久了，问得多了，答得烦了，难免耳朵长茧，嘴角生泡。这时，你只需要在你电脑上装上这款插件，扮成不懂科学上网的小白用户，便可以一劳永逸，远离尘世喧嚣了。 希望这款插件能救你于水深火热之中。https://greasyfork.org/zh-CN/scripts/372883 以上，即是本次分享。不多，但有趣。今后分享也是如此，内容贵精不贵多。觉得好玩、有意思的，不妨点个赞，支持一下。推荐阅读：GitHub 项目推荐：俄罗斯小游戏、Markdown 幻灯片、头像生成器、Logo 制作工具、坦克大战]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何以光速查看一行代码的提交记录]]></title>
    <url>%2F2019%2F06%2F18%2Fyuque%2F%E5%A6%82%E4%BD%95%E4%BB%A5%E5%85%89%E9%80%9F%E6%9F%A5%E7%9C%8B%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E7%9A%84%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[❓这行代码谁写的 ？在多人协作的项目中进行开发，总是会遇到这些问题：- 这行代码谁写的？明显是个坑，上线肯定是个故障。- 这行代码谁写的？相当优雅，得学习下。- 这行代码谁写的？看不懂，得咨询下。- 这行代码谁写的？不是我呀，得查一下。好，问题来了，这行代码谁写的？ 怎么查是谁写的？ 💢命令行工具 git blame例如，查询 request.js 第 99 行代码是谁提交的，命令为： 12$ git blame -L 99,99 request.js-&gt; dadd208596 lib/core/app/extend/request.js (fengmk2 2016-07-17 12:48:09 +0800 99) * @member &#123;String&#125; Request#ip 即使把这个命令设置为快捷方式，一行一行的查询也是非常耗费精力的，那么有没有一眼可以看到的方式呢？那就是直接在 GitHub 上查。 😑使用 GitHub 查询直接打开 GitHub 查询 request.js 提交记录，就可以看到了。然而，代码敲的好好的，能不能不切换窗口呢？那就是使用各大 IDE 的插件实现了。 🔥使用 VS Code 查询VS Code 在我的电脑上存在有两个原因：- 写 TypeScript- 使用 Git Blame 插件主要说一下 Git Blame 插件，迄今为止用过的最方便的查询代码提交记录的工具，来张截图感受下：光标在哪行，状态栏就显示该行代码的提交者。如果你使用 VS Code 用户，恭喜你，已经完美解决了本篇文章的问题。如果你喜欢轻量级编辑器，喜欢秒开，喜欢像特斯拉 P100D 一样百公里加速 2.5 秒的感觉，那就接着往下看吧。 🌟使用 Sublime Text 查询好好好，你要的，都给你。安装 Git Blame 插件后，需要在光标所在行启动命令框，输入：”Git Blame”，效果如下：重点到了，身为 VIM 用户，我们的插件呢？ 🚀在 VIM 中使用 git-blame.vim 快速查询我是一只小小鸟，想要飞呀却飞也飞不高我遨游在 GitHub 中，寻找着 VIM 适合的查询插件，tpope/vim-fugitive 太重，没有个轻量的插件么？git-blame.vim 横空出世！先看效果：怎么做到的？只需要同时按 ,s 即可。当然也支持自定义快捷键了。对实现感兴趣，请戳 git-blame.vim 代码仓库 🔧安装最直接的方式： 12cd ~/.vim/bundlegit clone git@github.com:zivyangll/git-blame.vim.git 如果你跟你一样用的是 Vundle： 1Plugin &apos;zivyangll/git-blame.vim&apos; 👏使用在 .vimrc 中设置快捷键“逗号+s“： 1nnoremap &lt;Leader&gt;s :&lt;C-u&gt;call gitblame#echo()&lt;CR&gt; 若未设置 Leader，建议设置为逗号： 12let mapleader = &quot;,&quot; &quot; map leader键设置let g:mapleader = &quot;,&quot; 如果你是 VIM 新手，一键上手没有用过 VIM 没关系，可以参考我的 vim 配置：zivim，一键安装： 1$ curl -k https://raw.githubusercontent.com/zivyll/zivim/master/install.sh 配置文件及其适合新手阅读和学习，截两张图 🔚结束语如果你觉得这个插件对你有帮助，不要吝啬你的 star：zivyangll/git-blame.vim，哈哈😄，也可以在 vim.org 投出你宝贵的一票。使用中有任何问题请提 issue。 转自：https://zhuanlan.zhihu.com/p/37599990]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端规范文档]]></title>
    <url>%2F2019%2F06%2F17%2Fyuque%2F%E5%89%8D%E7%AB%AF%E8%A7%84%E8%8C%83%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[百度：ecomfe/spec · GitHub 腾讯AlloyTeam：Code Guide by @AlloyTeam GitHub：Styleguide · GitHub Airbnb JavaScript 风格指南 项目规范 滴滴出行前端（FE）团队联盟文章集 项目目录结构规范 要求在本文档中，使用的关键字会以中文+括号包含的关键字英文表示：必须(MUST)。关键字”MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL”被定义在 rfc2119 中。 规范说明约定以下规范文档中： 项目包含但不限于业务项目和包项目。 ${root}表示项目的根目录。 资源分类资源分成两大类： 源代码资源：指开发者编写的源代码，包括js、html、css、template等。 内容资源：指希望做为内容提供给访问者的资源，包括图片、字体、flash、pdf等。 目录命名原则 简洁。有习惯性缩写的单词 必须(MUST) 采用容易理解的缩写。如：源代码目录使用src，不使用source。下面是更多例子： img: 图片。 不允许(MUST NOT) 使用image、images、imgs等。 js: javascript 脚本。 不允许(MUST NOT) 使用script、scripts等。 css: 样式表。 不允许(MUST NOT) 使用style、styles等。 swf: flash。 不允许(MUST NOT) 使用flash等。 src: 源文件目录。 不允许(MUST NOT) 使用source等。 dep: 引入的第三方依赖包目录。 不允许(MUST NOT) 使用lib、library、dependency等。 不允许(MUST NOT) 使用复数形式。如：imgs、docs是不被允许的。 目录划分 ${root}目录结构划分在${root}下，目录结构 必须(MUST) 按照职能进行划分， 不允许(MUST NOT) 将资源类型或业务逻辑划分的目录直接置于${root}下。常用的目录有src、doc、dep、test等。详细请参考一级目录详细说明${root}/src/test/doc/dep/… 业务项目目录结构划分业务项目的${root}目录结构划分遵循${root}目录结构划分。 项目代号业务项目 可以(SHOULD) 为项目起一个代号名称。代号名称 必须(MUST) 为一个单词，不宜过长。例：北斗的项目代号为triones，哥伦布的项目代号为clb，百度锦囊的项目代号为jn。项目代号有利于区分不同项目，为未来项目之间的重用留下扩展的后路。在项目开发时，通常会使用如下加载器配置，将项目代号指向src。 123456&#123; baseUrl: '$&#123;docroot&#125;', paths: &#123; 'triones': 'src' &#125;&#125; 根据业务逻辑划分 src 目录结构业务项目的src目录内，绝大多数情况 应当(SHOULD) 根据业务逻辑划分目录结构。划分出的子目录（比如例子中的biz1）我们称为业务目录。src下 必须(MUST) 只包含业务目录与common目录。业务公共资源 必须(MUST) 命名为common。common目录做为业务公共资源的目录，也视如业务目录。${root}/src/common/biz1/subbiz1/subbiz2/biz2/较小规模的业务项目（如投放端），src目录允许视如业务目录，直接按照业务目录划分原则划分目录结构。${root}/src/foo.js 业务目录划分原则 JS资源 不允许(MUST NOT) 按资源类型划分目录， 必须(MUST) 按业务逻辑划分目录。JS资源应直接置于业务目录下。即：业务目录下不允许出现js目录。 除JS资源外的源文件资源，当资源数量较多时，为方便管理， 允许(SHOULD) 按资源类型划分目录。即：业务目录下允许出现css、tpl目录。 内容资源 允许(SHOULD) 按资源类型划分目录。即：业务目录下允许出现img、swf、font目录。 业务目录中，如果文件太多不好管理，需要划分子目录时，也 必须(MUST) 继续遵守根据业务逻辑划分的原则，划分子业务。如：下面例子中的subbiz1。通常，对于一个业务目录， 鼓励(SHOULD) 将业务相关的源文件资源都直接置于业务目录下。biz1/img/add_button.pngadd.jsadd.tpl.htmladd.css业务目录下源文件资源数量较多时，我们第一直觉应该是：是否业务划分不够细？是否应该划分子业务，建立子业务目录？biz2/subbiz1/list.jslist.tpl.htmllist.csssubbiz2/遇到确实是一个业务整体，无法划分子业务时， 允许(MAY) 将非JS资源按资源类型划分目录进行管理。biz1/css/add.cssedit.cssremove.cssimg/add_button.pngtpl/add.htmledit.htmlremove.htmladd.jsedit.jsremove.js源文件资源和内容资源请参考资源分类章节，常用资源目录请参考资源目录章节，常用业务目录请参考业务目录章节。 业务项目目录划分示例1234567891011121314151617181920212223242526272829303132$&#123;root&#125;/ src/ common/ img/ sprites.png logo.png conf.js layout.css biz1/ img/ add_button.png add.js add.tpl.html add.less biz2/ subbiz1/ list.js list.tpl.html list.css subbiz2/ dep/ er/ src/ test/ esui/ src/ test/ test/ doc/ index.html main.html ...... 包项目目录结构划分包项目的${root}目录结构划分遵循${root}目录结构划分。 包项目 src 目录结构划分包是实现某个独立功能，有复用价值的代码集。按照通常的理解，一个包项目不应该特别复杂。所以，包可视如一个不太复杂的业务，其src下的划分原则与业务项目的业务目录划分原则保持一致。${root}/src/css/img/sprites.pngtable.cssbutton.cssselect.cssmain.jsControl.jsInputControl.jsButton.jsTable.jsSelect.jstest/doc/package.json… 常用目录 一级目录直接置于${root}下的目录称作一级目录。一级目录 必须(MUST) 具有某种职能属性。除了下面列举的一些常见目录之外，${root}下面也可以放置一些跟项目发布相关的文件，例如build.sh，build.xml，Makefile，Gruntfile等等. srcsrc目录用于存放开发时源文件，发布时 必须(MUST) 被删除。 depdep目录用于存放项目引入依赖的第三方包。该目录下的内容通过平台工具管理，项目开发人员 不允许(MUST NOT) 更改dep目录下第三方包的任何内容。当项目需要修改引入的第三方代码时，第三方包应将源码直接置于${root}/src目录下，规则见该目录下的规定。更多关于包的内容请参考 包结构规范 tooltool目录用于存放开发时或构建阶段使用的工具。该目录在发布时 必须(MUST) 被删除。 testtest目录用于存放测试用例以及开发阶段的模拟数据。该目录在发布时 必须(MUST) 被删除。 docdoc目录用于存放项目文档。项目文档可能是开发者维护的文档，也可能是通过工具生成的文档。 entryentry目录用于存放项目的页面入口文件，通常是上线后可被直接访问的静态页面。RIA项目通常会包含较少的页面入口文件，常见的是main.html，这些文件 可以(SHOULD) 直接放在${root}目录下。${root}/src/common/conf.jscard/gold/message/index.htmlmain.html……多页面项目通常页面入口文件较多， 可以(SHOULD) 统一放在entry目录中，按业务逻辑命名。${root}/src/common/conf.jscard/gold/message/entry/card.htmlgold.htmlmessage.html……项目在发布的时候，构建工具可以页面入口文件为入口进行分析和编译。RIA项目经过构建工具编译后，目录结构可能如下：output/asset/js/css/tpl/img/index.htmlmain.html多页面项目经过构建工具编译后，目录结构可能如下：output/card/asset/js/css/img/index.htmlgold/asset/js/css/img/index.html assetasset目录用于存放用于线上访问的静态资源。通常构建工具会对src目录和dep目录下的资源进行分析、合并与压缩等，生成到asset目录下。所以该目录尽量避免手工管理。下面是一个构建工具生成后的asset目录示例：${root}/asset/js/loader.jsbuild.jscss/common.cssimg/tpl/build.tpl.htmlimg/… 资源目录按资源类型命名的目录称作资源目录。资源目录 不允许(MUST NOT) 直接置于${root}下。 jsjs目录可用于存放js资源文件（包含可编译成js的coffeescript等语言）。js文件后缀名 必须(MUST) 为.js，coffeescript文件后缀名 必须(MUST) 为.coffee。js目录内 必须(MUST) 存放js资源文件，但js资源文件不一定（MAY NOT）存放于js目录下： 对于src目录，js资源文件 不允许(MUST NOT) 存放于js目录下。 对于asset目录，js资源文件 可以(SHOULD) 存放于js目录下，视构建行为决定。 对于其他一级目录内，js资源文件 可以(SHOULD) 不存放于js目录下。 csscss目录可用于存放css资源文件（包含less，sass等动态样式表语言）。css文件后缀名 必须(MUST) 为.css，less文件后缀名 必须(MUST) 为.less。css目录内 必须(MUST) 存放css资源文件，但css资源文件不一定（MAY NOT）存放于css目录下： 对于src目录，css资源文件 可以(SHOULD) 存放于业务目录下，也 可以(SHOULD) 存放于css目录下。 对于asset目录，css资源文件 可以(SHOULD) 存放于css目录下，视构建行为决定。 对于其他一级目录内，css资源文件 可以(SHOULD) 不存放于css目录下。关于 css 引用图片的位置说明，请参考img章节。 imgimg目录可用于存放图片资源文件。包括页面直接引用的图片与css引用图片。常见的图片资源有gif/jpg/png/svg/bmp等。对于css引用的图片， 必须(MUST) 放在./img目录下，.代表当前css资源所在的目录。对于页面直接引用的图片： 被多页面引用的图片 应该(SHOULD) 放在${root}/src/common/img目录下。 单一页面引用的图片 应该(SHOULD) 放在./img目录下，.代表当前页面所在的目录。 tpltpl目录可用于存放template资源文件。template资源文件后缀名 可以(SHOULD) 为.html或.tpl。通常，对于RIA系统，template资源文件采用.html后缀使其能够被xhr加载。 fontfont目录可用于存放字体资源文件。常见的字体资源有tff/woff/svg等。 swfswf目录可用于存放flash资源文件。flash资源文件 不允许(MUST NOT) 置于img目录中。 业务目录 commoncommon目录为业务公共目录，用于存放业务项目的业务公共文件。所以，根据业务逻辑划分目录结构时，业务逻辑命名 不允许(MUST NOT) 为common。 FAQ 为啥 biz 下面没资源类型目录了？如果在biz下继续划分资源目录，代码的结构可能就是这样子了：${root}/src/biz1/js/list.js当我们需要使用list.js的时候，必须写如下的代码：require(&quot;../biz1/js/list&quot;)，但是从逻辑上说，更合理的写法应该是require(&quot;../biz1/list&quot;)。因此我们不推荐在biz下面对源代码资源划分目录。]]></content>
  </entry>
  <entry>
    <title><![CDATA[markdown]]></title>
    <url>%2F2019%2F06%2F14%2Fyuque%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[markdown API 欢迎使用 Cmd Markdown 编辑阅读器 学习网站：https://www.zybuluo.com/mdeditor、[https://markdown-here.com/](https://markdown-here.com/) 安装chrome插件：chrome-extension://elifhakcjgalahccnjkneoccemfahfoa/common/options.html可以编辑markdown我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown： 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持）除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载： Windows/Mac/Linux 全平台客户端 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 新文稿 或者使用快捷键 Ctrl+Alt+N。 什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 1. 制作一份待办事宜 Todo 列表 支持以 PDF 格式导出文稿 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 新增 Todo 列表功能 修复 LaTex 公式渲染问题 新增 LaTex 公式编号功能 2. 书写一个质能守恒公式[1]$$E=mc^2$$ 3. 高亮一段代码[2]123456@requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world' 4. 高效绘制 流程图 5. 高效绘制 序列图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 6. 高效绘制 甘特图12345678910111213title 项目开发流程 section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5d section 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5d section 发布验收 发布: 2d 验收: 3d 7. 绘制表格 项目 价格 数量 计算机 $1600 5 手机 $12 12 管线 $1 234 8. 更详细语法说明 想要查看更详细的语法说明，可以参考我们准备的 [Cmd Markdown 简明语法手册][1]，进阶用户可以参考 [Cmd Markdown 高阶语法手册][2] 了解更多高级功能。 总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。 什么是 Cmd Markdown您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 编辑/发布/阅读 Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。 1. 实时同步预览我们将 Cmd Markdown 的主界面一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！ 2. 编辑工具栏也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 编辑区 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。 3. 编辑模式完全心无旁骛的方式编辑文字：点击 编辑工具栏 最右侧的拉伸按钮或者按下 Ctrl + M，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！ 4. 实时的云端文稿为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 编辑工具栏 的最右侧提示 已保存 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。 5. 离线模式在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。 6. 管理工具栏为了便于管理您的文稿，在 预览区 的顶部放置了如下所示的 管理工具栏：通过管理工具栏可以：发布：将当前的文稿生成固定链接，在网络上发布，分享新建：开始撰写一篇新的文稿删除：删除当前的文稿导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地列表：所有新增和过往的文稿都可以在这里查看、操作模式：切换 普通/Vim/Emacs 编辑模式 7. 阅读工具栏通过 预览区 右上角的 阅读工具栏，可以查看当前文稿的目录并增强阅读体验。工具栏上的五个图标依次为：目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落视图：互换左边编辑区和右边预览区的位置主题：内置了黑白两种模式的主题，试试 黑色主题，超炫！阅读：心无旁骛的阅读模式提供超一流的阅读体验全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境 8. 阅读模式在 阅读工具栏 点击 或者按下 Ctrl+Alt+M 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。 9. 标签、分类和搜索在编辑区任意行首位置输入以下格式的文字可以标签当前文档：标签： 未分类标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示： 10. 文稿发布和分享 在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 (Ctrl+Alt+P) 发布这份文档给好友吧！再一次感谢您花费时间阅读这份欢迎稿，点击 (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！作者 [@ghosert][3]2016 年 07月 07日 123// All the code you will ever needvar hw = "Hello World!"alert(hw); My math is so rusty that I barely remember the quadratic equation:$-b \pm \sqrt{b^2 - 4ac} \over 2a$ 支持 LaTeX 编辑显示支持，例如：$\sum_{i=1}^n a_i=0$， 访问 [MathJax][4] 参考更多使用方法。 ↩︎ 代码高亮功能支持包括 Java, Python, JavaScript 在内的，四十一种主流编程语言。[1]: https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown[2]: https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#cmd-markdown-高阶语法手册[3]: http://weibo.com/ghosert[4]: http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference| Name | Lunch order | Spicy | Owes || —– | ———– | —— | —: || Joan | saag paneer | medium | $11 || Sally | vindaloo | mild | $14 || Erin | lamb madras | HOT | $5 |There are multiple syntax highlighting themes to choose from. Here’s one of them: ↩︎]]></content>
  </entry>
  <entry>
    <title><![CDATA[mermaidjs]]></title>
    <url>%2F2019%2F06%2F14%2Fyuque%2Fmermaidjs%2F</url>
    <content type="text"><![CDATA[mermaidjs]]></content>
  </entry>
  <entry>
    <title><![CDATA[markExample]]></title>
    <url>%2F2019%2F06%2F14%2Fyuque%2FmarkExample%2F</url>
    <content type="text"><![CDATA[https://segmentfault.com/markdown markdown例子Basic writing and formatting syntax 文本 Headers This is an tagThis is an tagThis is an tagInline-style: 12var s = "JavaScript syntax highlighting";alert(s); 12s = "Python syntax highlighting"print s 12No language indicated, so no syntax highlighting. But let&apos;s throw in a &lt;b&gt;tag&lt;/b&gt;. 表情包来自余：https://www.webfx.com/tools/emoji-cheat-sheet/ https://github.com/ikatyang/emoji-cheat-sheet/edit/master/README.md https://help.github.com/en/articles/basic-writing-and-formatting-syntax#using-emoji 1@octocat :+1: This PR looks great - it&apos;s ready to merge! :shipit: | top | :bowtie: | :bowtie: | | :smile: | emoji-cheat-sheetThis cheat sheet is automatically generated from GitHub Emoji API and Emoji Cheat Sheet. Table of Contents People Nature Objects Places Symbols Uncategorized]]></content>
  </entry>
  <entry>
    <title><![CDATA[在 VPS 上部署 Hexo]]></title>
    <url>%2F2019%2F06%2F14%2Fyuque%2F%E5%9C%A8%20VPS%20%E4%B8%8A%E9%83%A8%E7%BD%B2%20Hexo%2F</url>
    <content type="text"><![CDATA[Hexo博客架构 简单地说，在本地用 markdown 写好文章，用 hexo 生成静态的 html 文件并 push 到远程服务器（vps），vps 再通过 git-hooks 同步网站目录。其实这两个是可以合成一个的，不过每次写文章都要 ssh 登录到 vps，体验可能没那么好。 流程大纲 本地 – 环境搭建，安装 Hexo,包括 hexo-cli, Nodejs, git; 本地 – 写文章； 远程 VPS – 环境搭建，包括 Nodejs, git, Nginx 配置和创建 git 用户;使用 git 自动化部署发布博客 使用 Git 自动化部署发布博客 本地 Hexo 安装和配置首先要安装 Nodejs 和 git , mac 系统可用 brew 安装，其它系统自行摸索 1brew install nodejs git 安装 hexo-cli 1npm install -g hexo-cli 找个地方放 Hexo 程序 123mkdir -p ~/Documents/codecd ~/Documents/codehexo init blog 然后安装两个插件，分别是 git 自动部署插件 hexo-deployer-git 和简单的本地web服务器 hexo-server 123cd ~/Documents/code/blognpm install hexo-deployer-git --savenpm install hero-server --save 至此本地环境算搭建好了，下面是写文章 本地 Hexo 发表文章使用命令新建文章 12cd ~/Documents/codehexo new "hello Hexo" 该命令会成一个对应的 .md 文件放置在 sources/_posts 文件夹 1sources/_posts/hello-hexo.md 接下来用你喜欢的编辑器编辑 hello-hexo.md 文件，记得要用 markdown 语法。写好以后， 使用 hexo g 命令将 .md 文件渲染成静态文件 1hexo g 然后启动本地 web 服务器 hexo-server 1hexo server 该命令可简写为 hexo s, 现在可以用浏览器打开 http://localhost:4000 访问博客了。（注：以上本地环境搭建完成可以放在远程服务器 vps 上，当然写文章也得在 vps 上写，传统的做法是像架构图那样分离开。） 远程 VPS 环境搭建同样要安装 Nodejs 和 git，根据自己的系统自行摸索，此步略过Nginx 配置，我用宝塔 linux 面板一键安装，不用手动配置，如果要手动改，参考配置如下（抄来的，仅供参考）： 1234567891011121314151617181920212223242526272829server&#123; listen 80; #listen [::]:80; server_name www.xxb.me xxb.me; index index.html index.htm index.php default.html default.htm default.php; #这里要改成网站的根目录 root /path/to/www; include other.conf; #error_page 404 /404.html; location ~ .*\.(ico|gif|jpg|jpeg|png|bmp|swf)$ &#123; access_log off; expires 1d; &#125; location ~ .*\.(js|css|txt|xml)?$ &#123; access_log off; expires 12h; &#125; location / &#123; try_files $uri $uri/ =404; &#125; access_log /home/wwwlogs/blog.log access;&#125; 未完待续]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo 优化设置]]></title>
    <url>%2F2019%2F06%2F14%2Fyuque%2FHexo%20%E4%BC%98%E5%8C%96%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[hexo官网 修改博客标题简介语言等创建页面 编辑 _config.yml 12345678910# Sitetitle: Xxbsubtitle: Linux,crypto,miningdescription:keywords: Linux,crypto,miningauthor: xxb.melanguage: - zh-CN - zh-TW - en 修改网站 URL 和链接格式编辑 _config.yml 123456# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://www.xxb.meroot: /permalink: :category/:title/permalink_defaults: 创建分类页运行命令新建page页 1hexo new page categories 编辑页面123456789101112---title: 分类date: 2018-04-25 22:34:08type: "categories"------title: 标签date: 2018-04-25 22:34:08type: "tags"--- 实际使用1234567891011121314151617181920212223242526title: hexo 添加标签和分类date: 2018-04-27 23:00:34categories:- hexotags:- linux---layout: phototitle: My Gallerydate: 2019-06-19 15:54:13# tags: [photo, 照片]categories: - hexotags: - linux - React------title: post title with whitespacedate: 2019-06-19 15:39:18tags: [photo, 照片]--- 配置别名其中: 以前的是正式的名称，以后的是访问的路径 12345678910111213# Category &amp; Tagdefault_category: uncategorizedcategory_map: hexo:hexo ubuntu:ubuntu computer vision:computer-visiontag_map: linux:linux ubuntu:ubuntu vim:vim tmux:tmux hexo:hexo yolo:yolo opencv:opencv computer vision:computer-vision 部署生效一定要记得先clean在生成 123$ hexo clean$ hexo g$ hexo d 运行后提示 1INFO Created: ~/Documents/code/blog/source/categories/index.md 找到 index.md 这个文件，为其添加 type 属性 12345---title: tagsdate: 2019-01-30 17:37:12type: "categories"--- 修改主题 _config.yml 文件的menu段落，反注释掉tags那一行 123456789menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 创建标签页方法和创建分类页一样，只是把 categories 改为 tags 创建about页参考创建标签页 添加诗词插件今日诗词 API 根据不同地点、时间、节日、季节、天气、景观、城市、事件进行智能推荐，每次刷新都不同。官网： https://www.jinrishici.com/调用文档： https://www.jinrishici.com/doc/在想放置诗词的地方添加以下代码：（我放在_partials/header/brand.swig） 12&lt;div id="jinrishici-sentence" class="shici"&gt;&lt;/div&gt;&lt;script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"&gt;&lt;/script&gt; 自定义样式，修改主题样式文件source/css/_custom/custom.styl 1.shici &#123;font-size: 15px;text-align: center;font-weight: 300;color: #444;font-style: italic;&#125; 在线演示： www.xxb.me 主题：https://github.com/ppoffice/hexo-theme-icarus 未完待续 …]]></content>
  </entry>
  <entry>
    <title><![CDATA[UI组件库]]></title>
    <url>%2F2019%2F06%2F14%2Fyuque%2FUI%E7%BB%84%E4%BB%B6%E5%BA%93%2F</url>
    <content type="text"><![CDATA[经典模块化前端框架]]></content>
  </entry>
  <entry>
    <title><![CDATA[教程一]]></title>
    <url>%2F2019%2F06%2F14%2Fyuque%2F%E6%95%99%E7%A8%8B%E4%B8%80%2F</url>
    <content type="text"><![CDATA[手摸手教程手摸手，带你用合理的姿势使用 webpack4（上）手摸手，带你用合理的姿势使用 webpack4（下） url-loader vs file-loader 2018-08-13 很多人搞不清楚这两个 loader 是干嘛的？其实 url-loader 就是对 file-loader 的一个拓展。照你设置的文件大小 limit, 将其内联为 base64 或者单独作为文件引入。 将图片文件转换为 base64 编码并载入浏览器能够减少 http 请求数，但是增大了 js 或 html 文件的体积，如果图片在项目中的重用度较高，那么每处引用都会生成 base64 编码，造成了代码的冗余。所以是否需要内联自己需要权衡一下。 file-loader： 可以指定要复制和放置资源文件的位置，以及如何使用版本哈希命名以获得更好的缓存。此外，这意味着 你可以就近管理图片文件，可以使用相对路径而不用担心部署时 URL 的问题。使用正确的配置，webpack 将会在打包输出中自动重写文件路径为正确的 URL。 url-loader： 允许你有条件地将文件转换为内联的 base-64 URL (当文件小于给定的阈值)，这会减少小文件的 HTTP 请求数。如果文件大于该阈值，会自动的交给 file-loader 处理。]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue]]></title>
    <url>%2F2019%2F06%2F14%2Fyuque%2Fvue%2F</url>
    <content type="text"><![CDATA[##Router Linkrouter-link基本每一个人都会用，但有的时候我们需要在点击的时候做一些额外的操作，比如点击的时候先弹出一个确认框，问用户是否需跳转。但发现怎么也禁止不了它的默认时间。查阅文档之后发现它有一个 event参数，默认是click。我们只要将它设空，之后自己来处理跳转的逻辑就可以了。 1234&lt;router-link :to="&#123; name: 'my-favorites' &#125;" :event="''" @click.native.prevent="routeOrLogin(&#123; name: 'my-favorites' &#125;)"&gt; Favorites&lt;/router-link&gt; Dynamic Componentsvue 一个就是 它可以写愉快的写 template 一个类 html 的模板，大多数情况下都非常好用。但在一些复杂场景下，它就显得不太灵活了。 这里举一个例子来说： 12345678910&lt;a v-if="isExternalLink" :href="xxx"&gt; &lt;componentA /&gt; &lt;componentA /&gt; &lt;componentC /&gt;&lt;/a&gt;&lt;router-link v-else :to="xxx"&gt; &lt;componentA /&gt; &lt;componentA /&gt; &lt;componentC /&gt;&lt;/router-link&gt; 这里只是一个最简单一个例子，实际场景中，中间重复的内容可能更多，两者唯一的区别只是外链的时候使用a标签，内部链接使用router-link。但却要写一大串的 if..else很不爽。这里提供一个简单的方法解决这个问题。就是使用动态组件，我们将a标签和router-link分装成一个动态组件，根据传入的 url 是否是外部链接，动态的选择使用什么标签来渲染。 1234567891011121314151617181920212223242526272829303132&lt;!-- Link.vue --&gt;&lt;template&gt; &lt;component v-bind="linkProps(to)"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/component&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: &#123; to: &#123; type: String, required: true &#125; &#125;, methods: &#123; linkProps (url) &#123; if (url.match(/^(http(s)?|ftp):\/\//)) &#123; return &#123; is: 'a', href: url, target: '_blank', rel: 'noopener' &#125; &#125; return &#123; is: 'router-link', to: url &#125; &#125; &#125; &#125;&lt;/script&gt; 这样我们将代码的复杂度都封装在了Link.vue之中，我们在原来文件中只需这样使用： 12345&lt;link :to="xxx"&gt; &lt;componentA /&gt; &lt;componentA /&gt; &lt;componentC /&gt;&lt;/link&gt; 是不是一下子简单了许多，代码的可阅读性也直线上升了。 Fragmentreact 很早就有了 Fragment 但 vue 迟迟还没有支持。]]></content>
  </entry>
  <entry>
    <title><![CDATA[产品]]></title>
    <url>%2F2019%2F06%2F14%2Fyuque%2F%E4%BA%A7%E5%93%81%2F</url>
    <content type="text"><![CDATA[如何理解 DAU 和 MAU 这两个数据？DAU (Daily Active Users) 日活 单日活跃用户数，反应产品短期用户活跃度MAU (Monthly Active Users) 月活 单月活跃用户量，反应产品长期用户活跃度 DAU 的分析价值所在核心用户规模：DAU 指标直接反应了核心用户规模。可以结合其他指标一同分析。 生命周期分析的价值：产品不同阶段，DAU 的数据表现不一样。DAU趋势下滑，那么很可能是老用户流失，产品开始走下坡路。是否要投入运营预算，是否要产品重新战略部署等。 产品黏性：DAU 指标结合留存指标来分析产品的用户粘性。 渠道价值分析：DAU可以间接判断各大渠道对产品的贡献价值。在产品初期投放各大渠道之后，DAU 数据会逐步减少，后期可以有选择的保留用户基数大的渠道运营。 用户流失分析：运营活动结束之后，DAU 数据有大幅减少，则要进行用户流失分析。 DAU 的多维度分析趋势：通过判断 DAU 指标在某一时间段的变化来预测未来的数据表现，一般用趋势图表示。例如，未来一个月的收益表现，可以参考三个月的 DAU，去年同期的数据表现，可以综合评估分析。同比：是将本周期内的数据与历史相同时间点的数据进行比对。例如，今年 N 月与去年 N 月相比。环比：是将本期数据与前期数据进行对比，体现了数据连续性变化的趋势。例如，今年九月同八月、七月的数据进行比对。定基比：数据进行比对才有意义。该分析需要以某个时期为基数，其他各期数据都可以与之对比。基准线是产品发展的里程碑水平，可以反映产品的发展运营情况如何异常定位一般表现为：数据异常时间点的不同（如节假日，高考等），产品体验，近期是否发版，近期的运营活动，渠道投放，广告推广，产品相关的新闻事件，以及市场竞品的影响（如有新竞品进入市场，竞品最近搞运营活动）等。 比值DAU/MAU 代表的是，每天登录的玩家占月活跃的百分比。形象点就是说，你这些活跃玩家，是每天都在登录，还是隔了几天登录。假设，每天都在登录，粘性就高。你隔个四五天登录，粘性就低。一般这个值会在 0.03 到 1 之间。 如果低于10%，很可能已经处于衰退期；高于 20%的留存还不错。 交互席克定律它描述了根据已知选项做某项决定所花的时间——随着选项数量的增加，投入的时间也会呈对数增加。简单来讲，越少越快。 当用户出现恐慌或困惑时，唯一的选择反而给人一种「山有小口，仿佛若有光」的感觉。所以，如果「反应时间」很重要，那选项数量一定要控制在最少。这样也可以加快用户抉择的速度。 解决方案:分步选择, 均分总复杂度到每一个步骤限制选项数量, 保留基本的选项控制单个元素的复杂度, 使页面简单好理解]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端性能监控]]></title>
    <url>%2F2019%2F06%2F14%2Fyuque%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[前端性能优化原理与实践前端性能监控分为两种方式，一种叫做合成监控（Synthetic Monitoring，SYN），另一种是真实用户监控（Real User Monitoring，RUM）。 合成监控什么叫合成监控？就是在一个模拟场景里，去提交一个需要做性能审计的页面，通过一系列的工具、规则去运行你的页面，提取一些性能指标，得出一个审计报告。 常见的工具有 Google 的 Lighthouse，webpagetest，pagespeed 等。 当然其实业界对于 Lighthouse 也是评价有褒有贬，因为 Google 借助这个看似中立的性能评审工具也是在推行它的一些技术的方案。 比如你的页面如果没有支持 PWA 评分就不会很高。 合成监控的优缺点 优点 缺点 实现简单 无法还原全部真实场景 能采集到丰富的数据，如硬件指标或瀑布图 登录等场景需要额外解决 不影响真实用户的访问性能 单次数据不够稳定 可以提供页面加载幻灯片等可视化分析途径 数据量较小，无法发挥更大价值 真实用户监控所谓真实用户监控，就是用户在我们的页面访问之后就会产生各种各样的性能指标，之后会将这些性能指标上传的我们的日志服务器上，进行数据的提起清洗加工，最后在我们的监控平台上进行展示和分析的一个过程。 真实用户监控的优缺点 优点 缺点 无需配置模拟条件，完全还原真实场景 一定程度影响真实用户的访问性能及流量消耗 不存在登录等需要额外解决的场景 无法采集硬件相关指标 数据样本足够庞大，可以减少统计误差 受传输限制无法采集完整的资源加载瀑布图 新年数据可与其它数据关联，产生更大价值 无法可视化展示加载过程 对比 对比项 合成监控 真实用户监控 实现难度及成本 较低 较高 采集数据丰富度 丰富 基础 数据样本量 较小 大(视业务体量) 适合场景 团队自由业务，对性能做定性分析，或配合 CI 做小数据量的监控分析 作为中台产品支持前台业务，对性能做定量分析，结合业务数据进行深度挖掘 方案在真实用户性能数据采集时，要关注四个方面的东西： 使用标准的 API定义合适的指标采集正确的数据上报关联的维度使用标准的 API之前大家都使用一个叫 performance.timing，来做性能监控。但这个 API 已经“废弃”了。为什么会被废弃？因为 W3C 给我们提供了更全面、更强大的一个性能分析矩阵，比单一的 performance.timing更加强大，能帮助我们从各个方面分析前端页面性能。 采集性能数据时先抹平 Navigation Timing spec 差异，优先使用 PerformanceTimeline API(在复杂场景，亦可考虑优先使用 PerformanceObserver)。 定义合适的指标First Meaningful Paint，首次有效渲染时长，这个指标最早是由 Google 提出的，它的一个核心的想法是渲染并不一定代表着用户看到了主要内容，Load也不一定代表用户看到主要内容，那用户什么时候能够看到主要内容呢？我们假设当一个网页的 DOM 结构发生剧烈的变化的时候，就是这个网页主要内容出现的时候，那么在这样的一个时间点上，就是用户看到主要内容的一个时间点。 它的优点是相对校准的估算出内容渲染时间，贴近用户感知。但缺点是无原生 API 支持，算法推导时 DOM 节点不含权重。 怎样采集正确的数据？上报页⾯加载开始时间，以及后续各时间点相对增量，在数据端进行阶段清洗和异常处理。 上报关联的维度我们都知道在做前端的数据采集的时候，维度数据是非常重要的，除了我们刚才定义的各种度量，怎样采集到合适的相关维度，也能够极大地帮助我们分析页面性能的效果。 在分析页面性能的时候，有很多相对专业的维度是会被大家忽略掉的，比如说当前页面是否可见，这个页面加载方式是怎么样的，它是直接打开，还是刷新打开，还是前进后退打开等等。就是通过后面的数据分析，我们会发现，不同的页面操作，页面打开方式都会对我们页面加载的性能会有影响，以及一些更复杂的，比如说是否启用HTTP2、Service Worker 等等，这些数据我们都应该尽可能采集到，从而能够更好的去分析我们的页面性能。 原文本文为蚂蚁金服如何把前端性能监控做到极致? 的阅读笔记。 拓展阅读 我理解的前端性能 &amp; 优化]]></content>
  </entry>
  <entry>
    <title><![CDATA[uni-app]]></title>
    <url>%2F2019%2F06%2F14%2Fyuque%2Funi-app%2F</url>
    <content type="text"><![CDATA[uni-app已经被阿里手接纳 https://docs.alipay.com/mini/ide/0.70-stable 官网git源码地址]]></content>
  </entry>
  <entry>
    <title><![CDATA[Javascript]]></title>
    <url>%2F2019%2F06%2F14%2Fyuque%2FJavascript%2F</url>
    <content type="text"><![CDATA[querySelectorAll getElementsBy 区别？浏览器兼容querySelectorAll 已被 IE 8+、FF 3.5+、Safari 3.1+、Chrome 和 Opera 10+ 良好支持 。getElementsBy 系列，以最迟添加到规范中的getElementsByClassName 为例，IE 9+、FF 3 +、Safari 3.1+、Chrome 和 Opera 9+ 都已经支持该方法了。 接收参数querySelectorAll 方法接收的参数是一个 CSS 选择符。而 getElementsBy 系列接收的参数只能是单一的 className、tagName 和 name。 123var c1 = document.querySelectorAll('.b1 .c')var c2 = document.getElementsByClassName('c')var c3 = document.getElementsByClassName('b2')[0].getElementsByClassName('c') 返回值大部分人都知道，querySelectorAll 返回的是一个 Static Node List，而 getElementsBy 系列的返回的是一个 Live Node List。 1234567891011121314151617181920212223&lt;ul&gt; &lt;li&gt;&lt;/ul&gt; &lt;li&gt;&lt;/ul&gt; &lt;li&gt;&lt;/ul&gt; &lt;li&gt;&lt;/ul&gt; &lt;li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;script&gt;// Demo 1var ul = document.querySelectorAll('ul')[0], lis = ul.querySelectorAll("li");for(var i = 0; i &lt; 5 ; i++)&#123; ul.appendChild(document.createElement("li"));&#125;console.log(lis) //5// Demo 2var ul = document.getElementsByTagName('ul')[0], lis = ul.getElementsByTagName("li");for(var i = 0; i &lt; 5 ; i++)&#123; ul.appendChild(document.createElement("li"));&#125;console.log(lis) //5+2&lt;/script&gt; Demo 1 中的 lis 是一个静态的 Node List，是一个 li 集合的快照，对文档的任何操作都不会对其产生影响。Demo 2 中的 lis 是一个动态的 Node List， 每一次调用 lis 都会重新对文档进行查询，导致无限循环的问题。但为什么要这样设计呢？ 其实，在 W3C 规范中对 querySelectorAll 方法有明确规定 The NodeList object returned by the querySelectorAll() method must be static ([DOM], section 8). 那什么是 NodeList 呢？ The NodeList interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented. NodeList objects in the DOM are live. 所以，NodeList 本质上是一个动态的 Node 集合，只是规范中对 querySelectorAll 有明确要求，规定其必须返回一个静态的 NodeList 对象。 12document.querySelectorAll('a').toString() // return "[object NodeList]"document.getElementsByTagName('a').toString() // return "[object HTMLCollection]" 这里又多了一个 HTMLCollection 对象出来，那 HTMLCollection 又是什么？ 实际上，HTMLCollection 和 NodeList 十分相似，都是一个动态的元素集合，每次访问都需要重新对文档进行查询。两者的本质上差别在于，HTMLCollection 是属于 Document Object Model HTML 规范，而 NodeList 属于 Document Object Model Core 规范。这样说有点难理解，看看下面的例子会比较好理解 12345var ul = document.getElementsByTagName('ul')[0], lis1 = ul.childNodes, lis2 = ul.childrenconsole.log(lis1.toString(), lis1.length) // "[object NodeList]" 11console.log(lis2.toString(), lis2.length) // "[object HTMLCollection]" 4 NodeList 对象会包含文档中的所有节点，如 Element、Text 和 Comment 等。HTMLCollection 对象只会包含文档中的 Element 节点。另外，HTMLCollection 对象比 NodeList 对象 多提供了一个 namedItem 方法。所以在现代浏览器中，querySelectorAll 的返回值是一个静态的 NodeList 对象，而 getElementsBy 系列的返回值实际上是一个 HTMLCollection 对象 。 参照文章 NodeList 和 HTMLCollection 之间的关系？历史上的 DOM 集合接口。主要不同在于 HTMLCollection是元素集合而 NodeList 是节点集合（即可以包含元素，也可以包含文本节点）。所以 node.childNodes 返回 NodeList，而 node.children 和 node.getElementsByXXX 返回 HTMLCollection 。唯一要注意的是 querySelectorAll 返回的虽然是 NodeList ，但是实际上是元素集合，并且是静态的（其他接口返回的 HTMLCollection 和 NodeList 都是 live 的）。Both interfaces are collections of DOM nodes. They differ in the methods they provide and in the type of nodes they can contain. While a NodeList can contain any node type, an HTMLCollection is supposed to only contain Element nodes. An HTMLCollection provides the same methods as a NodeList and additionally a method called namedItem.Collections are always used when access has to be provided to multiple nodes, e.g. most selector methods (such as getElementsByTagName) return multiple nodes or getting a reference to all children (element.childNodes). [“1”, “2”, “3”].map(parseInt) 坑第一反应都觉得结果会是 [1,2,3]但实际结果却是 [1, NaN, NaN]这是为什么呢？主要是 map 这个方法在调用 callback函数时，会给它传递三个参数: 当前正在遍历的元素 元素索引 原数组本身 也是就是说如上代码其实等同于 1['1', '2', '3'].map((i, index, array) =&gt; parseInt(i, index, array)) 这样就直观的解释了上面的答案是怎么产生得了。因为 parseInt 会接受两个参数：参数和进制数。 1234// 实际代码运算等于如下parseInt('1', 0) // 1parseInt('2', 1) // NaNparseInt('3', 2) // NaN 所以为了避免这个坑，平时写 map 还是不要偷懒了，完整的写法才更直观并且更容易维护。 1['1', '2', '3'].map(str =&gt; parseInt(str)) ## 省略参数引发的 bug省略参数是 es6 之后提供的一个很好用也非常常用的功能。但还是有一些细节值得注意，不然一不小心就会出现 bug。 12345678910function test(num = 1) &#123; console.log(num)&#125;test() // (num is set to 1)test(undefined) // (num is set to 1 too)test('') // (num is set to '')test(null) // (num is set to null)test(false) // (num is set to false) 如上面 demo 所示，只有参数没传或者是 undefined 是才会生效，其它情况默认参数并不会起作用。所以有的时候你传入了&#39;&#39;空字符串是不行的，还需要自己手动判断一下。str = str || defalutString 另外，一个容易忽略的地方是，参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。 123456789let x = 99function foo(p = x + 1) &#123; console.log(p)&#125;foo() // 100x = 100foo() // 101 上面代码中，参数 p 的默认值是 x + 1。这时，每次调用函数 foo，都会重新计算 x + 1，而不是默认 p 等于 100。 多余逗号引发的错误刚入前端的时候看错误日志，ie 的错误日志特别多，一直没找到原因，后来发现是 JSON 最后一组键值后多逗号。 1234567891011// 所有浏览器都正常var json_normal = &#123; id: 1, name: "John"&#125;;// ie 报错，其它游览器正常var json_error = &#123; id: 1, name: "John",&#125;; 好在现在有了 eslint 或者 preitter这种工具，这种错误很少会再发生了。 js 中的逗号123if (((a = 1), a++, a)) &#123; console.log(a)&#125; 很多人一下子可能会一脸懵逼。但看一下 MDN 文档 就很清楚了 逗号操作符 对它的每个操作数求值（从左到右），并返回最后一个操作数的值。 举个例子var a=(1+1,2+2,3+3); 结果就是 6。 3+3但在函数中，比如比 Math.max(x,y,z)。这里的逗号就是分隔函数参数。还有声明变量时，var a=1,b=2,c=3。这里的逗号也是起分隔的作用。再举一个例子大家应该就理解了 1234567alert(2 * 5, 2 * 4)//输出10而不是8 函数接收第一个参数,也说明逗号级别比较低console.log(2 * 5, 2 * 4) // 10,8alert((2 * 5, 2 * 4))// 输出8 ()是返回了,相当于隐藏了return 所以返回最右边操作数的值console.log((2 * 5, 2 * 4));//8 其实最常见的运用场景就是平时经常的for循坏 1for (var i = 0, j = 9; i &lt;= 9; i++, j--) &#123;console.log(i,j)&#125; document.documentElement 与 document.body 区别在前端开发中，我们经常需要获取网页中滚动条滚过的长度，获取该值的方式一般通过scrollTop属性，如：document.body.scrollTop，或者document.documentElement.scrollTop，这两者都是经常用来获取文档滚动条滚过长度值的方式，他们又有什么区别呢？ 之前一直没注意，只到有一天发现了一个 bug:document.body.scrollTop 拿到的值一直是 0。在这个之前我们先来了解一下 是干嘛的？为什么每个页面都需要加上这段声明。 doctype 声明不属于 HTML 标签，它是一条指令，告诉浏览器编写页面所用的标记的版本。 这个声明的目的是防止浏览器在渲染文档时，切换到我们称为“怪异模式(兼容模式)”的渲染模式。&lt;!DOCTYPE html&gt; 能确保浏览器按照最佳的相关规范进行渲染，而不是使用一个不符合规范的渲染模式。 document.documentElement 与 document.body document 代表的是整个文档(对于一个网页来说包括整个网页结构) document.documentElement 是整个文档节点树的根节点，在网页中即 html 标签 document.body 是整个文档 DOM 节点树里的 body 节点，网页中即为 body 标签元素 但在标准模式下document.body.scrollTop是无效的。 从 Chrome 61 开始，标准模式中 document.scrollingElement 已被修正为 document.documentElement。换句话说，这个版本开始标准模式中 document.body.scrollTop 始终都等于 0。 所以这里建议使用兼容写法： 12345const scrollTop = Math.max( window.pageYOffset, document.documentElement.scrollTop, document.body.scrollTop) 或者 12345function getBodyScrollTop() &#123; const el = document.documentElement || document.scrollingElement || document.body return el.scrollTop&#125; 每当这时候我就有一些怀念jQuery了。 sort123var array = [3, 7, 2, 8, 2, 782, 7, 29, 1, 3, 0, 34]array.sort()// =&gt; [0, 1, 2, 2, 29, 3, 3, 34, 7, 7, 782, 8] 默认情况下，sort是按照Unicode code points排序的，换而言之，先回比较首个字符的 code point，若相同的情况下依次位数比下去。 所以很多时候我们需要自定义 sort 的规则。最常见的操作： 123const array = [3, 7, 2, 8, 2, 782, 7, 29, 1, 3, 0, 34]array.sort((pre, next) =&gt; pre - next)// =&gt; [0, 1, 2, 2, 3, 3, 7, 7, 8, 29, 34, 782] 其实它的规则很简单，你想让 next 和 pre 换位子就返回一个&gt;0的值，其它情况位置不变，即返回&lt;=0的值。 codePointAt vs charCodeAtJavaScript 允许采用\uxxxx形式表示一个字符，其中xxxx表示字符的 Unicode 码点。但是，这种表示法只限于码点在\u0000~\uFFFF 之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。 12'\uD842\uDFB7'// "𠮷" JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为 2 个字节。对于那些需要 4 个字节储存的字符（Unicode 码点大于 0xFFFF 的字符），JavaScript 会认为它们是两个字符。 1234567var s = '𠮷's.length // 2s.charAt(0) // ''s.charAt(1) // ''s.charCodeAt(0) // 55362s.charCodeAt(1) // 57271 所以 ES6 提供了 codePointAt 方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。 1'𠮷'.codePointAt() //134071 总之，codePointAt 方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与 charCodeAt 方法相同。 switch 作用域其实我们经常会忽略一个点，switch case 是共用一个作用域的。比如如下代码就会抛出重复定义的错误： 12345678910switch (x) &#123; case 0: let foo break case 1: let foo // 重复定义引起TypeError break&#125;// Uncaught SyntaxError: Identifier 'foo' has already been declared 解决方案也很简单，我们给每一个 case 加上一个 bracket 就可以了： 1234567891011switch (x) &#123; case 0: &#123; let foo break &#125; case 1: &#123; let foo // 重复定义引起TypeError break &#125;&#125; div 如何监听 keydown 事件之前有一个人问我，为什么他监听了一个 div 的 keydown 事件，为什么没有用？ 我看了一下代码发现的确没有写错？但为什么就不触发呢？后来查阅了一下文档 Focused element processing the key event, root element if no suitable input element focused 发现只有能被 focus 的元素才能出发键盘事件，所以 div 也就不能触发 keydown 事件了。那怎么才能让 div 支持呢？答案是 tabindex mdn。它表示元素是可聚焦的，并且可以通过键盘导航来访问到该元素。这样一来我们就能愉快的使用keydown事件了. try catch 的 finally 坑try…catch 的 finally 可能很多人都没有使用过，它其实和 promise 中的 finally 很类似。 见MDN。它无论是否有异常它都会执行。 常见的操作就是 将关闭弹窗或者 loading 1234567891011121314var fn = function() &#123; try &#123; console.log('ok') return 'ok' &#125; catch &#123; console.log('error') return 'error' &#125; finally &#123; console.log('finally') return 'finally' &#125;&#125;fn()// ok finally "finally" 我们发现最终输出了finally。因为这个语句只会有一个 return，finally 中的 return 覆盖了之前的定义。而且 return 会被放在最后执行。详情见。 1234567891011var fn = function() &#123; var res='' try &#123; res='ok' &#125; catch &#123; res='error' &#125; finally &#123; return res &#125;&#125;fn() //"ok" 不过最好还是和 promise 中的 finally 一样，在里面做一些没有副作用的事情。免得发生一些 bug。 atob 方法解码中文字符由于一些网络通讯协议的限制,你必须使用 window.btoa() 方法对原数据进行编码后，才能进行发送。接收方使用相当于 window.atob() 的方法对接受到的 base64 数据进行解码,得到原数据。 12345window.btoa('foo')// "Zm9v"window.atob('Zm9v')// "foo" atob 这个方法名称乍一看，很奇怪，不知道这个单词什么意思。我们可以理解为 A to B，也就是从 A 到 B。atob 表示 Base64 字符 to 普通字符，也就是 Base64 解码。当你在 Chrome console 中执行 window.btoa(&#39;中文&#39;)会发下会报错。 Uncaught DOMException: Failed to execute &#39;btoa&#39; on &#39;Window&#39;: The string to be encoded contains characters outside of the Latin1 range. 这时候我们可以借助 encodeURIComponent 和 decodeURIComponent 转义非中文字符。 12345window.btoa(encodeURIComponent('中文'))// ('JUU0JUI4JUFEJUU2JTk2JTg3')decodeURIComponent(window.atob('JUU0JUI4JUFEJUU2JTk2JTg3'))// "中文" Safari 下 Date 的坑在 使用 Date 相关 api 的时候要牢记一个坑，就是 Safari 对一些时间格式是不支持的。比如： 123Date.parse('2018-10-16 12:00:00')// 1539662400000 -- 在Chrome 下// NaN -- 在Safari下 问题就出在 Safari 对于这个格式 YYYY-MM-DD HH:MM:SS 无法解析，Safari 要求 Date.parse()或 Date()转换日期的字符串需要满足 RFC2822 或 ISO 8601 定义的格式。不过我们可以将其转化为 YYYY/MM/DD HH:MM:SS 1Date.parse(new Date('2018-10-16 12:00:00'.replace(/-/g, '/'))) 相关stackoverflow new Date 在 safari 的坑new Date(&#39;2019-06-04 00:00:00&#39;)在除了 Safari 的浏览器都能正常运行。 问题就出在 Safari 对于这个格式 YYYY-MM-DD HH:MM:SS 无法解析，所以我们需要做的是将其转化为 YYYY/MM/DD HH:MM:SS 1+new Date('2019-06-04 00:00:00'.replace(/-/g, '/')) e.target 与 e.currentTarget 的区别有一次在面试的时候问了事件委托的题目，面试人说了一个 currentTarget，突然发现target和currentTarget的区别我好像有些忘记了，太多相似的 api 和属性了。 首先我们来看一下 MDN 上对它们的解释 target：一个触发事件的对象的引用， 当事件处理程序在事件的冒泡或捕获阶段被调用时。 currentTarget： 当事件遍历 DOM 时，标识事件的当前目标。它总是引用事件处理程序附加到的元素，而不是 event.target，event.target 标识事件发生的元素。 可能还是很抽象 ，这里提供一个在线demo。 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width"&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;li&gt;hello 1&lt;/li&gt; &lt;li&gt;hello 2&lt;/li&gt; &lt;li&gt;hello 3&lt;/li&gt; &lt;li&gt;hello 4&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;const ul = document.querySelectorAll('ul')[0]ul.addEventListener('click', function(e) &#123; let oLi1 = e.target let oLi2 = e.currentTarget console.log(oLi1.tagName); // 被点击的li console.log(oLi2.tagName); // ul console.log(oLi1 === oLi2); // false&#125;);&lt;/script&gt; 也就是说，currentTarget 始终是监听事件者，而 target 是事件的真正发出者。 函数变量必填校验这里分享一个平时写 ES6 的时候一个小技巧。如何简单的校验并强制在使用这个函数时必须传参数。 12345678910const isRequired = () =&gt; &#123; throw new Error('Missing parameter')&#125;const foo = (something = isRequired()) =&gt; &#123; console.log(something) return something&#125;foo(123)foo() // Error:Missing parameter 前端错误处理错误处理对于任何前端来说都是必不可少的。任何人写代码都避免不了会有 bug，而且很多 bug 也不是测试用例能完全覆盖的，如果我们没有一个完整的错误处理和错误收集的系统，我们都无法知道我们有 bug，不仅如此，很多 bug 也不一定是前端的问题，比如某个接口返回的数据格式不对了或者少字段了，亦或是在某个特定的浏览器型号上才有的问题等等。而且有了错误处理和收集，我们也才能更好的通过错误栈来还原这个问题。 有哪些错误需要处理 JS 语法错误、代码异常 请求错误 静态资源加载异常 Promise 异常 页面崩溃和卡顿Try Catchtry-catch 只能捕获到同步的运行时错误，对语法和异步错误却无能为力，捕获不到。 1.同步运行时错误： 同步错误 123456try &#123; let name = 'foo' console.log(nam)&#125; catch (e) &#123; console.log('捕获到异常：', e)&#125; 捕获到异常： ‘ReferenceError: nam is not defined at :3:15’ 语法错误 123456try &#123; let name = 'foo console.log(nam)&#125; catch (e) &#123; console.log('捕获到异常：', e)&#125; Uncaught SyntaxError: Unexpected identifier 异步错误 1234567try &#123; setTimeout(() =&gt; &#123; undefined.map(v =&gt; v) &#125;, 1000)&#125; catch (e) &#123; console.log('捕获到异常：', e)&#125; 每次的数都不一样，运行一次就加1Uncaught TypeError: Cannot read property ‘map’ of undefined window.onerror当 JS 运行时错误发生时，window 会触发一个 ErrorEvent 接口的 error 事件，并执行 window.onerror()。 12345678910/** * @param &#123;String&#125; message 错误信息 * @param &#123;String&#125; source 出错文件 * @param &#123;Number&#125; lineno 行号 * @param &#123;Number&#125; colno 列号 * @param &#123;Object&#125; error Error对象（对象） */window.onerror = function(message, source, lineno, colno, error) &#123; console.log('捕获到异常：', &#123; message, source, lineno, colno, error &#125;)&#125; 不同域名下的 js 报错不能被 全局的 window.onerror 监听到，我们需要给相关的 js 文件上加上 Access-Control-Allow-Origin:*的 response header，并且引用相关的 js 文件时加上 crossorigin 属性。相关文章 在实际的使用过程中，onerror 主要是来捕获预料之外的错误，而 try-catch 则是用来在可预见情况下监控特定的错误，两者结合使用更加高效。 window.addEventListener当一项资源（如图片或脚本）加载失败，加载资源的元素会触发一个 Event 接口的 error 事件，并执行该元素上的 onerror() 处理函数。这些 error 事件不会向上冒泡到 window ，不过（至少在 Firefox 中）能被单一的 window.addEventListener 捕获。 123456&lt;img src="./foo.png"&gt;&lt;scritp&gt;window.addEventListener('error', (error) =&gt; &#123; console.log('捕获到异常：', error);&#125;, true)&lt;/script&gt; Promise Catch没有写 catch 的 Promise 中抛出的错误无法被 onerror 或 try-catch 捕获到，所以我们务必要在 Promise 中不要忘记写 catch 处理抛出的异常。或者可以全局增加一个对 unhandledrejection 的监听，用来全局监听 Uncaught Promise Error。使用方式： 123window.addEventListener('unhandledrejection', function(e) &#123; console.log(e)&#125;) 当然你如果使用如 axios 这种库的话，错误处理完全可以放在它的请求实例里面做。更加的灵活。 VUE errorHandler123456Vue.config.errorHandler = (err, vm, info) =&gt; &#123; console.error('通过vue errorHandler捕获的错误') console.error(err) console.error(vm) console.error(info)&#125; React 异常捕获123componentDidCatch(error, info) &#123; console.log(error, info);&#125; 崩溃和卡顿相关文章 实践总结】优雅的处理 vue 项目异常 insertBefore 坑Node.insertBefore()很多人都用过， 它在参考节点之前插入一个节点作为一个指定父节点的子节点。 var insertedNode = parentNode.insertBefore(newNode, referenceNode); 但看文档还有一句补充说明： 如果 referenceElement 为 null 则 newElement 将被插入到子节点的末尾。如果 newElement 已经在 DOM 树中，newElement 首先会从 DOM 树中移除。 这就很坑了，如下面的例子： 12345678910&lt;div id="parentElement"&gt; &lt;span id="bar"&gt;bar&lt;/span&gt; &lt;span id='foo'&gt;foo&lt;/span&gt;&lt;/div&gt;&lt;script&gt;var foo = document.getElementById("foo")var bar = document.getElementById("bar")var parentDiv = document.getElementById("parentElement")parentDiv.insertBefore(foo, bar)&lt;/script&gt; 原本以为结果是 foo bar foo，但实际结果是foo bar。因为根据文档，当你 insertBefore 的是一个已存在的值时，会移动它而不是拷贝它重新插入。贼坑！！！如果使用 ES6 的话可以使用 before 123var foo = document.getElementById('foo')var bar = document.getElementById('bar')bar.before(foo) ## 为什么前端监控要用 GIF 打点目前主流的前端监控数据上报都是采用 GIF 的上报方式，(百度统计/友盟/谷歌统计）都是这样实现的。但为什么一定要使用 GIF 呢？不能发 post 请求或者通过 script 标签的形式么？当然你也可以使用一些黑科技的方式上报，用纯 css 来实现。但这种方案并没有什么特别的好处。 123.track-xx:active:after &#123; content: url(track.php?xxxx=foo);&#125; ### 主要原因 没有跨域问题 不会阻塞页面加载，影响用户体验 在所有图片中体积最小，相较 BMP/PNG，可以节约 41%/35%的网络资源 详情见 为什么前端监控要用 GIF 打点 使用方式但建议不要按如下方法使用 1new Image().src = 'https://foo.com/bar.gif?t=xxxx&amp;b=1' 这段代码的问题是这个 new Image()是一个没有引用的临时变量，随时可能被浏览器的垃圾回收机制回收。如果这个图片的 HTTP 请求尚未建立，那么在被回收时这个请求就会被取消，导致打点并没有真正发出。如果打点所在的页面比较复杂，浏览器垃圾回收机制可能会被频繁触发，那么这种方式打点的丢失率可能会高达 10%以上。 解决方法很简单，将这个图片赋值给一个全局变量即可，例如： 12345678910const img = new Image()const key = +new Date() //加一个时间戳，防止图片被浏览器缓存了，不再发送请求 "+"转换时间戳window[t] = imgimg.onload = img.onerror = img.onabort = function() &#123; // img标签加载完成、错误或终止时，解除事件绑定，销毁相关对象 img.onload = img.onerror = img.onabort = null window[key] = null img = null&#125;img.src = `$&#123;url&#125;?t=key` ### 其它方案Beacon API 在空闲的时候异步发送统计，不影响页面诸如 JS、CSS Animation 等执行 即使页面在 unload 状态下，也会异步发送统计，不影响页面过渡/跳转到下跳页 能够被客户端优化发送，尤其在 Mobile 环境下，可以将 Beacon 请求合并到其他请求上，一同处理 Object.create(null) vs {}查看 vue 的源码 或者一些开源项目的源码，发现不少地方都是使用 Object.create(null)来创建一个空对象的。当使用语句 const obj = {}; 创建对象时，它其实并不是一个真的空对象，它从 Object.prototype 上继承了一些方法： hasOwnProperty isPrototypeOf propertyIsEnumerable toString/toLocaleString valueOf 如果使用 Object.create(null) 创建的对象，在没有继承任何东西。 所以说是不是 Object.create(null) 是更好的创建一个空对象的方案呢？这就要看从 Object 上继承的那些方法我们是不是有用到了。 hasOwnProperty判断一个对象属性中是否具有指定的属性，返回 true or false。 valueOfvalueOf 很少直接使用。在隐式转换类型时，JavaScript 引擎会调用 valueOf 方法，强制把对象转换成原始值 toString、isPrototypeOf 和 propertyIsEnumerable这几个方法直接使用的情况较少，但自己的代码中不用并不表示别人写的代码不会调用。比如，有些框架可能会调用 toString 方法来判断结果是否为 [object Object]。 结论因此，我们可以得出结论：当创建的对象只在当前执行环境中使用并且不会用到任何从 Object.prototype 上继承来的方法，也不会将该对象作为其他对象的原型的时候，那么可以使用 Object.create(null)。比如，构造一个字典对象的时候。不过相对而言 const obj={}在浏览器中的执行速度是会比Object.create(null)快的，具体可点击链接test。不过你一般代码中这些性能差距完全是可以忽略不计的。 async/await with forEach()之前在工作中遇到了一个需求，实现一个简单的请求队列，大概意思就是这个页面有一个 list，我需要按 list 顺序依次发请求，多数据做一些操作，每次等前一个请求成功之后，再执行下一个，全部执行完毕之后，显示已完成。这不就是用 async/await就可以实现了。于是写了如下代码： 123456const waitFor = ms =&gt; new Promise(r =&gt; setTimeout(r, ms));[1, 2, 3].forEach(async num =&gt; &#123; await waitFor(1000) console.log(num)&#125;)console.log('Done') What？为什么await没有生效，直接就输出了1,2,3？谷歌搜索了一下，发现原来是forEach的锅。 我们简单来看一下 forEach的实现原理： 1234567Array.prototype.forEach = function(callback) &#123; // this represents our array for (let index = 0; index &lt; this.length; index++) &#123; // We call the callback for each entry callback(this[index], index, this) &#125;&#125; 我们可以看到它只是 for 循环的一个简单封装，而且在内部它只是简单做了一个回调，根本就不会wait。其实一些其它的数组方式比如map、reduce等等也是不支持的，因为 Array 的迭代方法就支持不支持参数函数返回 promise 的异步用法，有兴趣的可以自行了解。那我们直接用 for循环不就好了 1234567async function test() &#123; for (let index = 0; index &lt; [1, 2, 3].length; index++) &#123; await waitFor(1000) console.log(index) &#125; console.log('done')&#125; 或者 for-of更为简单 1234567async function test() &#123; for (let i of [1, 2, 3]) &#123; await waitFor(1000) console.log(i) &#125; console.log('done')&#125; 获取元素宽度说真的，我觉得前端麻烦的地方就是 API 太多了，我只是想获取一个元素的宽度居然有getBoundingClientRect().width 我使用 Async/Await 而不使用 Promises 的六个理由本文主要来自于 6 Reasons Why JavaScript’s Async/Await Blows Promises Away，在 medium 上，需要翻墙阅读。之前我很长一段时间内都是使用 promise 的，但遇到一些复杂业务的时候，发现还是写起来会很不爽，代码阅读性也有所欠缺。 简洁 对比 Promise，我们不需要书写.then，不需要新建一个匿名函数处理响应，也不需要再把数据赋值给一个我们其实并不需要的变量 a 但 Async/Await 也不是没有缺点的，很多人经常会错用它。比如我一个组件创建的的时候会异步向服务器发送三个请求，a、b、c。 很多人会这么写 123456async function mount() &#123; const resultA = await fetch('A') const resultB = await fetch('B') const resultC = await fetch('C') render(resultA, resultB, resultC)&#125; 虽然上面的这段写法相对于 promise 简洁了不少，但效率来说是不合格的。因为这个请求是异步的，毫无联系的，所有没必要顺序请求，他们三个明显可以异步并发的去请求。要想实现真正的异步，还是需要依赖 Promise.all 封装一层： 12345678async function mount() &#123; const result = await Promise.all( fetch('a.json'), fetch('b.json'), fetch('c.json') ) render(...result)&#125; 未完待续…]]></content>
  </entry>
  <entry>
    <title><![CDATA[Virtual DOM 性能好？]]></title>
    <url>%2F2019%2F06%2F14%2Fyuque%2FVirtual%20DOM%20%E6%80%A7%E8%83%BD%E5%A5%BD%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[每次面试，面试人一谈到 react 就必然会谈到 Virtual DOM，一谈到 Virtual DOM 就会说它比原生操作 DOM 性能哪里哪里好。 但任何一个 v-dom 框架都不会说自己的性能快过 DOM 操作。就拿 react 为例子，它的目标是：“每次数据变化都以最小的代价来更新真实 DOM”。引入 v-dom，在内存中比较虚拟节点，然后找出不同，之后执行更新。 就能更改页面上一个元素的内容，直接操作 DOM 的反应速度绝对会比你 diff 一次之后再更新来的快。但这时你可能会觉得当程序到达一定的复杂度之后，v-dom 性能上的优势才能体现出来。但是，无论你代价再少也好，v-dom 都是有消耗的，光从你要生成整个页面的 v-dom 就会比单单生成原生 dom 要多消耗一大截内存，更别说其中的复杂递归，比对，然后再变换。但是！它依然是纯 js 层面的计算，比起后面的 DOM 操作来说，依然便宜了太多。 所以 v-dom 真正的价值是什么？ 框架给你的保证是，你在不需要手动优化的情况下，我依然可以给你提供过得去的性能。 我认为是带来了跨屏能力，以及代码的可维护性， 同时为函数式的 UI 编程方式打开了大门。]]></content>
  </entry>
  <entry>
    <title><![CDATA[垃圾回收]]></title>
    <url>%2F2019%2F06%2F14%2Fyuque%2F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%2F</url>
    <content type="text"><![CDATA[作为编写程序的人，是可以做出“这个对象已经不再需要了”这样的判断，但计算机是做不到的。因此，如果程序（通过某个变量等等）可能会直接或间接地引用一个对象，那么这个对象就被视为“存活”；与之相反，已经引用不到的对象被视为“死亡”。将这些“死亡”对象找出来，然后作为垃圾进行回收，这就是 GC 的本质。 三大基础 GC 算法 引用计数法 它的基本原理是，在每个对象中保存该对象的引用计数，当引用发生增减时对计数进行更新。引用计数的增减，一般发生在变量赋值、对象内容更新、函数结束（局部变量不再被引用）等时间点。当一个对象的引用计数变为 0 时，则说明它将来不会再被引用，因此可以释放相应的内存空间。 引用计数最大的缺点，就是无法释放循环引用的对象。 标记清除法/标记压缩法这个算法假定设置一个叫做根（root）的对象（在 Javascript 里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象从 2012 年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对 JavaScript 垃圾回收算法的改进都是基于标记-清除算法的改进，并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义。标记清除算法有一个缺点，就是在分配了大量对象，并且其中只有一小部分存活的情况下，所消耗的时间会大大超过必要的值，这是因为在清除阶段还需要对大量死亡对象进行扫描。 复制收集算法在这种算法中，会将从根开始被引用的对象复制到另外的空间中，然后，再将复制的对象所能够引用的对象用递归的方式不断复制下去。但是，和标记相比，将对象复制一份所需要的开销则比较大，因此在“存活”对象比例较高的情况下，反而会比较不利。这种算法的另一个好处是它具有局部性（Lo-cality）。在复制收集过程中，会按照对象被引用的顺序将对象复制到新空间中。于是，关系较近的对象被放在距离较近的内存空间中的可能性会提高，这被称为局部性。局部性高的情况下，内存缓存会更容易有效运作，程序的运行性能也能够得到提高。 分代回收V8 引擎将保存对象的 堆 (heap) 进行了分代: 对象最初会被分在 新生区(New Space) (1~8M)，新生区的内存分配只需要保有一个指向内存区的指针，不断根据内存大小进行递增，当指针达到新生区的末尾，会有一次垃圾回收清理(小周期)，清理掉新生区中不再活跃的死对象。 对于超过 2 个小周期的对象，则需要将其移动至 老生区(Old Space)。老生区在 标记-清除 或 标记-紧缩 的过程(大周期) 中进行回收。 大周期进行的并不频繁。一次大周期通常是在移动足够多的对象至老生区后才会发生参考： JavaScript 垃圾回收机制 GC 的三大基础算法]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue面试题]]></title>
    <url>%2F2019%2F06%2F13%2Fyuque%2Fvue%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[很多人面试会问啥 vue 实现原理，但我觉得这略过分，有多少人会老老实实看过它的源码。但我觉得面者这也只是知道 vue 双向绑定的原理吧。 发布者-订阅者模式（backbone.js） 一般通过 sub, pub 的方式实现数据和视图的绑定监听，更新数据方式通常做法是 vm.set(‘property’, value)，这种方式现在毕竟太 low 了，我们更希望通过 vm.property = value 这种方式更新数据，同时自动更新视图，于是有了下面两种方式 脏值检查（angular.js） angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然 Google 不会这么 low，angular 只有在指定的事件触发时进入脏值检测，大致如下： DOM 事件，譬如用户输入文本，点击按钮等( ng-click ) XHR 响应事件 ( $http ) 浏览器 Location 变更事件 ( $location ) Timer 事件( $timeout , $interval ) 执行 $digest() 或 $apply() 数据劫持（vue.js） vue.js[2.0] 则是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 vue.js[3.0]采取了 proxy 的方式]]></content>
  </entry>
  <entry>
    <title><![CDATA[React面试题]]></title>
    <url>%2F2019%2F06%2F13%2Fyuque%2FReact%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[React面试题&amp;回答 React在使用 react 的过程中，我们绕不开渲染性能优化问题，因为默认情况下 react 组件的 shouldComponentUpdate 函数会一直返回 true，这回导致所有的组件都会进行耗时的虚拟 DOM 比较。在使用 redux 作为 react 的逻辑层框架时，我们可以使用经典的 PureComponent+ShallowCompare 的方式进行渲染性能优化https://foio.github.io/mobx-react/ MobX作为一个数据层框架，mobx 基于一个最简单的原则： 当应用状态更新时，所有依赖于这些应用状态的监听者（包括 UI、服务端数据同步函数等），都应该自动得到细粒度地更新。 在使用 mobx 作为 react 的 store 时，我们该如何进行渲染性能优化呢？ 通过分析源代码发现，在使用@observer 将 react 组件转换成一个监听者(Reactions)后，mobx 会为 react 组件提供一个精确的、细粒度的 shouldComponentUpdate 函数: 123456789shouldComponentUpdate: function(nextProps, nextState) &#123; ...... // update on any state changes (as is the default) if (this.state !== nextState) &#123; return true; &#125; // update if props are shallowly not equal return isObjectShallowModified(this.props, nextProps);&#125; 借助于 mobx 框架对 Observable 变量引用的跟踪和依赖收集，mobx 能够精确地得到 react 组件对 Observable 变量的依赖图谱，然后再用经典的 ShallowCompare 实现细粒度的 shouldComponentUpdate 函数，以达到 100%无浪费 render。这一切都是自动完成地，fantastic！使用 mobx 后，我们再也无需手动写 shouldComponentUpdate 函数了。 React Native 优势 跨平台 （只有 0.2% 的平台特定代码） 统一的设计语言，同时还能为不同平台提供不同设计 React 的 scale 很好。组件化，简单的生命周期,声明式 迭代速度快（主要是 hot reloading 很快） 大量基础设施的投入值得（网络、国际化、复杂动画、设备信息、用户信息等等都是通过一- 个桥把原生 api 暴露给 RN 的。） 同时他们在这里也指出：他们并不相信在一个已有 app 上集成 RN 是一件简单事儿，必须- 要大量且持续地投入基础设施才行（说好的「满意的地方」呢） 性能 （尽管大家都担心但是其实基本没有问题） 不过首次渲染比较慢，导致不适合用作启动屏、deeplink，也增加了可交互时间（TTI），另外掉帧不好 debug（说好的「满意的地方」呢） Redux（好用，虽然废话太多） 背后是原生，一些曾经不确定能不能做的功能（Shared element transitions、动画库 Lottie、网络层、核心基础设施）发现都能做 静态分析（eslint，prettier，一些性能检测） 动画 JS/React 的开源生态 Flexbox 有时候可以加上 Web 跨三端 劣势 论成熟度，稳定性，RN 比 不上 iOS 和 Android 原生。 由于 RN 的 Bug，有时我们必须维护自己的一个 RN 分支。 JS 缺少类型系统，Flow 太严格，TS 集成到已有项目也还有问题。 不好重构（JS 没有类型无法静态分析，重构引起的错误不能在编译时被捕捉到） JavaScriptCore 不一致性，更糟糕的是，现在都 8102 年了，RN （Android）带的还是不支持 ES 6 的 JSC RN 开源库质量参差不齐。比如在 iOS 上正常的库在 Android 上可能有意想不到的错误（因为为作者也许只熟悉 iOS 和 RN,并不熟悉 Android） 有时不得不白手起家，因为很多的基础框架中的库还没有 的 RN 封装。 崩溃监控库在 RN 上表现不是特别特定业。内没方案，只能自己搞。 Native Bridge 的由于 JS 的弱类型造成 Native 与 JS 通信 中类型的不匹配，容易造成错误。 启动时间，RN 框架初始化需要几秒，即使是在高端机器上。 新开页面的渲染时间，0.4 秒左右页面第一次渲染费时。 APP 大小。至少增加 12M。 直到目前都无法在 Android 上支持 64 位。 手势，iOS 和 Android 的手势 API 差距很大，不过喜闻 react-native-gesture-handler 发布了 1.0 版本。 长列表，虽然 RN 团队很努力了，但是由于 RN 的异步通信机制，长列表的流畅渲染，目前依然无解。 React Native 升级是个坑。 RN 中的 Accessibility 就是个大坑。 还有一些奇怪的 Bug，暂没有修复。 SavedInstanceState 在 Android 上跨进程的坑。 不是技术问题的问题 要用好 RN 你必须同时熟悉 iOS 和 Android ，当然还有 RN 本身，这就对我们工程师提出了更多挑战。 团队的管理，责任的划分。 RN 文档及相关资源不如 iOS 和 Android 的丰富。 面试题reactjs-interview-questions]]></content>
  </entry>
  <entry>
    <title><![CDATA[网络面试题]]></title>
    <url>%2F2019%2F06%2F13%2Fyuque%2F%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[WebSocket WebSocket 与 HTTP 什么关系呢？简单来说，WebSocket 是一种协议，是一种与 HTTP 同等的网络协议，两者都是应用层协议，都基于 TCP 协议。但是 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。 WebSocket 与 Socket网络应用中，两个应用程序同时需要向对方发送消息的能力（即全双工通信），所利用到的技术就是 socket，其能够提供端对端的通信。对于程序员而言，其需要在 A 端创建一个 socket 实例，并为这个实例提供其所要连接的 B 端的 IP 地址和端口号，而在 B 端创建另一个 socket 实例，并且绑定本地端口号来进行监听。当 A 和 B 建立连接后，双方就建立了一个端对端的 TCP 连接，从而可以进行双向通信。WebSocekt 是 HTML5 规范中的一部分，其借鉴了 socket 的思想，为 client 和 server 之间提供了类似的双向通信机制。同时，WebSocket 又是一种新的应用层协议，包含一套标准的 API；而 socket 并不是一个协议，而是一组接口，其主要方便大家直接使用更底层的协议（比如 TCP 或 UDP） 什么是 Socket.IOSocket.IO 是一个封装了 Websocket、基于 Node 的 JavaScript 框架，包含 client 的 JavaScript 和 server 的 Node。其屏蔽了所有底层细节，让顶层调用非常简单。另外，Socket.IO 还有一个非常重要的好处。其不仅支持 WebSocket，还支持许多种轮询机制以及其他实时通信方式，并封装了通用的接口。这些方式包含 Adobe Flash Socket、Ajax 长轮询、Ajax multipart streaming 、持久 Iframe、JSONP 轮询等。换句话说，当 Socket.IO 检测到当前环境不支持 WebSocket 时，能够自动地选择最佳的方式来实现网络的实时通信。 WebSocket VS SSE(Server-Sent Events)Server-sent Events 其实很多人都不知道这东西，但其实肯定用过的，webpack-hot-middleware就是运用该原理进行热更新的，当然webpack-dev-server使用的是 WebSocket。SSE 与 WebSocket 作用相似，都是建立浏览器与服务器之间的通信渠道，然后服务器向浏览器推送信息。总体来说，WebSocket 更强大和灵活。因为它是全双工通道，可以双向通信；SSE 是单向通道，只能服务器向浏览器发送，因为流信息本质上就是下载。如果浏览器向服务器发送信息，就变成了另一次 HTTP 请求。但是，SSE 也有自己的优点。 SSE 使用 HTTP 协议，现有的服务器软件都支持。WebSocket 是一个独立协议。 SSE 属于轻量级，使用简单；WebSocket 协议相对复杂。 SSE 默认支持断线重连，WebSocket 需要自己实现。 SSE 一般只用来传送文本，二进制数据需要编码后传送，WebSocket 默认支持传送二进制数据。 SSE 支持自定义发送的消息类型。 相关补充文章 Server-Sent Events-阮一峰 WebSockets vs. Server-Sent events/EventSourceWebSocket 推荐阅读文章WebSocket 是什么原理？TCP VS UDPTCP UDP 这两个东西已经是老生常谈了，基本每个面试都会问一下，还不了解的赶快去补习一下。但发现一个问题，大家都只是知道这两者的区别是什么，完全不知道他们各自的应用场景是什么？UDP 场景： 实时音视频是可以而且应该用 UDP 的，一方面因为它常常涉及到网络穿透，另外一方面它不需要重传。——我需要实时的看到你的图像跟声音，至于中间丢一帧什么的完全不重要。而为了重传往往会造成延迟与不同步，考虑一下，某一帧因为重传，导致 0.5 秒以后才到，那么整个音视频就延迟了 0.5 秒。考虑一下接收方看视频，如果使用 TCP 导致视频的中间延迟了 0.5 秒，只要我不按「快进」键，那么后续的视频全都会比发送方延迟 0.5 秒。这种延迟是累加的，随着持续丢帧，延迟会越来越大，达到数秒，甚至分钟级，这会严重影响实时音视频的用户体验。因此「实时音视频聊天」功能通常都会使用 UDP 实现。 网络真的非常非常可靠，以至于你完全不需要考虑 UDP 丢包问题的情况。典型的例子应该是专门为有线局域网设计的协议。 另外一个问题是 TCP 是纯粹的流式数据，所以制定传输协议的时候，接受方需要自行判定一个包的开始和结束，因为你完全可能接受到半个包或者两个包。——如果数据报的起止判定对你具体的程序会成为大问题，也可以考虑 UDP。 采用 UDP 有 3 个关键点： 网络带宽需求较小，而实时性要求高 大部分应用无需维持连接 需要低功耗]]></content>
  </entry>
  <entry>
    <title><![CDATA[常规面试题]]></title>
    <url>%2F2019%2F06%2F13%2Fyuque%2F%E5%B8%B8%E8%A7%84%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[事件委托应该是前端最经常问的一个问题。 但其实里面有非常非常多的知识点可以考察。 css last-of-type last-child 事件委托的好处 addEventListener 第三个参数 实现 index 类数组 =&gt; 数组 querySelectorAll 方法相比 getElementsBy 系列方法有什么区别 HTMLCollection NodeList 区别 https://www.zhihu.com/question/24702250 12345678const ul = window.document.getElementsByTagName('ul')[0]ul.addEventListener('click', e =&gt; &#123; const children = [...ul.getElementsByTagName('li')] //htmlCollection =&gt; array if (e.target &amp;&amp; e.target.nodeName.toLowerCase() === 'li') &#123; const index = children.indexOf(e.target) console.log(index) &#125;&#125;) 一道有意思的面试题 100*100 的 canvas 占多少内存？ 你有必要知道的几个 JavaScript 面试题 1. 使用 typeof bar === “object” 判断 bar 是不是一个对象有神马潜在的弊端？如何避免这种弊端？大部分情况下 typeof 是可信的，但 js 就是这样不靠谱，总是有一些边缘 case。 1234567typeof &#123;&#125; //'object'typeof [] //'object'typeof null //'object'typeof new String() //'object'typeof NaN //'number'const var reg = /pop/gtypeof reg //'object' 这时候你可以说使用 instanceof。但 instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型。 简而言之就是 123'' instanceof String //falsenew String() instanceof String //truenew String() instanceof Object //true 只有使用构造函数创建的基本类型可以正确显示。所以到底有没有靠谱的校验类型方法？答案是有的 详情见玉伯的分享 12345678910111213var toString = Object.prototype.toStringfunction isObject(obj) &#123; return toString.call(obj) === '[object Object]'&#125;function isString(obj) &#123; return toString.call(obj) === '[object String]'&#125;function isArray(obj) &#123; return toString.call(obj) === '[object Array]'&#125;function isFunction(obj) &#123; return toString.call(obj) === '[object Function]'&#125; 附加问题： 我们知道 typeof new String(“xxx”) 返回 “object”，请问 typeof String(“xxx”) 返回什么？为什么？ 返回”string”，因为直接调用 String 返回的是一个字符串，而 new String 返回的是一个 String 对象。2. 下面的代码会在 console 输出神马？为什么？12345;(function() &#123; var a = (b = 3)&#125;)()console.log(typeof a)console.log(b) 12console.log(typeof a) //undefinedconsole.log(b) //3 这题是以前比较常见的变量提升的问题 它实际执行步骤是这样子的 12b = 3var a = b 并且 b 变成一个全局变量，而 a 还是一个局部变量，所以你在外部 console 是会报错的。 3. 下面的代码会在 console 输出神马？为什么？12345678910111213var myObject = &#123; foo: 'bar', func: function() &#123; var self = this console.log('outer func: this.foo = ' + this.foo) console.log('outer func: self.foo = ' + self.foo) ;(function() &#123; console.log('inner func: this.foo = ' + this.foo) console.log('inner func: self.foo = ' + self.foo) &#125;)() &#125;&#125;myObject.func() 这题是最简单的作用域问题，没啥好讨论的了。 4. 将 JavaScript 代码包含在一个函数块中有神马意思呢？为什么要这么做？换句话说，为什么要用立即执行函数表达式（Immediately-Invoked Function Expression）。IIFE 有两个比较经典的使用场景，一是类似于在循环中定时输出数据项，二是类似于 JQuery/Node 的插件和模块开发。 12345for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(i) &#125;, 1000)&#125; 上面的输出并不是你以为的 0，1，2，3，4，但输出的全部是 5，这时 IIFE 就能有用了： 1234567for (var i = 0; i &lt; 5; i++) &#123; ;(function(i) &#123; setTimeout(function() &#123; console.log(i) &#125;, 1000) &#125;)(i)&#125; ES6 的话，可以用 let 12345for (let i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(i) &#125;, 1000)&#125; 而在 JQuery/Node 的插件和模块开发中，为避免变量污染，也是一个大大的 IIFE： 123;(function($) &#123; //代码&#125;)(jQuery) 5. 在严格模式(‘use strict’)下进行 JavaScript 开发有神马好处？ 消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的 Javascript 做好铺垫。6. 下面两个函数的返回值是一样的吗？为什么？1234567891011function foo1() &#123; return &#123; bar: 'hello' &#125;&#125;function foo2() &#123; return &#123; bar: 'hello' &#125;&#125; 对于 return 、break、continue 等语句，如果后面紧跟换行，解析器一定会自动在后面填充分号(😉，所以上面的第二个函数就直接被 return了。所以第二个函数是返回 undefined。 7. 神马是 NaN，它的类型是神马？怎么测试一个值是否等于 NaN?NaN 是 Not a Number 的缩写，JavaScript 的一种特殊数值，其类型是 Number，可以通过 isNaN(param) 来判断一个值是否是 NaN： 12345678910console.log(isNaN(NaN)) //trueconsole.log(isNaN(23)) //falseconsole.log(isNaN('23')) //false 因为执行的时候先回转化为数字 所以 '23'=&gt; 23console.log(isNaN('ds')) //trueconsole.log(isNaN('32131sdasd')) //true 先回 Number("123ABC") 结果是 NaNconsole.log(NaN === NaN) //falseconsole.log(NaN === undefined) //falseconsole.log(undefined === undefined) //falseconsole.log(typeof NaN) //numberconsole.log(Object.prototype.toString.call(NaN)) //[object Number] ES6 中，isNaN() 成为了 Number 的静态方法：Number.isNaN().它的 polyfill 实现起来也很简单–利用了 NaN 自身永不相等于自身这一特征 1234const isNaN = function(value) &#123; const n = Number(value) return n !== n&#125; 8. 解释一下下面代码的输出12console.log(0.1 + 0.2) //0.30000000000000004console.log(0.1 + 0.2 == 0.3) //false 另一道非常经典的面试题，js 精度问题 JavaScript 浮点数陷阱及解法JavaScript 存储任何数字都是遵循 IEEE-754 标准，使用 64 位固定长度来表示，也就是标准的 double 双精度浮点数。所以为什 0.1+0.2=0.30000000000000004？ 计算步骤为： 12345// 0.1 和 0.2 都转化成二进制后再进行运算0.00011001100110011001100110011001100110011001100110011010 +0.0011001100110011001100110011001100110011001100110011010 =0.0100110011001100110011001100110011001100110011001100111// 转成十进制正好是 0.30000000000000004 解决方案 你可以使用一些成熟的库如：big.js，bignumber.js。 或者对精度要求不高的情况下 直接 toFixed就可以了。不过注意它得到的值可能是不准确的。如：1.005.toFixed(2) 返回的是 1.00 而不是 1.01。原因： 1.005 实际对应的数字是 1.00499999999999989，在四舍五入时全部被舍去！ 9. 实现函数 isInteger(x) 来判断 x 是否是整数可以将 x 转换成 10 进制，判断和本身是不是相等即可： 123function isInteger(x) &#123; return parseInt(x, 10) === x&#125; 10. 在下面的代码中，数字 1-4 会以什么顺序输出？为什么会这样输出？12345678910;(function() &#123; console.log(1) setTimeout(function() &#123; console.log(2) &#125;, 1000) setTimeout(function() &#123; console.log(3) &#125;, 0) console.log(4)&#125;)() 最简单的运行提了，如果这都不会的话，真应该好好补习补习基础了。 11. 判断一个字符串是不是回文字符串12345678910function isPalindrome(str) &#123; str = str.replace(/\W/g, '').toLowerCase() return ( str == str .split('') .reverse() .join('') )&#125; 12. 写一个按照下面方式调用都能正常工作的 sum 方法12console.log(sum(2, 3)) // Outputs 5console.log(sum(2)(3)) // Outputs 5 13. 据下面的代码片段回答后面的问题12345678for (var i = 0; i &lt; 5; i++) &#123; var btn = document.createElement('button') btn.appendChild(document.createTextNode('Button ' + i)) btn.addEventListener('click', function() &#123; console.log(i) &#125;) document.body.appendChild(btn)&#125; 没啥难度，不说了 15. 下面的代码会输出什么？为什么？123456console.log(1 + '2' + '2')console.log(1 + +'2' + '2')console.log(1 + -'1' + '2')console.log(+'1' + '1' + '2')console.log('A' - 'B' + '2')console.log('A' - 'B' + 2) 这个主要考察的隐式转换，规则太多太复杂了，我也记不住，如果真有面试官问你这个的话，随缘吧。 16. 解释下列代码的输出1234console.log('0 || 1 = ' + (0 || 1))console.log('1 || 2 = ' + (1 || 2))console.log('0 &amp;&amp; 1 = ' + (0 &amp;&amp; 1))console.log('1 &amp;&amp; 2 = ' + (1 &amp;&amp; 2)) 运算符优先级的问题，这题同上，遇到就随缘吧，我反正搞不清也记不住。 17. 解释下面代码的输出12console.log(false == '0')console.log(false === '0') ==和===的区别，太基础略。 18.移动端问题 1. 你怎么提高一个长列表在手机端滑动的流畅度这里主要考察的是否知道 passive这个属性首先解释一下为什么会卡顿： 当你触摸滑动页面时，页面应该跟随手指一起滚动。而此时你绑定了一个 touchstart 事件，你的事件大概执行 200 毫秒。这时浏览器就犯迷糊了：如果你在事件绑定函数中调用了 preventDefault，那么页面就不应该滚动，如果你没有调用 preventDefault，页面就需要滚动。但是你到底调用了还是没有调用，浏览器不知道。只能先执行你的函数，等 200 毫秒后，绑定事件执行完了，浏览器才知道，“哦，原来你没有阻止默认行为，好的，我马上滚”。此时，页面开始滚。 题外话，这里也可以考察你对addEventListenerapi 的熟练度，很多人其实不知道addEventListener其实第三个参数除了可以传true or false，还可以传一个对象。 12345&#123; capture: Boolean, // 表示`listener`会在该类型的事件捕获阶段传播到该`EventTarget`时触发 once: Boolean, // 表示`listener`在添加之后最多只调用一次。如果是`true`，`listener`会在其被调用之后自动移除 passive: Boolean, // 表示`listener`永远不会调用`preventDefault()`。如果`listener`仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告&#125; 拓展：will-change 、pointer-events 19.用 setTimeout 实现 setIntervalrender props 和 HOC 的区别 purecomponent 柯里化 高阶函数 尾调用 vue 3.0 proxy Object.defineProperty 原因 线上版本回退 发布流程 开发生产环境区分 调试 dokder 持续集成 babel-polyfil babel-plugin-transform-runtime babel-preset-env htttp2 有哪些优势，对于前端来说会有什么影响？ 设计一个登录系统 es6 私有方法 WeakMap 顺序存储结构与链式存储结构的比较（也可以说的顺序表与链表的比较） HOC(高阶组件)和 Decorator(装饰器)的区别是什么？ 如何使用一个 Decorator 来修饰一个函数? https://github.com/sunyongjian/blog/issues/32 iOS 下 input 无法自动聚焦的问题 手写实现以下事件委托函数 function delegate(parent, selector, handle) {} 手写实现 inherit 函数 手写实现 throttle 函数 请解释 XSS 与 CSRF 分别是什么，两者有什么联系？如何防御？ 手写代码实现一下 Array.prototype.trim 这个函数，并写个测试用例跑给我看下 面向切面编程和函数式编程听说过吗 图灵完备理论知道吗？关于图灵的其他知识知道吗？ 如果一系列操作数据的规则（如指令集、编程语言、细胞自动机）可以用来模拟单带图灵机，那么它是图灵完备的。图灵机由以下几个部分组成： 一条无限长的纸带 TAPE。 一个读写头 HEAD。 一套控制规则 TABLE。 一个状态寄存器。 图片懒加载的两种实现形式 如何实现图片懒加载； 如何提高图片懒加载的效率； PWA 的原理； 如何写一个 PWA； getBoundingClientRect 方法的弊端； 前端性能优化有哪些； 静态资源加载和更新的策略； CDN 服务器的了解和使用；缓存静态资源的注意事项； history 路由和 hash 路由的区别, 在浏览器有什么影响； http 1.1 与 http 2 的区别； 遇到过什么 Webpack 上的坑； 什么是虚拟 DOM； 为什么虚拟 DOM 的操作比 DOM 更快； 谈一下你对 MVVM 的认识； 谈一下你对 Vue 的认识，以及 Vue 底层实现的机制； 写一个自定义事件系统，实现 on、off、emit API，要求可以同时触发多个事件，也可同时取消多个事件 使用 requestAnimationFrame 实现类似 setInterval 的计时器 实现一个类似百度的搜索框，就是一边输入内容，一边在一个下拉列表显示搜索结果，需要考虑哪些问题？ file-loader 和 url-loader 区别 淘宝 P6 前端要求，比较泛的能力描述，供参考： 掌握程序设计的一般性原则，能正确应用设计模式 提炼可复用组件，为类库贡献高质量代码；至少掌握一门后端语言，并有相关的开发使用经验 理解程序内部原理，能快速定位解决疑难杂症；通过开发、使用、推广效率工具让自己与团队的效率得到提高 有效跟进，能独立计划实施复杂项目，过程监控，有预案，保证结果 有效传达思想观念信息，把握别人的意图立场，快速与别人达成共识 积极的学习，并学以致用，甚至突破经验与常规思维方式，引入新的方法，流程等 精通各种前端技术（包括 HTML/CSS/JavaScript 等），熟悉 ES6 语法，具备跨终端（Mobile+PC）的前端开发能力，熟悉网络协议（HTTP/SSL），熟悉常见安全问题和对策； 熟悉前端工程化与模块化开发，并有实践经验（如 gulp/webpack、VueJS/React 等）； 熟悉 NodeJS，并有实践经验；熟悉一门非前端的语言（如 Java/C/C++ 等），加分； 有桌面客户端相关开发经验（如 Electron/VSCode Plugin 等），加分； 熟悉 TypeScript，并有较大项目实践经验，加分； 有独立的开源项目或者参与知名开源项目经验，加分； 百度阿里网易大疆等大小厂前端校招面筋 如何轻松拿到淘宝前端 offer]]></content>
  </entry>
  <entry>
    <title><![CDATA[面试题]]></title>
    <url>%2F2019%2F06%2F13%2Fyuque%2F%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[TIP你的简历是自己工作的答卷，项目经历是你给面试官出的考纲。所以，我的面试一定是与我的简历、工作经历相关的，一些面试题并不一定适用于任何人，但是你可以从中了解他们考察的点，以及侧重点。基础知识可以查漏补缺。 前端工程师手册30-seconds-of-interviewsfront-end-interview-handbook33-js-concepts33-js-concepts 中国国情版Git 飞行规则 看了这个常规的 git 应该没什么问题了node-interviewNode.js-Troubleshooting-Guide Node.js 应用线上/线下故障、压测问题和性能调优指南手册2018 大厂高级前端面试题汇总Daily-Interview-Question 每天一道前端大厂面试题https://github.com/forthealllight/blog/issues想成为一个好的前端工程师，光有强大的编程能力是远远不够的，还有很多软知识需要知道。学会与人沟通。前端是一个承上启下的工作，在实际业务之中你除了要面对代码之外还需要对接 UI、产品、后端和其它前端有时候经常也会和运营啊广告销售打交道。因此怎么与其他角色很好的沟通也是一个非常重要的能力，代码写的再好，但不满足需求也是白搭。需求明确再动手；发现问题尽快解决；意见分歧不要拒绝沟通；学会换位思考，不要总站在自己的角度想当然； 华尔街见闻面试题请先 fork 本项目，之后按照题目规则，完成功能之后，请不要依赖任何外部框架。 页面中有一个 ul列表，里面有 20 个 li，和若干个其它元素：div，需要实现一个功能，点击任何一个 li都会 alert hello world，点击其它元素没反应 在线demo 注意：请在在线 demo 的基础上进行修改， 在第一题的基础上进行修改，现在点击任何 li需要 alert 它的位置，即 它的 index，第一个 li alert(1)，第二个 alert(2)，以此类推 需要实现一个功能，每过 1s，往列表的末端添加新的5 个li元素，并且li的内容是它的位置，并且当页面的 li 个数超过 50 个时，停止添加。 请根据设计稿，写成相应的静态页面，并且有如下要求 根据 api 拉取列表数据 可以使用 Vue、React 或者任何框架还原页面 需要自适应 适配 PC 和 Mobile 最后一个 item 不需要下划线 点击任何一个 item alert 它的 title title 超过两个需要省略超出部分 对 Node.js 的看法 算法 OSI 七层协议？ http 和 https 有什么区别？ https 使用上有什么注意点？ https 和 http 性能有什么区别？ 常见的排序方法，你都熟悉那些？ 说下希尔排序的过程？ 希尔排序的时间复杂度和空间复杂度多少？（ 希尔排序的时间复杂度是：O（nlogn）～ O（n2），平均时间复杂度大致是 O(n√n)） 时间复杂度怎么推测的？ 数据结构你对那些比较熟悉？ 二叉树是什么啊？ 平衡二叉树（AVL）有什么特点？ 平衡二叉树（AVL）有什么好处？ 平衡二叉树（AVL）和红黑树的区别？ 平衡树的插入和删除的时间复杂度？ 怎么实现 短链？ 设计模式https://juejin.im/post/5c2e10a76fb9a049c0432697设计模式定义：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。通俗一点来讲就是在某种特定场合下对某个问题的一种解决方案。所有的设计模式的实现都遵循一条原则，‘找出程序变化的地方，并将变化封装起来’。 设计原则设计本身是为了提高代码可利用性，增加可维护性，符合以下的原则： 单一原则：永远不应该有多于一个原因来改变某个类。当我们做系统设计时，如果发现有一个类拥有了两种的职责，那就问自己一个问题：可以将这个类分成两个类吗？如果真的有必要，那就分吧。千万不要让一个类干的事情太多！ 开放封闭原则：软件实体，如：类、模块与函数，对于扩展应该是开放的，但对于修改应该是封闭的。当需求有改动，要修改代码了，此时您要做的是，尽量用继承或组合的方式来扩展类的功能，而不是直接修改类的代码。当然，如果能够确保对整体架构不会产生任何影响，那么也没必要搞得那么复杂了，直接改这个类吧。 最少知识原则（迪米特原则）：尽量减少对象之间的交互，从而减小类之间的耦合。简言之，一定要做到：低耦合，高内聚。 里氏转换原则：在使用基类的的地方可以任意使用其子类，能保证子类完美替换基类。 接口隔离原则：一个类与另一个类之间的依赖性，应该依赖于尽可能小的接口。不要对外暴露没有实际意义的接口 依赖倒转原则：引用一个对象，如果这个对象有底层对象，直接引用底层对象，比如可以直接用小桶打水，就没必要引用大桶向大桶灌水再用大桶。单例模式应用场景：全局唯一模态框，登录注册。 延伸：单例懒加载 定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。策略模式应用场景：计算不同绩效的工资，表单验证 将计算逻辑或者验证逻辑的算法单独封装。 定义：一系列的算法，将它们一个个封装起来，并且使它们可以相互替代。代理模式应用场景：图片懒加载(proxyImage),代理缓存，代理合并请求 定义：一个对象提供一个代用品或占位符，以便控制对它的访问。迭代器模式定义：提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。发布-订阅模式应用场景：DOM 事件系统(addEventListener)，网站登录系统 定义：又叫观察者模式，它定义了对象间的一种一对多的依赖关系。当一个对象的状态发生变化时，所有依赖它的对象都将受到通知。 延伸：订阅不同事件，订阅离线缓存命令模式组合模式模板模式延伸：好莱坞原则享元模式定义：核心是运用共享技术来有效的支持大量颗粒度的对象，常用于性能优化。 延伸：对象池职责链模式定义：避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，知道有一个对象处理它为止。 例子：手机商城-是否有 500 打折券-&gt;200 打折券 -&gt;有库存…，aop，上传组件适配 html5=&gt;flash=&gt;xxx中介者模式定义：作用是解除对象与对象之间的紧耦合关系，所有的相关对象都通过中介者对象来通信装饰者模式状态模式适配器模式定义：作用是解决两个软件实体间的接口不兼容问题。常规面试题 网络面试题 React面试题 VUE面试题]]></content>
  </entry>
  <entry>
    <title><![CDATA[文章收集]]></title>
    <url>%2F2019%2F06%2F13%2Fyuque%2F%E6%96%87%E7%AB%A0%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[说明主要是用来收集汇总平时看过得一些不错的文章，方便日后查找 Vue手摸手，带你用 vue 撸后台 系列一(基础篇)手摸手，带你用 vue 撸后台 系列二(登录权限篇)手摸手，带你用 vue 撸后台 系列三 (实战篇)手摸手，带你用 vue 撸后台 系列四(vueAdmin 一个极简的后台基础模板)手摸手，带你封装一个 vue component手摸手，带你优雅的使用 icon 前端Press Enter to Submit 背后的那些事Webnovel 国际化实践Things I Don’t Know as of 2018The TypeScript Tax: A Cost vs Benefit Analysis 主要讲 ts 收益，具有一定可读性TypeScript 解决了什么痛点？ 比较中肯的一个答案，做技术不要盲目跟风 GraphQLGraphQL 核心概念RPC vs REST vs GraphQLWhy use GraphQL, good and bad reasons 职业发展一个程序员的成长之路 张云龙大佬的文章，强推！！值得反复阅读。开发者如何在「技术+管理」的路上越走越宽？蔡志忠：努力是没有用的 视频计算机科学速成课 计算机科学基础的系列视频，很不错，浅显易懂，看完这四十节课能多计算机世界有一个大概的整体认知。 其它前端人工智能？TensorFlow.js 学会游戏通关谈谈 WebSocket https://zhuanlan.zhihu.com/p/37171897 小程序只需两步获取任何微信小程序源码 挺有意思的一篇文章 node基于 node.js 的脚手架工具开发经历 How to build a CLI with Node.js 网络什么是 RPC 框架？前端技术清单关于 JavaScript 单线程的一些事从零开始开发一款属于你的 Visual Studio Code 插件 AST平庸前端码农之蜕变 — AST]]></content>
  </entry>
  <entry>
    <title><![CDATA[网站]]></title>
    <url>%2F2019%2F06%2F13%2Fyuque%2F%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[常看的网站 awesome-f2e-libs sorrycc 整理的个人关注使用的前端库 overreacted react Dan 的个人博客，更新频率很高 DailyJS codeburst Github github 短域名服务 shields Github README 里面的装逼小图标 Emoji 方便平时写查找 emoji emoji.muan 同上 而且更全 git-awards github ranking 没事可以查着玩玩 http://githubrank.com/ github 按照 followers 排名 github-rank同上，githubrank 基本算挂了已经，只能用这个新的 star-history 展示一个项目 Stars 增长规矩曲线 probot 基于 github 做一个小机器人。可以做很多 workflow 的事情 开发 can i use 前端常用网站了 查看不同属性和方法的兼容性 Squoosh 谷歌出品在线免费图片压缩工具 神器 codesandbox-client - 在线 web 开发容器 astexplorer - 一个在线 ast 生成器 30 seconds of code 收集了许多有用的代码小片段 zeplin 前端和设计师神器，有标注、Style Guide、版本管理、简单的团队协作，重点是前端不用写 css 了，复制就可以了。 iconfont 阿里出的图标库，非常实用，支持 svg、font、png 多种格式，基本现在所有图标都在上面找。 cssicon 所有的 icon 都是纯 css 画的 缺点：icon 不够多 智图 腾讯出品 在线图片压缩 支持转成 webP 处理静态图片时候很好用 picdiet 另一个图片压缩网站 CSS triangle generator 帮你快速用 css 做出三角形 cssarrowplease 帮你做对话框三角的 clippy 在线帮你使用 css clip-path 做出各种形状的图形 Regular Expressions 在线正则网站 jex 正则可视化网站，配合上面的 Regular Expressions，写正则方便很多 jsfiddle 在线运行代码网站 很不错，可惜要翻墙 codepan 在线运行代码网站 不用翻墙，可以自己部署 fiddle.md 一个方便的在线共享 markdown 在线笔试题一般都用这个 jsdelivr cdn 服务 unpkg cdn 服务 coderpad 远程面试的神器，可以让面试者远程写代码 不过需要翻墙 icode 有赞团队出品的 coderpad 可以互补，它不需要翻墙 codeadvice 又一个让面试者远程写代码的网址 snipper 一个代码协同的网站。你新建一个代码片段，然后把网址分享给其他人，就可以看到他们的实时编辑。 codesandbox 一个可以在线编辑且提供在线 demo 的网站 支持 vue react angular 多种框架 神器 codrops 上面的交互都非常酷炫 bgremover 在线图片去底工具 photopea 一个网页端 Photoshop 很变态 bestofjs 查看一个项目增长经历，Star 数变化的网站，辅助你判断这个库的质量 stackblitz 一款在线 IDE,主要面向 Web 开发者,移植了很多 VS Code 的特性与功能 programmingfonts.org 一个专门介绍编程字体的网站 早报 一个个人开发者的前端开发的分享日报 emoji-search 帮你快速找到能表达你情感的 emoji gitmoji 通过 emoji 表达 git 的操作内容 starcharts 可以把你一个项目的 stars 增长轨迹当做 svg 放在 readme 中 mockapi 一个还不错的在线 mock 服务（可在线可视化编辑），可以满足大部分简单需求了 coder 在线版 VS Code browserstack 远程调整各种版本浏览器 兼容性问题 carbon 根据源码生成图片 主要作用是让你打代表片段分享的时候更好看一点 clipboard2markdown 将你所有复制进去的内容都转化为 markdown grammarly 英语写作检查工具 quickchart 通过 URL 生成图表的开源服务 hipdf 一站式在线 PDF 解决方案 whimsical 画路程图 Lorem Picsum 提供免费的占位图 sm.ms 免费图床 设计 https://www.photopea.com/ Photopea,高级图片编辑器 uimovement 能从这个网站找到不少动画交互的灵感 awwwards是一个一个专门为设计精美的网站以及富有创意的网站颁奖的网站 dribbble 经常能在上面找到很多有创意好看的 gif 或者图片，基本上我所有的图都是上面招的 Bēhance dribbble 是设计师的微博，Bēhance 是设计师的博客 Logojoy 使用 ai 做 logo 的网站，做出来的 logo 质量还不错。 brandmark 另一个在线制作 logo 网站 instant 又一个 logo 制作网站 logo-maker 又一个 logo 制作网站 这个更简单点 就是选模板之后微调 coolors 帮你在线配色的网站 你能找到不少配色灵感 colorhunt 另一个配色网站 uigradients 渐变色网站 designcap 在线海报设计 Flat UI 色表 Flat UI 色表 0to255 颜色梯度 Ikonate 提供免费的图标 icons remixicon 又一个提供免费图标 icons feather 免费的 icons nord 北欧性冷淡风主题配色 Unsplash 提供免费的高清图片 colorkitty 从你的图片中提取配色 有趣 帮你百度一下 可以 点我测试一下- 国际版 同帮我百度一下-点我测试一下- wallhaven 壁纸网站- URL 地址播放 Emojis 动画 在地址栏里面播放 emoji Can’t Unsee 强烈建议前端、客户端、UI 开发的同学玩下，检查一下自己对设计稿的敏感度怎么样 ggtalk 平时一直在听的一个技术博客 awesome-comment 里面收集了很多有趣的代码注释 text-img 都将图片转化为 ascii 用来写注释 weird-fonts 将普通字母转化为 特殊 unicode snake 在地址栏里面玩贪吃蛇 交互 微交互 里面收集了市面上很多很好的微交互例子 值得学习 Little Big Details 同上，一个国外微交互汇集网站 cruip 登录页的各种页面设计，可以免费下载模板 Comixify 一个波兰团队做了非常好玩的工具，可以把视频自动转成漫画，上图是他们提供的 demo，效果很棒。 taiko-web 太鼓达人网页版 只能说很 6 Csscss-tricks 一个学习 css 不错的网站 有很多有意思的 demo 教程 npx 教你怎么合理的使用 npx hacksplaining 网络安全学习网站 产品 产品大牛 什么有很多完整的产品原型可以借鉴 磨刀 快速出 ui 原型 实用 typeform 一个国外的在线调查问卷网站 Talk peerigon-talks 收集了不少有意思的 talks 算法 leetcode 用 js 刷 leetcode ### PC UI https://baidu.github.io/amis/一种基于特定 JSON 格式生成 MIS 页面的工具 http://fis.baidu.com/ 简单页面制作 https://github.com/fex-team/fis fis git 源码 UmiJS 可插拔的企业级 react 应用框架。]]></content>
  </entry>
  <entry>
    <title><![CDATA[推荐库]]></title>
    <url>%2F2019%2F06%2F13%2Fyuque%2F%E6%8E%A8%E8%8D%90%E5%BA%93%2F</url>
    <content type="text"><![CDATA[太常用的一些库，比如 lodash、axios、echarts、normalize.css等就不再下面推荐了。这里主要推荐一下自己平时常用，提高效率的，但大家可能又不知道的一些库。 前端常用 sweetalert2 一个自适应，且自定义性强的弹出框（零依赖） https://bower.io/ 管理web库 tippy.js 最著名的 tooltip/popover library text-mask 可以让 input 按照规则输入(如电话,email,日期,信用卡等)，特殊格式 input dinero.js 用来创建、计算和格式化货币价值的不可变的框架，支持国际化 lerna 大项目版本控制工具，项目中可以有多个 package.json 文件 img-2 一个提高图片加载性能和体验的库，懒加载使用 web worker 模糊预览 fingerprintjs 是一个快速的浏览器指纹库，通浏览环境的一系列配置生成 id ajv 一个 json schema 验证的库 dayjs 一个轻量级类 moment.js API 时间库 primjs 让页面支持代码高亮 ReLaXed 一个将 document html 转成 PDF 的工具 uppy 一个很好看的也很好用的 前端上传库 Filepond 一个小巧的文件上传库 tui-calendar 功能全面的日程安排日历控件，还支持拖拽 tui.editor markdown 所见即所得编辑器 tabler - 基于 Bootstrap 4 的 Dashboard UI Kit 和美观 高颜值 ui 模板 pulltorefresh.js - 下个下拉刷新插件 lulu - 腾讯阅文基于 jQuery，针对 PC 网站 IE8+（peak 主题）的前端 UI 框架 chancejs - 生成随机数据的库 spritejs - 360 奇舞团出的跨平台绘图对象模型 workbox - 让你的网站更方便的变成 pwa tui.image-editor - 一个功能齐全的在线图片编辑，基于 canvas nanoid - 前端轻量 unique string ID 生成库 rxdb - 一款开源的快速、灵活的客户端数据库，支持各种浏览器以及 NodeJS，Electron、React 等等，是 PouthDB 之上的一个封装库 percollate - 命令行工具 能将网页转换成 pdf rawact - 一个 babel 插件，把 react 组件转为原生 dom irondb - 是一个浏览器 key-value 储存的封装库，把 Cookies、IndexedDB、LocalStorage、SessionStorage 统一成一个接口。它的最大特色就是数据冗余机制，即使某种底层储存机制失效，它可以从其他机制恢复数据。 big.js 解决 js 浮点数问题。 主要就是 Big Number 或者小数点温柔 bignumber.js - 同上 stickybits - CSS 的 position: sticky 是一个很有用的设置，但是老的浏览器不支持。这个 JS 库是该功能的垫片库。 react-jsonschema-form - Mozilla service 开源了一个通过 JSON 直接生成表单的 React 组件 cleave.js - 用于在输入时格式化输入内容（信用卡格式、日期等） shiny - 在手机设备上模拟光的反射效果。 支持 DeviceMotion 事件 cloudquery - Turn any website to serverless API A-Programmers-Guide-to-English - 专为程序员编写的英语学习指南。 rrweb - 一个可以记录你页面中所有操作的库 nodeppt - markdown 写 ppt flexsearch - 能让你更加高效和快速的检索文本内容 public-apis - 汇集了市面上一些对外免费开放的 api，做一些自己练手 app 的时候很好用。 scroll-hint 用于提示用户页面可以左右滑动的一个提示库 fuse.js 轻量级前端模糊查询库 非常的好用 FileSaver.js 文件下载插件 很多时候下载会有兼容性问题，它能帮你解决这些问题 instant.page 一个判断用户行为 预测提前加载页面的库 screenfull.js 浏览器全屏插件 解决了不少兼容性问题 VuePress 本网站就是基于它实现的，简单方便的静态网站生成器 selection 可视化选择页面元素的库 scroll-out 滚动效果（滚动视差）的框架，框架大小不到 1KB,使用回调的方式将相关动画元素的属性进行实时分配 gpu.js 通过将 js 转为特定的 language，利用 GPU 来执行，大大提高了执行性能和速度 pressure 前端实现 3D Touch hammer 移动端手势库 AlloyFinger 腾讯出的手势库 lowdb LowDB 是一个本地 JSON 数据库，基于 Lodash 开发的 JSON-server 可以配合 LowDB 使用 快速搭建一个 REST API lunr.js 是个用于浏览器的轻量级 JavaScript 全文搜索引擎,对于一些小型的博客、开发者文档或 Wiki 网站来说,完全可以通过它实现站内离线搜索 he 一个前端 encoder/decoder 库 grade 一个可以根据你的 图片 调整底色的插件 pretty-bytes 将字节转换成可以读的字符串，比如 1337 个字节，会显示成 1.34 KB Css &amp;&amp; 动画 animate.css 最有名的动画效果库 magic.css css 动画效果库 类似 animate.css popmotion 一个函数式声明前端动画库 NES.css 任天堂主题风格 css 库 particles.js 前端实现颗粒粒子的动画效果库，比较炫酷，但相对的也比较吃性能 PaperCSS 手绘风格感觉 css 库 rough 基于 Canvas 的手绘风格图形库 wired-elements 基于 rough.js 分装 button input radio 等组件。它的底层是 Web components matter-js web 物理引擎 micron 通过在元素上绑定属性从而实现动画效果的库 direction-reveal 根据鼠标进入位置，展现从不同方向 展现 hover 效果 laxxx 滚动特效库 轻量级 压缩完 2kb cssfx 优雅的 CSS 动画效果，开箱即用 zdog 3D engine 引擎 Vue vue-multiselect select 组件 目前 vue 里面用过最好用的 Vue.Draggable DnD 拖拽组件 基于 Sortable.js 的 vue 版本 vue-sauce 一个可以展示 vue 源码的指令 vue-smooth-dnd Vue wrappers components for smooth-dnd vuegg 一个 vue 可视化拖拽界面生成器 vee-validate 基于 vue 的验证，能验证的内容比较全 vuesax 一个很漂亮的基于 vue 的 ui 框架 vue-analytics 基于 vue 的 谷歌统计封装 vue-virtual-scroller 基于 vue 的虚拟列表无限滚动 vue-content-placeholders 页面龙骨 skeleton 实践库 Jasonette 一个用 json 来构建 hybrid App 的框架 crate 一个 react 全栈练习(pc,mobile,rn,api) demo，适合入门拿来练手 react-in-patterns 一本开源教你如何写 react 的书 hocs react 相关 hoc 收集库 工具库 live-server 可以快速启一个本地 dev 服务 并且支持自动刷新的 http server serve - 快速起本地静态服务 picojs js 人脸识别库 es-checker 检查当前环境对 ES6 支持的情况。支持浏览器和 node.js merge-images 图片合成，利用canvas能将几张图片合成一张 fabric.js 基于 canvas 创建交互式的图片编辑界面非常适合用来做图片合成类工作。 phaser 这是一个为桌面和移动浏览器开发 HTML5 游戏的快速开源框架。 你可以为 iOS、 Android 和不同的本地应用程序创建游戏。 purifycss 移除没使用到的 css dropcss 同上 fast-cli 命令行测试下载上传速度 @pika/web 让你不需要在本地 webpack 中 import，直接在游览器里面运行 npm 包 pinyin 汉字拼音转换工具 JavaScript Obfuscator Tool js 代码混淆工具 tesseract 图像识别，它能识别图片中的文字，支持中文 gka 一款高效、高性能的帧动画生成工具。只需一行命令，快速图片优化、生成动画文件，支持效果预览。 recast 前端 ast 库 jscodeshift 将 js 内容解析成 AST 语法树，然后提供一些便利的操作接口，方便我们对各个节点进行更改 stats.js 前端性能监控 如 FPS、内存使用情况等 PapaParse 解析 csv excel Node consola 优雅的命令行 console vuepress 也使用了它 cheerio - 用类 jQuery 语法处理 HTML chokidar - node 监听文件变化的库 fs-extra - fs-extra 模块是系统 fs 模块的扩展，提供了更多便利的 API，并继承了 fs 模块的 API rimraf - 删除文件 globby - 用于模式匹配目录文件 glob - 文件查找 tiny-glob - 文件查找 node-semver - node 版本验证库 npm-run-all - 一个 CLI 工具可以并行或者串行执行 script live-server - 一个简单的 http server 带有 reload 功能 node-portfinder - 一个端口嗅探工具 update-notifier - Update notifications for your CLI app. cli 升级提醒工具 y18n - yargs 基于 i18n 的一个包 signale - Hackable console logger 一个 Node 的日志格式库，自带 16 个级别，可以定制颜色和 Emoji execa - A better child_process listr - Terminal task commander.js - 自动的解析命令和参数，合并多选项，处理短参，等等，功能强大，上手简单 Inquirer.js - A collection of common interactive command line user interfaces. 命令行询问库 enquirer - 命令行 prompt 询问库，写 cli 的时候很有用 Qoa 同上 ora - Elegant terminal spinner 命令行 loading chalk - 命令行着色美化库 hygen - 快速方便的创建代码 可以命令行创建预设的 template ndb - node 调试 got - http 请求库 如果你觉得 request 太多的话 这是一个不错的选择 dumper.js - 能让你的 node console 更加的规整，方便调试 node-in-debugging - node.js 调试指南 node-best-practices - node 最佳实践 fastscan - node 敏感词库 fx - 命令行优化 JSON 输出 dataloader - 解决 Graphql 中的 N+1 查询问题 progress-estimator - 命令行 progress bar 进度条模拟库 Node.js 最佳实践 grpc-web - 前端直连 gRPC 服务 node-fetch - node 环境下轻量级 fetch 请求库 ink 是一个 React 的命令行渲染器，命令行界面可以像写页面那么写了 strapi 开源的解决方案来创建、部署和管理自己的 API listr Terminal task list dotenv 通过.env 设置环境部变量 vue-cli 也依赖它 GraphQL prisma - 让前端也能快速的写出 Apollo GraphQL - 是基于 GraphQL 的全栈解决方案集合。从后端到前端提供了对应的 lib 使得开发使用 GraphQL 更加的方便 有趣 the-bread-code - 使用程序员的思维制作面包 ，比如制作中使用 A/B test, 来比较那种做法更好。 build-your-own-x - 教你用各种语言实现 Bot Database Neural Network javascript-algorithms - 教你用前端知识认识各种算法 not-paid - 如果你给人做网站，交过去以后对方没有付款，那么这个 JS 会把网站的透明度一天调低一点，直到看不见 nsfwjs - 前端图片鉴黄，基于 Tensorflow elevator.js 我很喜欢的一个库，让一个 back-to-top 的效果有了一种坐复古电梯的感觉 app-ideas 很多年轻人苦于缺少练手的项目，这个项目收集了不少点子，每个点子都有明确的目标和复杂资源。 WebGL-Fluid-Simulation 很酷的 WebGL 交互 工具 high-speed-downloader - 百度网盘不限速下载 支持 Windows 和 Mac hyper - 前端命令行 yapi - 是一个可本地部署的、打通前后端及 QA 的、可视化的接口管理平台 sway - 一个微软自己出的在线 ppt 很强大 bigjpg - 放大图片的神器 通过神经网络可以放大图片并能降噪 Ascii Art Generator - 在线生成 Ascii 图案 Winds - 开源 RSS JSUI - 一个用来控制管理前端项目的客户端 docz - 让你能快速写文档的一个库 hiper - 性能统计分析工具 verdaccio - 私有 npm git-guide - git 入门指南 git-tips - git 进阶 bit - 实现了项目之间的代码共享 可以自建私有 simpread - 简悦 ( SimpRead ) 让你瞬间进入沉浸式阅读的扩展 mkcert - 一键命令 让本地也支持 https termtosvg - 录制 命令操作转成 svg 基于 python gh-polls - 可以在 github issue 中添加投票 eruda - 移动端调试工具 vConsole - 也是一个移动端调试工具 腾讯出品 terminalizer - 命令行录制工具 基于 node badgen - 快速构建和 shields 一样的 svg badge 但速度更快 readability - 移除页面非正文部分 基于 jsdom WeChatPlugin-MacOS - 一款功能强大的 macOS 版微信小助手 puppeteer-recorder - 一个 chrome 插件 能够根据你的操作 自动生成 puppeteer 相关代码 mdx-deck - 用 markdown 编写演示文稿 code-surfer - 基于 mdx-deck 的一个插件 让你更好的在文稿中展示 code Progressive Tooling - 前端性能优化工具集合 https://github.com/artf/grapesjs - 可视化建站工具 不需要写代码就能写一个页面，前端再次再次要下岗了 image-charts - 该服务通过 URL 接受参数，然后生成图表，以图片形式返回 eagle.js - 一个用 vue 来制作 PPT 的库 Optimizely - A/B Test appadhoc - 一个国内的 A/B Test 服务 glorious-demo - 通过编写代码的方式构建一个命令行的演示例子 nginxconfig - 可视化配置 nginx 提供了多个基础模板 bundlephobia - 一个可以查看某个库的大小，并且分析它的依赖 jsperf - 一个提供在线 test case 的网站，主要用来比较性能。可以比较如： forEach vs for 的性能 perflink 与 jsperf 类似的一个比较 js 性能的网站 algorithm-visualizer - 算法代码可视化 An-English-Guide-for-Programmers - 专为程序员编写的英语学习指南 Webhint - 用于检查代码的可访问性、性能和安全的开源检查（Linting）工具 airtap - 测试浏览器兼容性，可覆盖 800 多种浏览器 jsonstore - 供免费，安全且基于 JSON 的云数据存储，自己玩的小项目神器 git-history - 可视化查看一个文件的历史变化 x-spreadsheet 一个基于 Canvas 的 JS 电子表格库 excel imgcook 阿里出品，一键通过设计稿生成代码 majestic jest 可视化 leon 你开源项目的 ai 个人助手 js-code-to-svg-flowchart 将代码逻辑用流程图的方式展现出来 Webpack webpackbar webpack 打包进度可视化 jarvis webpack dashboard webpack-chain 通过 chain 风格 api 的方式修改 webpack 配置 speed-measure-webpack-plugin 探测 webpack 各阶段的耗时 obsolete-webpack-plugin 基于 browserslist 做浏览器升级提示 mini-css-extract-plugin 提取 CSS 为单独文件 copy-webpack-plugin 复制额外的文件到输出目录 duplicate-package-checker-webpack-plugin 检查是否存在重复依赖 Mac get-plain-text - 能清除剪贴板里的格式 很实用 IINA - mac 平台感觉免费最好的播放器 强推 magnet - 分屏管理 Xnip - 方便好用的截图工具-支持截长图 Spectacle - 窗口管理工具 vanilla - 顶栏图标管理工具 Dozer - 一个开源的顶栏管理 腾讯电脑管家 - 反正我用下来好觉得蛮好用的 mos - 鼠标平滑滚动软件，很好用。免费开源 sequel pro - mysql 客户端 好用 Microsoft Remote Desktop Beta - Mac 远程登录 Windows 调试神器 pap.er - 专为 Mac 设计的壁纸应用 The Unarchive - Mac 目前感觉最好用的免费解压软件 Tickeys - 让你用 Mac 键盘也能打出机械键盘的感觉 Beaker Browser - P2P 开源浏览器 支持点对点发布文件，成为了文件传输工具，支持 DAT 对等协议 Gifski - 视频转 gif 工具 more - 更多优秀的 mac app 介绍 Motrix - 支持 HTTP、FTP、BT、磁力链、百度网盘的下载工具 Chrome 拓展 Tampermonkey 油猴 神器 扩展管理器 轻松管理扩展，就不用担心安装太多扩展了 visbug 它可以帮助你改变 css，移动元素等等一系类强大的功能,页面调试神器。当然有些时候还是 DevTools 更好用 refined-github 优化 github 默认功能和样式的 chrome 插件 ADB chrome 真机调试安卓神器 Adblock Plus 免费广告拦截程序 这个应该不用说了，装机必备 Axure RP Extension 看原型必备 JSON Formatter JSON 格式化 程序员必备 Lighthouse 谷歌出品，检查网页综合性能评分，分析不足 二维码(QR 码)生成器 手机扫码神器 Octotree github 上看代码必备神器 OctoLinker 能在 github 上看代码的时候 快速链接跳转到依赖的库 The Great Suspender chrome 太吃内存了，当页面开的很多时候会很卡，它就完美的解决了这个问题。它将几分钟没浏览过的页面都挂载了，当你想看是再重新加载 WEB 前端助手 支持 JSON 格式化、二维码生成与解码、代码压缩、Markdown 与 HTML 互转、网页滚动截屏、正则表达式、时间转换工具、JSON 比对工具等 掘金 目前我默认新开 tab 的默认页，可以刷刷新的文章或者项目，还不错。 沙拉查词 划词翻译插件 npmhub在 README 下方显示 npm 依赖信息 #VS Code Import Cost 查看你引入的依赖模块大小 Auto Close Tag 自动补全 html 标签，如输入将自动补全 Auto Rename Tag 自动重命名 html 标签，如修改为，将自动修改结尾标签为 polacode 生产代码图片快照插件 vscode-leetcode - 一个能让你在 vscode 中刷 LeetCode 的插件 算一个划水神器吧 vscode-icons VS Code 必备吧，为文件添加炫图标 工程 lerna - monorepo 管理。 lerna-changelog - 为 lerna 项目自动生成 changelog。 eslint - JS 风格约束。 eslint-config-airbnb xo - 封装自 eslint。 prettier - 更主观的风格自动修改。 yeoman-generator - 脚手架工具。 serve - 本地静态服务器。 np - npm publish 辅助，自动 push、打 tag、升版本等。 lint-staged - eslint 提速，只 lint 提交的代码。 coveralls - 覆盖率。 husky - 添加 git hooks。 cross-env - 跨平台的环境变量声明。 projj - 本地 git 项目管理，支持 github 和 gitlab。 nvm - 管理 node 版本。 concurrently -在 npm scripts 里并行执行命令。 @zeit/ncc - 打包为 npm 包为一个文件。 npm-check - 检测依赖升级情况，我会和 yarn upgrade-interactive 配合着用，主要用来检测冗余依赖。 cpx - 复制，支持 glob，并且可以 watch。 onchange - 监听文件变动然后做一些事。 常看的网站]]></content>
  </entry>
  <entry>
    <title><![CDATA[素材网站收集]]></title>
    <url>%2F2019%2F06%2F13%2Fyuque%2F%E7%B4%A0%E6%9D%90%E7%BD%91%E7%AB%99%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[干货01—PPT素材全搜罗]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSS]]></title>
    <url>%2F2019%2F06%2F13%2Fyuque%2FCSS%2F</url>
    <content type="text"><![CDATA[占位图 Css&amp;&amp;动画 animate.css 最有名的动画效果库 magic.css css 动画效果库 类似 animate.css popmotion 一个函数式声明前端动画库 NES.css 任天堂主题风格 css 库 particles.js 前端实现颗粒粒子的动画效果库，比较炫酷，但相对的也比较吃性能 PaperCSS 手绘风格感觉 css 库 rough 基于 Canvas 的手绘风格图形库 wired-elements 基于 rough.js 分装 button input radio 等组件。它的底层是 Web components matter-js web 物理引擎 micron 通过在元素上绑定属性从而实现动画效果的库 direction-reveal 根据鼠标进入位置，展现从不同方向 展现 hover 效果 laxxx 滚动特效库 轻量级 压缩完 2kb cssfx 优雅的 CSS 动画效果，开箱即用 zdog 3D engine 引擎 KulerKuler是在线色彩工具的典范。有数千个出色的预置色彩模板可供选择，你也可以利用这款既先进又好用的工具来生成自己的模板。kuler from adobe - Color:https://color.adobe.com/zh/create PiknikPiknik是地球上最基本的色彩工具之一，绝对是我的至爱之一。只需轻轻移动鼠标去改变颜色，滚动一下改变亮度，然后点击复制数值到粘贴板上，大功告成矣。做网站的时候，我每天都用它来为颜色选用找感觉，包括它看起来会如何、如果覆盖整个屏幕效果会怎样、做幻灯片用哪个颜色好等等。 0to2550to255也是我的至爱之一，是寻找颜色变化的一款非常震撼的工具。这让它在设计网站的边界和悬浮（hover）效果时表现出色，但你同样可以用它来为PPT的排版或其他要素寻找重点色。]]></content>
  </entry>
  <entry>
    <title><![CDATA[ppt制作]]></title>
    <url>%2F2019%2F06%2F13%2Fyuque%2Fppt%E5%88%B6%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[PPT排版https://www.zhihu.com/question/29386330/answer/79692944 PPT像电影一样流畅？这5招带你入门MG动画 色彩灵感来源https://zhuanlan.zhihu.com/p/41077780在前面的 里提到过一个网站pictogram2.com提供各种人形素材，而这些素材均有矢量文件下载，因此可以随下随用在Behance.net上看到过大神Rutger PauJusse的每日C4D练习，立刻就被这种风格吸引了～虽然整体只采用一种搭配，却显得十分和谐自然。 精选15个PPT制作网站，收藏好，别丢了 pptfans.cn 不仅有海量的模板，还有各种级别的视频教程。很适合初学者来丰富自己的素材库。 *NO.1 officeplus *微软官方在线模板网站，模板比较丰富，内容花样多，可以来学习一波。 **叮当设计 **全网站总共1037的模板，全部免费下载。 **present **这是一个全球的网站，内容比较丰富，设计水平比较高端，缺点就是需要付费够买。一些对内容要求比较高的可以看一下。 *演界网 *yanj.cn 国内原创ppt模板网站，有大量的免费图表分享给大家使用。有一部分需要付费，免费的就可以满足我们的普通需求啦。 *逼格 *tretars.com 这是一个个人博客网站，逼格高，在发模板的同时还有一些ppt小技巧教程，图文结合，写的挺不错。 *优品 *ypppt.com 这个网站内容分类比较清晰，直接搜索自己所需要的模板内容就能找到。内容质量都挺高，免费。 *雷锋 *lfppt.com 有着海量的ppt，分类比较明确。需要哪个点哪个就完事。 *扑奔 *pooban.com 内容极其丰富，图表免费的居多，但是有些优质模板都需要200个积分才可以下载。 *无忧ppt *网站如其名字，搜集了很多的ppt模板，完全免费，内容质量也不错，就是网站广告有点多。 ppt宝藏** **pptbz.com 内容比较丰富，但是质量参差不齐，有缺点，网站分类不太明确，不能够想要什么点什么，适合上网浏览，收集模板，免费。 **500丁 **内容都是优质的，质量也比较高，有一些简历模板，都是收费的，适合大佬使用。 **变色龙 **和500丁一样，质量也都挺高。内容更是不得了，不仅分类明确，而且全面。同样全部收费，适合大佬使用。 ppt之家 **压轴**的来啦，内容全面，质量高。文章、教程、图表、背景、素材、应有尽有。重点是免费下载，只需要关注一下人家的公众号就可以了。 http://yanshuo.io/演说 NO.2 slidemodel 国外的PPT模板网站，网站绝大部分的PPT都是图标或者图形类型的，而且还添加了地图类型的ppt模板，虽然这些都是需要付费订阅，但网站每周会提供150个免费的ppt模板，注册后均可下载。 NO.3 presentationmagazine 网站模板内容非常齐全，大部分的模板都可以免费使用，还免费提供一些制作 PPT 时所用到背景元素，如果你在PPT的制作过程中遇到什么困难，可以在网站的官方论坛上提出来， NO.4 slidehunter 4000个完全免费ppt模板网站，不管你做什么工作，都能在网站中找到相应的 PPT 模板，有趣的是网站还提供3D类型的 PPT，感兴趣的朋友可以去了解一下。 NO.5 AllPPT 网站设计简洁大方，种类也比较齐全，并且还有4；3的模板下载，如果你不会 PPT，他们还提供了 PPT 学习网站，以及免版权的图片使用网站，该网站每周会更新30个精美的ppt模板提供下载。 PPT审美训练营 ： https://www.zhihu.com/question/39233528/answer/390237175 PPT遥控器：http://ppt.baidu.com/ PPT 插件： iSlide iSlide 是一款基于 PowerPoint 的插件工具，即便您不懂设计，也能简单、高效地创建各类专业PPT演示文档。拥有近数十万 PPT 模板，而且还会持续更新。你可以快速检索、一键插入PPT 。另外，使用 iSlide 智能图表可以让数据变得直观易懂！目前 ，iSlide 已经全面支持微软 Office 以及金山 WPS。 口袋动画 口袋动画分为盒子版和专业版。盒子版是 PPT 小白专属工具；专业版是 PPT 进阶级变身，无论使用哪个版本，都能让你快速制作出媲美 AE 特效水准的 PPT 动画。同时它还拥有一键美化功能，覆盖片头、片尾、图表等多场景动画，还有各种组合、单一动画。仅需一键下载，既可替换元素，生成酷炫动画展示页。目前这款插件同时支持微软 Office 和金山 WPS 。 OneKeyTools OneKeyTools 简称 “OK插件” 或 “OK” ，是一款免费开源的 PPT 设计辅助插件。功能覆盖形状、图片、调色、表格、图表、音频、辅助等领域。目前支持微软 Office 2013 及以上版本。 PPT 美化大师 PPT 美化大师拥有海量在线模板素材。专业模板、精美图示、创意画册、实用形状等，细致分类，内容也会持续更新。最大的特点是支持一键全自动智能美化，让精美的 PPT变得简单起来。同时，它还支持将 PPT 一键生成不能复制、修改的只读格式。目前，PPT 美化大师都支持微软 Office 和金山 WPS 。 ispring suite 作为教师或者课程开发者，我们可能会有制作在线课程的需要，而这款名为 ispring suite 的 PPT 插件可以帮你把普通的 PPT 演示文档转换为适合在 Windows、Mac、iPad、iPhone、Android 等多种平台独立使用的在线课程。你可以将 PPT 生成为 H5 或者 Flash ，也可以集成为 exe 格式的软件或者 MP4 视频。目前这款插件并不支持 WPS ，适配微软的 Office 2007 及以上版本。 查看这里：https://topbook.cc/overview 1、Note &amp; Point Note &amp; Point2、Stock XCHNG stock.xchng - the leading free stock photography site3、Lauren Tucker Wheat Field In Newton-St-Loe4、色彩理论 Basic color schemes: Color Theory Introduction5、三个工具：KulerPiknikOto255 PPT动画基于软件工具开发3D素材网站：free3d.com画图神器：Paint 3D 寻找模型（Paint3D+Remix3D）：在较新的win10版本，系统里已经自带了Paint3D这项APP，通过可以直接进行建模。如果没有找到，可以至MS Store下载：画图 3D - Microsoft Store3D模型逆天新功能全剧透： https://zhuanlan.zhihu.com/p/30860481PPT-3D使用教程：这一招，带你的PPT突破天际！C4d入门：零基础自学C4D？不妨从这里开始Focusky动画：Focusky动画演示大师：https://zhuanlan.zhihu.com/p/37336987 动画背景网站：1.videos.pexels.com2.Free HD Stock Video &amp; HD Video Clips3.Mazwai 好的动画网站或APPPPT中最酷的效果—3D模型全解 一懒再懒—好用到爆的PPT插件来自：有哪些让你相见恨晚的 PPT 制作技术或知识？https://www.zhihu.com/question/30018273/answer/3657817581_._全能选手-iSlide（原Nordri tools）2.动画爱好者福音—PA口袋动画3.排版/图片神器-OneKeyTools js/css 怎么制作动画版PPT，基于js Slides Revealjs http://hakim.se 可给ppt增加模版组件 一般需求用 http://slides.com 的服务应该能满足大部分场景。但如果需要内嵌脚本之类的，可能就不太够用了。可以手写 HTML/Markdown 然后用 reveal.js 来展示。 用Markdown写一个极客范儿的PPThttps://www.jianshu.com/p/e063303317cb这个需要一定的程序基础才可以进入 前端大神都用什么做PPT？ yanshuo.io nodeppt slides.com 声响 impress.js http://demo.orbitale.io/easy_impress/ http://parhumm.github.io/presentation-learning-to-design/ http://pkoperek.github.io/bytecode-presentation/#/title reveal.js - The HTML Presentation Framework 此外reveal.js还提供了可视化编辑的功能，不会写代码也能带你装逼带你飞哦 prezi.com]]></content>
  </entry>
  <entry>
    <title><![CDATA[vim]]></title>
    <url>%2F2019%2F06%2F13%2Fyuque%2Fvim%2F</url>
    <content type="text"><![CDATA[Vim 有什么奇技淫巧？ Vim实用插件推荐 笨方法学Vimscript面向那些想学会如何自定义Vim编辑器的用户。 Mac开发配置手册 安装macvimmac预装了vim，但官方的 vim 在 Mac 上只有一个很不完善的，长期没人维护的 Carbon 图形用户界面。macvim 主要是在此基础上添加了一个完整的 Cocoa 用户界面，其核心部分和 vim 同步。MacVim 采用了分离进程的方式，一个 MacVim 程序可以启动多个 vim 进程，每个显示在一个 MacVim 窗口中，这是官方的 vim 和其他平台下的 gvim 所不支持的。MacVim 还支持很多 Mac OS X 原生的界面特性，比如工具栏、滚动条、全屏显示、Mac 菜单快捷键的绑定等。 12345# 查看预装vim版本vim --version# 查看预装vim路径where vim 安装有两种方式来安装macvim: Github上下载macvim.dmg安装包进行安装 使用Homebrew安装 https://aaaaaashu.gitbooks.io/mac-dev-setup/content/Homebrew/index.html 这也是我们所采用的方式： 1brew install macvim 建立软链接(这步可以不走)无论使用哪种方式进行安装，可以在MacVim.app包文件中找到mvim和vim的可执行文件，要在shell中方便的执行这些命令，可以： 将可执行文件所在路径添加到环境变量$PATH中 将可执行文件复制到环境变量$PATH中的某一个路径下； 在$PATH中的某一个路径下创建该可执行文件的软/硬链接； 为可执行文件设置别名，并添加到配置文件中（/.bash_profile或/.zshrc）； 这里推荐在/usr/local/bin目录下为mvim软链接的方式。同时，mac预装vim版本过低，推荐使用MacVim.app包中的vim将其替代,如果想同时保留原来预装的/usr/bin/vim中的vim，可以通过创建别名来将其“覆盖”掉。 12345678910111213# 将可执行文件所在路径添加到环境变量`$PATH`中，单引号内的字符会原样输出echo 'export PATH=/usr/local/Cellar/macvim/8.0-133/MacVim.app/Contents/bin:$PATH' &gt;&gt; ~/.zshrc# 或将可执行文件mvim复制到/usr/local/bin/路径下cp /usr/local/Cellar/macvim/8.0-133/MacVim.app/Contents/bin/mvim /usr/local/bin/mvim# 或者在/usr/local/bin/路径中为mvim建立软链接ln -s /usr/local/Cellar/macvim/8.0-133/MacVim.app/Contents/bin/mvim /usr/local/bin/mvim# 为macvim中的vim创建别名，将其添加至~/.zshrc配置文件echo 'alias vim="/usr/local/Cellar/macvim/8.0-133/MacVim.app/Contents/MacOS/vim"' &gt;&gt; ~/.zshrc# 重新加载.zshrc以使修改生效 source ~/.zshrc 安装验证终端输入vim，终端vim显示如下:终端输入mvim，弹出GUIvim如下： 配置文件在vim启动过程中，首先将查找配置文件并执行其中的命令，而这些初始化文件一般有vimrc、gvimrc和exrc三种。通过:version命令可以查看vim的配置文件信息： 配置文件的位置vim的配置文件有全局和用户两种版本，分别存放于$VIM和$HOME目录中，用户配置文件默认是没有的，必要时由用户自己在$HOME目录下创建。可以使用:echo命令查看他们的路径，使用:e命令进入目录： 12345:echo $VIM/usr/local/Cellar/macvim/8.0-133/MacVim.app/Contents/Resources/vim:echo $HOME/Users/fangcao vimrc是vim最常用的配置文件 gvim是Gvim的配置文件 exrc仅用于向后兼容olvi/ex；除非你使用vi-compatible模式，否则不需要关注exrc配置文件 配置文件的加载顺序(这步也可以不用)可以通过:scriptname查看各脚本的加载顺序: 12345678910111213141: /usr/local/Cellar/macvim/8.0-133/MacVim.app/Contents/Resources/vim/vimrc 2: ~/.vimrc 3: /usr/local/Cellar/macvim/8.0-133/MacVim.app/Contents/Resources/vim/runtime/syntax/syntax.vim 4: /usr/local/Cellar/macvim/8.0-133/MacVim.app/Contents/Resources/vim/runtime/syntax/synload.vim 5: /usr/local/Cellar/macvim/8.0-133/MacVim.app/Contents/Resources/vim/runtime/syntax/syncolor.vim 6: /usr/local/Cellar/macvim/8.0-133/MacVim.app/Contents/Resources/vim/runtime/filetype.vim 7: /usr/local/Cellar/macvim/8.0-133/MacVim.app/Contents/Resources/vim/runtime/menu.vim 8: /usr/local/Cellar/macvim/8.0-133/MacVim.app/Contents/Resources/vim/runtime/autoload/paste.vim 9: /usr/local/Cellar/macvim/8.0-133/MacVim.app/Contents/Resources/vim/runtime/ftoff.vim 10: ~/.vim/bundle/Vundle.vim/autoload/vundle.vim ...... 85: /usr/local/Cellar/macvim/8.0-133/MacVim.app/Contents/Resources/vim/gvimrc 86: ~/.gvimrc ...... 可以看到：macvim在启动时会依次加载全局vimrc&gt;&gt;用户.vimrc&gt;&gt;全局gvimrc&gt;&gt;用户.gvimrc，而终端vim在启动既不加载gvimrc也不加载.gvimrc也就是说： 用户配置文件中的配置会覆盖全局配置文件的配置；因此，我们可以通过创建~/.vimrc来修改vim的默认配置。 对GUIvim，gvimrc会覆盖vimrc中的配置；因此，我们可以通过创建~/.vimrc使终端vim和GUIvim拥有不同的配置。此外，GUIvim支持更多扩展，有些功能在终端vim中无法使用。创建用户配置文件 1234# 切换至用户目录cd ~# 使用mvim创建并打开.vimrcmvim .vimrc 编辑配置文件1234可以使用以下命令，新建缓冲区来编辑配置文件：:edit $MYVIMRC也可以使用以下命令，新建标签页来编辑配置文件：:tabedit $MYVIMRC 当然也可以使用任何其他文本编辑器打开配置文件进行编辑。 应用配置文件修改配置文件后，需要重新启动Vim，或使用:source命令来应用新的设置： 1:source $MYVIMRC 我们可以在配置文件中增加以下命令，在保存后自动应用配置： 1autocmd bufwritepost .vimrc source $MYVIMRC 配置文件基本配置 显示中文帮助 下载vimdoc 将文件解压到~/.vim/doc，若路径不存在则自己创建 打开vim执行:helptags ~/.vim/doc 在~/.vimrc中进行配置： 12345set helplang=cn if version &gt;= 603 set helplang=cn set encoding=utf-8endif 没有完毕转自：https://www.jianshu.com/p/923aec861af3]]></content>
  </entry>
  <entry>
    <title><![CDATA[JsBridge]]></title>
    <url>%2F2019%2F06%2F12%2Fyuque%2FJsBridge%2F</url>
    <content type="text"><![CDATA[整个流程就是Native和Js两端各准备一个bridge，Native的bridge提供modules，js的bridge注册Native提供的modules。这就是bridge存在的意义–提供一个桥梁，让两边通信。 简单来说，只需要两步，第一简历桥连接，第二注册方法： 123456789101112131415161718192021222324252627function setupWebViewJavascriptBridge(callback) &#123; if (window.WebViewJavascriptBridge) &#123; return callback(WebViewJavascriptBridge); &#125; if (window.WVJBCallbacks) &#123; return window.WVJBCallbacks.push(callback); &#125; window.WVJBCallbacks = [callback]; var WVJBIframe = document.createElement('iframe'); WVJBIframe.style.display = 'none'; WVJBIframe.src = 'wvjbscheme://__BRIDGE_LOADED__'; document.documentElement.appendChild(WVJBIframe); setTimeout(function () &#123; document.documentElement.removeChild(WVJBIframe) &#125;, 100)&#125;function connectWebViewJavascriptBridge(callback) &#123; if (window.WebViewJavascriptBridge) &#123; callback(WebViewJavascriptBridge) &#125; else &#123; document.addEventListener( 'WebViewJavascriptBridgeReady' , function () &#123; callback(WebViewJavascriptBridge) &#125;, false); &#125;&#125; 兼容安卓ios 12345678910111213141516171819if (navigator.userAgent.match(/(iPhone|iPod|iPad);?/i)) &#123; //ios setupWebViewJavascriptBridge(function (bridge) &#123; bridge.callHandler(funcName, data,callback ); &#125;);&#125; else if (navigator.userAgent.match(/android/i)) &#123; connectWebViewJavascriptBridge(function(bridge) &#123; if(window.WebViewJavascriptBridge)&#123; window.WebViewJavascriptBridge.callHandler( funcName , data, callback ); &#125;else&#123; bridge.callHandler(funcName, data, callback); &#125; &#125;);&#125; else &#123;&#125; Android 初次加载是需要初始化 1bridge.init(function(message, responseCallback) &#123;responseCallback(data)&#125;); h5调用nativeiOS在setupWebViewJavascriptBridge里注册android在connectWebViewJavascriptBridge里注册 1bridge.callHandler(funcName, data, callback); native调用js 12bridge.registerHandler(funcName, function(responseData, responseCallback) &#123;&#125;); 概念1、H5，即是html5，超文本标记语言，用于描述网页内容结构的语言，网页编程中由它有负责描述页面数据和信息2、JS，即是JavaScript，广泛用于web应用开发中的脚本语言，负责响应用户的操作，为网页添加动态功能3、native APP，即传统的原生APP开发模式，Android基于Java语言，底层调用Google的 API；iOS基于Objective-C或者Swift语言，底层调用App官方提供的API4、Hybrid App，即原生和web的混合开发模式，由原生提供统一的API给js调用，实现跨平台的效果 交互方式 第一种为H5与native的基本通讯方式 说是基本通讯方式是因为由native自身的组件进行通讯的，这里需要区分为android和iOS，两端的组件实现有差异 基本通讯方式汇总 iOS通过官方提供的库文件JaveScriptCore来实现交互，可以脱离webview直接运行js android是通过addJavascriptInterface开放统一的api给js调用，实现交互，但具有安全性问题，版本4.2之前addJavascriptInterface接口引起安全漏洞，可被反编译获取Native注册的js对象，在页面通过反射Java的内置静态类，获取一些敏感的信息和破坏。 第二种H5与native交互方式为JSBridge原理 JSBridge是H5代码与native代码之间的一个通讯桥梁，是广为流行的交互理念。目前的统一实现流程是：H5触发url scheme–&gt;native捕获url scheme–&gt;原生分析并执行–&gt;原生调用H5，如下图： URL scheme，是一个URL最初始的位置，即://之前的那段字符，如baidu.com的scheme为http；根据我们上面对URL scheme的使用，我们可以理解，H5通过某种方式如iframe触发scheme，然后Native用某种方法捕获对应的url触发事件，根据定义好的协议，分析当前触发了哪种方法，然后根据定义来执行。比如短信，就是sms：，比如微信，就是weixin所以JSBridge交互本质就是通过webview的代理拦截url scheme，然后注入相应的JS，从而实现交互，目前我们公司使用的是第三方开源库WebViewJavascriptBridge，下面我们来讲讲这个通讯桥梁。 实现流程 首先在H5代码注入js代码块 1234567891011121314151617181920212223242526272829303132333435function setupFH5JsBridge(callback) &#123; var ua = navigator.userAgent.toLowerCase(), isiOS = ua.match(/(iphone|ipod|ipad);?/i), isAndroid = ua.match("android"); if (isAndroid) &#123; if (window.FH5JsBridge) &#123; window.FH5JsBridge.initBridge(callback); &#125; else &#123; document.addEventListener( "FH5JsBridgeReady", function() &#123; window.FH5JsBridge.initBridge(callback); &#125;, false ); &#125; window.WebViewJavascriptBridge = window.FH5JsBridge; &#125; else if (isiOS) &#123; if (window.WebViewJavascriptBridge) &#123; return callback(WebViewJavascriptBridge); &#125; if (window.WVJBCallbacks) &#123; return window.WVJBCallbacks.push(callback); &#125; window.WVJBCallbacks = [callback]; var WVJBIframe = document.createElement("iframe"); WVJBIframe.style.display = "none"; WVJBIframe.src = "wvjbscheme://__BRIDGE_LOADED__"; document.documentElement.appendChild(WVJBIframe); setTimeout(function() &#123; document.documentElement.removeChild(WVJBIframe); &#125;, 0); &#125;&#125;setupFH5JsBridge(function(bridge) &#123;&#125;); or我们项目里是这样： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153function nativeApp() &#123; var App = &#123; callbacks: &#123;&#125; &#125;, slice = Array.prototype.slice; /** * 常量定义 */ var ua = navigator.userAgent.toUpperCase(); // 当前环境是否为Android平台 App.IS_ANDROID = ua.indexOf("ANDROID") != -1; // 当前环境是否为IOS平台 App.IS_IOS = ua.indexOf("IPHONE OS") != -1; // 当前环境是否为WP平台 App.IS_WP = ua.indexOf("WINDOWS") != -1 &amp;&amp; ua.indexOf("PHONE") != -1; App.IS_YZT = /One Account (IOS|Android)/gi.test(ua); App.callbacks.__leftAction__ = function() &#123; var haveLeftAction = typeof App.callbacks.leftAction === "function", args = slice.call(arguments); if (haveLeftAction) &#123; setTimeout(function() &#123; App.callbacks.leftAction.apply(App.callbacks, args); &#125;, 0); if (App.IS_ANDROID) &#123; App.call(["called"]); &#125; else if (App.IS_IOS) &#123; return true; &#125; &#125; &#125;; //=======================Native 相关================================ var callindex = 0, isFunc = function(name) &#123; return typeof name === "function"; &#125;, isObj = function(name) &#123; return typeof name === "object"; &#125;; /** * 调用一个Native方法 * @param &#123;String&#125; name 方法名称 */ App.call = function(name) &#123; // 获取传递给Native方法的参数 var args = slice.call(arguments, 1); var successCallback = "", errorCallback = "", item = null, returnArg; var methodName = name[name.length - 1]; if (App.IS_YZT) &#123; if (App.IS_ANDROID) &#123; if (window.HostApp) &#123; var newArguments = []; for (var i = 0; i &lt; args.length; i++) &#123; if (isFunc(args[i])) &#123; var callbackName = methodName + "Callback" + callindex; window[callbackName] = args[i]; newArguments.push(callbackName); callindex++; &#125; else if (isObj(args[i])) &#123; newArguments.push(JSON.stringify(args[i])); &#125; else &#123; newArguments.push(args[i]); &#125; &#125; // 之所以要重新调用，是因为Android 初始化HostApp可能晚于JS调用。 try &#123; HostApp[methodName].apply(window.HostApp, newArguments); &#125; catch (e) &#123; // TODO 这里应该走Mock functions var params = slice.call(arguments, 0); setTimeout(function() &#123; App["call"].apply(window.App, params); &#125;, 300); &#125; &#125; else &#123; var params = slice.call(arguments, 0); setTimeout(function() &#123; App["call"].apply(window.App, params); &#125;, 1000); &#125; &#125; else if (App.IS_IOS) &#123; var tempArgument = []; for (var i = 0; i &lt; args.length; i++) &#123; if (isFunc(args[i])) &#123; var callbackName = methodName + "Callback" + callindex; window[callbackName] = args[i]; tempArgument.push(callbackName); callindex++; &#125; else &#123; args[i] &amp;&amp; tempArgument.push(args[i]); &#125; &#125; callindex++; var iframe = document.createElement("iframe"); var _src = "callnative://" + methodName + "/" + (tempArgument &amp;&amp; tempArgument.length ? encodeURIComponent(JSON.stringify(tempArgument)) + "/" + callindex : ""); console.log(_src); iframe.src = _src; iframe.style.display = "none"; document.body.appendChild(iframe); iframe.parentNode.removeChild(iframe); iframe = null; &#125; else &#123; // WP 用户不支持。 Mock functions, 模拟H5 容器 console.warn("Tips: No available environment WP"); // Mock functions, 模拟H5 容器 for (var i = 0; i &lt; args.length; i++) &#123; if (isFunc(args[i])) &#123; args[i](&#123;&#125;); return; &#125; &#125; &#125; &#125; else &#123; console.warn("Tips: No available environment, NO YZT"); // Mock functions, 模拟H5 容器 for (var i = 0; i &lt; args.length; i++) &#123; if (isFunc(args[i])) &#123; args[i](&#123;&#125;); return; &#125; &#125; &#125; &#125;;&#125;window.AppAPI = nativeApp();AppAPI.call(["onGetShareData"], data);AppAPI.call( ["checkLoginStatus"], function(data) &#123; callback &amp;&amp; callback(SUCCESS, formatJSON(data)); &#125;, function(err) &#123; //do nothing callback &amp;&amp; callback(ERROR, err); &#125;, &#123;&#125;); JS端使用方式 native端需要进行注册对应的方法，H5才可以调用 Android注册方式如下: 1FH5JsBridge.registerHandler(bridgeWebView, handlerName, bridgeHandler); iOS端注册方式如下 12345678910111213/*** @param registerHandler 要注册的事件名称@param handel 回调block函数 当后台触发这个事件的时候会执行block里面的代码 ***/ [_bridgeregisterHandler:@"loginFunc" handler:^(id data, PAFFWVJBResponseCallbackresponseCallback) &#123; // data 后台传过来的参数,例如用户名、密码等 NSLog(@"testObjcCallback called:%@", data); //具体的登录事件的实现,这里的login代表实现登录功能的一个OC函数。 [self login]; // responseCallback 给后台的回复 responseCallback(res);&#125;]; H5调用方式如下 12FH5JsBridge.callHandler(methodName, 方法名options,对象 callback) 调用 Native API其中callback 统一接受一个参数json对象 H5常见的调用方法 打开native 页面，从H5页面跳转到某个原生页面 1void openAppPage(data,callback) --data 为&#123;pageName:''&#125; 获取会话token，H5登录区内的操作需获取原生的登录态 1void getSSOTicket(data,callback) 刷新会话，在一定的时间内刷新会话 1void refreshSession(data,callback) 打开原生App的安全键盘 1void openSafeKeyboard(data,callback) 打开分享，微信QQ等分享 1void share(data,callback) 设置临时存储数据，H5需要存储native的数据作为临时数据，退出APP后，临时数据清空 12void setData(data, callback)data 格式为&#123;key:"key", value: string &#125; 获取临时存储数据，获取临时存储的数据进行使用 12void getData(data, callback)data 格式为&#123;key:"key"&#125; 删除临时存储数据 12void removeData(data, callback)data格式为&#123;key:"key"&#125; 加载过程加载和互相调用]]></content>
  </entry>
  <entry>
    <title><![CDATA[学习的UP主收集]]></title>
    <url>%2F2019%2F06%2F12%2Fyuque%2F%E5%AD%A6%E4%B9%A0%E7%9A%84UP%E4%B8%BB%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[关注这些牛人，你可以丰富多彩 3Blue1Brown 对不少理工科学生来说，数学都是噩梦一般的存在。从线代到离散，从高数到数分，每一科都要耗费大量的时间和精力，让人想怒摔课本。为了人类的未来发展，3Blue1Brown 决心用动画讲述数学专业知识，其视频涵盖了线性代数、微积分、拓扑学等领域，每门课都配有直观生动的动画演示，帮助观众加深对数学概念定理的理解。3Blue1Brown 原作者毕业于斯坦福大学数学系，并在 Khan Academy 担任过数学讲师，专业性有所保障。如果你上网方式比较科学，也可以关注其 YouTube 账号，第一时间掌握其动态。 李永乐老师官方 如果你还是高中生，不妨关注李永乐老师官方这个 B 站账号。他任职于人大附中，取得了北京大学双学士学位，在物理和数学两大学科领域都颇有造诣。除了高中数学讲座外，他还会结合时事热点，推出《流浪地球》科普、金庸武侠的科学解释等视频，幽默风趣，寓教于乐。 田浅浅 田浅浅是一位人大本科生，高考排名全省前百，她的学习经验对文科生来说大有裨益。在她的个人投稿中，你可以找到文综答题技巧、练字方法、高效笔记术、期末复习技巧等，凝聚了一枚学霸的心血。 蜡笔和小勋 蜡笔和小勋 是一对浙大毕业的情侣，他俩上传的视频，除了狂撒狗粮外，就是自己学习的经验之谈了，例如提高记忆效率、自律和自制力、对付拖延症等。如果你想提高自己的成绩排名，看他们的视频准没错。 潘子Jane 潘子Jane 是一位清华大学在读研究生，她的 B 站账号为我们分享了诸多生活技巧和个人感悟，如学生党如何月入过万、快速背单词方法、考研历程分享等，都是过来人的经验之谈。此外，你也可以借她的视频窥见清华学生的日常生活，激励自己进取前行。 FanfaniShare FanfaniShare 是一位在美国高校教英文的中国女孩，她 TESOL 硕士全 A 毕业，在国内教过雅思口语和新概念课程，水平与母语者不相上下。你可以借助她的投稿视频练习英式口语、雅思写作、单词记忆等，并纠正错误的发音习惯，面对歪果仁也不怯场。 小圆脸Paprika 读书破万卷，下笔如有神，这句诗人人皆知，却非人人都能做到。如果你正面临不知看何书、又如何看书的困境，小圆脸Paprika 就可以帮到你。她会为我们定期分享最近出版的好书、个人读书的感触等，伴你一路前行。 oeasy 如果你想涉足设计领域，关注oeasy可以避免走许多弯路。作为中国传媒大学的计算机教师，他可谓是这一领域的全才，出品了 Photoshop、Illustrator、Office、视频编辑、动画制作乃至编程入门等教程，内容翔实易懂，广受好评，带你从零开始，成为大神。 doyoudo doyoudo 同样是一位设计教程分享 UP 主，不过其更侧重于技术在具体生活场景中的应用，如用 C4D 制作猫爪杯模型、用 Photoshop 制作表情包、用 Audition 制作鬼畜音频等，选题十分有趣，小白也能轻松跟上节奏。 影视飓风 随着智能手机的普及和人们对生活追求的提高，Vlog 这一表现形式受到了越来越多人的欢迎。如果你想拍摄属于自己的 Vlog，又不知从何下手，影视飓风 或许能帮上忙。它的视频涵盖了 Vlog 制作的方方面面，从拍摄前期的准备工作到拍摄过程中的布光技巧，乃至后期剪辑等专业知识，深入浅出。 左手plus 拍照人人都会，手机一举，快门咔嚓，就大功告成了。但想拍出一张好照片，却并不那么简单，如果你内心深处有一个摄影梦，关注 左手plus 准没错。你可以从他的视频中学到鲜为人知的摄影技巧、摄影器材选购知识、照片后期处理流程等，再也不怕给妹子拍照后被踹了。 Free从容 如果你想学一门乐器，吉他可以说是性价比最高的选择之一：价格实惠、易于上手、在聚会上小露一手还能收获喝彩无数。如果你的公司年会在即，不妨关注 Free从容 的 B 站账号，突击学习吉他的弹奏方法，成为全公司最靓的仔。 少数派sspai 少数派sspai 是国际知名科技媒体我派本派（本句收费五毛）的 B 站官方账号，专注于提高你的数字生活效率。在目前投稿的视频中，你可以了解 Windows 美化技巧、捷径使用指南、隐私保护秘笈、新鲜科技产品评测等，推荐大家关注。]]></content>
  </entry>
  <entry>
    <title><![CDATA[名人博客收集]]></title>
    <url>%2F2019%2F06%2F12%2Fyuque%2F%E5%90%8D%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[看过的博客收集地址 语雀AlloyTeam 腾讯全端 AlloyTeam 团队 Blog学习的 UP 主收集京程一灯程墨 Morgan我的兜兜有糖PanjiaChen云龙 http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1530517140411/Codelife.pdf小Z博客360准备的平台，众诚翻译—这个可以翻译文章发表博客https://www.smashingmagazine.com/https://overreacted.io/how-are-function-components-different-from-classes/ GMTC 2019 全球大前端技术大会]]></content>
  </entry>
  <entry>
    <title><![CDATA[GitHub Pages 建立个人网站详细教程]]></title>
    <url>%2F2019%2F06%2F12%2Fyuque%2FGitHub%20Pages%20%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[GitHub Pages是免费的静态站点，三个特点： 免费托管、 自带主题、 支持自制页面和Jekyll。 为什么使用github pages 搭建简单而且免费； 支持静态脚本； 可以绑定你的域名； DIY自由发挥，动手实践一些有意思的东西git,markdown,bootstrap,jekyll； 理想写博环境，git+github+markdown+jekyll； 创建github pages 安装git工具 http://windows.github.com/http://mac.github.com/ 2.两种pages模式 使用自己的用户名，每个用户名下面只能建立一个； 资源命名必须符合这样的规则username/http://username.github.com； 主干上内容被用来构建和发布页面 gh-pages分支用于构建和发布； 如果user/org pages使用了独立域名，那么托管在账户下的所有project pages将使用相同的域名进行重定向，除非project pages使用了自己的独立域名； 如果没有使用独立域名，project pages将通过子路径的形式提供服务http://username.github.com/projectname； 自定义404页面只能在独立域名下使用，否则会使用User Pages 404； 创建项目站点步骤： 123456$ git clone https://github.com/USERNAME/PROJECT.git PROJECT$ git checkout --orphan gh-pages$ git rm -rf .$ git add .$ git commit -a -m "First pages commit"$ git push origin gh-pages 可以通过User/Organization Pages建立主站，而通过Project Pages挂载二级应用页面。 创建步骤第一步：创建个人站点第二步：设置站点主题 常用命令123456789$ git clone git@github.com:username/username.github.com.git //本地如果无远程代码，先做这步，不然就忽略$ cd .ssh/username.github.com //定位到你blog的目录下$ git pull origin master //先同步远程文件，后面的参数会自动连接你远程的文件$ git status //查看本地自己修改了多少文件$ git add . //添加远程不存在的git文件$ git commit * -m "what I want told to someone"$ git push origin master //更新到远程服务器上 使用Jekyll搭建博客 1 什么是jekyllJekyll是一种简单的、适用于博客的、静态网站生成引擎。它使用一个模板目录作为网站布局的基础框架，支持Markdown、Textile等标记语言的解析，提供了模板、变量、插件等功能，最终生成一个完整的静态Web站点。说白了就是，只要安装Jekyll的规范和结构，不用写html，就可以生成网站。[jekyll介绍][jekyll on github][jekyllbootstrap]。Jekyll使用Liquid模板语言，表示文章标题， GitHub Pages是免费的静态站点，三个特点： 免费托管、 自带主题、 支持自制页面和Jekyll。 为什么使用github pages 搭建简单而且免费； 支持静态脚本； 可以绑定你的域名； DIY自由发挥，动手实践一些有意思的东西git,markdown,bootstrap,jekyll； 理想写博环境，git+github+markdown+jekyll； 创建github pages 安装git工具 http://windows.github.com/http://mac.github.com/ 2.两种pages模式 使用自己的用户名，每个用户名下面只能建立一个； 资源命名必须符合这样的规则username/http://username.github.com； 主干上内容被用来构建和发布页面 gh-pages分支用于构建和发布； 如果user/org pages使用了独立域名，那么托管在账户下的所有project pages将使用相同的域名进行重定向，除非project pages使用了自己的独立域名； 如果没有使用独立域名，project pages将通过子路径的形式提供服务http://username.github.com/projectname； 自定义404页面只能在独立域名下使用，否则会使用User Pages 404； 创建项目站点步骤： 123456$ git clone https://github.com/USERNAME/PROJECT.git PROJECT$ git checkout --orphan gh-pages$ git rm -rf .$ git add .$ git commit -a -m "First pages commit"$ git push origin gh-pages 可以通过User/Organization Pages建立主站，而通过Project Pages挂载二级应用页面。 创建步骤第一步：创建个人站点第二步：设置站点主题 常用命令123456789$ git clone git@github.com:username/username.github.com.git //本地如果无远程代码，先做这步，不然就忽略$ cd .ssh/username.github.com //定位到你blog的目录下$ git pull origin master //先同步远程文件，后面的参数会自动连接你远程的文件$ git status //查看本地自己修改了多少文件$ git add . //添加远程不存在的git文件$ git commit * -m "what I want told to someone"$ git push origin master //更新到远程服务器上 使用Jekyll搭建博客 1 什么是jekyllJekyll是一种简单的、适用于博客的、静态网站生成引擎。它使用一个模板目录作为网站布局的基础框架，支持Markdown、Textile等标记语言的解析，提供了模板、变量、插件等功能，最终生成一个完整的静态Web站点。说白了就是，只要安装Jekyll的规范和结构，不用写html，就可以生成网站。[jekyll介绍][jekyll on github][jekyllbootstrap]。Jekyll使用Liquid模板语言，{{page.title}}表示文章标题，{{content}}表示文章内容。我们可以用两种Liquid标记语言：输出标记（output markup）和标签标记 (tag markup)。输出标记会输出文本（如果被引用的变量存在），而标签标记不会。输出标记是用双花括号分隔，而标签标记是用花括号-百分号对分隔。[Liquid模板语言] [Liquid模板变量参考]。jekyll与github的关系：GitHub Pages一个由 GitHub 提供的用于托管项目主页或博客的服务，jekyll是后台所运行的引擎。 2 jekyll本地环境搭建1.下载最新的RubyInstaller并安装(我下载的是rubyinstaller-1.9.3-p194.exe)，设置环境变量，path中配置C:Ruby193bin目录，然后在命令行终端下输入gem update –system来升级gem；2.下载最新的DevKit，DevKit是windows平台下编译和使用本地C/C++扩展包的工具。它就是用来模拟Linux平台下的make,gcc,sh来进行编译。但是这个方法目前仅支持通过RubyInstaller安装的Ruby，并双击运行解压到C:DevKit。然后打开终端cmd，输入命令进行安装。3.完成上面的准备就可以安装Jekyll了,因为Jekyll是用Ruby编写的,最好的安装方式是通过RubyGems(gem): 1gem install Jekyll 并使用命令检验是否安装成功 1jekyll --version 4.安装Rdiscount，这个用来解析Markdown标记的包，使用如下命令： 1gem install rdiscount 5.运行本地工程：cd 到工程目录，启动服务： 1jekyll --server 3 jekyll目录结构 _posts：_posts中的数据文档，通过注入_layouts定义的模板，通过jekyll –server最终生成的静态页面在_sites目录。目录是用来存放你的文章的，一般以日期的形式书写标题。 _layouts：_layouts中的模板一般指向了_includes/themes中的模板。目录是用来存放模板的，在这里你可以定义页面中不同的头部和底部。 _includes： _includes/JB中有一些常用的工具，用于列表显示、评论等； _includes/themes中可参看主题的相关html文档。 _includes/themes中的主题一般包含default.html、post.html和page.html三个文档。default.html定义了网站的最上层框架（模板），post.html和page.html是其子框架（模板）。 生成好的html子页面通过default.html的{{ content }}变量调用，生成整个页面。assets渲染页面的CSS和JS文档在assets/themes中_config.yml站点生成需要用到_config.yml配置文件，站点的全局变量在_config.yml中定义，用site.访问；页面的变量在YAML Front Matter中定义，用page.访问，更多的模板变量可参考模板数据。index.html你的页面首页。Jekyll-Bootstrap创建博客 1.创建个人站点，即创建一个新资源，格式为http://username.github.com；2.安装Jekyll-Bootstrap： 1234$ git clone https://github.com/plusjade/jekyll-bootstrap.git USERNAME.github.com$ cd USERNAME.github.com$ git remote set-url origin git@github.com:USERNAME/USERNAME.github.com.git$ git push origin master 3.访问创建好的个人站点： http://username.github.com4.在本地测试查看效果： 1cd USERNAME.github.comjekyll --server 详细的教程看：http://jekyllcn.com/https://www.zhihu.com/question/30018945?sort=created 表示文章内容。我们可以用两种Liquid标记语言：输出标记（output markup）和标签标记 (tag markup)。输出标记会输出文本（如果被引用的变量存在），而标签标记不会。输出标记是用双花括号分隔，而标签标记是用花括号-百分号对分隔。[Liquid模板语言] [Liquid模板变量参考]。jekyll与github的关系：GitHub Pages一个由 GitHub 提供的用于托管项目主页或博客的服务，jekyll是后台所运行的引擎。 2 jekyll本地环境搭建1.下载最新的RubyInstaller并安装(我下载的是rubyinstaller-1.9.3-p194.exe)，设置环境变量，path中配置C:Ruby193bin目录，然后在命令行终端下输入gem update –system来升级gem；2.下载最新的DevKit，DevKit是windows平台下编译和使用本地C/C++扩展包的工具。它就是用来模拟Linux平台下的make,gcc,sh来进行编译。但是这个方法目前仅支持通过RubyInstaller安装的Ruby，并双击运行解压到C:DevKit。然后打开终端cmd，输入命令进行安装。3.完成上面的准备就可以安装Jekyll了,因为Jekyll是用Ruby编写的,最好的安装方式是通过RubyGems(gem): 1gem install Jekyll 并使用命令检验是否安装成功 1jekyll --version 4.安装Rdiscount，这个用来解析Markdown标记的包，使用如下命令： 1gem install rdiscount 5.运行本地工程：cd 到工程目录，启动服务： 1jekyll --server 3 jekyll目录结构 _posts：_posts中的数据文档，通过注入_layouts定义的模板，通过jekyll –server最终生成的静态页面在_sites目录。目录是用来存放你的文章的，一般以日期的形式书写标题。 _layouts：_layouts中的模板一般指向了_includes/themes中的模板。目录是用来存放模板的，在这里你可以定义页面中不同的头部和底部。 _includes： _includes/JB中有一些常用的工具，用于列表显示、评论等； _includes/themes中可参看主题的相关html文档。 _includes/themes中的主题一般包含default.html、post.html和page.html三个文档。default.html定义了网站的最上层框架（模板），post.html和page.html是其子框架（模板）。 生成好的html子页面通过default.html的 GitHub Pages是免费的静态站点，三个特点： 免费托管、 自带主题、 支持自制页面和Jekyll。 为什么使用github pages 搭建简单而且免费； 支持静态脚本； 可以绑定你的域名； DIY自由发挥，动手实践一些有意思的东西git,markdown,bootstrap,jekyll； 理想写博环境，git+github+markdown+jekyll； 创建github pages 安装git工具 http://windows.github.com/http://mac.github.com/ 2.两种pages模式 使用自己的用户名，每个用户名下面只能建立一个； 资源命名必须符合这样的规则username/http://username.github.com； 主干上内容被用来构建和发布页面 gh-pages分支用于构建和发布； 如果user/org pages使用了独立域名，那么托管在账户下的所有project pages将使用相同的域名进行重定向，除非project pages使用了自己的独立域名； 如果没有使用独立域名，project pages将通过子路径的形式提供服务http://username.github.com/projectname； 自定义404页面只能在独立域名下使用，否则会使用User Pages 404； 创建项目站点步骤： 123456$ git clone https://github.com/USERNAME/PROJECT.git PROJECT$ git checkout --orphan gh-pages$ git rm -rf .$ git add .$ git commit -a -m "First pages commit"$ git push origin gh-pages 可以通过User/Organization Pages建立主站，而通过Project Pages挂载二级应用页面。 创建步骤第一步：创建个人站点第二步：设置站点主题 常用命令123456789$ git clone git@github.com:username/username.github.com.git //本地如果无远程代码，先做这步，不然就忽略$ cd .ssh/username.github.com //定位到你blog的目录下$ git pull origin master //先同步远程文件，后面的参数会自动连接你远程的文件$ git status //查看本地自己修改了多少文件$ git add . //添加远程不存在的git文件$ git commit * -m "what I want told to someone"$ git push origin master //更新到远程服务器上 使用Jekyll搭建博客 1 什么是jekyllJekyll是一种简单的、适用于博客的、静态网站生成引擎。它使用一个模板目录作为网站布局的基础框架，支持Markdown、Textile等标记语言的解析，提供了模板、变量、插件等功能，最终生成一个完整的静态Web站点。说白了就是，只要安装Jekyll的规范和结构，不用写html，就可以生成网站。[jekyll介绍][jekyll on github][jekyllbootstrap]。Jekyll使用Liquid模板语言，{{page.title}}表示文章标题，{{content}}表示文章内容。我们可以用两种Liquid标记语言：输出标记（output markup）和标签标记 (tag markup)。输出标记会输出文本（如果被引用的变量存在），而标签标记不会。输出标记是用双花括号分隔，而标签标记是用花括号-百分号对分隔。[Liquid模板语言] [Liquid模板变量参考]。jekyll与github的关系：GitHub Pages一个由 GitHub 提供的用于托管项目主页或博客的服务，jekyll是后台所运行的引擎。 2 jekyll本地环境搭建1.下载最新的RubyInstaller并安装(我下载的是rubyinstaller-1.9.3-p194.exe)，设置环境变量，path中配置C:Ruby193bin目录，然后在命令行终端下输入gem update –system来升级gem；2.下载最新的DevKit，DevKit是windows平台下编译和使用本地C/C++扩展包的工具。它就是用来模拟Linux平台下的make,gcc,sh来进行编译。但是这个方法目前仅支持通过RubyInstaller安装的Ruby，并双击运行解压到C:DevKit。然后打开终端cmd，输入命令进行安装。3.完成上面的准备就可以安装Jekyll了,因为Jekyll是用Ruby编写的,最好的安装方式是通过RubyGems(gem): 1gem install Jekyll 并使用命令检验是否安装成功 1jekyll --version 4.安装Rdiscount，这个用来解析Markdown标记的包，使用如下命令： 1gem install rdiscount 5.运行本地工程：cd 到工程目录，启动服务： 1jekyll --server 3 jekyll目录结构 _posts：_posts中的数据文档，通过注入_layouts定义的模板，通过jekyll –server最终生成的静态页面在_sites目录。目录是用来存放你的文章的，一般以日期的形式书写标题。 _layouts：_layouts中的模板一般指向了_includes/themes中的模板。目录是用来存放模板的，在这里你可以定义页面中不同的头部和底部。 _includes： _includes/JB中有一些常用的工具，用于列表显示、评论等； _includes/themes中可参看主题的相关html文档。 _includes/themes中的主题一般包含default.html、post.html和page.html三个文档。default.html定义了网站的最上层框架（模板），post.html和page.html是其子框架（模板）。 生成好的html子页面通过default.html的{{ content }}变量调用，生成整个页面。assets渲染页面的CSS和JS文档在assets/themes中_config.yml站点生成需要用到_config.yml配置文件，站点的全局变量在_config.yml中定义，用site.访问；页面的变量在YAML Front Matter中定义，用page.访问，更多的模板变量可参考模板数据。index.html你的页面首页。Jekyll-Bootstrap创建博客 1.创建个人站点，即创建一个新资源，格式为http://username.github.com；2.安装Jekyll-Bootstrap： 1234$ git clone https://github.com/plusjade/jekyll-bootstrap.git USERNAME.github.com$ cd USERNAME.github.com$ git remote set-url origin git@github.com:USERNAME/USERNAME.github.com.git$ git push origin master 3.访问创建好的个人站点： http://username.github.com4.在本地测试查看效果： 1cd USERNAME.github.comjekyll --server 详细的教程看：http://jekyllcn.com/https://www.zhihu.com/question/30018945?sort=created 变量调用，生成整个页面。assets渲染页面的CSS和JS文档在assets/themes中_config.yml站点生成需要用到_config.yml配置文件，站点的全局变量在_config.yml中定义，用site.访问；页面的变量在YAML Front Matter中定义，用page.访问，更多的模板变量可参考模板数据。index.html你的页面首页。Jekyll-Bootstrap创建博客 1.创建个人站点，即创建一个新资源，格式为http://username.github.com；2.安装Jekyll-Bootstrap： 1234$ git clone https://github.com/plusjade/jekyll-bootstrap.git USERNAME.github.com$ cd USERNAME.github.com$ git remote set-url origin git@github.com:USERNAME/USERNAME.github.com.git$ git push origin master 3.访问创建好的个人站点： http://username.github.com4.在本地测试查看效果： 1cd USERNAME.github.comjekyll --server 详细的教程看：http://jekyllcn.com/https://www.zhihu.com/question/30018945?sort=created]]></content>
  </entry>
  <entry>
    <title><![CDATA[flutter]]></title>
    <url>%2F2019%2F06%2F12%2Fyuque%2Fflutter%2F</url>
    <content type="text"><![CDATA[一门跨全平台移动应用开发（这里主要是以Mac电脑来安装和开发） API:https://flutterchina.club/web-analogs/ 知乎flutter:https://zhuanlan.zhihu.com/p/65033883 https://book.flutterchina.club/chapter2/flutter_router.html Flutter 1.7 正式发布 安装过程：1.下载Flutter2.新建目录：/Users/fangcao/Documents/flutter_code3.将flutter安装程序放在flutter_code 12cd ~/flutter_codeunzip ~/Downloads/flutter_macos_v0.5.1-beta.zip 将flutter_macos_v0.5.1-beta.zip解压到flutter_code里面4.在～/.bash_profile目录里面加入：export PATH=pwd/flutter/bin:$PATH5.如果你的终端用了zshrc,就得：vim ~/.zshrc 最后添加 source ~/.bash_profile 这样全局的环境变量PATH安装成功 注意：google出的东西都需要翻墙下载，不过，这次google给我们提供了一个临时镜像，此镜像为临时镜像，并不能保证一直可用，读者可以参考详情请参考 Using Flutter in China 以获得有关镜像服务器的最新动态。 12export PUB_HOSTED_URL=https://pub.flutter-io.cn //国内用户需要设置export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn //国内用户需要设置 接着运行1flutter doctor 检查安装哪些依赖,该命令检查您的环境并在终端窗口中显示报告缺少的功能或者模块，它会给你提示，按照指示安装即可（一般ios和android软件安装配置完成即可，下面会讲解ios和android软件的安装和配置）。 该flutter工具使用Google Analytics匿名报告功能使用情况统计信息和基本崩溃报告。 这些数据用于帮助改进Flutter工具。Analytics不是一运行或在运行涉及flutter config的任何命令时就发送， 因此您可以在发送任何数据之前退出分析。要禁用报告，请执行flutter config –no-analytics并显示当前设置，然后执行flutter config。 请参阅Google的隐私政策。 在vscode里面的终端：发现没有flutter,就运行一下source ~/.bash_profile最后检查下echo $PATH 看看 是否已经添加到环境变量中 安装flutter插件安装后，flutter doctor检查一下。 发现要进行如下安装： 123456brew updatebrew install --HEAD usbmuxd brew link usbmuxd brew install --HEAD libimobiledevice brew install ideviceinstaller ios-deploy cocoapods pod setup 前端：vscode安装flutter，还要安装Dart sdk安卓：IOS:Xcode 详细步骤：Flutter macOS 开发环境搭建笔记 开始HelloWorld这里以最新的Dart2为主 1.安装dart:https://dart.dev/tutorials/web/get-started12brew tap dart-lang/dartbrew install dart --devel 如果你需要开发 web 应用，则还需要安装 Dartium 和 Content Shell： 12$ brew tap dart-lang/dart$ brew install dart --with-content-shell --with-dartium 2.看看flutterSDK是不是最新的，如果不是，就升级FlutterSDK1flutter upgrade 3.开启手机应用IOS： 1open -a Simulator Flutter 配置在 Android StudioAndroid Studio添加Flutter开发 如果发现报错了：1.flutter错误解决–Error running Gradle 错误 2.flutter\packages\flutter_tools\gradle打开文件进行修改，修改代码如下（其实也是换成阿里的路径就可以了）。这一步有两种情况1，flutter.gradle文件中repositories中是google() 和 jcenter()，repositories{google()gcenter()}把google() 和 jcenter()这两行去掉。改为阿里的链接。maven { url ‘https://maven.aliyun.com/repository/google&#39; }maven { url ‘https://maven.aliyun.com/repository/jcenter&#39; }maven { url ‘http://maven.aliyun.com/nexus/content/groups/public&#39; } 4.创建flutter程序 1234flutter create my_appcd my_appflutter runflutter -h 5.VScode中常用的快捷键R键：点击后热加载，直接查看预览效果P键：在虚拟机中显示网格，工作中经常使用O键：切换Android和IOS的预览模式Q键：推出调试预览模式 APP开启Xcode 9 —进阶的 iOS Simulator查询设备 选择运行在哪个模拟器上运行在安卓上运行在IOS上运行在所有设备上 123flutter emulator //在运行前检查模拟器是否存在如果有模拟器，输入：flutter emulators --launch &lt;模拟器ID&gt;,运行模拟器如果创建新的模拟器，输入：flutter emulators --create [--name &lt;模拟器ID&gt;] 开始组件讲解https://www.imooc.com/video/18530 123456789101112131415161718192021222324252627282930import 'package:flutter/material.dart';void main() =&gt; runApp(new MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Welcome to Flutter', home: Scaffold( appBar: AppBar( title: Text('Hello World'), ), body: Center( child: Text( 'Hello World,触发事件，在触发n秒后才执行，如果在触发时间的n秒内再次触发事件，那就以新的时间为准，n秒后才执行。总之，需要你在触发事件的n秒内不再触发新事件，我才执行。', textAlign: TextAlign.left, // maxLines: 2, // overflow: TextOverflow.fade, style: TextStyle( fontSize: 25.0, color: Color.fromARGB(120, 255, 0, 0), decoration: TextDecoration.underline, decorationStyle: TextDecorationStyle.solid), ), ), ), ); &#125;&#125; Flutter webhttps://dart.dev/web 如何评价 Flutter for Web？针对 Web 的 Flutter 框架的技术预览版：https://flutter.dev/webGithub 仓库：https://https://github.com/flutter/flutter_webter_web示例程序：https://https://flutter.github.io/samples/ or https://github.com/flutter/flutter_web Flutter for Web架构图https://dart.dev/tutorials/web/get-started 1.安装 Dart12$ pub global activate webdev$ pub global activate stagehand 2.安装 webdev 和 stagehand:Stagehand- A Dart project generator 12$ pub global activate webdev$ pub global activate stagehand 3.创建一个wep app1234mkdir quickstartcd quickstartstagehand web-simplepub get 获取包 4.运行app12webdev servewebdev serve --auto restart 加入了热重新加载 如果觉得webdev serve –auto restart 太麻烦，可以尝试 flutter pub global run webdev serve –auto restart 5.打包发布1webdev build flutter项目和flutter web项目的不同 s/ 文件配置说明 pubspec.yaml包管理资源管理在Flutter中添加资源和图片 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#name很重要，如果修改了name所有的dart的文件的import前引用的本地的文件啊的包名都需要修改name: flutterdemo #包名description: A new Flutter application. dependencies: flutter: sdk: flutter #添加依赖packages ^表示适配和当前大版本一致的版本，~表示适配和当前小版本一致的版本 cupertino_icons: ^0.1.2 english_words: ^3.1.0 # image_picker: ^0.4.8 dev_dependencies: flutter_test: sdk: flutter #启用国际化1 flutter_localizations: sdk: flutter #定义常量 #数组server: - aaaaaa - bbbbbb - dddddd#常量age: 22 # intboolitem: true #定义一个boolean值name: 'hello' #定义一个string flutter: # The following line ensures that the Material Icons font is # included with your application, so that you can use the icons in # the material Icons class. uses-material-design: true #启用国际化2 # To add assets to your application, add an assets section, like this: #添加资源，不单单是图片，images是个和pubspec.yaml配置文件同级的目录，如果不同级，需要添加.. assets: - images/park.jpg - images/lake.jpg - images/touxiang.jpg # - images/a_dot_burr.jpeg # - images/a_dot_ham.jpeg #字体设置 fonts: - family: Schyler fonts: - asset: fonts/Schyler-Regular.ttf - asset: fonts/Schyler-Italic.ttf style: italic - family: Trajan Pro fonts: - asset: fonts/TrajanPro.ttf - asset: fonts/TrajanPro_Bold.ttf weight: 700 name:包名 引入图片资源1234#不同尺寸图片资源写法：…/my_icon.png…/2.0x/my_icon.png…/3.0x/my_icon.png 读取文本12345import 'package:flutter/services.dart' show rootBundle;Future&lt;String&gt; loadAsset() async &#123;//读取文件是的路径，就是assets下配置的 return await rootBundle.loadString('assets/config.json');&#125; 使用图片12//图片路径的配置new AssetImage('graphics/background.png'), 加载依赖包中图片12//配置name的作用，需要读取其他外部package下的资源时new AssetImage('icons/heart.png', package: 'my_icons') 支持字体的设置，可以使用自定义字体1style: new TextStyle( fontFamily: 'Schyler', fontSize: 24.0, ), 基本控件flutter提供了一套完备的基本控件，最常用的有如下几个： Text ：Text提供了一个用来显示文本的一次性控件（即无状态）。 Row, Column：这两个控件用来显示水平或垂直方向上的多个组件，并且是可伸缩的。 Stack：可以将多个组件以一定的顺序排列，可以使用Positioned控件来指定组件在Stack中的顺序。 Container: 是一个可视化的矩形控件，它可以使用BoxDecoration来进行外观装饰，装饰内容可以是背景，边框和阴影等。Container也有外边距，内边距等属性，也可以约束自身的大小，另外值得一提的是Container还可以利用矩阵在三维控件内做转换。 下面结合一些基本的控件来自定义我们的组件并构建应用： 开发Packages和插件 Package 介绍 Package 类型 Developing Dart packages Step 1: 开发Dart包 Step 2: 实现package 开发插件包 Step 1: 创建 package Step 2: 实现包 package Step 2a: 定义包API（.dart） Step 2b: 添加Android平台代码（.java / .kt） Step 2c: 添加iOS平台代码 (.h+.m/.swift) Step 2d: 连接API和平台代码 添加文档 API documentation 发布 packages 处理包的相互依赖 Android iOS 解决冲突 Flutter应用代码讲解 原生App项目集成flutter混合开发详细指南参考：Flutter视频学习Flutter实战Flutter中文网Dart官网 以前的名字叫https://www.dartlang.orgDart http://dart.goodev.org/Dartpad跨平台的应用程序 [必学]学习Flutter各种布局路由Flutter配置for Mac – VSCodeFlutter入门基础（一）-LabelFlutter入门基础（二）-ButtonFlutter入门基础（三）-TextFile登录页Flutter入门基础（四）-imageviewFlutter入门基础（五）-UITableViewFlutter入门基础（六）-UITableView(二)添加headerViewFlutter入门基础（七）-路由Flutter入门基础（八）-push页面跳转 flutter-goflutter 开发者帮助 APP，包含 flutter 常用 140+ 组件的demo 演示与中文文档]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何优雅地使用 macOS]]></title>
    <url>%2F2019%2F06%2F12%2Fyuque%2F%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8%20macOS%2F</url>
    <content type="text"><![CDATA[来自：https://www.zhihu.com/question/20873070 终端配置 (iTerm2 + zsh + oh-my-zsh + tmux) 和一些好用的小插件 oh-my-zsh theme: 自带主题已经很多了, 想折腾的, 可以自己定制一套主题 wting/autojump: 终端中一键直达目录, 命令行中切换目录是最常用的操作, 只要正常 cd 过目录, 下次只要记住目录名字, 就可以直接进去, 支持模糊匹配, 用过一次, 无法离开 zsh-users/zsh-autosuggestions: 终端历史操作记录自动补全 vim-mode: 喜欢 vim 键位的可以配合oh-my-zsh开启 vim mode, 当然终端中默认使用的是emacs jeffkaufman/icdiff: diff 的 升级美化版, 高亮文件差异对比工具 jakubroztocil/httpie: curl 的升级美化版,高亮效果和返回结果格式化效果 ack: 更强大的文件内容检索, grep 的升级版本 Taskwarrior: 这个是装逼的, 终端 todo list dbcli/mycli: 这个是装逼的, 终端操作数据库的时候, 自动提示 guarinogabriel/Mac-CLI: 这个是 mac 终端工具一个集合包, 暂时还没用过 生产力工具, 介绍几个常用的插件 有道翻译: 翻译结果回车可到剪贴板 音量控制: 直接输入音量大小, 控制音量 terminal finder: terminal 的目录在 finder 中打开, finder 当前目录在 terminal 中打开 source tree: 直接进入到指定 show desktop: 隐藏所有窗口, 显示桌面 jetBrains: 直接进入到 idea 指定项目的编辑窗口 Search tabs in Safari and Chrome: 搜索到 chrome 或者 safari 中 tab 等等 日常 网易邮箱大师 网易云音乐 chrome 微信 印象笔记 QQ iPic ，图床神器，搭配个人站上传图片使用 百度网盘 Microsoft 365 MacDown，Atom上有MD撰写的插件，不过感觉没这个好用 typora, 评论好多同学分享的另外一款MD的阅读编辑器，简单大方～ 网易有道词典 Xmind，思维导图 OmniGraffle，Visio替代品 番茄土豆，番茄工作法，让你知道其实你一天的工作效率其实低的可怜 OneDrive，微软云的桌面版，可以把仓库克隆到Finder里面实现本地无缝云同步 (2018-10-08 更新） Folx，BT下载工具，告别迅雷 iina，播放工具，开源软件，完全免费,作者还是校友，厉害厉害（相关：作者知乎) 1password，密码管理软件，多终端密码管理 CAJ云阅读，mac版的caj阅读器，妈妈再也不用担心我下载的论文读不了了～ (2019-01-17 更新） duet, 如果你同时拥有一个ipad的话，你一定会需要它。屏幕扩展，让你的ipad成为你的第二个屏幕～ Things3, to-do软件，个人强推，比上面提到的番茄要好的多哈哈哈，我现在已经把番茄卸载了～ 开发工具 Dash，离线api文档，搭配aflred食用体验更佳（后文有aflred） Postman，接口测试工具 iTerm2，替换原生终端 Oh My zsh，zsh扩展，留坑待补充 brew，mac的包管理工具，类似于apt-get一套，开发环境配置不用太简单 tmux，shell多窗口管理，终端断开延续，终端历史共享等（Oh My Tmux!，tmux配套插件，酌情选择使用） Xcode，特别说明，mac的一些系统扩展需要xcode支持，必须下载xcode才能使用 Docker，容器盒子 Atom，GitHub官方IDE，对git有很好的支持，感觉都不会使用sourceTree了 VS Code,另外一款IDE，微软旗下，速度性能很优秀，不输Atom，可以两个都下，同时品味，然后选择最喜欢的一款～ SourceTree，对，就是这个软件，Git的GUI管理软件 Navicat，数据库管理GUI 奇技淫巧（系统增强） Aflred，WorkFlow神器，谁用谁知道 TotalFinder，Finder增强，多标签页管理Finder Dr.Cleaner，内存监控，系统优化 Proxifier ，网络代理软件，支持对单一软件的强制代理 Bartender，菜单栏管理软件，给你一个简洁优雅的菜单栏 Moom，窗口大小管理，谁用谁知道 iStat Menus，菜单栏系统监控（内存，网速，磁盘，电池…..) PopClip，划词增强工具，包括但不限于（上百个官方扩展）：复制，粘贴，翻译，定制搜索（淘宝，知乎，google…） ProxyeeDown，底层 HTTP 高速下载器，支持百度云不限速下载 Disk Drill，数据恢复，磁盘数据安全 Mounty，NTFS格式U盘的完全读写 Qbserve，时间监控，记录你在电脑上花费的时间 Scroll Reveser，鼠标（触摸板）控制滚动翻转，让mac上鼠标滚轮方向不再反人类 cDock，Dock栏增强，几乎你能想到的它都有，不过目前版本1.13部分功能在macOS 10.14中失效了 AppCleaner，超级小，超级好用的app删除工具 Tips（效率提升） 关于双系统： 目前我接触到的最完美的解决办法是Parallels Desktop+bootcamp。 日常使用可以使用pd做虚拟机，需要更强性能和稳定性的时候使用bootcamp。PD真的很强大。。。 关于更加详细的双系统教程，戳这里官方解释（有时间我自己做一个教程～） 通过 Parallels Desktop 使用 Boot Camp 大写键和control键交换一下。contorl键绑定了很多的快捷键，交换了之后可以打开快捷键世界的大门。 屏幕触发角设置，提高鼠标党和单手党的工作效率。 2.如果你是程序员，最好学会使用Alfred，如果你只是普通的用户那也应该学会用Spotlight。Alfred有各种好用的workflow强烈推荐！具体请看：https://github.com/zenorocha/alfred-workflows喜欢这个workflow，不用再跑到terminal里面找pid了… 借助 Alfred 的 Workflows 功能可以做哪些好玩的事情？ 3.Dash + alfred 很好用，程序员必备 这是纯 Dash，加上了 alfred 以后就变成了下面这样： 觉得这几个软件可以提高我们使用的流畅度, 便捷度高,能用快捷键尽量不要用触摸板, 能用触摸板尽量不要用鼠标,来回移动右手, 真的好累!!!!]]></content>
  </entry>
  <entry>
    <title><![CDATA[Github+Hexo搭建个人网站]]></title>
    <url>%2F2019%2F06%2F12%2Fyuque%2FGithub%2BHexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2F2019%2F06%2F12%2Fyuque%2FGit%2F</url>
    <content type="text"><![CDATA[git查看命令地址github接口文档：https://developer.github.com/v3/repos/ 不了解GitHub,可以看 https://github.com/xirong/my-git/blob/master/how-to-use-github.md 作为一名开发者，GitHub上面有很多东西值得关注学习，可是刚刚接触GitHub，怎样一步步学习使用GitHub？怎样更高效的利用GitHub？ 在这里搜集整理网络上面的资料，汇总成这么一篇repo 《GitHub使用指南》，供大家一起学习。 GitHub 入门使用教程-图文并茂 很简洁的说明如何使用，看图即可明白。 GitHub help Sometimes you just need a little help. 中文翻译版在此GitHub 帮助文档。 GitHub 之 fork 简介指南 帮你理解清楚什么是fork，fork 的工作流有哪些。 GitHub-cheat-sheet 关于使用 git 和 GitHub 的一些技巧汇总，中文版在此GitHub秘籍 The GitHub Blog GitHub 官方博客，关注最新动态。 How to Build a GitHub GitHub一名早期员工介绍GitHub的历史，5年108名员工无人离职。 阳志平：如何高效利用GitHub 介绍的挺全，以及一些用法，如怎样利用GitHub来学习、演讲找工作等。 GitHub 支持的 emoji表情 emoji-cheat-sheet ✌️ 👏 感觉不好找到需要的表情？试试Emoji Searcher GitHub guides 从Contributing to Open Source on GitHub、Hello World、Forking Projects、Be Social、Making Your Code Citable、Mastering Issues、Mastering Markdown、Mastering Wikis、Getting Started with GitHub Pages 等9个方面图文详细讲解每一步如何使用，以及能做哪些功能。 fork-me-on-GitHub 个人博客、技术博客等如果需要添加GitHub 的彩带，可以使用此方法。 蒋鑫-GotGitHub 《Git权威指南》的作者，对GitHub有很深的了解。（由于首页打开太慢，放到了本文目录中，下面的文章既是） GitHub Skills Using Git blame to trace changes in a file 如果你想看某一个文件中每一行是谁修改的，为什么修改？那么尽情的使用 blame 按钮，发现文件的历史。 GitHub 搜索技巧 Closing issues via commit messages - 通过提交信息关闭Issues Update your forked code from original repository - 如何更新自己 Fork 的代码 更多关于 GitHub 的内容请查看：GitHubHelp 查找需要的信息。 原文地址：http://www.worldhello.net/gotgithub/index.html git - Retrieve the commit log for a specific line in a file? - Stack Overflow Git - git-blame Documentation Git Book 中文版 - 查找问题的利器 - Git Blame 每一行代码都有记录—如何用git一步步探索项目的历史 - Alexia(minmin) - 博客园Git &amp; Gitlab 使用指南 一、Git 有什么奇技淫巧？ 如何以光速查看一行代码的提交记录 在保存所有的文件的情况下，删除所有的commit记录： 检出 1git checkout --orphan latest_branch 添加所有文件夹 1git add -A 评论消息改动 1git commit -am "just come and commit" 删除分支 1git branch -D master 将现有分支设置为master 1git branch -m master push 1git push -f origin master 在尝试过所有命令都不能把你从深渊里挽救出来的时候, git reflog 也许能起作用。 比如撤销一次 rebase（rebase 可是会直接修改历史的，一定要了解原理后再使用） Undoing a git rebase 每次 merge 完总是出现很多 .orig 文件，使用 git clean -f 干掉所有 untracked files rebase 一个 diverged 分支一直要解决冲突很痛苦，可以尝试在自己的分支先 squash 一下，git rebase -i，然后再 rebase 主干，解决一次冲突就 ok 了 本地有很多其实早就被删除的远程分支，可以用 git remote prune origin 全部清除掉，这样再 checkout 别的分支时就清晰多了. 1git bisect 有没有过写了一天的代码，checkin无数，结果突然发现之前没注意的地方break的时候？这个时候要在茫茫commits里寻找那个错误的commit是多么的痛苦啊。git-bisect就是大救星！git-bisect本质上就是一个二分法，用起来也很简单： 123git bisect start #startgit bisect bad #current branch is badgit bisect good &lt;SHA-1&gt; #some old commit that is good 然后只要不停的告诉git当前commit是不是好的， 1git bisect good or 1git bisect bad 就能找到罪魁祸首了！ 二、Git log常见用法 三、git checkout 命令详解 四、git重要的三个命令stash, checkout, reset的一些总结 正常的情形，修改工作区的文件然后add，commit，我使用git一般的流程是：git status ——&gt; git stash save “message…”——&gt; git pull –&gt; git stash pop ——&gt; git add . 或 git add filename ——&gt; git commit -m ‘message…’ ——&gt; git push 其中 . 表示所有的文件。 只需要撤销工作区的文件修改，即用暂存区的文件覆盖工作区中的文件 git checkout – filename 当修改的文件已经add到暂存区，需要撤销这次添加，即撤销上一次git add filename 操作： git reset – filename / git reset HEAD filename 撤销暂存区内所有的文件改动:git reset / git reset HEAD 当对上次提交不满意，可以让HEAD指针回退，而暂存区和工作区可以不用动 git reset –soft HEAD^ 如果让工作区不改变，而暂存区和引用（HEAD指针）回退一次 git reset –mixed HEAD^ 当需要彻底撤销最近的提交，HEAD指针、暂存区、工作区都回到上次的提交状态，自上一次以来的提交全部丢失 git reset –hard HEAD^ git stash 用于保存和恢复工作进度。 git stash 保存当前的工作进度。会分别对暂存区和工作区的状态进行保存。 git stash list 显示进度列表。此命令显然暗示了git stash 可以多次保存工作进度，并用在恢复时候选择。 git stash drop [] 删除一个存储的进度。默认删除最新的进度。 git stash clear 删除所有存储的进度。 git stash pop [–index] [] –index 参数：不仅恢复工作区，还恢复暂存区 指定恢复某一个具体进度。如果没有这个参数，默认恢复最新进度 如：以下命令恢复编号为0的进度的工作区和暂存区 1# git stash pop --index stash@&#123;0&#125; 如果不使用任何参数，会恢复最新保存的工作进度，并将恢复的工作进度从存储的工作进度列表中清除。 如果提供参数（来自git stash list显示的列表），则从该中恢复。恢复完毕也将从进度列表中删除。 选项–index除了恢复工作区的文件外，还尝试恢复暂存区。这也就是为什么恢复进度的时候显示的状态和保存进度前的略有不同。 git stash [save [–patch] [-k|–[no]keep-index] [-q|–quiet] []] 这条命令实际上是git stash命令的完整版。 save，即如果需要在保存工作进度的时候使 用指定的说明，必须使用如下格式： git stash save “message…” 使用参数–patch会显示工作区和HEAD的差异，通过对差异文件的编辑决定在进度中 最终要保存的工作区的内容，通过编辑差异文件可以在进度中排除无关内容。 使用-k或者–keep-index参数，在保存进度后不会将暂存区重置。默认会将暂存区和工 作区强制重置。 git stash apply [–index] [] 除了不删除恢复的进度之外，其余和git stash pop 命令一样。 检出命令git checkout是git最常用的命令之一，同时也是一个很危险的命令，因为这条命令会重写工作区。 检出命令的用法如下：用法一：git checkout [-q] [] [–] …用法二：git checkout []用法三：git checkout [-m] [[-b]–orphan] ] [] 注：&lt;1&gt; 为了避免路径和引用（或者提交ID）同名而发生冲突，可以在前用两个连续的短线（短号）–作为分隔。&lt;2&gt; 在用法一中， 省略commit：用暂存区的文件覆盖工作区的文件。 加上commit：用指定提交中的文件覆盖暂存区和工作区中的文件。 &lt;3&gt;在用法二中，会改变HEAD头指针 加上：因为只有HEAD切换到一个分支才可以对提交进行跟踪，否则仍然会进入“分离头指针”的状态。在“分离头指针”状态下的提交不能被引用关联到，从而可能丢失。 所以用法二（加上）最主要的作用就是切换到某分支。(2）省略：则相当于对工作区进行状态检查。&lt;4&gt;在用法三中，主要是创建和切换到新的分支（），新的分支从指定的提交开始创建。新分支和我们熟悉的master分支没有什么实质的不同，都是在refs/heads命名空间下的引用。 下图所示的版本库模型图描述了git checkout实际完成的操作。使用： git checkout branch 检出branch分支。要完成图中的三个步骤，更新HEAD以指向branch分支，以及用branch 指向的树更新暂存区和工作区。 git checkout / git checkout HEAD 汇总显示工作区、暂存区与HEAD的差异。 git checkout – filename 用暂存区中filename文件来覆盖工作区中的filename文件。相当于撤销自上次执行git add filename以来（如果执行过）的本地修改。 git checkout – . / git checkout . 这条命令最危险！会撤销所有本地的修改（相对于暂存区）。相当于用暂存区的所有文件直接覆盖本地文件，不给用户任何确认的机会！ git reset是Git最常用的命令之一，也是最危险最容易误用的命令。用法一：git reset [-q] [] [–] …用法二：git reset [–soft –mixed | –hard | –merge | –keep] [-q] []注：（1）第一种用法（包含了路径的用法）不会重置引用，更不会改变工作区，而是用指定提交状态()下的文件()替换掉暂存区中的文件。例如：git reset HEAD 相当于取消之前执行的git add 命令时改变的暂存区。（2）第二种用法（不使用路径的用法）则会重置引用。根据不同的选项，可以对暂存区或工作区进行重置。参照下面的版本库模型图，可以看不同的参数对第二种重置语法的影响。命令格式：git reset [–soft | –mixed | –hard] []（1）使用参数–soft，如 git reset –soft 会执行上图中的操作①。即只更改引用的指向，不改变暂存区和工作区。（2）使用参数–mixed或者不使用参数（默认为–mixed），如 git reset 会执行上图中的操作①和②。即更改引用的指向及重置暂存区，但是不改变工作区。（3）使用参数–hard，如git reset –hard 会执行上图中的全部动作①、②、③，（理解为此时工作区、暂存区、commit都相同）即： ①替换引用的指向。引用指向新的提交ID。 ②替换暂存区。替换后，暂存区的内容和引用指向的目录树一致。 ③替换工作区。替换后，工作区的内容变得和暂存区一致，也和HEAD所指向的目录树内容相同。注： 引用即HEAD指针 使用：git reset / git reset HEAD仅用HEAD指向的目录树重置暂存区，工作区不会受到影响，相当于将之前用git add命令更新到暂存区的内容撤出暂存区。引用也未改变，因为引用重置到HEAD相当于没有重置。git reset – filename / git reset HEAD filename仅将文件filename 的改动撤出暂存区，暂存区中其他文件不改变。相当于命令git add filename 的反射操作。git reset –soft HEAD^工作区和暂存区不改变，但是引用向前回退一次。当对最新的提交说明或者提交的更改不满意时，撤销最新的提交以便重新提交。之前提到过修补提交命令git commit –amend，用于对最新的提交进行重新提交以修补错误的提交说明或者错误的提交文件。修补提交命令实际上相当于执行了下面两条命令。（注：文件.git/COMMIT_EDITMSG保存了上次的提交日志） git reset –soft HEAD^ git commit -e -F .git/COMMIT_EDITMSGgit reset HEAD^ / git reset –mixed HEAD^工作区不改变，但是暂存区会回退到上一次提交之前，引用也会回退一次。git reset –hard HEAD^彻底撤销最近的提交。引用回退到前一次，而且工作区和暂存区都会回退到上一次提交的状态。自上一次以来的提交全部丢失。 五、如何以光速查看一行代码的提交记录怎么查是谁写的，命令行工具git blame 1git blame -L 99,99 package.json 即使把这个命令设置为快捷方式，一行一行的查询也是非常耗费精力的，那么有没有一眼可以看到的方式呢？那就是直接在 GitHub 上查。]]></content>
  </entry>
  <entry>
    <title><![CDATA[vscode]]></title>
    <url>%2F2019%2F06%2F12%2Fyuque%2Fvscode%2F</url>
    <content type="text"><![CDATA[VSCode 拓展推荐 使用说明 相似功能的插件，不推荐全都装上，请挑选一个使用 本列表所有插件均已测试使用过，但不代表不存在问题 任何插件本身的问题，请到对于代码仓库提交 issue 插件 名称 简述 Auto Close Tag 自动闭合 HTML 标签 Auto Import import 提示 Auto Rename Tag 修改 HTML 标签时，自动修改匹配的标签 Babel JavaScript babel 插件，语法高亮 Babelrc .babelrc 文件高亮提示 Beautify css/sass/scss/less css/sass/less 格式化 Better Align 对齐赋值符号和注释 Better Comments 编写更加人性化的注释 Bookmarks 添加行书签 Bracket Pair Colorizer 用不同颜色高亮显示匹配的括号 Can I Use HTML5、CSS3、SVG 的浏览器兼容性检查 Code Outline 展示代码结构树 Code Runner 运行选中代码段（支持多数语言） Code Spell checker 单词拼写检查 CodeBing 快速打开 Bing 并搜索，可配置搜索引擎 Color Highlight 颜色值在代码中高亮显示 Color Info 小窗口显示颜色值，rgb,hsl,cmyk,hex 等等 Color Picker 拾色器 CSS-in-JS CSS-in-JS 高亮提示和转换 Dash 集成 Dash Debugger for Chrome 调试 Chrome Document This 注释文档生成 DotENV .env 文件高亮 EditorConfig for VS Code EditorConfig 插件 Emoji 在代码中输入 emoji endy 将输入光标跳转到当前行最后面 ESLint ESLint 插件，高亮提示 File Peek 根据路径字符串，快速定位到文件 filesize 状态栏显示当前文件大小 Find-Jump 快速跳转到指定单词位置 Font-awesome codes for html FontAwesome 提示代码段 ftp-sync 同步文件到 ftp Git Blame 在状态栏显示当前行的 Git 信息 Git History(git log) 查看 git log gitignore .gitignore 文件语法 GitLens (Git 增强)显示文件最近的 commit 和作者，显示当前行 commit 信息 GraphQL for VSCode graphql 高亮和提示 Guides 高亮缩进基准线 Gulp Snippets Gulp 代码段 HTML CSS Class Completion CSS class 提示 HTML CSS Support css 提示（支持 vue） HTMLHint HTML 格式提示 htmltagwrap 快捷包裹 html 标签 htmltagwrap 包裹 HTML Import Beautify import 分组、排序、格式化 Import Cost 行内显示导入（import/require）的包的大小 Indenticator 缩进高亮 IntelliSense for css class names css class 输入提示 JavaScript (ES6) code snippets ES6 语法代码段 JavaScript Standard Style Standard 风格 JS Refactor 代码重构工具，提取函数、变量重命名等等 JSON to TS JSON 结构转化为 typescript 的 interface JSON Tools 格式化和压缩 JSON jumpy 快速跳转到指定单词位置 language-stylus Stylus 语法高亮和提示 Less IntelliSense less 变量与混合提示 Lodash Lodash 代码段 Log Wrapper 生产打印选中变量的代码 markdownlint Markdown 格式提示 MochaSnippets Mocha 代码段 Node modules resolve 快速导航到 Node 模块 npm 运行 npm 命令 npm Intellisense 导入模块时，提示已安装模块名称 Output Colorizer 彩色输出信息 Partial Diff 对比两段代码或文件 Path Autocomplete 路径完成提示 Path Intellisense 另一个路径完成提示 Polacode 将代码生成图片 PostCss Sorting css 排序 Prettier - Code formatter prettier 官方插件 Prettify JSON 格式化 JSON Project Manager 快速切换项目 Quokka.js 不需要手动运行，行内显示变量结果 React Native Storybooks storybook 预览插件，支持 react React Playground 为编辑器提供一个 react 组件运行环境，方便调试 React Standard Style code snippets react standar 风格代码块 REST Client 发送 REST 风格的 HTTP 请求 Sass sass 插件 Settings Sync VSCode 设置同步到 Gist Sort lines 排序选中行 Sort Typescript Imports typescript 的 import 排序 String Manipulation 字符串转换处理（驼峰、大写开头、下划线等等） stylelint css/sass/less 代码风格 SVG Viewer SVG 查看器 Syncing vscode 设置同步到 gist Test Spec Generator 测试用例生成（支持 chai、should、jasmine） TODO Parser Todo 管理 TS/JS postfix completion ts/js 后缀提示 TSLint TypeScript 语法检查 Types auto installer 自动安装@types 声明依赖 TypeScript Hero TypeScript 辅助插件，管理 import、outline 等等 TypeScript Import TS 自动 import TypeScript Import Sorter import 整理排序 Typescript React code snippets React Typescript 代码段 TypeSearch TS 声明文件搜索 Version Lens package.json 文件显示模块当前版本和最新版本 vetur 目前比较好的 Vue 语法高亮 View Node Package 快速打开选中模块的主页和代码仓库 VS Live Share 实时多人协助 VSCode Great Icons 文件图标拓展 vscode-database 操作数据库，支持 mysql 和 postgres vscode-icons 文件图标，方便定位文件 vscode-random 随机字符串生成器 vscode-spotify 集成 spotify，播放音乐 vscode-styled-components styled-components 高亮支持 vscode-styled-jsx styled-jsx 高亮支持 Vue TypeScript Snippets Vue Typescript 代码段 VueHelper Vue2 代码段（包括 Vue2 api、vue-router2、vuex2） Wallaby.js 实时测试插件 12345678910111213141516171819202122232425262728293031323334353637&#123; "breadcrumbs.enabled": true, "editor.tabSize": 2, "editor.renderWhitespace": "boundary", "editor.cursorBlinking": "smooth", "editor.minimap.renderCharacters": false, "editor.fontFamily": "'Fira Code', 'Droid Sans Mono', 'Courier New', monospace, 'Droid Sans Fallback'", "editor.fontLigatures": true, "explorer.confirmDragAndDrop": false, "extensions.autoUpdate": false, "files.insertFinalNewline": true, "git.autofetch": true, "git.path": "F:\\Program Files\\Git\\cmd\\git.exe", "search.exclude": &#123; "**/node_modules": true, "**/dist": true &#125;, "typescript.locale": "en", "window.titleBarStyle": "custom", "window.title": "$&#123;dirty&#125;$&#123;activeEditorMedium&#125;$&#123;separator&#125;$&#123;rootName&#125;", "window.zoomLevel": 1, "workbench.activityBar.visible": true, "workbench.colorTheme": "Plastic - deprioritised punctuation", "workbench.iconTheme": "vscode-great-icons", "workbench.startupEditor": "newUntitledFile", "eslint.autoFixOnSave": true, "eslint.validate": ["javascript", "javascriptreact", "vue"], "vsicons.projectDetection.autoReload": true, "vsicons.dontShowNewVersionMessage": true, "tslint.autoFixOnSave": true, "debugwrapper.wrappers": &#123; "default": "console.log('$eSEL', $SEL)" &#125;, "prettier.tslintIntegration": true, "cSpell.userWords": ["Unmount"], "jest.autoEnable": false&#125; Visual Studio Code 最好的功能、插件和设置 让 create-react-app 支持 do 表达式 1.先安装@babel/plugin-proposal-do-expressions2.在.babelrc里配置： 1"plugins": ["@babel/plugin-proposal-do-expressions"] 3.vsCode 不支持 ES6 do{}表达式，这样设置即可： 全局安装：npm install -g eslint 安装 babel-eslint: npm install –save-dev babel-eslint 安装 eslint-plugin-react(如果你用 react 的话): npm install –save-dev eslint-plugin-react 创建’.eslintrc’文件 12345678910111213141516171819202122232425262728293031323334353637383940414243&#123; "env": &#123; "browser": true, "node": true, "es6": true, "jest": true, "jquery": true &#125;, "parser": "babel-eslint", "parserOptions": &#123; "ecmaVersion": 6, "sourceType": "module", "ecmaFeatures": &#123; "arrowFunctions": true, "binaryLiterals": true, "blockBindings": true, "classes": true, "defaultParams": true, "destructuring": true, "forOf": true, "generators": true, "modules": true, "objectLiteralComputedProperties": true, "objectLiteralDuplicateProperties": true, "objectLiteralShorthandMethods": true, "objectLiteralShorthandProperties": true, "octalLiterals": true, "regexUFlag": true, "regexYFlag": true, "spread": true, "superInFunctions": true, "templateStrings": true, "unicodeCodePointEscapes": true, "globalReturn": true, "jsx": true, "experimentalObjectRestSpread": true &#125; &#125;, "plugins": ["react"], "rules": &#123; "strict": 0 &#125;&#125; 关闭 vscode 的语法验证:”javascript.validate.enable” : false vscode 主题背景设置 JavaScript 开发者 10 种必备 VS Code 扩展 代码片段扩展当您第一次安装 VS Code 时，它附带了几个 JavaScript 和 Typescript 的代码片段功能。在开始编写现代 JavaScript 之前，您需要一些额外的代码片段来帮助您快速编写重复的 ES6 / ES7 代码： VS Code JavaScript(ES6) snippets ：目前最流行的，迄今为止安装量超过 120 万。此扩展为 JavaScript ， TypeScript ，HTML，React和Vue扩展提供 ES6 语法支持。 JavaScript Snippet Pack：JavaScript 有用的代码片段集合。 Atom JavaScript Snippet：从 atom/language-javascript 扩展移植的JavaScript代码段。 JavaScript Snippets：一系列ES6片段。此扩展包含 Mocha，Jasmine和其他BDD测试框架的片段。 注：另外你也可以根据自己的习惯创建代码片段，请参阅 如何在 Visual Studio Code 中创建代码片段 。 语法扩展VS Code 为 JavaScript 代码提供了非常好的语法高亮显示。 您可以通过安装主题来更改颜色。 但是，如果您想要增强代码的可读性，则需要语法高亮显示扩展。 以下是其中几个： JavaScript Atom Grammar：此扩展使用 Atom 编辑器中的 JavaScript 语法替换 Visual Studio Code 中的 JavaScript 语法。 Babel JavaScript：支持 ES201x JavaScript，React，FlowType和GraphQL代码的语法高亮显示。 DotENV：支持.env文件语法高亮显示。如果您正在使用Node，请使用方便。 代码检测扩展编写有效的 JavaScript 代码时，需要一个能够为所有团队成员强制执行特定编码风格的检测工具(linter)。 ESLint 是最受欢迎的，因为它支持许多编码风格，包括 Standard ，Google 和 Airbnb 。 以下是 Visual Studio Code 最流行的 linter 插件： ESLint ：此扩展将 ESLint 集成到 VS Code 中。它是最受欢迎的 linter 扩展，迄今为止安装量超过670万。规则在 .eslintrc.json 中配置。 JSHint ：JSHint 的代码检查器扩展。在项目的根目录使用 .jshintrcfile 进行配置。 JavaScript Standard Style ：零配置和严格规则的检测工具。执行 StandardJS 规则。 JSLint ：JSLint的 linter 扩展。 如果您想了解可用的 检测工具(linter) 及 各自的优缺点，请查看我们对 JavaScript linting 工具的比较 。 Node 扩展每个 JavaScript 项目都需要至少一个 Node 包，除非你是一个喜欢艰苦工作的人。以下是一些 VS Code 扩展，可帮助您更轻松地使用 Node 模块。 npm ：使用 package.json 验证已安装的软件包。确保已安装的软件包版本号正确，高亮显示 package.json 中缺少的已安装软件包以及尚未安装的软件包。 Node.js Modules IntelliSense：自动补全 import 语句中的 JavaScript 和 TypeScript 模块。源码：vscode-node-module-intellisense Path IntelliSense ：它和 Node 其实并不相关，但你肯定需要对本地文件的智能提示，这个扩展将自动补全文件名。 Node exec ：允许您使用Node.js执行当前文件或您选择的代码。 View Node Package ：使用此扩展快速查看 Node 包源，允许您直接从 VS Code 打开 Node 包仓库库/文档。 Node Readme ：快速打开npm包文档。 Search node_modules ：此扩展允许您搜索 node_modules 文件夹，该文件夹不在默认的搜索范围内。源码：vscode-search-node-modules。 Import Cost ：显示导入的包的大小。源码：import-cost。 代码格式化扩展偶尔，您会发现自己格式化的代码并非以首选的编码风格编写。为了节省时间，您可以以下任何的 VS Code 扩展来快速格式化和重构现有代码： Beatufy ：一个支持 JavaScript，JSON，CSS 和 HTML 的 jsBeautifier(代码美化) 扩展。可以通过 .jsbeautifyrc 文件进行自定义。迄今为止最流行的格式化工具，安装量为 230 万次。 Prettier Code Formatter ：一个扩展，支持使用Prettier（一种固定代码格式化程序）格式化JavaScript，TypeScript和CSS。迄今已安装超过150万。 JS Refactor ：提供了许多用于重构 JavaScript 代码的实用程序和操作，例如提取变量/方法，将现有代码转换为使用箭头函数或模板字面量以及导出函数。 JavaScript Booster ：一个牛逼的代码重构工具。具有多种编码操作，例如将 var 转换为 const 或 let ，删除冗余的 else语句，以及合并声明和初始化。很大程度上受到 WebStorm 的启发。源码：vscode-javascript-booster。 浏览器扩展除非你是在用 JavaScript 编写控制台程序，否则您很可能会在浏览器中执行 JavaScript 代码。 这意味着,您需要经常刷新页面来查看您所做的每次代码更新的效果。 这里有一些工具可以显着减少重复过程的开发时间，而不是每次都手动刷新浏览器： Debugger for Chrome ：在 Chrome 中轻松调试 JavaScript（通过在编辑器中设置断点）。源码：vscode-chrome-debug。 Live Server ：具有静态和动态页面的实时重新加载功能的本地开发服务器。源码：vscode-chrome-debugvscode-live-server。 Preview on Web Server ：提供web服务器和实时预览功能。 PHP Server ：对于测试仅需要在客户端运行的 JavaScript 代码非常有用。。 Rest Client ：您可以安装此工具以在编辑器内交互式运行HTTP 请求，而不是使用浏览器或 CURL 程序来测试 REST API 端点。 框架类扩展对于大多数项目，您需要一个合适的框架来构建代码并缩短开发时间。 VS Code 通过扩展支持大多数主流框架。 但是，仍然有许多已建立的框架尚未完全支持。 以下是一些提供重要功能的 VS Code 扩展。 Angular 6 ：提供 Angular 6 的代码片段。支持 Typescript，HTML，Angular Material ngRx，RxJS 和 Flex Layout。到目前为止，已安装了220多万个安装和 172 个 Angular 代码片段。 Angular v5 snippets ：为 TypeScript，RxJS，HTML 和 Docker 文件提供 Angular 代码片段。迄今为止已有 270多 万个安装量。 React Native/React/Redux snippets for es6/es7 ：为所有这些框架提供 ES6 / ES7 语法的片段。 React Native Tools ：为 React Native 框架提供智能提示，命令行工具和调试功能。 Vetur ：为Vue框架提供语法高亮，代码片段，Emmet，linting（代码检测），格式化，智能提示和调试支持。它附带了在 GitBook 上发布的使用文档 。 Ember ：为Ember提供命令支持和智能提示。安装后，所有 ember cli 命令都可以通过 VS Code 自己的命令行列表中使用。 Cordava Tools ：支持 Cordova 插件和 Ionic 框架。为基于 Cordova 的项目提供智能提示，调试和其他支持功能。 jQuery Code Snippets ：提供了超过130个jQuery的代码片段，使用 jq 前缀来激活。 测试类扩展测试是软件开发的关键环节，特别是对于处于生产阶段的项目。 您可以全面了解 JavaScript 的测试，并且你可以通过阅读我们的指南：JavaScript测试：单元测试 vs 功能测试 vs 集成测试 来获得更多不同类型的测试的信息。 Mocha sidebar ：为使用 Mocha 库进行测试的项目提供支持。此扩展可帮助您直接在代码上运行测试，并将错误信息以装饰器形式显示。 ES Mocha Snippets ：提供 ES6 语法的 Mocha 代码片段。这个插件的重点在于利用箭头函数，尽可能减少花括号的使用，保持代码的紧凑。可通过设置允许使用分号。 Jasmine Code Snippets ：针对Jasmine测试框架的代码片段。 Protractor Snippets ：Protractor 框架的端到端测试片段。支持 JavaScript 和 Typescript 。 Node TDD ：为Node和JavaScript项目的测试驱动开发提供支持。可以在更新源时触发自动测试构建。源码：node-tdd 。 还有一些非常棒的扩展我只是将下一批 VS Code 扩展归入到 “awesome” 类别中，因为它最能描述它们！ Quokka.js ：一个很棒的调试工具，为 JavaScript 代码提供快速原型操作。附带 优秀的文档 。 Paste as JSON ：快速将 JSON 数据转换为 JavaScript 代码。源码：quick-type。 Code Metrics ：这是计算 JavaScript 和 TypeScript 代码复杂性的另一个很棒的扩展。源码：codemetrics 。 扩展包现在我们已经进入最后一个类别，我想告诉您，VS Code 市场有 一个扩展包类别 。 从本质上讲，它们是相关联的一些 VS Code插件的集合，打成一个包，方便安装。这里有些较好的： Nodejs Extension Pack ：这个包里包含了 ESLint、npm、JavaScript(ES6) 代码片段、搜索 node_modules、NPM IntelliSense 和 路径智能提示。 VS Code for Node.js – Development Pack ：包含 这个有 NPM 智能提示，ESLint，Chrome 调试器，代码指标，Docker和 导入包的字节开销。 Vue.js Extension Pack ：Vue 和 JavaScript 扩展的集合。它目前包含大约 12 个 VS Code 扩展，其中一些在这里没有提到，例如 auto-rename-tag 和 auto-close-tag。 Ionic Extesion Pack：此包包含许多用于Ionic，Angular，RxJS，Cordova和HTML开发的 VS Code 扩展。 更多的 Visual Studio Code 主题、功能、插件和设置 Visual Studio Code 最好的功能、插件和设置 使用顶级 VSCode 扩展来加快开发 JavaScript Visual Studio Code 必备插件，主题及语法提示 原文链接：https://www.sitepoint.com/vs-code-extensions-javascript-developers/]]></content>
  </entry>
  <entry>
    <title><![CDATA[Theme]]></title>
    <url>%2F2019%2F06%2F11%2Fyuque%2FTheme%2F</url>
    <content type="text"><![CDATA[根据Hexo博客的自动发布体系，想要完整的主题，也有主题收集 hexo主题：https://hexo.io/themes/ next主题：https://theme-next.iissnan.com/]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo同步语雀文章一]]></title>
    <url>%2F2019%2F06%2F11%2Fyuque%2FHexo%E5%90%8C%E6%AD%A5%E8%AF%AD%E9%9B%80%E6%96%87%E7%AB%A0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[创建 Hexo 博客已经有 Hexo 博客的可以跳过。如果你是 Jekyll ，也可以跳过。 安装 Node.js 安装 Hexo 脚手架 12345npm install -g hexo-clihexo init blogcd blognpm install or yarn installhexo server Hexo建站参考Hexo官方文档：https://hexo.io/zh-cn/docs/ 安装语雀文章下载插件yuque-hexo 是一个 Node.js 环境下的语雀下载器，使用 npm 安装 安装 yuque-hexo 注册语雀，创建知识库，获得你的个人路径和知识库的名字，比如我的博客的知识库是 :https://www.yuque.com/fangcao/api 在 Hexo 博客的目录下面的 package.json 中，进行下面的配置 123456789101112131415161718192021222324252627282930313233343536373839&#123; "name": "hexo-site", "version": "0.0.0", "private": true, "hexo": &#123; "version": "3.8.0" &#125;, "dependencies": &#123; "hexo": "^3.8.0", "hexo-generator-archive": "^0.1.5", "hexo-generator-category": "^0.1.3", "hexo-generator-index": "^0.2.1", "hexo-generator-tag": "^0.2.0", "hexo-renderer-ejs": "^0.3.1", "hexo-renderer-marked": "^1.0.1", "hexo-renderer-stylus": "^0.3.3", "hexo-server": "^0.3.3" &#125;, "yuqueConfig": &#123; "baseUrl": "https://www.yuque.com/api/v2", "login": "fangcao", "repo": "api", "mdNameFormat": "title", "postPath": "source/_posts/yuque", "token": "放上自己的语雀token" &#125;, "scripts": &#123; "clean": "hexo clean", "clean:yuque": "DEBUG=yuque-hexo.* yuque-hexo clean", "deploy": "hexo deploy", "publish": "npm run clean &amp;&amp; npm run deploy", "dev": "hexo s", "sync": "DEBUG=yuque-hexo.* yuque-hexo sync", "reset": "npm run clean:yuque &amp;&amp; npm run sync" &#125;, "devDependencies": &#123; "yuque-hexo": "^1.6.1" &#125;&#125; 参数名 含义 默认值 postPath 文档同步后生成的路径 source/_posts/yuque cachePath 文档下载缓存文件 yuque.json mdNameFormat 文件名命名方式 (title / slug) title adapter 文档生成格式 (hexo/markdown) hexo concurrency 下载文章并发数 5 baseUrl 语雀 API 地址 - login 语雀 login (group) - repo 语雀仓库短名称 - onlyPublished 只展示已经发布的文章 如果不是 Hexo 博客，则需要按照上面的文件保存一个 package.json 到博客目录，并且配置 postPath 为正确的文章目录 同步文章 1yuque-hexo sync 语雀同步过来的文章会生成两部分文件； yuque.json: 从语雀 API 拉取的数据 source/_posts/yuque/*.md: 生成的 md 文件 支持配置 front-matter, 语雀编辑器编写示例如下: 语雀编辑器示例，可参考hexo的终极玩法 配置GitHub pages首先需要一个GitHub账号然后可以具体可参照官方教程 改变主题这是官方的主题网站将主题clone到你的theme，在配置文件中将theme改变为你下载的主题名称然后编译，运行，发布。 使用next主题的可以参考官方网址 配置Travis CI之前也有不少文章用不同的方法解决上述的问题，例如利用 Dropbox 同步或者利用 Github 的 Webhooks 进行自动部署。这些方法需要付出一定的成本，因为都需要利用到一台 VPS 去完成。而今有一个更加简单而且免费的方法去完成 hexo 的自动部署，就是利用 Travis CI。 重点来了，详细步骤可参考用 Travis CI 自动部署 hexo，手把手教你Travis CI,作者已经说的比较详细。需要注意的一点是：在package.json中增加depoly的命令行语句，防止travis在自动执行到npm run deploy这一步的时候报找不到该script的错。 123&quot;scripts&quot;: &#123; &quot;deploy&quot;: &quot;hexo clean &amp;&amp; hexo g -d&quot;&#125;, 上述代码加在dependencies同级即可。 查看TravisCi https://travis-ci.org/fangcao7618/fangcao7618.github.io 主题： 主题选择：next 主题主题二：https://hexo.io/themes/ https://theme-next.org/ 例子：https://www.jinrishici.com/]]></content>
  </entry>
  <entry>
    <title><![CDATA[通过 ngrok 实现 ssh 内网穿透]]></title>
    <url>%2F2019%2F06%2F11%2Fyuque%2F%E9%80%9A%E8%BF%87%20ngrok%20%E5%AE%9E%E7%8E%B0%20ssh%20%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%2F</url>
    <content type="text"><![CDATA[ngrok用 ssh 访问一台主机，如果和主机在一个局域网中或者主机拥有公网 IP，就可以使用 ssh 命令直接连接主机的 IP 地址，但是大部分公司和家庭内部都是局域网，并不能给局域网内的每一台主机都分配一个公网 IP，这时候就需要进行内网穿透，才能从外部连接到局域网内的主机。ngrok 是一个反向代理工具，可以实现将内网的端口暴露到公网，通过 ngrok，也能将 ssh 使用的端口暴露出去，以此实现 ssh 的内网穿透。 注册并下载 ngrok访问 https://ngrok.com/ 注册 ngrok 账号并下载 ngrok 客户端。 查看 ngrok 的 token访问 https://dashboard.ngrok.com/auth 查看 token并复制。 在内网机器上启动 ngrok连接 ngrok 账号 1ngrok authtoken 5TqUhMnum6ntDE8Z5HkNb_49F9ffzzcV9V7pKLVdDYc 启动 ngrok 并打开 22 端口转发 1ngrok tcp 22 --log=stdout &gt; &quot;$HOME/ngrok.log&quot; --region ap &amp; 其中 region 的 ap 代表 ngrok 新加坡节点，访问速度相比美国节点会快一些。访问 https://ngrok.com/docs#config-options 可以查看支持的所有区域。访问 http://127.0.0.1:4040。可以看到一个tcp开头的地址，通过访问这个地址，就可以转发到本机的 22 端口上。 通过 ssh 访问内网机器查看到转发地址后，就可以在外网通过 ssh 命令访问内网机器来。以上图为例，ssh 访问的命令是： 1ssh -p 10502 username@0.tcp.ap.ngrok.io 需要注意的问题由于所有流量都要经过 ngrok 服务器，而 ngrok 的服务节点又只有美国、新加坡等地，所以速度上还是比较慢的。另外，如果 ngrok 的服务节点存在安全隐患的话，存在敏感内容的泄漏的可能性。]]></content>
  </entry>
  <entry>
    <title><![CDATA[语雀 + netlify 自动部署静态博客]]></title>
    <url>%2F2019%2F06%2F11%2Fyuque%2F%E8%AF%AD%E9%9B%80%20%2B%20netlify%20%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[语雀 + netlify 1. netlify 配置1一、使用github或者gitlab登陆netlify首先，打开netlify网站(https://app.netlify.com/)然后使用github或者gitlab账号登录。二、根据github/gitlab仓库创建网站点击New site from Git按钮： 根据你的仓库所在平台选择，以下三选一：选择你需要部署的仓库：设置部署选项，包括三点： 部署分支（对应下图中 Branch to deploy）:顾名思义就是你的git仓库的分支，默认选择为master分支 打包命令（对应下图中 Build command）：就是你的打包命令，诸如 npm run build，gulp build 之类；如果本身已是静态文件，不需打包编译，这一栏则不填 打包后目录（对应下图中 Publish directory）：即执行完打包命令之后静态文件所在目录，诸如 dist，_site 之类；如果本身已是静态文件，这一栏则不填 完成之后点击途中 deploy site 按钮 三、设置域名，绑定域名进行完第二步，我们可以看到自动化部署已经开始运行了，而且过不多久，我们的网站就已经可以利用netlify域名就行访问了，如下图：可以看到netlify为我们随机生成了一个netlify下的域名，这里我们可以更改其前缀，并绑定到我们自己的域名下：&gt;&gt; 更改netlify域名前缀：首先，点击上图中 Site settings 按钮，然后在下方点击 Change site name 按钮，然后在弹出框中输入自己需要更改的前缀名，点击保存即可，如下图所示：&gt;&gt; 绑定到自己的域名下：首先，点击上上图中 Domain settings 按钮，然后在下方点击 Add custom domain 按钮，然后在弹出框中输入自己需要绑定的完整域名，点击保存，如下图所示：这个时候会显示 ！Check DNS configuration，因为我们还没有设置域名解析到netlify服务器，所以这个时候需要到你自己域名的相应服务商网站登录之后在需要绑定的域名下添加一条CNAME解析，解析的主机记录即对应的netlify域名值（这里即 codernie.netlify.com）ok，过一会儿就可以使用自己的域名访问自己的网站啦 四、生成HTTPS证书，实现HTTPS访问第四部中的Domain settings 中往下拉，可以看到 HTTPS 几个大字母：点击 Verify DNS configuration 按钮，待它变成下方绿色按钮之后，再点击：然后在弹出框中点击确认，过一会儿之后就可以使用https访问你的小站啦：看到自己的小站前面可以有绿色的安全字样，是不是很酷炫，而且很放心，再也不用担心运营商在自己的网站上挂广告啦，哈哈哈。。。等等，是不是还差了点什么：对啊，还没有强制跳转https，OK，继续 五、强制HTTP跳转HTTPS访问在第四步 Domain settings 再往下翻一点，可以看到 Force HTTPS，只需点击 Force HTTPS 即可实现，是不是很方便，如下图： 六、设置redirect利用netlify实现自动化部署和HTTPS就写到这里了。 https://app.netlify.com/sites/stoic-murdock-f3d33b/settings/general 2. netlify 配置2前往 Settings -&gt; Build &amp; Deploy 找到 Build hooks，添加一个 build hook 3. 语雀配置URL 填入刚刚从 netlify 生成的 hook 链接 所有更新触发：该知识库下的任何一篇文档的更新都会触发 WebHook 仅主动推送更新触发：只在文档发布或更新的时候勾选了「文档有较大更新，推送给关注人」才会触发 WebHook 同步语雀文章Gatsby -&gt; https://github.com/Raincal/gatsby-source-yuqueVuePress -&gt; https://github.com/ulivz/vuepress-plugin-yuqueHexo -&gt; https://github.com/x-cold/yuque-hexo完成上面三步后，就可以尝试发布新文章啦！参考文章Hexo 博客终极玩法：云端写作，自动部署]]></content>
  </entry>
  <entry>
    <title><![CDATA[gatsbyjs]]></title>
    <url>%2F2019%2F06%2F10%2Fyuque%2Fgatsbyjs%2F</url>
    <content type="text"><![CDATA[gatsbyjs]]></content>
  </entry>
  <entry>
    <title><![CDATA[前言]]></title>
    <url>%2F2019%2F06%2F10%2Fyuque%2F%E5%89%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[H5，即是html5，超文本标记语言，用于描述网页内容结构的语言，网页编程中由它有负责描述页面数据和信息 JS，即是JavaScript，广泛用于web应用开发中的脚本语言，负责响应用户的操作，为网页添加动态功能 native APP，即传统的原生APP开发模式，Android基于Java语言，底层调用Google的 API；iOS基于Objective-C或者Swift语言，底层调用App官方提供的API Hybrid App，即原生和web的混合开发模式，由原生提供统一的API给js调用，实现跨平台的效果 很久以前，这是hexo制作出的博客，是长这样的，当时，觉得好玩，记录了一下，后面就忘记了… 现在又重新捡起来，对过去的一些回忆吧，重点是有时候看过的东西，再回过去找很难找，要么文章都不在了，记录也是一种存储吧。]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript语言基础知识点总结]]></title>
    <url>%2F2019%2F06%2F10%2Fyuque%2FJavaScript%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[写给Node.js新手的7个小技巧]]></title>
    <url>%2F2019%2F06%2F10%2Fyuque%2F%E5%86%99%E7%BB%99Node.js%E6%96%B0%E6%89%8B%E7%9A%847%E4%B8%AA%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[一些我更愿意在开始就知道东西利用 Node.js 开发是一个非常有趣，和令人满足的过程， 他有3万多个模块可以选择使用，并且所有的模块可以非常容易的集成入现有的应用之中。 无论如何，对于一些刚开始使用Node.js 开发的的人来说，很容易碰壁，在这个文章中，我会提到在你学习过程中遇到的问题。 贴士 1: 在开发环境使用 nodemon, 在生产环境使用pm2当你第一次开发Node.js应用的时候，其中一件事情就是一次又一次的运行[file].js 就和揭伤疤一样。 当我第一次开发的node app时候，这个让我感到异常挫败和痛苦， 尤其是每当我修改很小东西的时候需要control+c 幸运的是我发现了一个非常棒的工具Nodemon. 你可以利用以下的命令来安装。 npm install -g nodemonNodemon 是一个令人惊叹的工具， 当你全局安装他以后，可以通过 nodemon [file].js 来启动你的node.js scripts，它会告诉nodemon来监视你的script和scripts的所有变化，这样的Node.js开发方式非常震撼以及让大大提高开发速度。 那么，生产环境又如何，除非你用了heroku，Nodejitsu或者其他一些好的 Node.js 平台(也许他们有类似的功能)，但是碰巧你用了EC2 或者一些其他的云平台来运行你的Node.js app，你如何能然保证这是一个始终运行的Node.js app？ 案就是PM2, PM2 是一个类似于Nodemon的工具，不同之处在于它用于生产环境，和Nodemon相似的地方在于他会监控你的app的任何修改或者重新部署，但是有更好的一面， PM2 在遭遇到崩溃的时候，他会正确重启你的app. PM2的优胜之处在于当你要将app需要多核处理的时候，PM2内部集成的负载均衡可以让你很容易的去指定运行多少个实例。 pm2 start app.js -i max-i参数目的是指定运行多少个实例，在这个例子中 PM2 使用了一个常量max来扩展你的app运转到你最大的核数，不要忘记Node 平时只会运行在单核！ 贴士 2: Async 或者 Q当你专注于写了更多的node.js apps的时候，你肯定领略了什么是回调地狱。如果你还不知道,这里有一个例子： function register(name, password, cb){ checkIfNameExists(name, function(err, result){ if(err){ return cb(“error”); } checkIfPasswordGood(password, function(err, result){ if(err){ return cb(“error”); } createAccount(name,password, function(err,result){&lt;br /&gt; if(err){&lt;br /&gt; return cb(“error”);&lt;br /&gt; }&lt;br /&gt; createBlog(name, function(err, result){&lt;br /&gt; sendEmail(name, function(err, result){&lt;br /&gt; callback(result);&lt;br /&gt; });&lt;br /&gt; });&lt;br /&gt; });&lt;br /&gt; });&lt;br /&gt; });&lt;br /&gt; }&lt;br /&gt;这显然不是一个有用或者令人折服的代码， 反而进入一种回调地狱般两难的境地，是你的话将如何避免？一个简单的办法是使用events， 但是我个人不建议这么做，因为使用events来调用只有一个用途的私有方法，足以令人受挫。所以你该怎么做? 这里有两个编译好的模块async.js和Q, 他们两个都可以防止落入回调地狱。 Async.js或者 ‘async’ 让你可以容易的执行一些连续或者平行的任务，在不依赖一个又一个的嵌套循环前提下. 下面是一些来自Async的readme，写明了他支持的模式，如需获取全部的支持方式请去他们的github主页查看。 async.map([‘file1’,’file2’,’file3’], fs.stat, function(err, results){ // results is now an array of stats for each file }); async.filter([‘file1’,’file2’,’file3’], fs.exists, function(results){ // results now equals an array of the existing files}); async.parallel([ function(){ … }, function(){ … } ], callback); async.series([ function(){ … }, function(){ … } ]); async.waterfall([ function(callback){ callback(null, ‘one’, ‘two’); }, function(arg1, arg2, callback){ callback(null, ‘three’); }, function(arg1, callback){ // arg1 now equals ‘three’ callback(null, ‘done’); } ], function (err, result) { // result now equals ‘done’ });如果我们用async的waterfall来修改之前的例子,结果将更加容易阅读, 再也不用让你的代码看起来像一个死亡金字塔. 另一个重要的库叫做Q. 这个库是一个暴漏promises的概念，Promise 是一个含有’promise’方法的返回对象，他提供了一个最终的返回值，非常优雅的将javascripts的异步和node.js紧密联系在一起。 promiseMeSomething() .then(function (value) { }, function (reason) { });这个 promise me 方法正确返回了一个对象，对象将在传入value的时候调用这个方法当，并且他提供了一个额外的callback来处理失败后的返回值。 这是一个非常有条理的方式来避免回调地狱，如果你重写我们之前的那个例子，你可以非常容易的让这些函数正确被调用并执行。 就和我之前说的一样，我很不愿创建只有一个用途的一堆功能，相反的在’then’之后传入一个方法名，仅仅创建了一个匿名的内部功能和传递,当然了选择权始终在你手里。 总的来说，当你落入回调地狱的时候，是时候去看看 async.js或者Q吧。 我的选择? 当然是 Q贴士 3: 轻松调试 Node.js apps如果你从一个IDE重度集成的语言比如java 或者C# 转来调试Node.js,，你一定会感到很困扰，大部分新加入node的开发者采用了’flow’的调试模式，从这一刻开始你最好的朋友就是console.log 但是依然有更常见的调试方式来代替， Node.js 内置了一个调试器你可以称为 node debug，不过我更喜欢的 node-inspector 他们的github说 “Node Inspector 是一个使用Blink Developer Tools (以前称为WebKit Web Inspector)node.js调试器的界面,” 简而言之，node-inspector 可以让你用任何你想用的编辑器和chrome web tools来调试你的应用,这是多么的性感。 Node-inspector 可以让你做一些非常酷的事情,比如实时修改,单步调试,注入以及一堆其他非常酷的东西。 让我们来根据指示一步一步安装。 https://github.com/node-inspector/node-inspector 贴士 4: Nodefly一旦你有你的应用程序正常运行，你可能会问自己，你怎么可以监视它的性能和配置文件，以确保您的应用程序运行在最佳的速度。最简单的答案是一个伟大的服务，我称为Nodefly。 用简单的一行代码Nodefly开始监视你的应用程序内存泄漏，测量redis用了多久，mongo查询和一堆其他很酷的东西。 http://www.nodefly.com 贴士 5: 利用NPM进行模块管理Node做最常见的事情之一是通过NPM安装软件包。Node有一个惊人的包管理器安装所有指定在你的package.json的manifest文件中的模块。然而，所有初学者都会碰上保持的package.json文件中您所使用的所有的模块都是最新版。 这似乎是一个痛苦的过程,总是打开的package.json来更新新模块的依赖，但许多人不知道的是npm会为你做这个！ 非常简单运行 npm install - save module_name 然后 npm将自动更新你的package.json 包含正确的模块和版本。 npm install - save module_name贴士 6: 不要检查node_modules 文件夹虽然我们的话题一直是modules和npm，但是并不是不是很多人都知道，你不应该提交node_modules文件夹。这背后最大的原因是，没有必要提交这个文件夹。只要有人下载你的代码，他们可通过运行NPM来安装和下载所有需要的模块。 您可能会说，它是不是一个大问题，如果检查node_modules，但是，如果下载代码的人使用了和你编译modules不一样的操作系统的来安装通过NPM？你的应用程序将会崩溃，下载代码的人将不知道为什么会如此！ 举个例子bcrypt以及sentimental如果当在您安装在主机系统上编译他们，因为他们用了本地C语言组件来编译。 避免检查node_modules文件夹的方式是加入.gitignore // .gitignore node_modules/*贴士 7: 别忘记返回初学者经常犯一个很常识的错误,就是忘记callback后的返回值,虽然有些时候，这没有影响，有很多时候，你会遇到奇怪的问题，因为你的回调被调用两次。 让我们看一个简单的例子 function do(err,result, callback){ if(err){ callback(“error”); } callback(“good”); }乍一看，这个片段是有道理的。如果有错误，在回调中发送“错误。如果不发送return，调用callaback后这个函数不会停下来。它只是将移动到调用回callback(“good”)。 这样做在长期和复杂的代码行里面会节省几个小时的调试。]]></content>
  </entry>
  <entry>
    <title><![CDATA[学习Git]]></title>
    <url>%2F2019%2F06%2F10%2Fyuque%2F%E5%AD%A6%E4%B9%A0Git%2F</url>
    <content type="text"><![CDATA[Git是一个免费开源的分布式版本控制系统，用于以高效、迅速的方式处理从很小到非常大的项目。Github是程序员的名片。代码，是程序员沟通的最直接的手段。 使用Git应该是每一位程序员的必备技能（钟情于SVN的亲们勿喷），Git被很多IT公司使用并在开源届和圈内有着巨大的声誉，之前团队做项目经常使用的也都是SVN现在接触了Github后，学习掌握Git也成了顺理成章的事情。希望这篇短文可以帮助到Git的初学者，我们共同学习。 Git入门Git本身非常容易掌握，同样学习Git也很容易，通过下面几个网站你就可以轻松掌握Git。 Git的官方网站提供了Git的所有文档。墙内用户可以参考Git Reference。 书籍：《Pro Git》提供在线的中文版和英文版。 Github与Code School联合提供了一个在线互动教程：Try Git，除此之外Git Immersion也是个不错的选择。各种英文看不懂？来看看Git 简易指南 。 进阶篇：Git图解，Git Magic，Think like a Git。 Github入门Github是一群有趣的人在做的有趣的事，Github不仅仅简单的是Git服务器，更是发展成了Social Coding，在Github你可以得到的绝对超出你的想象。 Github提供了官方的帮助信息和他们的博客。 《Git权威指南》一书的作者编写的GotGitHub是一份非常好的学习资料。 好文两篇：如何高效利用Github，Gthub初级运用。 最好的学习当然是Learning by doing！]]></content>
  </entry>
  <entry>
    <title><![CDATA[gongsi]]></title>
    <url>%2F2019%2F06%2F10%2Fyuque%2Fgongsi%2F</url>
    <content type="text"><![CDATA[$$ 表示整行公式：$$ \sum_{i=1}^n a_i=0$$$$ f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$$$ \sum^{j-1}{k=0}{\widehat{\gamma}{kj} z_k}$$ 这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如：Here is an example of AppleScript: 123tell application "Foo" beepend tell]]></content>
  </entry>
  <entry>
    <title><![CDATA[兼容所有浏览器的菱形]]></title>
    <url>%2F2019%2F06%2F10%2Fyuque%2F%E5%85%BC%E5%AE%B9%E6%89%80%E6%9C%89%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%8F%B1%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;菱形裁剪&lt;/title&gt; &lt;script type="text/javascript" charset="utf-8" src="js/raph.js"&gt;&lt;/script&gt; &lt;style type="text/css" charset="utf-8"&gt; #canvas &#123; background-color: #F4F4F4; left: 0; position: absolute; top: 0; &#125; #paper &#123; left: 0; position: relative; top: 0; &#125; h2 &#123; text-align: center; &#125; #vic1, #vic2, #vic3 &#123; position:absolute; left:0; top:0; &#125; shape, span &#123; font-size: 16px; font-family:'Microsoft YaHei'; color: #ffffff; font-style: oblique; display:block; height:100%; width:100%; text-align:center; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="canvas"&gt; &lt;div id="paper"&gt; &lt;div id="vic1"&gt;&lt;/div&gt; &lt;div id="vic2"&gt;&lt;/div&gt; &lt;div id="vic3"&gt;&lt;/div&gt; &lt;div id="vic4"&gt;&lt;/div&gt; &lt;div id="vic5"&gt;&lt;/div&gt; &lt;div id="vic6"&gt;&lt;/div&gt; &lt;div id="vic7"&gt;&lt;/div&gt; &lt;div id="vic8"&gt;&lt;/div&gt; &lt;div id="vic9"&gt;&lt;/div&gt; &lt;div id="vic10"&gt;&lt;/div&gt; &lt;div id="vic11"&gt;&lt;/div&gt; &lt;div id="vic12"&gt;&lt;/div&gt; &lt;div id="vic13"&gt;&lt;/div&gt; &lt;div id="vic14"&gt;&lt;/div&gt; &lt;div id="vic15"&gt;&lt;/div&gt; &lt;div id="vic16"&gt;&lt;/div&gt; &lt;div id="vic17"&gt;&lt;/div&gt; &lt;div id="vic18"&gt;&lt;/div&gt; &lt;div id="vic19"&gt;&lt;/div&gt; &lt;div id="vic20"&gt;&lt;/div&gt; &lt;div id="vic21"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; (function(Raphael,wh) &#123; var attr = &#123; fill: "#fff", stroke: "#BCBCBC", "stroke-width": 1 &#125;, attr2 = &#123; fill: "#F8F8F8", stroke: "#BBBBBB", "stroke-width": 1 &#125;, attr3 = &#123; fill: "#795755", stroke: "#BBBBBB", "stroke-width": 1, "opacity": "0", "cursor": "pointer" &#125;, attr4 = &#123; fill: "#fff", font: "40px Georgia", "opacity": "0", 'text-anchor': 'start' &#125;, x = 30/146*wh, //距离横坐标点 这里也可以根据角度而计算 y = 30/146*wh, //距离竖坐标点 这里也可以根据角度而计算 width = wh, height = wh, xiejiao = parseInt(width * Math.sqrt(2)), //对角线 plength = document.getElementById("paper").getElementsByTagName("div").length, //总个数 itemCount = 9, //每行显示的个数 row = plength % itemCount == 0 ? plength / itemCount : parseInt(plength / itemCount) + 1, //行数 R = Raphael("paper", xiejiao * (itemCount / 2 + 0.5), xiejiao * (row + 0.5)), //绘制画布宽度 aus = &#123;&#125;, //声明数组 pstrs = attr, temp, H1 = 0, L1 = "", key = "", imagesL1 = 0, imagesH1 = 0, _index = 0; for (var i = 0; i &lt; row; i++) &#123; //console.log("第" + i + "行"); for (var j = 1; j &lt;= itemCount; j++) &#123; _index = j + i * itemCount; if (_index &gt; plength) &#123; break; &#125; //console.log(j); if (j % 2 != 0) &#123; pstrs = attr; L1 = i * xiejiao + "r45t-0"; H1 = j == 1 ? 0 : (j - 1) / 2 * xiejiao; imagesH1 = (xiejiao - 40) / 2 + xiejiao * i; imagesL1 = H1 + 30; //console.log("奇数:" + j + ":" + H1 + " " + L1 + "图:" +imagesL1+ ":"+ imagesH1); &#125; else &#123; pstrs = attr2; L1 = (i * xiejiao + xiejiao) + "r45t-" + width; H1 = j / 2 * xiejiao; imagesH1 = (0.5 * xiejiao + 30 - 40) * 2 + xiejiao * i; imagesL1 = (j / 2 - 0.5) * xiejiao + 35; //console.log("偶数:" + j + ":" + H1 + " " + L1+ "图:" +imagesL1+ ":"+ imagesH1); &#125; //绘制最底层的形状 R.path(Raphael.format("M&#123;0&#125;,&#123;1&#125;h&#123;2&#125;v&#123;3&#125;h&#123;4&#125;z", x, y, width, height, -width)).transform("t" + H1 + "," + L1 + ",0s1").attr(pstrs); //绘制内容图片 R.image("images/big_1.jpg", imagesL1, imagesH1, 133, 40); //图片的位置及大小 //绘制遮罩层 temp = R.path(Raphael.format("M&#123;0&#125;,&#123;1&#125;h&#123;2&#125;v&#123;3&#125;h&#123;4&#125;z", x, y, width, height, -width)).transform("t" + H1 + "," + L1 + ",0s1").attr(attr3); //绘制遮罩层上面的说明文字 R.text(imagesL1 + 20, imagesH1 + 20, "60." + _index+"a").attr(attr4).data("i", _index+"a"); key = "vic" + _index; aus[key] = temp; &#125; &#125; for (var state in aus) &#123; aus[state].color = Raphael.getColor(); (function(st, state) &#123; st[0].style.cursor = "pointer"; //console.log(st.next[0].childNodes[0].innerHTML.length*parseInt(st.next[0].style.fontSize)/2); st.next[0].onmouseover = function() &#123; st.animate(&#123; "opacity": ".5" &#125;); st.next.animate(&#123; "opacity": "1.0" &#125;); &#125;; st.next[0].onmouseout = function() &#123; st.animate(&#123; "opacity": "0" &#125;); st.next.animate(&#123; "opacity": "0" &#125;); &#125;; st[0].onmouseover = function() &#123; st.animate(&#123; "opacity": ".5" &#125;); st.next.animate(&#123; "opacity": "1.0" &#125;); &#125;; st[0].onmouseout = function() &#123; st.animate(&#123; "opacity": "0" &#125;); st.next.animate(&#123; "opacity": "0" &#125;); &#125;; &#125;)(aus[state], state); &#125;; &#125;)(Raphael,146); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[babel笔记]]></title>
    <url>%2F2019%2F06%2F10%2Fyuque%2Fbabel%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[bable bable 官网英文版本: https://babeljs.io/docs/en/ bable 官网中文版本: https://www.babeljs.cn/docs/git源码地址：&gt; https://github.com/babel/website]]></content>
  </entry>
  <entry>
    <title><![CDATA[vuepress]]></title>
    <url>%2F2019%2F06%2F06%2Fyuque%2FVuePress%2F</url>
    <content type="text"><![CDATA[介绍VuePress 由两部分组成：第一部分是一个极简静态网站生成器，它包含由 Vue 驱动的主题系统和插件 API，另一个部分是为书写技术文档而优化的默认主题，它的诞生初衷是为了支持 Vue 及其子项目的文档需求。 1234567891011# 安装yarn global add vuepress@next # 或者：npm install -g vuepress@next# 新建一个 markdown 文件echo '# Hello VuePress!' &gt; README.md# 开始写作vuepress dev .# 开始写作vuepress dev .]]></content>
  </entry>
  <entry>
    <title><![CDATA[web前端学习资料收集]]></title>
    <url>%2F2019%2F06%2F06%2Fyuque%2Fweb%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[读谷歌开发指南专业高效的在线翻译管理平台其实谷歌除了一个分很好的学习指南，但很多人都不知道。DOM(Document Object Mode) 前端规范https://github.com/ecomfe/specThis repository contains the specifications. JavaScript编码规范 [1.3] JavaScript编码规范 - ESNext补充篇 [draft] HTML编码规范 [1.2] CSS编码规范 [1.2] Less编码规范 [1.1] E-JSON数据传输标准 [1.0] 模块和加载器规范 [1.1] 包结构规范 [1.1] 项目目录结构规范 [1.1] 图表库标准 [1.0] react编码规范 [draft] Airbnb 项目规范 Lint and fix tool：FECS 前端开发者手册2019 面向亿万用户级的移动端Web解决方案https://github.com/AlloyTeam/Mars 代码结构规范 前端跨框架跨平台框架 http://omijs.org 字体设置最佳实践 模拟原生效果实践 工具类方法汇总 iOS 与 Android 平台上问题列表 高性能 Mobile Web 开发 特效制作解决方案 - css3transform 触摸运动解决方案 - AlloyTouch Mobile 手势解决方案 - AlloyFinger Mobile 裁剪解决方案 - AlloyCrop Mobile 级联选择器 1kb代码搞定移动 Web 开发调试发布错误监控上报用户问题定位 - AlloyLever 小程序、小游戏以及 Web 通用 Canvas 渲染引擎 - Cax 前端学习地址和查询地址 各种开发文档大全 —–https://devdocs.io/ 开发者手册–腾讯云 多看 JavaScript指南 知乎 掘金 WordPress - 百度百科 全球最大中文百科全书 语雀–https://cn.wordpress.org/–http://www.wordpress.org.cn/ 前端免费学习网 segmentfault 学习技能，解决难题 Topics 浏览 Github 上最常用的主题 GitHub Explore Mozilla 开发者网络，简称 MDN w3schools.com https://developer.mozilla.org MDN 源于开发者，服务开发者 慕课网 懒人图库 力扣 Mac开发配置手册 FEX 技术峰会 推荐的经典的前端书籍 《JavaScript 忍者秘籍》 《JavaScript 高级程序设计》 《编写可维护的 JavaScript》 《Javascript 语言精粹》 《锋利的 jQuery》 《JavaScript DOM 编程艺术（第二版）》 《学习 JavaScript 数据结构与算法》 《JavaScript 权威指南》 《JavaScript 忍者秘籍》 《高性能 JavaScript》 《ECMAScript 6 标准入门》 《Build Your Own AngularJS》 《Effective JavaScript:编写高质量 JavaScript 代码的 68 个有效方法》 《你不知道的 JavaScript（上）》 《单页 Web 应用：JavaScript 从前端到后端》 《HTML5 与 CSS3 基础教程（第八版）》 《深入浅出 HTML 与 CSS》 《CSS 揭秘》 《HTML5 权威指南》 《CSS 权威指南》 《精通正则表达式》 深入理解 JavaScript 特性 Java Web 应用开发 Web全栈工程师学习大纲 推荐库 网站 文章收集 JavaScript面试题 vue面试题 ## 前端性能监控 产品 前端开发全面知识库]]></content>
  </entry>
</search>
