
---

title: 常用的判断技巧

date: 2019-07-11 15:09:44 +0800

tags: []

---
<a name="DfWbz"></a>
#### 1、 用于整数的奇偶性判断
 <br />一个整数a, a & 1 这个表达式可以用来判断a的奇偶性。二进制的末位为0表示偶数，最末位为1表示奇数。使用a%2来判断奇偶性和a & 1是一样的作用，但是a & 1要快好多。

```javascript
var a=3,b=6;
a&1 //1
b&1 //0
```

<a name="LbYoW"></a>
#### 2、 判断n是否是2的正整数冪
 <br />**(!(n&(n-1)) )&& n**<br /> <br />举个例子：<br />如果n = 16 = 10000， n-1 = 1111<br />那么：<br />**10000**<br />**& 1111**<br />**----------**<br />**           0**<br />再举一个例子：如果n = 256 = 100000000， n-1 = 11111111<br />那么：<br />**100000000**<br />**&11111111**<br />**--------------**<br />**0**<br />**好！看完上面的两个小例子，相信大家都有一个感性的认识。从理论上讲，如果一个数a他是2的正整数幂，那么a 的二进制形式必定为1000…..（后面有0个或者多个0），那么结论就很显然了。

```javascript
var a=n=>(!(n&(n-1)) )&& n
a(16) //16
a(13) //false
a(2) //2
a(4) //4
a(5) //false
a(1)  //1
```
<a name="uNats"></a>
#### 3、 统计n中1的个数
 <br />朴素的统计办法是：先判断n的奇偶性，为奇数时计数器增加1，然后将n右移一位，重复上面步骤，直到移位完毕。<br />朴素的统计办法是比较简单的，那么我们来看看比较高级的办法。<br /> <br />举例说明，考虑2位二进制数 n=11，里边有2个1，先提取里边的偶数位10，奇数位01，把偶数位右移1位，然后与奇数位相加，因为每对奇偶位相加的和不会超过“两位”，所以结果中每两位保存着数n中1的个数；相应的如果n是四位整数 n=0111，先以“一位”为单位做奇偶位提取，然后偶数位移位（右移1位），相加；再以“两位”为单位做奇偶提取，偶数位移位（这时就需要移2位），相加，因为此时没对奇偶位的和不会超过“四位”，所以结果中保存着n中1的个数，依次类推可以得出更多位n的算法。整个思想类似分治法。<br />在这里就顺便说一下常用的二进制数：<br />0xAAAAAAAA=10101010101010101010101010101010<br />0x55555555 = 1010101010101010101010101010101（奇数位为1，以1位为单位提取奇偶位）<br /> <br />0xCCCCCCCC = 11001100110011001100110011001100<br />0x33333333 = 110011001100110011001100110011（以“2位”为单位提取奇偶位）<br /> <br />0xF0F0F0F0 = 11110000111100001111000011110000<br />0x0F0F0F0F = 1111000011110000111100001111（以“8位”为单位提取奇偶位）<br /> <br />0xFFFF0000 =11111111111111110000000000000000<br />0x0000FFFF = 1111111111111111（以“16位”为单位提取奇偶位）<br /> <br />例如：32位无符号数的1的个数可以这样数：

举个例子吧，比如说我的生日是农历2月11，就用211吧，转成二进制：<br />n = 11010011<br />计算n = ((n & 0xAAAAAAAA) >> 1) + (n & 0x55555555);<br />得到 n = 10010010<br />计算n = ((n & 0xCCCCCCCC) >> 2) + (n & 0x33333333);<br />得到 n = 00110010<br />计算n = ((n & 0xF0F0F0F0) >> 4) + (n & 0x0F0F0F0F);<br />得到 n = 00000101 -----------------à无法再分了，那么5就是答案了。

```javascript
var count_one=n=>{
	//0xAAAAAAAA，0x55555555分别是以“1位”为单位提取奇偶位
    n = ((n & 0xAAAAAAAA) >> 1) + (n & 0x55555555);

    //0xCCCCCCCC，0x33333333分别是以“2位”为单位提取奇偶位
    n = ((n & 0xCCCCCCCC) >> 2) + (n & 0x33333333);

    //0xF0F0F0F0，0x0F0F0F0F分别是以“4位”为单位提取奇偶位
    n = ((n & 0xF0F0F0F0) >> 4) + (n & 0x0F0F0F0F);

    //0xFF00FF00，0x00FF00FF分别是以“8位”为单位提取奇偶位
    n = ((n & 0xFF00FF00) >> 8) + (n & 0x00FF00FF);

    //0xFFFF0000，0x0000FFFF分别是以“16位”为单位提取奇偶位
    n = ((n & 0xFFFF0000) >> 16) + (n & 0x0000FFFF);

    return n;
}
count_one(211) //5
```

<a name="3QMeD"></a>
#### 4、对于正整数的模运算（注意，负数不能这么算）
 <br />先说下比较简单的：<br />乘除法是很消耗时间的，只要对数左移一位就是乘以2，右移一位就是除以2，传说用位运算效率提高了60%。<br />乘2^k众所周知： n<<k。所以你以后还会傻傻地去敲2566*4的结果10264吗？直接2566<<4就搞定了，又快又准确。<br /> <br />除2^k众所周知： n>>k。<br /> <br />那么 mod 2^k 呢？（对2的倍数取模）<br />**n&((1<<k)-1)**<br />用通俗的言语来描述就是,对2的倍数取模，只要将数与2的倍数-1做按位与运算即可。<br />好！方便理解就举个例子吧。<br />思考：如果结果是要求模2^k时，我们真的需要每次都取模吗？<br /> <br />在此很容易让人想到快速幂取模法。<br />**快速幂取模算法**<br />经常做题目的时候会遇到要计算 a^b mod c 的情况，这时候，一个不小心就TLE了。那么如何解决这个问题呢？位运算来帮你吧。<br /> <br />首先介绍一下秦九韶算法：(数值分析讲得很清楚)

把一个n次多项式f(x) = a[n]x^n+a[n-1]x^(n-1)+......+a[1]x+a[0]改写成如下形式：<br />　　f(x) = a[n]x^n+a[n-1]x^(n-1))+......+a[1]x+a[0]<br />　　= (a[n]x^(n-1)+a[n-1]x^(n-2)+......+a[1])x+a[0]<br />　　= ((a[n]x^(n-2)+a[n-1]x^(n-3)+......+a[2])x+a[1])x+a[0]<br />　　=. .....<br />　　= (......((a[n]x+a[n-1])x+a[n-2])x+......+a[1])x+a[0].<br />　　求多项式的值时，首先计算最内层括号内一次多项式的值，即<br />　　v[1]=a[n]x+a[n-1]<br />　　然后由内向外逐层计算一次多项式的值，即<br />　　v[2]=v[1]x+a[n-2]<br />　　v[3]=v[2]x+a[n-3]<br />　　......<br />　　v[n]=v[n-1]x+a[0]<br />这样，求n次多项式f(x)的值就转化为求n个一次多项式的值。<br /> <br />好！有了前面的基础知识，我们开始解决问题吧

<br />由(a ×b) mod c=( (a mod c) × b) mod c.<br />我们可以将 b先表示成就：<br />b = a[t] × 2^t + a[t-1]× 2^(t-1) + …… + a[0] × 2^0. (a[i]=[0,1]).<br />这样我们由 a^b mod c = (a^(a[t] × 2^t + a[t-1]× 2^（t-1） + …a[0] × 2^0) mod c.<br />然而我们求 a^( 2^(i+1) ) mod c=( (a^(2^i)) mod c)^2 mod c .求得。<br />具体实现如下：<br />使用秦九韶算法思想进行快速幂模算法，简洁漂亮

// 快速计算 (a ^ p) % m 的值

// 快速计算 (a ^ p) % m 的值<br />__int64 FastM(__int64 a, __int64 p, __int64 m)<br />{if (p == 0) return 1;<br />__int64 r = a % m;<br />__int64 k = 1;while (p > 1)<br />{if ((p & 1)!=0)<br />{<br />k = (k * r) % m;<br />}<br />r = (r * r) % m;<br />p >>= 1;<br />}return (r * k) % m;<br />}<br /> <br />[http://acm.pku.edu.cn/JudgeOnline/problem?id=3070](http://acm.pku.edu.cn/JudgeOnline/problem?id=3070)

5、计算掩码<br />比如一个截取低6位的掩码：0×3F用位运算这么表示：(1<< 6) - 1这样也非常好读取掩码，因为掩码的位数直接体现在表达式里。<br />按位或运算很简单，只要a和b中相应位出现1，那么a|b的结果相应位也为1。就不多说了。<br />6、子集<br />　　枚举出一个集合的子集。设原集合为mask，则下面的代码就可以列出它的所有子集：

