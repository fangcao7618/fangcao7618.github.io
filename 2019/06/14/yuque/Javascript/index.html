<!DOCTYPE html><html class="theme-next mist use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="Hexo, NexT"><meta name="description" content="querySelectorAll getElementsBy 区别？   浏览器兼容querySelectorAll 已被 IE 8+、FF 3.5+、Safari 3.1+、Chrome 和 Opera 10+ 良好支持 。getElementsBy 系列，以最迟添加到规范中的 getElementsByClassName 为例，IE 9+、FF 3 +、Safari 3.1+、Chrome"><meta property="og:type" content="article"><meta property="og:title" content="Javascript"><meta property="og:url" content="http://yoursite.com/2019/06/14/yuque/Javascript/index.html"><meta property="og:site_name" content="FangCao"><meta property="og:description" content="querySelectorAll getElementsBy 区别？   浏览器兼容querySelectorAll 已被 IE 8+、FF 3.5+、Safari 3.1+、Chrome 和 Opera 10+ 良好支持 。getElementsBy 系列，以最迟添加到规范中的 getElementsByClassName 为例，IE 9+、FF 3 +、Safari 3.1+、Chrome"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2019/png/263301/1560496421757-4fdbc517-a05f-420c-81b4-52b37d79d591.png#align=left&display=inline&height=301&name=image.png&originHeight=315&originWidth=419&size=41364&status=done&width=400"><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2019/png/263301/1560496470556-3b7706ae-8953-40a0-bfeb-39fb28de3e1e.png#align=left&display=inline&height=159&name=image.png&originHeight=130&originWidth=328&size=9324&status=done&width=400"><meta property="og:updated_time" content="2019-06-20T08:42:40.992Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Javascript"><meta name="twitter:description" content="querySelectorAll getElementsBy 区别？   浏览器兼容querySelectorAll 已被 IE 8+、FF 3.5+、Safari 3.1+、Chrome 和 Opera 10+ 良好支持 。getElementsBy 系列，以最迟添加到规范中的 getElementsByClassName 为例，IE 9+、FF 3 +、Safari 3.1+、Chrome"><meta name="twitter:image" content="https://cdn.nlark.com/yuque/0/2019/png/263301/1560496421757-4fdbc517-a05f-420c-81b4-52b37d79d591.png#align=left&display=inline&height=301&name=image.png&originHeight=315&originWidth=419&size=41364&status=done&width=400"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!0,scrollpercent:!0,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://yoursite.com/2019/06/14/yuque/Javascript/"><title>Javascript | FangCao</title><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?f6bca865fcf2ff03fc0a96417de90b09";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">FangCao</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> 归档</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/14/yuque/Javascript/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="FangCao"><meta itemprop="description" content><meta itemprop="image" content="/uploads/1916867.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="FangCao"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Javascript</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-14T10:25:59+08:00">2019-06-14</time></span> <span class="post-comments-count"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i></span><a href="/2019/06/14/yuque/Javascript/#comments" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/06/14/yuque/Javascript/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><p><a name="RGsMd"></a></p><h2 id="querySelectorAll-getElementsBy-区别？"><a href="#querySelectorAll-getElementsBy-区别？" class="headerlink" title="querySelectorAll getElementsBy 区别？"></a>querySelectorAll getElementsBy 区别？</h2><blockquote><p><a name="bd16e43f"></a></p></blockquote><h4 id="浏览器兼容"><a href="#浏览器兼容" class="headerlink" title="浏览器兼容"></a>浏览器兼容</h4><p>querySelectorAll 已被 IE 8+、FF 3.5+、Safari 3.1+、Chrome 和 Opera 10+ 良好支持 。getElementsBy 系列，以最迟添加到规范中的 getElementsByClassName 为例，IE 9+、FF 3 +、Safari 3.1+、Chrome 和 Opera 9+ 都已经支持该方法了。</p><blockquote><p><a name="f82513a1"></a></p></blockquote><h4 id="接收参数"><a href="#接收参数" class="headerlink" title="接收参数"></a>接收参数</h4><p>querySelectorAll 方法接收的参数是一个 CSS 选择符。而 getElementsBy 系列接收的参数只能是单一的 className、tagName 和 name。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c1 = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.b1 .c'</span>)</span><br><span class="line"><span class="keyword">var</span> c2 = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'c'</span>)</span><br><span class="line"><span class="keyword">var</span> c3 = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'b2'</span>)[<span class="number">0</span>].getElementsByClassName(<span class="string">'c'</span>)</span><br></pre></td></tr></table></figure><blockquote><p><a name="ddc6e94b"></a></p></blockquote><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>大部分人都知道，querySelectorAll 返回的是一个 Static Node List，而 getElementsBy 系列的返回的是一个 Live Node List。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="comment">// Demo 1</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelectorAll(<span class="string">'ul'</span>)[<span class="number">0</span>],</span></span><br><span class="line"><span class="javascript">    lis = ul.querySelectorAll(<span class="string">"li"</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span> ; i++)&#123;</span></span><br><span class="line"><span class="javascript">    ul.appendChild(<span class="built_in">document</span>.createElement(<span class="string">"li"</span>));</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(lis) <span class="comment">//5</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// Demo 2</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'ul'</span>)[<span class="number">0</span>],</span></span><br><span class="line"><span class="javascript">    lis = ul.getElementsByTagName(<span class="string">"li"</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span> ; i++)&#123;</span></span><br><span class="line"><span class="javascript">    ul.appendChild(<span class="built_in">document</span>.createElement(<span class="string">"li"</span>));</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(lis) <span class="comment">//5+2</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Demo 1 中的 lis 是一个静态的 Node List，是一个 li 集合的快照，对文档的任何操作都不会对其产生影响。<br>Demo 2 中的 lis 是一个动态的 Node List， 每一次调用 lis 都会重新对文档进行查询，导致无限循环的问题。<br>但为什么要这样设计呢？ 其实，在 W3C 规范中对 querySelectorAll 方法有明确规定<br></p><blockquote><p>The NodeList object returned by the querySelectorAll() method must be static ([DOM], section 8).</p></blockquote><p>那什么是 NodeList 呢？</p><blockquote><p>The NodeList interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented. NodeList objects in the DOM are live.</p></blockquote><p>所以，NodeList 本质上是一个动态的 Node 集合，只是规范中对 querySelectorAll 有明确要求，规定其必须返回一个静态的 NodeList 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">'a'</span>).toString() <span class="comment">// return "[object NodeList]"</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'a'</span>).toString() <span class="comment">// return "[object HTMLCollection]"</span></span><br></pre></td></tr></table></figure><p>这里又多了一个 HTMLCollection 对象出来，那 HTMLCollection 又是什么？</p><p>实际上，HTMLCollection 和 NodeList 十分相似，都是一个动态的元素集合，每次访问都需要重新对文档进行查询。两者的本质上差别在于，HTMLCollection 是属于 Document Object Model HTML 规范，而 NodeList 属于 Document Object Model Core 规范。这样说有点难理解，看看下面的例子会比较好理解</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'ul'</span>)[<span class="number">0</span>],</span><br><span class="line">  lis1 = ul.childNodes,</span><br><span class="line">  lis2 = ul.children</span><br><span class="line"><span class="built_in">console</span>.log(lis1.toString(), lis1.length) <span class="comment">// "[object NodeList]" 11</span></span><br><span class="line"><span class="built_in">console</span>.log(lis2.toString(), lis2.length) <span class="comment">// "[object HTMLCollection]" 4</span></span><br></pre></td></tr></table></figure><p>NodeList 对象会包含文档中的所有节点，如 Element、Text 和 Comment 等。HTMLCollection 对象只会包含文档中的 Element 节点。另外，HTMLCollection 对象比 NodeList 对象 多提供了一个 namedItem 方法。所以在现代浏览器中，querySelectorAll 的返回值是一个静态的 NodeList 对象，而 getElementsBy 系列的返回值实际上是一个 HTMLCollection 对象 。</p><p><a href="https://www.zhihu.com/question/24702250" target="_blank" rel="noopener">参照文章</a><br><a name="I4tMa"></a></p><h2 id="NodeList-和-HTMLCollection-之间的关系？"><a href="#NodeList-和-HTMLCollection-之间的关系？" class="headerlink" title="NodeList 和 HTMLCollection 之间的关系？"></a>NodeList 和 HTMLCollection 之间的关系？</h2><p><br>历史上的 DOM 集合接口。主要不同在于 <code>HTMLCollection</code>是元素集合而 NodeList 是节点集合（即可以包含元素，也可以包含文本节点）。所以 <code>node.childNodes</code> 返回 <code>NodeList</code>，而 <code>node.children</code> 和 <code>node.getElementsByXXX</code> 返回 <code>HTMLCollection</code> 。<br>唯一要注意的是 <code>querySelectorAll</code> 返回的虽然是 <code>NodeList</code> ，但是实际上是元素集合，并且是静态的（其他接口返回的 <code>HTMLCollection</code> 和 <code>NodeList</code> 都是 live 的）。<br>Both interfaces are collections of DOM nodes. They differ in the methods they provide and in the type of nodes they can contain. While a NodeList can contain any node type, an HTMLCollection is supposed to only contain Element nodes. An HTMLCollection provides the same methods as a NodeList and additionally a method called namedItem.<br>Collections are always used when access has to be provided to multiple nodes, e.g. most selector methods (such as getElementsByTagName) return multiple nodes or getting a reference to all children (element.childNodes).<br></p><p><a name="Rx8bI"></a></p><h2 id="“1”-“2”-“3”-map-parseInt-坑"><a href="#“1”-“2”-“3”-map-parseInt-坑" class="headerlink" title="[“1”, “2”, “3”].map(parseInt) 坑"></a>[“1”, “2”, “3”].map(parseInt) 坑</h2><p>第一反应都觉得结果会是 <code>[1,2,3]</code><br>但实际结果却是 <code>[1, NaN, NaN]</code><br>这是为什么呢？主要是 <code>map</code> 这个方法在调用 <code>callback</code>函数时，会给它传递三个参数:</p><ul><li>当前正在遍历的元素</li><li>元素索引</li><li>原数组本身</li></ul><p>也是就是说如上代码其实等同于</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>].map(<span class="function">(<span class="params">i, index, array</span>) =&gt;</span> <span class="built_in">parseInt</span>(i, index, array))</span><br></pre></td></tr></table></figure><p>这样就直观的解释了上面的答案是怎么产生得了。因为 <code>parseInt</code> 会接受两个参数：参数和进制数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际代码运算等于如下</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1'</span>, <span class="number">0</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'2'</span>, <span class="number">1</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'3'</span>, <span class="number">2</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p>所以为了避免这个坑，平时写 <code>map</code> 还是不要偷懒了，完整的写法才更直观并且更容易维护。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>].map(<span class="function"><span class="params">str</span> =&gt;</span> <span class="built_in">parseInt</span>(str))</span><br></pre></td></tr></table></figure><p><a name="Qu4B3"></a></p><p>##<br><a name="RXhM8"></a></p><h2 id="省略参数引发的-bug"><a href="#省略参数引发的-bug" class="headerlink" title="省略参数引发的 bug"></a>省略参数引发的 bug</h2><p>省略参数是 es6 之后提供的一个很好用也非常常用的功能。但还是有一些细节值得注意，不然一不小心就会出现 bug。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">num = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test() <span class="comment">// (num is set to 1)</span></span><br><span class="line">test(<span class="literal">undefined</span>) <span class="comment">// (num is set to 1 too)</span></span><br><span class="line"></span><br><span class="line">test(<span class="string">''</span>) <span class="comment">// (num is set to '')</span></span><br><span class="line">test(<span class="literal">null</span>) <span class="comment">// (num is set to null)</span></span><br><span class="line">test(<span class="literal">false</span>) <span class="comment">// (num is set to false)</span></span><br></pre></td></tr></table></figure><p>如上面 demo 所示，只有参数没传或者是 <code>undefined</code> 是才会生效，其它情况默认参数并不会起作用。<br>所以有的时候你传入了<code>&#39;&#39;</code>空字符串是不行的，还需要自己手动判断一下。<br>str = str || defalutString</p><p>另外，一个容易忽略的地方是，参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">99</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">p = x + <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">100</span></span><br><span class="line">foo() <span class="comment">// 101</span></span><br></pre></td></tr></table></figure><p>上面代码中，参数 p 的默认值是 x + 1。这时，每次调用函数 foo，都会重新计算 x + 1，而不是默认 p 等于 100。</p><p><a name="vPi0o"></a></p><h2 id="多余逗号引发的错误"><a href="#多余逗号引发的错误" class="headerlink" title="多余逗号引发的错误"></a>多余逗号引发的错误</h2><p>刚入前端的时候看错误日志，<code>ie</code> 的错误日志特别多，一直没找到原因，后来发现是 JSON 最后一组键值后多逗号。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有浏览器都正常</span></span><br><span class="line"><span class="keyword">var</span> json_normal = &#123;</span><br><span class="line">  id: <span class="number">1</span>,</span><br><span class="line">  name: <span class="string">"John"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ie 报错，其它游览器正常</span></span><br><span class="line"><span class="keyword">var</span> json_error = &#123;</span><br><span class="line">  id: <span class="number">1</span>,</span><br><span class="line">  name: <span class="string">"John"</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>好在现在有了 <code>eslint</code> 或者 <code>preitter</code>这种工具，这种错误很少会再发生了。</p><p><a name="Awisc"></a></p><h2 id="js-中的逗号"><a href="#js-中的逗号" class="headerlink" title="js 中的逗号"></a>js 中的逗号</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (((a = <span class="number">1</span>), a++, a)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很多人一下子可能会一脸懵逼。<br>但看一下 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/if...else" target="_blank" rel="noopener">MDN 文档</a> 就很清楚了<br></p><blockquote><p>逗号操作符 对它的每个操作数求值（从左到右），并返回最后一个操作数的值。</p></blockquote><p>举个例子<br><code>var a=(1+1,2+2,3+3);</code> 结果就是 6。 <code>3+3</code><br><br><br>但在函数中，比如比 <code>Math.max(x,y,z)</code>。这里的逗号就是分隔函数参数。<br>还有声明变量时，<code>var a=1,b=2,c=3</code>。这里的逗号也是起分隔的作用。<br>再举一个例子大家应该就理解了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="number">2</span> * <span class="number">5</span>, <span class="number">2</span> * <span class="number">4</span>)</span><br><span class="line"><span class="comment">//输出10而不是8  函数接收第一个参数,也说明逗号级别比较低</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span> * <span class="number">5</span>, <span class="number">2</span> * <span class="number">4</span>) <span class="comment">// 10,8</span></span><br><span class="line"></span><br><span class="line">alert((<span class="number">2</span> * <span class="number">5</span>, <span class="number">2</span> * <span class="number">4</span>))</span><br><span class="line"><span class="comment">// 输出8 ()是返回了,相当于隐藏了return 所以返回最右边操作数的值</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">2</span> * <span class="number">5</span>, <span class="number">2</span> * <span class="number">4</span>));<span class="comment">//8</span></span><br></pre></td></tr></table></figure><p><br>其实最常见的运用场景就是平时经常的<code>for</code>循坏</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, j = <span class="number">9</span>; i &lt;= <span class="number">9</span>; i++, j--) &#123;<span class="built_in">console</span>.log(i,j)&#125;</span><br></pre></td></tr></table></figure><p><a name="gFEmn"></a></p><h2 id="document-documentElement-与-document-body-区别"><a href="#document-documentElement-与-document-body-区别" class="headerlink" title="document.documentElement 与 document.body 区别"></a>document.documentElement 与 document.body 区别</h2><p><br>在前端开发中，我们经常需要获取网页中滚动条滚过的长度，获取该值的方式一般通过<code>scrollTop</code>属性，如：<code>document.body.scrollTop</code>，或者<code>document.documentElement.scrollTop</code>，这两者都是经常用来获取文档滚动条滚过长度值的方式，他们又有什么区别呢？</p><p>之前一直没注意，只到有一天发现了一个 bug:document.body.scrollTop 拿到的值一直是 0。<br><br><br>在这个之前我们先来了解一下 是干嘛的？为什么每个页面都需要加上这段声明。</p><blockquote><p>doctype 声明不属于 HTML 标签，它是一条指令，告诉浏览器编写页面所用的标记的版本。 这个声明的目的是防止浏览器在渲染文档时，切换到我们称为“<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Quirks_Mode_and_Standards_Mode" target="_blank" rel="noopener">怪异模式(兼容模式)</a>”的渲染模式。<code>&lt;!DOCTYPE html&gt;</code> 能确保浏览器按照最佳的相关规范进行渲染，而不是使用一个不符合规范的渲染模式。</p></blockquote><p><code>document.documentElement</code> 与 <code>document.body</code></p><ul><li>document 代表的是整个文档(对于一个网页来说包括整个网页结构)</li><li>document.documentElement 是整个文档节点树的根节点，在网页中即 html 标签</li><li>document.body 是整个文档 DOM 节点树里的 body 节点，网页中即为 body 标签元素</li></ul><p>但在标准模式下<code>document.body.scrollTop</code>是无效的。</p><blockquote><p>从 Chrome 61 开始，标准模式中 document.scrollingElement 已被修正为 document.documentElement。换句话说，这个版本开始标准模式中 document.body.scrollTop 始终都等于 0。</p></blockquote><p>所以这里建议使用兼容写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> scrollTop = <span class="built_in">Math</span>.max(</span><br><span class="line">  <span class="built_in">window</span>.pageYOffset,</span><br><span class="line">  <span class="built_in">document</span>.documentElement.scrollTop,</span><br><span class="line">  <span class="built_in">document</span>.body.scrollTop</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBodyScrollTop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> el =</span><br><span class="line">    <span class="built_in">document</span>.documentElement || <span class="built_in">document</span>.scrollingElement || <span class="built_in">document</span>.body</span><br><span class="line">  <span class="keyword">return</span> el.scrollTop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>每当这时候我就有一些怀念<code>jQuery</code>了</strong>。<a name="sort"></a></p><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">782</span>, <span class="number">7</span>, <span class="number">29</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">34</span>]</span><br><span class="line">array.sort()</span><br><span class="line"><span class="comment">// =&gt; [0, 1, 2, 2, 29, 3, 3, 34, 7, 7, 782, 8]</span></span><br></pre></td></tr></table></figure><p>默认情况下，<code>sort</code>是按照<code>Unicode code points</code>排序的，换而言之，先回比较首个字符的 code point，若相同的情况下依次位数比下去。</p><p>所以很多时候我们需要自定义 sort 的规则。最常见的操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">782</span>, <span class="number">7</span>, <span class="number">29</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">34</span>]</span><br><span class="line">array.sort(<span class="function">(<span class="params">pre, next</span>) =&gt;</span> pre - next)</span><br><span class="line"><span class="comment">// =&gt; [0, 1, 2, 2, 3, 3, 7, 7, 8, 29, 34, 782]</span></span><br></pre></td></tr></table></figure><p>其实它的规则很简单，你想让 next 和 pre 换位子就返回一个&gt;0的值，其它情况位置不变，即返回&lt;=0的值。<br><a name="codepointat-vs-charcodeat"></a></p><h2 id="codePointAt-vs-charCodeAt"><a href="#codePointAt-vs-charCodeAt" class="headerlink" title="codePointAt vs charCodeAt"></a>codePointAt vs charCodeAt</h2><p>JavaScript 允许采用<code>\uxxxx</code>形式表示一个字符，其中<code>xxxx</code>表示字符的 Unicode 码点。<br>但是，这种表示法只限于码点在\u0000~\uFFFF 之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'\uD842\uDFB7'</span></span><br><span class="line"><span class="comment">// "𠮷"</span></span><br></pre></td></tr></table></figure><p>JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为 2 个字节。对于那些需要 4 个字节储存的字符（Unicode 码点大于 0xFFFF 的字符），JavaScript 会认为它们是两个字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'𠮷'</span></span><br><span class="line"></span><br><span class="line">s.length <span class="comment">// 2</span></span><br><span class="line">s.charAt(<span class="number">0</span>) <span class="comment">// ''</span></span><br><span class="line">s.charAt(<span class="number">1</span>) <span class="comment">// ''</span></span><br><span class="line">s.charCodeAt(<span class="number">0</span>) <span class="comment">// 55362</span></span><br><span class="line">s.charCodeAt(<span class="number">1</span>) <span class="comment">// 57271</span></span><br></pre></td></tr></table></figure><p>所以 ES6 提供了 codePointAt 方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'𠮷'</span>.codePointAt() <span class="comment">//134071</span></span><br></pre></td></tr></table></figure><p>总之，codePointAt 方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与 charCodeAt 方法相同。</p><p><a name="rTZKa"></a></p><h2 id="switch-作用域"><a href="#switch-作用域" class="headerlink" title="switch 作用域"></a>switch 作用域</h2><p>其实我们经常会忽略一个点，switch case 是共用一个作用域的。<br>比如如下代码就会抛出重复定义的错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (x) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">let</span> foo</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">let</span> foo <span class="comment">// 重复定义引起TypeError</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Identifier 'foo' has already been declared</span></span><br></pre></td></tr></table></figure><p>解决方案也很简单，我们给每一个 case 加上一个 bracket 就可以了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (x) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">    <span class="keyword">let</span> foo</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">    <span class="keyword">let</span> foo <span class="comment">// 重复定义引起TypeError</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="LciUL"></a></p><h2 id="div-如何监听-keydown-事件"><a href="#div-如何监听-keydown-事件" class="headerlink" title="div 如何监听 keydown 事件"></a>div 如何监听 keydown 事件</h2><p>之前有一个人问我，为什么他监听了一个 div 的 keydown 事件，为什么没有用？ 我看了一下代码发现的确没有写错？但为什么就不触发呢？<br>后来查阅了一下文档</p><blockquote><p>Focused element processing the key event, root element if no suitable input element focused</p></blockquote><p>发现只有能被 focus 的元素才能出发键盘事件，所以 div 也就不能触发 keydown 事件了。<br>那怎么才能让 div 支持呢？<br>答案是 <code>tabindex</code> <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/tabindex" target="_blank" rel="noopener">mdn</a>。它表示元素是可聚焦的，并且可以通过键盘导航来访问到该元素。<br>这样一来我们就能愉快的使用<code>keydown</code>事件了.<br><a name="lqKfa"></a></p><h2 id="try-catch-的-finally-坑"><a href="#try-catch-的-finally-坑" class="headerlink" title="try catch 的 finally 坑"></a>try catch 的 finally 坑</h2><p>try…catch 的 finally 可能很多人都没有使用过，它其实和 promise 中的 finally 很类似。 见<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/try...catch" target="_blank" rel="noopener">MDN</a>。<br>它无论是否有异常它都会执行。 常见的操作就是 将关闭弹窗或者 loading</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ok'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'ok'</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'error'</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'finally'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'finally'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line"><span class="comment">// ok finally "finally"</span></span><br></pre></td></tr></table></figure><p>我们发现最终输出了<code>finally</code>。因为这个语句只会有一个 return，finally 中的 return 覆盖了之前的定义。而且 return 会被放在最后执行。<a href="https://stackoverflow.com/questions/3837994/why-does-a-return-in-finally-override-try" target="_blank" rel="noopener">详情见</a>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res=<span class="string">''</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    res=<span class="string">'ok'</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    res=<span class="string">'error'</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn() <span class="comment">//"ok"</span></span><br></pre></td></tr></table></figure><p>不过最好还是和 promise 中的 finally 一样，在里面做一些没有副作用的事情。免得发生一些 bug。<br><a name="8eG9o"></a></p><h2 id="atob-方法解码中文字符"><a href="#atob-方法解码中文字符" class="headerlink" title="atob 方法解码中文字符"></a>atob 方法解码中文字符</h2><p>由于一些网络通讯协议的限制,你必须使用 window.btoa() 方法对原数据进行编码后，才能进行发送。接收方使用相当于 window.atob() 的方法对接受到的 base64 数据进行解码,得到原数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.btoa(<span class="string">'foo'</span>)</span><br><span class="line"><span class="comment">// "Zm9v"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.atob(<span class="string">'Zm9v'</span>)</span><br><span class="line"><span class="comment">// "foo"</span></span><br></pre></td></tr></table></figure><p>atob 这个方法名称乍一看，很奇怪，不知道这个单词什么意思。我们可以理解为 A to B，也就是从 A 到 B。<br>atob 表示 Base64 字符 to 普通字符，也就是 Base64 解码。<br>当你在 Chrome console 中执行 <code>window.btoa(&#39;中文&#39;)</code>会发下会报错。</p><blockquote><p><code>Uncaught DOMException: Failed to execute &#39;btoa&#39; on &#39;Window&#39;: The string to be encoded contains characters outside of the Latin1 range.</code></p></blockquote><p>这时候我们可以借助 <code>encodeURIComponent</code> 和 <code>decodeURIComponent</code> 转义非中文字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.btoa(<span class="built_in">encodeURIComponent</span>(<span class="string">'中文'</span>))</span><br><span class="line"><span class="comment">// ('JUU0JUI4JUFEJUU2JTk2JTg3')</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">decodeURIComponent</span>(<span class="built_in">window</span>.atob(<span class="string">'JUU0JUI4JUFEJUU2JTk2JTg3'</span>))</span><br><span class="line"><span class="comment">// "中文"</span></span><br></pre></td></tr></table></figure><p><a name="97hNP"></a></p><h2 id="Safari-下-Date-的坑"><a href="#Safari-下-Date-的坑" class="headerlink" title="Safari 下 Date 的坑"></a>Safari 下 Date 的坑</h2><p>在 使用 Date 相关 api 的时候要牢记一个坑，就是 Safari 对一些时间格式是不支持的。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Date</span>.parse(<span class="string">'2018-10-16 12:00:00'</span>)</span><br><span class="line"><span class="comment">// 1539662400000 -- 在Chrome 下</span></span><br><span class="line"><span class="comment">// NaN -- 在Safari下</span></span><br></pre></td></tr></table></figure><p>问题就出在 Safari 对于这个格式 YYYY-MM-DD HH:MM:SS 无法解析，Safari 要求 Date.parse()或 Date()转换日期的字符串需要满足 RFC2822 或 ISO 8601 定义的格式。不过我们可以将其转化为 YYYY/MM/DD HH:MM:SS</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Date</span>.parse(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2018-10-16 12:00:00'</span>.replace(<span class="regexp">/-/g</span>, <span class="string">'/'</span>)))</span><br></pre></td></tr></table></figure><p>相关<a href="https://stackoverflow.com/questions/4310953/invalid-date-in-safari" target="_blank" rel="noopener">stackoverflow</a><br></p><p><a name="fd465dc3"></a></p><h2 id="new-Date-在-safari-的坑"><a href="#new-Date-在-safari-的坑" class="headerlink" title="new Date 在 safari 的坑"></a>new Date 在 safari 的坑</h2><p><code>new Date(&#39;2019-06-04 00:00:00&#39;)</code>在除了 Safari 的浏览器都能正常运行。 问题就出在 Safari 对于这个格式 <code>YYYY-MM-DD HH:MM:SS</code> 无法解析，所以我们需要做的是将其转化为 <code>YYYY/MM/DD HH:MM:SS</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2019-06-04 00:00:00'</span>.replace(<span class="regexp">/-/g</span>, <span class="string">'/'</span>))</span><br></pre></td></tr></table></figure><p><a name="Tsg1B"></a></p><h2 id="e-target-与-e-currentTarget-的区别"><a href="#e-target-与-e-currentTarget-的区别" class="headerlink" title="e.target 与 e.currentTarget 的区别"></a>e.target 与 e.currentTarget 的区别</h2><p>有一次在面试的时候问了事件委托的题目，面试人说了一个 currentTarget，突然发现<code>target</code>和<code>currentTarget</code>的区别我好像有些忘记了，太多相似的 api 和属性了。</p><p>首先我们来看一下 MDN 上对它们的解释</p><ul><li>target：一个触发事件的对象的引用， 当事件处理程序在事件的冒泡或捕获阶段被调用时。</li><li>currentTarget： 当事件遍历 DOM 时，标识事件的当前目标。它总是引用事件处理程序附加到的元素，而不是 event.target，event.target 标识事件发生的元素。</li></ul><p>可能还是很抽象 ，这里提供一个在线<a href="https://jsbin.com/xekebepaqi/edit?html,js,console,output" target="_blank" rel="noopener">demo</a>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS Bin<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>hello 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>hello 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>hello 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>hello 4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> ul = <span class="built_in">document</span>.querySelectorAll(<span class="string">'ul'</span>)[<span class="number">0</span>]</span></span><br><span class="line"><span class="javascript">ul.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> oLi1 = e.target</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> oLi2 = e.currentTarget</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(oLi1.tagName); <span class="comment">//  被点击的li</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(oLi2.tagName); <span class="comment">// ul</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(oLi1 === oLi2); <span class="comment">// false</span></span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也就是说，currentTarget 始终是监听事件者，而 target 是事件的真正发出者。<br><a name="CFzhD"></a></p><h2 id="函数变量必填校验"><a href="#函数变量必填校验" class="headerlink" title="函数变量必填校验"></a>函数变量必填校验</h2><p>这里分享一个平时写 ES6 的时候一个小技巧。如何简单的校验并强制在使用这个函数时必须传参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isRequired = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Missing parameter'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function">(<span class="params">something = isRequired(</span>)) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(something)</span><br><span class="line">  <span class="keyword">return</span> something</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">123</span>)</span><br><span class="line">foo() <span class="comment">// Error:Missing parameter</span></span><br></pre></td></tr></table></figure><p><a name="3pXxV"></a></p><h2 id="前端错误处理"><a href="#前端错误处理" class="headerlink" title="前端错误处理"></a>前端错误处理</h2><p>错误处理对于任何前端来说都是必不可少的。任何人写代码都避免不了会有 bug，而且很多 bug 也不是测试用例能完全覆盖的，如果我们没有一个完整的错误处理和错误收集的系统，我们都无法知道我们有 bug，不仅如此，很多 bug 也不一定是前端的问题，比如某个接口返回的数据格式不对了或者少字段了，亦或是在某个特定的浏览器型号上才有的问题等等。而且有了错误处理和收集，我们也才能更好的通过错误栈来还原这个问题。<br></p><p><a name="MQRyh"></a></p><h3 id="有哪些错误需要处理"><a href="#有哪些错误需要处理" class="headerlink" title="有哪些错误需要处理"></a>有哪些错误需要处理</h3><ul><li>JS 语法错误、代码异常</li><li>请求错误</li><li>静态资源加载异常</li><li>Promise 异常</li><li>页面崩溃和卡顿<br><a name="try-catch"></a><h3 id="Try-Catch"><a href="#Try-Catch" class="headerlink" title="Try Catch"></a>Try Catch</h3>try-catch 只能捕获到同步的运行时错误，对语法和异步错误却无能为力，捕获不到。 1.同步运行时错误：</li></ul><ol><li>同步错误</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">'foo'</span></span><br><span class="line">  <span class="built_in">console</span>.log(nam)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'捕获到异常：'</span>, e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>捕获到异常： ‘ReferenceError: nam is not defined at<anonymous>:3:15’</anonymous></p></blockquote><ol start="2"><li>语法错误</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">'foo</span></span><br><span class="line"><span class="string">  console.log(nam)</span></span><br><span class="line"><span class="string">&#125; catch (e) &#123;</span></span><br><span class="line"><span class="string">  console.log('</span>捕获到异常：<span class="string">', e)</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>Uncaught SyntaxError: Unexpected identifier</p></blockquote><ol start="3"><li>异步错误</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="literal">undefined</span>.map(<span class="function"><span class="params">v</span> =&gt;</span> v)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'捕获到异常：'</span>, e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>每次的数都不一样，运行一次就加1<br>Uncaught TypeError: Cannot read property ‘map’ of undefined</p></blockquote><p><a name="window-onerror"></a></p><h3 id="window-onerror"><a href="#window-onerror" class="headerlink" title="window.onerror"></a>window.onerror</h3><p>当 JS 运行时错误发生时，window 会触发一个 ErrorEvent 接口的 error 事件，并执行 window.onerror()。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;String&#125;  message    错误信息</span></span><br><span class="line"><span class="comment"> * @param &#123;String&#125;  source    出错文件</span></span><br><span class="line"><span class="comment"> * @param &#123;Number&#125;  lineno    行号</span></span><br><span class="line"><span class="comment"> * @param &#123;Number&#125;  colno    列号</span></span><br><span class="line"><span class="comment"> * @param &#123;Object&#125;  error  Error对象（对象）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">message, source, lineno, colno, error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'捕获到异常：'</span>, &#123; message, source, lineno, colno, error &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同域名下的 js 报错不能被 全局的 window.onerror 监听到，我们需要给相关的 js 文件上加上 Access-Control-Allow-Origin:*的 response header，并且引用相关的 js 文件时加上 crossorigin 属性。相关<a href="https://www.jianshu.com/p/315ffe6797b8" target="_blank" rel="noopener">文章</a></p><p>在实际的使用过程中，onerror 主要是来捕获预料之外的错误，而 try-catch 则是用来在可预见情况下监控特定的错误，两者结合使用更加高效。</p><p><a name="window-addeventlistener"></a></p><h3 id="window-addEventListener"><a href="#window-addEventListener" class="headerlink" title="window.addEventListener"></a>window.addEventListener</h3><p>当一项资源（如图片或脚本）加载失败，加载资源的元素会触发一个 Event 接口的 error 事件，并执行该元素上的 onerror() 处理函数。这些 error 事件不会向上冒泡到 window ，不过（至少在 Firefox 中）能被单一的 window.addEventListener 捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">"./foo.png"</span>&gt;</span><br><span class="line">&lt;scritp&gt;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'error'</span>, (error) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'捕获到异常：'</span>, error);</span><br><span class="line">&#125;, <span class="literal">true</span>)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p><a name="promise-catch"></a></p><h3 id="Promise-Catch"><a href="#Promise-Catch" class="headerlink" title="Promise Catch"></a>Promise Catch</h3><p>没有写 catch 的 Promise 中抛出的错误无法被 onerror 或 try-catch 捕获到，所以我们务必要在 Promise 中不要忘记写 catch 处理抛出的异常。<br>或者可以全局增加一个对 unhandledrejection 的监听，用来全局监听 Uncaught Promise Error。使用方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'unhandledrejection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当然你如果使用如 axios 这种库的话，错误处理完全可以放在它的请求实例里面做。更加的灵活。</p><p><a name="vue-errorhandler"></a></p><h3 id="VUE-errorHandler"><a href="#VUE-errorHandler" class="headerlink" title="VUE errorHandler"></a>VUE errorHandler</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.config.errorHandler = <span class="function">(<span class="params">err, vm, info</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'通过vue errorHandler捕获的错误'</span>)</span><br><span class="line">  <span class="built_in">console</span>.error(err)</span><br><span class="line">  <span class="built_in">console</span>.error(vm)</span><br><span class="line">  <span class="built_in">console</span>.error(info)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="1hVlk"></a></p><h3 id="React-异常捕获"><a href="#React-异常捕获" class="headerlink" title="React 异常捕获"></a>React 异常捕获</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">componentDidCatch(error, info) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error, info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="UkWSW"></a></p><h3 id="崩溃和卡顿"><a href="#崩溃和卡顿" class="headerlink" title="崩溃和卡顿"></a>崩溃和卡顿</h3><p><a href="https://zhuanlan.zhihu.com/p/40273861" target="_blank" rel="noopener">相关文章</a> <a href="https://juejin.im/post/5cf72029f265da1b5f264334" target="_blank" rel="noopener">实践总结】优雅的处理 vue 项目异常</a></p><p><a name="4LEXG"></a></p><h2 id="insertBefore-坑"><a href="#insertBefore-坑" class="headerlink" title="insertBefore 坑"></a>insertBefore 坑</h2><p><br>Node.insertBefore()很多人都用过， 它在参考节点之前插入一个节点作为一个指定父节点的子节点。</p><blockquote><p>var insertedNode = parentNode.insertBefore(newNode, referenceNode);</p></blockquote><p>但看文档还有一句补充说明：</p><blockquote><p>如果 referenceElement 为 null 则 newElement 将被插入到子节点的末尾。如果 newElement 已经在 DOM 树中，newElement 首先会从 DOM 树中移除。</p></blockquote><p>这就很坑了，如下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"parentElement"</span>&gt;</span><br><span class="line">  &lt;span id=<span class="string">"bar"</span>&gt;bar&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">  &lt;span id='foo'&gt;foo&lt;/</span>span&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">var foo = document.getElementById("foo")</span></span><br><span class="line"><span class="regexp">var bar = document.getElementById("bar")</span></span><br><span class="line"><span class="regexp">var parentDiv = document.getElementById("parentElement")</span></span><br><span class="line"><span class="regexp">parentDiv.insertBefore(foo, bar)</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><p>原本以为结果是 <code>foo</code> <code>bar</code> <code>foo</code>，但实际结果是<code>foo</code> <code>bar</code>。<br>因为根据文档，当你 insertBefore 的是一个已存在的值时，会移动它而不是拷贝它重新插入。贼坑！！！<br>如果使用 ES6 的话可以使用 <code>before</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="built_in">document</span>.getElementById(<span class="string">'foo'</span>)</span><br><span class="line"><span class="keyword">var</span> bar = <span class="built_in">document</span>.getElementById(<span class="string">'bar'</span>)</span><br><span class="line">bar.before(foo)</span><br></pre></td></tr></table></figure><p><a name="d41d8cd9"></a></p><p>##<br><a name="O5Plg"></a></p><h2 id="为什么前端监控要用-GIF-打点"><a href="#为什么前端监控要用-GIF-打点" class="headerlink" title="为什么前端监控要用 GIF 打点"></a>为什么前端监控要用 GIF 打点</h2><p>目前主流的前端监控数据上报都是采用 GIF 的上报方式，(百度统计/友盟/谷歌统计）都是这样实现的。但为什么一定要使用 GIF 呢？不能发 post 请求或者通过 script 标签的形式么？<br>当然你也可以使用一些黑科技的方式上报，用纯 css 来实现。但这种方案并没有什么特别的好处。<br></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.track-xx</span><span class="selector-pseudo">:active</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="built_in">url</span>(track.php?xxxx=foo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="d41d8cd9-1"></a></p><p>###<br><a name="5caCe"></a></p><h3 id="主要原因"><a href="#主要原因" class="headerlink" title="主要原因"></a>主要原因</h3><ul><li>没有跨域问题<br></li><li>不会阻塞页面加载，影响用户体验<br></li><li>在所有图片中体积最小，相较 BMP/PNG，可以节约 41%/35%的网络资源<br></li></ul><p>详情见 <a href="https://mp.weixin.qq.com/s/v6R2w26qZkEilXY0mPUBCw" target="_blank" rel="noopener">为什么前端监控要用 GIF 打点</a><br><a name="a653042e"></a></p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>但建议不要按如下方法使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Image().src = <span class="string">'https://foo.com/bar.gif?t=xxxx&amp;b=1'</span></span><br></pre></td></tr></table></figure><p>这段代码的问题是这个 new Image()是一个没有引用的临时变量，随时可能被浏览器的垃圾回收机制回收。如果这个图片的 HTTP 请求尚未建立，那么在被回收时这个请求就会被取消，导致打点并没有真正发出。如果打点所在的页面比较复杂，浏览器垃圾回收机制可能会被频繁触发，那么这种方式打点的丢失率可能会高达 10%以上。</p><p>解决方法很简单，将这个图片赋值给一个全局变量即可，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> img = <span class="keyword">new</span> Image()</span><br><span class="line"><span class="keyword">const</span> key = +<span class="keyword">new</span> <span class="built_in">Date</span>() <span class="comment">//加一个时间戳，防止图片被浏览器缓存了，不再发送请求  "+"转换时间戳</span></span><br><span class="line"><span class="built_in">window</span>[t] = img</span><br><span class="line">img.onload = img.onerror = img.onabort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// img标签加载完成、错误或终止时，解除事件绑定，销毁相关对象</span></span><br><span class="line">  img.onload = img.onerror = img.onabort = <span class="literal">null</span></span><br><span class="line">  <span class="built_in">window</span>[key] = <span class="literal">null</span></span><br><span class="line">  img = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line">img.src = <span class="string">`<span class="subst">$&#123;url&#125;</span>?t=key`</span></span><br></pre></td></tr></table></figure><p><a name="d41d8cd9-2"></a></p><p>###<br><a name="VkXKl"></a></p><h3 id="其它方案"><a href="#其它方案" class="headerlink" title="其它方案"></a>其它方案</h3><p>Beacon API</p><ul><li>在空闲的时候异步发送统计，不影响页面诸如 JS、CSS Animation 等执行</li><li>即使页面在 unload 状态下，也会异步发送统计，不影响页面过渡/跳转到下跳页</li><li>能够被客户端优化发送，尤其在 Mobile 环境下，可以将 Beacon 请求合并到其他请求上，一同处理</li></ul><p><a name="object-create-null-vs"></a></p><h2 id="Object-create-null-vs"><a href="#Object-create-null-vs" class="headerlink" title="Object.create(null) vs {}"></a>Object.create(null) vs {}</h2><p>查看 vue 的源码 或者一些开源项目的源码，发现不少地方都是使用 <code>Object.create(null)</code>来创建一个空对象的。<br>当使用语句 const obj = {}; 创建对象时，它其实并不是一个真的<code>空对象</code>，它从 Object.prototype 上继承了一些方法：</p><ul><li>hasOwnProperty</li><li>isPrototypeOf</li><li>propertyIsEnumerable</li><li>toString/toLocaleString</li><li>valueOf</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2019/png/263301/1560496421757-4fdbc517-a05f-420c-81b4-52b37d79d591.png#align=left&display=inline&height=301&name=image.png&originHeight=315&originWidth=419&size=41364&status=done&width=400" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/263301/1560496470556-3b7706ae-8953-40a0-bfeb-39fb28de3e1e.png#align=left&display=inline&height=159&name=image.png&originHeight=130&originWidth=328&size=9324&status=done&width=400" alt="image.png"></p><p>如果使用 <code>Object.create(null)</code> 创建的对象，在没有继承任何东西。</p><p><strong>所以说是不是 <code>Object.create(null)</code> 是更好的创建一个空对象的方案呢？</strong><br>这就要看从 Object 上继承的那些方法我们是不是有用到了。</p><p><a name="hasownproperty"></a></p><h3 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty"></a>hasOwnProperty</h3><p>判断一个对象属性中是否具有指定的属性，返回 <code>true</code> or <code>false</code>。</p><p><a name="2LMgx"></a></p><h3 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf"></a>valueOf</h3><p>valueOf 很少直接使用。在隐式转换类型时，JavaScript 引擎会调用 valueOf 方法，强制把对象转换成原始值<br></p><p><a name="8b378531"></a></p><h3 id="toString、isPrototypeOf-和-propertyIsEnumerable"><a href="#toString、isPrototypeOf-和-propertyIsEnumerable" class="headerlink" title="toString、isPrototypeOf 和 propertyIsEnumerable"></a>toString、isPrototypeOf 和 propertyIsEnumerable</h3><p>这几个方法直接使用的情况较少，但自己的代码中不用并不表示别人写的代码不会调用。比如，有些框架可能会调用 toString 方法来判断结果是否为 [object Object]。<br></p><p><a name="54bbba80"></a></p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>因此，我们可以得出结论：当创建的对象只在当前执行环境中使用并且不会用到任何从 Object.prototype 上继承来的方法，也不会将该对象作为其他对象的原型的时候，那么可以使用 Object.create(null)。比如，构造一个字典对象的时候。<br>不过相对而言 <code>const obj={}</code>在浏览器中的执行速度是会比<code>Object.create(null)</code>快的，具体可点击链接<a href="https://jsperf.com/object-create-null-vs-literal/2" target="_blank" rel="noopener">test</a>。不过你一般代码中这些性能差距完全是可以忽略不计的。</p><p><a name="async-await-with-foreach"></a></p><h2 id="async-await-with-forEach"><a href="#async-await-with-forEach" class="headerlink" title="async/await with forEach()"></a>async/await with forEach()</h2><p>之前在工作中遇到了一个需求，实现一个简单的请求队列，大概意思就是这个页面有一个 list，我需要按 list 顺序依次发请求，多数据做一些操作，每次等前一个请求成功之后，再执行下一个，全部执行完毕之后，显示已完成。<br>这不就是用 <code>async/await</code>就可以实现了。于是写了如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> waitFor = <span class="function"><span class="params">ms</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> setTimeout(r, ms));</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach(<span class="keyword">async</span> num =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> waitFor(<span class="number">1000</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(num)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Done'</span>)</span><br></pre></td></tr></table></figure><p>What？为什么<code>await</code>没有生效，直接就输出了<code>1,2,3</code>？谷歌搜索了一下，发现原来是<code>forEach</code>的锅。 我们简单来看一下 <code>forEach</code>的实现原理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.forEach = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// this represents our array</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; <span class="keyword">this</span>.length; index++) &#123;</span><br><span class="line">    <span class="comment">// We call the callback for each entry</span></span><br><span class="line">    callback(<span class="keyword">this</span>[index], index, <span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到它只是 for 循环的一个简单封装，而且在内部它只是简单做了一个回调，根本就不会<code>wait</code>。其实一些其它的数组方式比如<code>map</code>、<code>reduce</code>等等也是不支持的，因为 Array 的迭代方法就支持不支持参数函数返回 promise 的异步用法，有兴趣的可以自行了解。<br>那我们直接用 <code>for</code>循环不就好了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].length; index++) &#123;</span><br><span class="line">    <span class="keyword">await</span> waitFor(<span class="number">1000</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(index)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'done'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者 <code>for-of</code>更为简单</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) &#123;</span><br><span class="line">    <span class="keyword">await</span> waitFor(<span class="number">1000</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'done'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="09ccd519"></a></p><h2 id="获取元素宽度"><a href="#获取元素宽度" class="headerlink" title="获取元素宽度"></a>获取元素宽度</h2><p>说真的，我觉得前端麻烦的地方就是 API 太多了，我只是想获取一个元素的宽度居然有<code>getBoundingClientRect().width</code></p><p><a name="7de30023"></a></p><h2 id="我使用-Async-Await-而不使用-Promises-的六个理由"><a href="#我使用-Async-Await-而不使用-Promises-的六个理由" class="headerlink" title="我使用 Async/Await 而不使用 Promises 的六个理由"></a>我使用 Async/Await 而不使用 Promises 的六个理由</h2><p>本文主要来自于 <a href="https://hackernoon.com/6-reasons-why-javascripts-async-await-blows-promises-away-tutorial-c7ec10518dd9" target="_blank" rel="noopener">6 Reasons Why JavaScript’s Async/Await Blows Promises Away</a>，在 medium 上，需要翻墙阅读。<br>之前我很长一段时间内都是使用 promise 的，但遇到一些复杂业务的时候，发现还是写起来会很不爽，代码阅读性也有所欠缺。<br></p><ol><li>简洁</li></ol><p>对比 Promise，我们不需要书写.then，不需要新建一个匿名函数处理响应，也不需要再把数据赋值给一个我们其实并不需要的变量</p><ol start="2"><li>a</li></ol><p>但 Async/Await 也不是没有缺点的，很多人经常会错用它。比如我一个组件创建的的时候会异步向服务器发送三个请求，<code>a</code>、<code>b、c</code>。 很多人会这么写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> resultA = <span class="keyword">await</span> fetch(<span class="string">'A'</span>)</span><br><span class="line">  <span class="keyword">const</span> resultB = <span class="keyword">await</span> fetch(<span class="string">'B'</span>)</span><br><span class="line">  <span class="keyword">const</span> resultC = <span class="keyword">await</span> fetch(<span class="string">'C'</span>)</span><br><span class="line">  render(resultA, resultB, resultC)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然上面的这段写法相对于 promise 简洁了不少，但效率来说是不合格的。因为这个请求是异步的，毫无联系的，所有没必要顺序请求，他们三个明显可以异步并发的去请求。要想实现真正的异步，还是需要依赖 Promise.all 封装一层：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(</span><br><span class="line">    fetch(<span class="string">'a.json'</span>),</span><br><span class="line">    fetch(<span class="string">'b.json'</span>),</span><br><span class="line">    fetch(<span class="string">'c.json'</span>)</span><br><span class="line">  )</span><br><span class="line">  render(...result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未完待续…</p></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2019/06/14/yuque/Virtual DOM 性能好？/" rel="next" title="Virtual DOM 性能好？"><i class="fa fa-chevron-left"></i> Virtual DOM 性能好？</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"> <a href="/2019/06/14/yuque/uni-app/" rel="prev" title="uni-app">uni-app<i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div><div class="comments" id="comments"><div id="disqus_thread"><noscript> Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap"> 站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/uploads/1916867.png" alt="FangCao"><p class="site-author-name" itemprop="name">FangCao</p><p class="site-description motion-element" itemprop="description">天空不留下鸟的痕迹，但我已飞过；流星是美丽的不为永恒，只为瞬间</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">67</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/index.html"><span class="site-state-item-count">1</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/index.html"><span class="site-state-item-count">2</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-blogroll motion-element links-of-blogroll-inline"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="http://macshuo.com/" title="MacTalk" target="_blank">MacTalk</a></li><li class="links-of-blogroll-item"> <a href="http://example.com/" title="Title" target="_blank">Title</a></li></ul></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#querySelectorAll-getElementsBy-区别？"><span class="nav-number">1.</span> <span class="nav-text">querySelectorAll getElementsBy 区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#浏览器兼容"><span class="nav-number">1.0.1.</span> <span class="nav-text">浏览器兼容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接收参数"><span class="nav-number">1.0.2.</span> <span class="nav-text">接收参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值"><span class="nav-number">1.0.3.</span> <span class="nav-text">返回值</span></a></li></ol></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#NodeList-和-HTMLCollection-之间的关系？"><span class="nav-number">2.</span> <span class="nav-text">NodeList 和 HTMLCollection 之间的关系？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#“1”-“2”-“3”-map-parseInt-坑"><span class="nav-number">3.</span> <span class="nav-text">[“1”, “2”, “3”].map(parseInt) 坑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#省略参数引发的-bug"><span class="nav-number">4.</span> <span class="nav-text">省略参数引发的 bug</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多余逗号引发的错误"><span class="nav-number">5.</span> <span class="nav-text">多余逗号引发的错误</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#js-中的逗号"><span class="nav-number">6.</span> <span class="nav-text">js 中的逗号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#document-documentElement-与-document-body-区别"><span class="nav-number">7.</span> <span class="nav-text">document.documentElement 与 document.body 区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sort"><span class="nav-number">8.</span> <span class="nav-text">sort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#codePointAt-vs-charCodeAt"><span class="nav-number">9.</span> <span class="nav-text">codePointAt vs charCodeAt</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#switch-作用域"><span class="nav-number">10.</span> <span class="nav-text">switch 作用域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#div-如何监听-keydown-事件"><span class="nav-number">11.</span> <span class="nav-text">div 如何监听 keydown 事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#try-catch-的-finally-坑"><span class="nav-number">12.</span> <span class="nav-text">try catch 的 finally 坑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#atob-方法解码中文字符"><span class="nav-number">13.</span> <span class="nav-text">atob 方法解码中文字符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Safari-下-Date-的坑"><span class="nav-number">14.</span> <span class="nav-text">Safari 下 Date 的坑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#new-Date-在-safari-的坑"><span class="nav-number">15.</span> <span class="nav-text">new Date 在 safari 的坑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#e-target-与-e-currentTarget-的区别"><span class="nav-number">16.</span> <span class="nav-text">e.target 与 e.currentTarget 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数变量必填校验"><span class="nav-number">17.</span> <span class="nav-text">函数变量必填校验</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#前端错误处理"><span class="nav-number">18.</span> <span class="nav-text">前端错误处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#有哪些错误需要处理"><span class="nav-number">18.1.</span> <span class="nav-text">有哪些错误需要处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Try-Catch"><span class="nav-number">18.2.</span> <span class="nav-text">Try Catch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#window-onerror"><span class="nav-number">18.3.</span> <span class="nav-text">window.onerror</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#window-addEventListener"><span class="nav-number">18.4.</span> <span class="nav-text">window.addEventListener</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Promise-Catch"><span class="nav-number">18.5.</span> <span class="nav-text">Promise Catch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VUE-errorHandler"><span class="nav-number">18.6.</span> <span class="nav-text">VUE errorHandler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#React-异常捕获"><span class="nav-number">18.7.</span> <span class="nav-text">React 异常捕获</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#崩溃和卡顿"><span class="nav-number">18.8.</span> <span class="nav-text">崩溃和卡顿</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#insertBefore-坑"><span class="nav-number">19.</span> <span class="nav-text">insertBefore 坑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么前端监控要用-GIF-打点"><span class="nav-number">20.</span> <span class="nav-text">为什么前端监控要用 GIF 打点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#主要原因"><span class="nav-number">20.1.</span> <span class="nav-text">主要原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用方式"><span class="nav-number">20.2.</span> <span class="nav-text">使用方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其它方案"><span class="nav-number">20.3.</span> <span class="nav-text">其它方案</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object-create-null-vs"><span class="nav-number">21.</span> <span class="nav-text">Object.create(null) vs {}</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#hasOwnProperty-NaN"><span class="nav-number">21.1.</span> <span class="nav-text">hasOwnProperty</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#valueOf-NaN"><span class="nav-number">21.2.</span> <span class="nav-text">valueOf</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#toString、isPrototypeOf-和-propertyIsEnumerable"><span class="nav-number">21.3.</span> <span class="nav-text">toString、isPrototypeOf 和 propertyIsEnumerable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结论"><span class="nav-number">21.4.</span> <span class="nav-text">结论</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#async-await-with-forEach"><span class="nav-number">22.</span> <span class="nav-text">async/await with forEach()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取元素宽度"><span class="nav-number">23.</span> <span class="nav-text">获取元素宽度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#我使用-Async-Await-而不使用-Promises-的六个理由"><span class="nav-number">24.</span> <span class="nav-text">我使用 Async/Await 而不使用 Promises 的六个理由</span></a></li></div></div></section><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2012 &mdash; <span itemprop="copyrightYear">2019</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">FangCao</span></div><div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div> <span class="post-meta-divider">|</span><div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div></div></footer></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/lib/three/three.min.js"></script><script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script id="dsq-count-scr" src="https://wangfangcao7618@gmail.com.disqus.com/count.js" async></script><script type="text/javascript">var disqus_config=function(){this.page.url="http://yoursite.com/2019/06/14/yuque/Javascript/",this.page.identifier="2019/06/14/yuque/Javascript/",this.page.title="Javascript"},d=document,s=d.createElement("script");s.src="https://wangfangcao7618@gmail.com.disqus.com/embed.js",s.setAttribute("data-timestamp",""+ +new Date),(d.head||d.body).appendChild(s)</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/tororo.model.json"},display:{position:"right",width:150,height:300},mobile:{show:!0,scale:.5},react:{opacityDefault:.7,opacityOnHover:.2},log:!1})</script></body><script type="text/javascript" src="/js/src/click.js"></script></html>