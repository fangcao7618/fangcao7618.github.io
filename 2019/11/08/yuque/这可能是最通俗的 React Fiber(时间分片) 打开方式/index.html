<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="写一篇关于 React Fiber 的文章， 这个 Flag 立了很久，这也是今年的目标之一。 最近的在掘金的文章获得很多关注和鼓励，给了我很多动力，所以下定决心好好把它写出来。 我会以最通俗的方式将它讲透, 因此这算是一篇科普式的文章。不管你是使用React、还是Vue，这里面的思想值得学习学习!一年一度的 React 春晚: React Conf 即将到来，不知道今年会不会有什么惊喜，去年是">
<meta property="og:type" content="article">
<meta property="og:title" content="这可能是最通俗的 React Fiber(时间分片) 打开方式">
<meta property="og:url" content="http://yoursite.com/2019/11/08/yuque/这可能是最通俗的 React Fiber(时间分片) 打开方式/index.html">
<meta property="og:site_name" content="FangCao">
<meta property="og:description" content="写一篇关于 React Fiber 的文章， 这个 Flag 立了很久，这也是今年的目标之一。 最近的在掘金的文章获得很多关注和鼓励，给了我很多动力，所以下定决心好好把它写出来。 我会以最通俗的方式将它讲透, 因此这算是一篇科普式的文章。不管你是使用React、还是Vue，这里面的思想值得学习学习!一年一度的 React 春晚: React Conf 即将到来，不知道今年会不会有什么惊喜，去年是">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396143-d4047282-b03c-418a-967a-663dabcf75af.webp#align=left&display=inline&height=268&originHeight=268&originWidth=592&size=0&status=done&width=592">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396159-3dea6e89-bc41-4402-9feb-42ecc0caaed9.webp#align=left&display=inline&height=772&originHeight=772&originWidth=960&size=0&status=done&width=960">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396175-412c5103-5f9b-4e86-8688-c35b8dd33561.webp#align=left&display=inline&height=580&originHeight=580&originWidth=794&size=0&status=done&width=794">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396147-79a9d69d-88b4-4f1b-9e52-c61d69529534.webp#align=left&display=inline&height=357&originHeight=357&originWidth=640&size=0&status=done&width=640">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396174-b1606b1e-594f-45bf-b937-3b10a3fa0381.webp#align=left&display=inline&height=498&originHeight=498&originWidth=942&size=0&status=done&width=942">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396200-9ea45c3e-4748-4570-88b3-2f08917a8376.webp#align=left&display=inline&height=375&originHeight=375&originWidth=500&size=0&status=done&width=500">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396195-543b56f5-f540-4852-ad7b-77cf32c89a28.webp#align=left&display=inline&height=167&originHeight=167&originWidth=1093&size=0&status=done&width=1093">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396196-0aac4744-b4ae-46d0-a48d-16dfbe6595e7.webp#align=left&display=inline&height=670&originHeight=670&originWidth=1280&size=0&status=done&width=1280">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2019/gif/263301/1573200396173-c420e139-3cbb-4028-b40a-ab90531c0aec.gif#align=left&display=inline&height=1080&originHeight=1080&originWidth=1678&size=0&status=done&width=1678">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2019/gif/263301/1573200396238-a43e8f91-15f4-4c8a-93d0-c415d75221b7.gif#align=left&display=inline&height=1080&originHeight=1080&originWidth=1721&size=0&status=done&width=1721">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396239-4588e86e-204a-4634-bfd2-1fa08ca19959.webp#align=left&display=inline&height=700&originHeight=700&originWidth=1268&size=0&status=done&width=1268">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396233-20281cd9-9923-4b7d-8edf-9d39c81b3bff.webp#align=left&display=inline&height=850&originHeight=850&originWidth=1280&size=0&status=done&width=1280">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396191-166ad4ef-e6b9-4944-a1a0-90f3cc0e6268.webp#align=left&display=inline&height=260&originHeight=260&originWidth=800&size=0&status=done&width=800">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396182-43d8dd11-d624-48d4-94d4-c7c9e7e58b9e.webp#align=left&display=inline&height=139&originHeight=139&originWidth=737&size=0&status=done&width=737">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396196-08223c2d-94e6-451d-a188-55919efe2ca8.webp#align=left&display=inline&height=243&originHeight=243&originWidth=1185&size=0&status=done&width=1185">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396185-4e1ab5e7-39a5-4fa2-83f9-ebf61a470860.webp#align=left&display=inline&height=990&originHeight=990&originWidth=960&size=0&status=done&width=960">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396179-c6b2f126-a957-4459-892d-374d1b3f4c29.webp#align=left&display=inline&height=330&originHeight=330&originWidth=1019&size=0&status=done&width=1019">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396241-14db8d9d-355a-4842-a759-11606136f7e7.webp#align=left&display=inline&height=439&originHeight=439&originWidth=982&size=0&status=done&width=982">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396195-aefd3b28-885e-4abc-9640-23a19b6b750f.webp#align=left&display=inline&height=461&originHeight=461&originWidth=566&size=0&status=done&width=566">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396192-4402b685-7e05-48db-abcd-68e34d61af97.webp#align=left&display=inline&height=439&originHeight=439&originWidth=708&size=0&status=done&width=708">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396228-9f5e5967-f1c6-45ea-911f-db79f4005f17.webp#align=left&display=inline&height=464&originHeight=464&originWidth=1232&size=0&status=done&width=1232">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396223-6e5ea448-8298-499b-9e9c-855f46be71ef.webp#align=left&display=inline&height=690&originHeight=690&originWidth=915&size=0&status=done&width=915">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396250-dd8d02ad-2b20-46b3-a163-4302cb36eaa1.webp#align=left&display=inline&height=342&originHeight=342&originWidth=560&size=0&status=done&width=560">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396188-f5fbcac4-564f-4ec1-b03d-f5c3d66b1e3a.webp#align=left&display=inline&height=155&originHeight=155&originWidth=709&size=0&status=done&width=709">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396224-13b13078-f902-4e60-a4ad-ad2faa5f5a25.webp#align=left&display=inline&height=200&originHeight=200&originWidth=681&size=0&status=done&width=681">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396304-8ecd6b99-ab21-401a-ac6d-560332af1c68.webp#align=left&display=inline&height=258&originHeight=258&originWidth=716&size=0&status=done&width=716">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396195-a8bb672b-2938-43b2-a75a-28f2249973fc.webp#align=left&display=inline&height=239&originHeight=239&originWidth=587&size=0&status=done&width=587">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396248-8aabcc50-23da-4705-98ea-9c11160c32c7.webp#align=left&display=inline&height=1151&originHeight=1151&originWidth=960&size=0&status=done&width=960">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396271-eefa3137-c2f2-4879-9a14-15f693743878.webp#align=left&display=inline&height=292&originHeight=292&originWidth=569&size=0&status=done&width=569">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2019/png/263301/1573208702714-ef95663e-db0b-4faa-a4f1-3e16a3f6921c.png#align=left&display=inline&height=732&originHeight=732&originWidth=970&size=0&status=done&width=970">
<meta property="og:updated_time" content="2019-12-10T06:58:23.069Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="这可能是最通俗的 React Fiber(时间分片) 打开方式">
<meta name="twitter:description" content="写一篇关于 React Fiber 的文章， 这个 Flag 立了很久，这也是今年的目标之一。 最近的在掘金的文章获得很多关注和鼓励，给了我很多动力，所以下定决心好好把它写出来。 我会以最通俗的方式将它讲透, 因此这算是一篇科普式的文章。不管你是使用React、还是Vue，这里面的思想值得学习学习!一年一度的 React 春晚: React Conf 即将到来，不知道今年会不会有什么惊喜，去年是">
<meta name="twitter:image" content="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396143-d4047282-b03c-418a-967a-663dabcf75af.webp#align=left&display=inline&height=268&originHeight=268&originWidth=592&size=0&status=done&width=592">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/11/08/yuque/这可能是最通俗的 React Fiber(时间分片) 打开方式/">





  <title>这可能是最通俗的 React Fiber(时间分片) 打开方式 | FangCao</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?f6bca865fcf2ff03fc0a96417de90b09";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>
<!-- 点击爆炸效果 -->
  
   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;"></canvas>
   <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
   <script type="text/javascript" src="/js/src/fireworks.js"></script>
  
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">FangCao</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <!-- echarts -->
    <script type="text/javascript" src="/js/src/echarts.common.min.js"></script>
    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/08/yuque/这可能是最通俗的 React Fiber(时间分片) 打开方式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FangCao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/1916867.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FangCao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">这可能是最通俗的 React Fiber(时间分片) 打开方式</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-08T16:05:46+08:00">
                2019-11-08
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-12-10T14:58:23+08:00">
                2019-12-10
              </time>
            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  17.2k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  63 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>写一篇关于 React Fiber 的文章， 这个 Flag 立了很久，这也是今年的目标之一。 最近的在掘金的文章获得很多关注和鼓励，给了我很多动力，所以下定决心好好把它写出来。 我会以最通俗的方式将它讲透, 因此这算是一篇科普式的文章。不管你是使用React、还是Vue，这里面的思想值得学习学习!<br><img src="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396143-d4047282-b03c-418a-967a-663dabcf75af.webp#align=left&display=inline&height=268&originHeight=268&originWidth=592&size=0&status=done&width=592" alt><br>一年一度的 React 春晚: <a href="https://conf.reactjs.org/schedule.html" target="_blank" rel="noopener">React Conf</a> 即将到来，不知道今年会不会有什么惊喜，去年是 React Hooks，前年是 React Fiber…<br>我得赶在 React Conf 之前发布这篇文章:</p>
<ul>
<li>😲 <strong>React Fiber 已经出来这么久了， 这文章是老酒装新瓶吧</strong>? <em>对于我来说，通过这篇文章我重新认识了 React Fiber，它不是一个新东西, 它也是老酒装新瓶，不信你就看吧…</em><br></li>
<li>🆕 <strong>React Fiber 不是一个新的东西，但在前端领域是第一次广为认知的应用</strong>。<br></li>
<li>😦 <strong>了解它有啥用</strong>? <em>React Fiber 代码很复杂，门槛很高，你不了解它，后面 React 新出的 Killer Feature 你可能就更不能理解了</em><br></li>
<li>🤥 <strong>我不是升到React v16了吗? 没什么出奇的啊</strong>? _真正要体会到 React Fiber 重构效果，可能下个月、可能要等到 v17。v16 只是一个过渡版本，也就是说，现在的React 还是同步渲染的，一直在跳票、不是说今年第二季度就出来了吗_？<br></li>
<li>😁 <strong>不好意思，一不小心又写得有点长，你就当小说看吧, 代码都是伪代码</strong><br></li>
</ul>
<p><strong>以下文章大纲</strong></p>
<ul>
<li><a href="#%E5%8D%95%E5%A4%84%E7%90%86%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6-fiber-%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E4%B8%9C%E8%A5%BF">单处理进程调度: Fiber 不是一个新的东西</a></li>
<li><a href="#%E7%B1%BB%E6%AF%94%E6%B5%8F%E8%A7%88%E5%99%A8javascript%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83">类比浏览器JavaScript执行环境</a></li>
<li><a href="#%E4%BD%95%E4%B8%BA-fiber">何为 Fiber</a><ul>
<li><a href="#1-%E4%B8%80%E7%A7%8D%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%8E%9F%E8%AF%AD">1. 一种流程控制原语</a></li>
<li><a href="#2-%E4%B8%80%E4%B8%AA%E6%89%A7%E8%A1%8C%E5%8D%95%E5%85%83">2. 一个执行单元</a></li>
</ul>
</li>
<li><a href="#react-%E7%9A%84fiber%E6%94%B9%E9%80%A0">React 的Fiber改造</a><ul>
<li><a href="#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E8%B0%83%E6%95%B4">1. 数据结构的调整</a></li>
<li><a href="#2-%E4%B8%A4%E4%B8%AA%E9%98%B6%E6%AE%B5%E7%9A%84%E6%8B%86%E5%88%86">2. 两个阶段的拆分</a></li>
<li><a href="#3-reconcilation">3. Reconcilation</a></li>
<li><a href="#4-%E5%8F%8C%E7%BC%93%E5%86%B2">4. 双缓冲</a></li>
<li><a href="#5-%E5%89%AF%E4%BD%9C%E7%94%A8%E7%9A%84%E6%94%B6%E9%9B%86%E5%92%8C%E6%8F%90%E4%BA%A4">5. 副作用的收集和提交</a></li>
</ul>
</li>
<li><a href="#%E2%9A%A0%EF%B8%8F-%E6%9C%AA%E5%B1%95%E5%BC%80%E9%83%A8%E5%88%86-%F0%9F%9A%A7----%E4%B8%AD%E6%96%AD%E5%92%8C%E6%81%A2%E5%A4%8D">⚠️ 未展开部分 🚧 – 中断和恢复</a></li>
<li><a href="#%E5%87%8C%E6%B3%A2%E5%BE%AE%E6%AD%A5">凌波微步</a></li>
<li><a href="#%E7%AB%99%E5%9C%A8%E5%B7%A8%E4%BA%BA%E7%9A%84%E8%82%A9%E8%86%80%E4%B8%8A">站在巨人的肩膀上</a><br><a name="gpT1v"></a><h2 id="单处理进程调度-Fiber-不是一个新的东西"><a href="#单处理进程调度-Fiber-不是一个新的东西" class="headerlink" title="单处理进程调度: Fiber 不是一个新的东西"></a>单处理进程调度: Fiber 不是一个新的东西</h2><img src="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396159-3dea6e89-bc41-4402-9feb-42ecc0caaed9.webp#align=left&display=inline&height=772&originHeight=772&originWidth=960&size=0&status=done&width=960" alt><br><em>这个黑乎乎的界面应该就是微软的 <code>DOS</code> 操作系统</em><br>微软 <a href="https://zh.wikipedia.org/zh-cn/DOS" target="_blank" rel="noopener"><code>DOS</code></a> 是一个<code>单任务操作系统</code>, 也称为’单工操作系统‘. 这种操作系统同一个时间只允许运行一个程序. <a href="https://www.zhihu.com/people/s.invalid" target="_blank" rel="noopener">invalid s</a>在<a href="https://www.zhihu.com/question/319595914/answer/683541635" target="_blank" rel="noopener">《在没有GUI的时代(只有一个文本界面），人们是怎么运行多个程序的？》</a> 的回答中将其称为: ‘<strong>一种压根没有任务调度的“残疾”操作系统</strong>‘.<br>在这种系统中，你想执行多个任务，只能等待前一个进程退出，然后再载入一个新的进程。<br>直到 Windows 3.x，它才有了真正意义的进程调度器，实现了多进程并发执行。<blockquote>
<p>注意并发和并行不是同一个概念。</p>
</blockquote>
</li>
</ul>
<p>现代操作系统都是<strong>多任务操作系统</strong>. 进程的调度策略如果按照CPU核心数来划分，可以分为<strong>单处理器调度</strong>和<strong>多处理器调度</strong>。本文只关注的是单处理器调度，因为它可以类比JavaScript的运行机制。<br><strong>🔴说白了，为了实现进程的并发，操作系统会按照一定的调度策略，将CPU的执行权分配给多个进程，多个进程都有被执行的机会，让它们交替执行，形成一种“同时在运行”假象, 因为CPU速度太快，人类根本感觉不到。实际上在单核的物理环境下同时只能有一个程序在运行</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396175-412c5103-5f9b-4e86-8688-c35b8dd33561.webp#align=left&display=inline&height=580&originHeight=580&originWidth=794&size=0&status=done&width=794" alt><br>这让我想起了“龙珠”中的分身术(小时候看过，说错了别喷)，实质上是一个人，只不过是他运动速度太快，看起来就像分身了. 这就是所谓的<strong>并发(Concurrent)</strong>(单处理器)。<br><img src="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396147-79a9d69d-88b4-4f1b-9e52-c61d69529534.webp#align=left&display=inline&height=357&originHeight=357&originWidth=640&size=0&status=done&width=640" alt><br>相比而言, 火影忍者中的分身术，是物理存在的，他们可以真正实现同时处理多个任务，这就是<strong>并行</strong>(严格地讲这是<code>Master-Slave</code>架构，分身虽然物理存在，但应该没有独立的意志)。<br>所以说<strong>🔴并行可以是并发，而并发不一定是并行，两种不能划等号, 并行一般需要物理层面的支持</strong>。 关于并发和并行，Go 之父 Rob Pike 有一个非常著名的演讲<a href="https://blog.golang.org/concurrency-is-not-parallelism" target="_blank" rel="noopener">Concurrency is not parallelism</a><br>扯远了，接下来进程怎么调度就是教科书的内容了。如果读者在大学认真学过<strong>操作系统原理</strong>, 你可以很快理解以下几种单处理器进程<strong>调度策略</strong>(我就随便科普一下，算送的, 如果你很熟悉这块，可以跳过)：<br><strong>0️⃣ 先到先得(First-Come-First-Served, FCFS)</strong><br>这是最简单的调度策略, 简单说就是<strong>没有调度</strong>。谁先来谁就先执行，执行完毕后就执行下一个。不过如果中间某些进程因为I/O阻塞了，这些进程会挂起移回就绪队列(说白了就是重新排队).<br><code>FCFS</code> 上面 <code>DOS</code> 的单任务操作系统没有太大的区别。所以非常好理解，因为生活中到处是这样的例子:。</p>
<ul>
<li><strong>FCFS 对<code>短进程</code>不利</strong>。 短进程即执行时间非常短的进程，可以用饭堂排队来比喻: <em>在饭堂排队打饭的时候，最烦那些一个人打包好好几份的人，这些人就像<code>长进程</code>一样，霸占着CPU资源，后面排队只打一份的人会觉得很吃亏，打一份的人会觉得他们优先级应该更高，毕竟他们花的时间很短，反正你打包那么多份再等一会也是可以的，何必让后面那么多人等这么久…</em><br></li>
<li><strong>FCFS 对<code>I/O密集</code>不利</strong>。I/O密集型进程(这里特指同步I/O)在进行I/O操作时，会阻塞休眠，这会导致进程重新被放入就绪队列，等待下一次被宠幸。 可以类比ZF部门办业务: <em>假设 CPU 一个窗口、I/O 一个窗口。在CPU窗口好不容易排到你了，这时候发现一个不符合条件或者漏办了, 需要去I/O搞一下，Ok 去 I/O窗口排队，I/O执行完了，到CPU窗口又得重新排队。对于这些丢三落四的人很不公平…</em><br></li>
</ul>
<p>所以 FCFS 这种原始的策略在单处理器进程调度中并不受欢迎。<br><strong>1️⃣ 轮转</strong><br>这是一种基于时钟的<strong>抢占策略</strong>，这也是抢占策略中最简单的一种: <strong>公平地给每一个进程一定的执行时间，当时间消耗完毕或阻塞，操作系统就会调度其他进程，将执行权抢占过来</strong>。</p>
<blockquote>
<p><strong>决策模式</strong>: <code>抢占策略</code>相对应的有<code>非抢占策略</code>，非抢占策略指的是让进程运行直到结束、阻塞(如I/O或睡眠)、或者主动让出控制权；抢占策略支持中断正在运行的进程，将主动权掌握在操作系统这里，不过通常开销会比较大。</p>
</blockquote>
<p>这种调度策略的要点是<strong>确定合适的时间片长度</strong>: 太长了，长进程霸占太久资源，其他进程会得不到响应(等待执行时间过长)，这时候就跟上述的 <code>FCFS</code> 没什么区别了;  太短了也不好，因为进程抢占和切换都是需要成本的, 而且成本不低，时间片太短，时间可能都浪费在上下文切换上了，导致进程干不了什么实事。<br>因此<strong>时间片的长度最好符合大部分进程完成一次典型交互所需的时间</strong>.<br>轮转策略非常容易理解，只不过确定时间片长度需要伤点脑筋；另外和<code>FCFS</code>一样，轮转策略对I/O进程还是不公平。<br><strong>2️⃣ 最短进程优先(Shortest Process Next, SPN)</strong><br>上面说了<code>先到先得</code>策略对<code>短进程</code>不公平，<code>最短进程优先</code>索性就让’最短’的进程优先执行，也就是说: <strong>按照进程的预估执行时间对进程进行优先级排序，先执行完短进程，后执行长进程。这是一种非抢占策略</strong>。<br>这样可以让短进程能得到较快的响应。但是怎么获取或者<strong>评估进程执行时间</strong>呢？一是让程序的提供者提供，这不太靠谱；二是由操作系统来收集进程运行数据，并对它们进程统计分析。例如最简单的是计算它们的平均运行时间。不管怎么说都比上面两种策略要复杂一点。<br><code>SPN</code> 的缺陷是: 如果系统有大量的短进程，那么长进程可能会饥饿得不到响应。<br>另外因为它不是抢占性策略, 尽管现在短进程可以得到更多的执行机会，但是还是没有解决 <code>FCFS</code> 的问题: 一旦长进程得到CPU资源，得等它执行完，导致后面的进程得不到响应。<br><strong>3️⃣ 最短剩余时间(Shortest Remaining Time, SRT)</strong><br><strong>SRT 进一步优化了SPN，增加了抢占机制</strong>。在 SPN 的基础上，当一个进程添加到就绪队列时，操作系统会比较_刚添加的新进程<em>和</em>当前正在执行的老进程_的‘剩余时间’，如果新进程剩余时间更短，新进程就会抢占老进程。<br>相比轮转的抢占，SRT 没有中断处理的开销。但是在 SPN 的基础上，操作系统需要记录进程的历史执行时间，这是新增的开销。<strong>另外长进程饥饿问题还是没有解决</strong>。<br><strong>4️⃣ 最高响应比优先(HRRN)</strong><br><strong>为了解决长进程饥饿问题，同时提高进程的响应速率</strong>。还有一种<code>最高响应比优先的</code>策略，首先了解什么是响应比:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">响应比 = （等待执行时间 + 进程执行时间） / 进程执行时间</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><strong>这种策略会选择响应比最高的进程优先执行</strong>：</p>
<ul>
<li>对于短进程来说，因为执行时间很短，分母很小，所以响应比比较高，会被优先执行</li>
<li>对于长进程来说，执行时间长，一开始响应比小，但是随着等待时间增长，它的优先级会越来越高，最终可以被执行</li>
</ul>
<p><strong>5️⃣ 反馈法</strong><br>SPN、SRT、HRRN都需要对进程时间进行评估和统计，实现比较复杂且需要一定开销。而反馈法采取的是<strong>事后反馈</strong>的方式。这种策略下: <strong>每个进程一开始都有相同的优先级，每次被抢占(需要配合其他抢占策略使用，如轮转)，优先级就会降低一级。因此通常它会根据优先级划分多个队列</strong>。<br>举个例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">队列1</span><br><span class="line">队列2</span><br><span class="line">...</span><br><span class="line">队列N</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>新增的任务会推入<code>队列1</code>，<code>队列1</code>会按照<code>轮转策略</code>以一个时间片为单位进行调度。短进程可以很快得到响应，而对于长进程可能一个时间片处理不完，就会被抢占，放入<code>队列2</code>。<br><code>队列2</code>会在<code>队列1</code>任务清空后被执行，有时候低优先级队列可能会等待很久才被执行，所以一般会给予一定的补偿，例如增加执行时间，所以<code>队列2</code>的轮转时间片长度是2。<br>反馈法仍然可能导致长进程饥饿，所以操作系统可以统计长进程的等待时间，当等待时间超过一定的阈值，可以选择提高它们的优先级。<br><img src="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396174-b1606b1e-594f-45bf-b937-3b10a3fa0381.webp#align=left&display=inline&height=498&originHeight=498&originWidth=942&size=0&status=done&width=942" alt><br>没有一种调度策略是万能的, 它需要考虑很多因素:</p>
<ul>
<li>响应速率。进程等待被执行的时间</li>
<li>公平性。兼顾短进程、长进程、I/O进程</li>
</ul>
<p>这两者在某些情况下是对立的，提高了响应，可能会减低公平性，导致饥饿。短进程、长进程、I/O进程之间要取得平衡也非常难。<br>上面这些知识对本文来说已经足够了，现实世界操作系统的进程调度算法比教科书上说的要复杂的多，有兴趣读者可以去研究一下 <code>Linux</code> 相关的进程调度算法，这方面的资料也非常多, 例如<a href="https://blog.csdn.net/gatieme/article/details/51456569" target="_blank" rel="noopener">《Linux进程调度策略的发展和演变》</a>。
<a name="J8zoe"></a></p>
<h2 id="类比浏览器JavaScript执行环境"><a href="#类比浏览器JavaScript执行环境" class="headerlink" title="类比浏览器JavaScript执行环境"></a>类比浏览器JavaScript执行环境</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396200-9ea45c3e-4748-4570-88b3-2f08917a8376.webp#align=left&display=inline&height=375&originHeight=375&originWidth=500&size=0&status=done&width=500" alt><br><em>JavaScript 就像单行道</em><br>JavaScript 是<a href="https://juejin.im/post/5a6547d0f265da3e283a1df7" target="_blank" rel="noopener">单线程运行</a>的，而且在浏览器环境屁事非常多，它要负责页面的JS解析和执行、绘制、事件处理、静态资源加载和处理, 这些任务可以类比上面’进程‘。</p>
<blockquote>
<p>这里特指Javascript 引擎是单线程运行的。 严格来说，Javascript 引擎和页面渲染引擎在同一个<code>渲染线程</code>，GUI 渲染和 Javascript执行 两者是互斥的. 另外异步 I/O 操作底层实际上可能是多线程的在驱动。</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396195-543b56f5-f540-4852-ad7b-77cf32c89a28.webp#align=left&display=inline&height=167&originHeight=167&originWidth=1093&size=0&status=done&width=1093" alt><br><em>图片来源: <a href="https://developers.google.com/web/fundamentals/performance/rendering" target="_blank" rel="noopener">Rendering Performance</a></em><br><strong>它只是一个’JavaScript’，同时只能做一件事情，这个和 <code>DOS</code> 的单任务操作系统一样的，事情只能一件一件的干。要是前面有一个傻叉任务长期霸占CPU，后面什么事情都干不了，浏览器会呈现卡死的状态，这样的用户体验就会非常差</strong>。<br><strong>对于’前端框架‘来说，解决这种问题有三个方向</strong>:</p>
<ul>
<li>1️⃣ 优化每个任务，让它有多快就多快。挤压CPU运算量</li>
<li>2️⃣ 快速响应用户，让用户觉得够快，不能阻塞用户的交互</li>
<li>3️⃣ 尝试 Worker 多线程</li>
</ul>
<p>Vue 选择的是第1️⃣, 因为对于Vue来说，使用<code>模板</code>让它有了很多优化的空间，配合响应式机制可以让Vue可以精确地进行节点更新, 读者可以去看一下<a href="https://www.yuque.com/vueconf/2019/gwn1z0" target="_blank" rel="noopener">今年Vue Conf 尤雨溪的演讲</a>，非常棒!；而 React 选择了2️⃣ 。对于Worker 多线程渲染方案也有人尝试，要保证状态和视图的一致性相当麻烦。<br>React 为什么要引入 Fiber 架构？ 看看下面的火焰图，这是React V15 下面的一个列表渲染资源消耗情况。整个渲染花费了130ms, <strong>🔴在这里面 React 会递归比对VirtualDOM树，找出需要变动的节点，然后同步更新它们, 一气呵成。这个过程 React 称为 <code>Reconcilation</code>(中文可以译为<code>协调</code>)</strong>.<br><img src="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396196-0aac4744-b4ae-46d0-a48d-16dfbe6595e7.webp#align=left&display=inline&height=670&originHeight=670&originWidth=1280&size=0&status=done&width=1280" alt><br>在 Reconcilation 期间，React 会霸占着浏览器资源，一则会导致用户触发的事件得不到响应, 二则会导致掉帧，用户可以感知到这些卡顿。<br>这样说，你可能没办法体会到，通过下面两个图片来体会一下(<em>图片来源于：<a href="https://twitter.com/dan_abramov" target="_blank" rel="noopener">Dan Abramov</a> 的 <a href="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html" target="_blank" rel="noopener">Beyond React 16</a> 演讲, 推荐看一下👍. 另外非常感谢<a href="https://www.zhihu.com/people/BlackGanglion/activities" target="_blank" rel="noopener">淡苍</a> 将一个<a href="https://codesandbox.io/s/koyz664q35" target="_blank" rel="noopener">类似的DEMO 分享在了 CodeSandbox</a>上🎉，大家自行体验</em>):<br>同步模式下的 React:<br><img src="https://cdn.nlark.com/yuque/0/2019/gif/263301/1573200396173-c420e139-3cbb-4028-b40a-ab90531c0aec.gif#align=left&display=inline&height=1080&originHeight=1080&originWidth=1678&size=0&status=done&width=1678" alt><br>优化后的 <code>Concurrent</code> 模式下的 React:<br><img src="https://cdn.nlark.com/yuque/0/2019/gif/263301/1573200396238-a43e8f91-15f4-4c8a-93d0-c415d75221b7.gif#align=left&display=inline&height=1080&originHeight=1080&originWidth=1721&size=0&status=done&width=1721" alt><br>React 的 Reconcilation 是CPU密集型的操作, 它就相当于我们上面说的’长进程‘。所以初衷和进程调度一样，我们要让高优先级的进程或者短进程优先运行，不能让长进程长期霸占资源。<br>所以React 是怎么优化的？ 划重点， <strong>🔴为了给用户制造一种应用很快的’假象’，我们不能让一个程序长期霸占着资源. 你可以将浏览器的渲染、布局、绘制、资源加载(例如HTML解析)、事件响应、脚本执行视作操作系统的’进程’，我们需要通过某些调度策略合理地分配CPU资源，从而提高浏览器的用户响应速率, 同时兼顾任务执行效率</strong>。<br><strong>🔴所以 React 通过Fiber 架构，让自己的Reconcilation 过程变成可被中断。 ‘适时’地让出CPU执行权，除了可以让浏览器及时地响应用户的交互，还有其他好处</strong>:</p>
<ul>
<li>与其一次性操作大量 DOM 节点相比, 分批延时对DOM进行操作，可以得到更好的用户体验。这个在<a href="https://juejin.im/post/5d76f469f265da039a28aff7#heading-1" target="_blank" rel="noopener">《「前端进阶」高性能渲染十万条数据(时间分片)》</a> 以及司徒正美的<a href="https://zhuanlan.zhihu.com/p/37095662" target="_blank" rel="noopener">《React Fiber架构》</a> 都做了相关实验</li>
<li>司徒正美在<a href="https://zhuanlan.zhihu.com/p/37095662" target="_blank" rel="noopener">《React Fiber架构》</a> 也提到：<strong>🔴给浏览器一点喘息的机会，他会对代码进行编译优化（JIT）及进行热代码优化，或者对reflow进行修正</strong>.</li>
</ul>
<p>这就是为什么React 需要 Fiber 😏。<br><a name="M1xrU"></a></p>
<h2 id="何为-Fiber"><a href="#何为-Fiber" class="headerlink" title="何为 Fiber"></a>何为 Fiber</h2><p>对于 React 来说，Fiber 可以从两个角度理解:<br><a name="To1aA"></a></p>
<h3 id="1-一种流程控制原语"><a href="#1-一种流程控制原语" class="headerlink" title="1. 一种流程控制原语"></a>1. 一种流程控制原语</h3><p>Fiber 也称<a href="https://www.liaoxuefeng.com/wiki/897692888725344/923057403198272" target="_blank" rel="noopener">协程</a>、或者纤程。 笔者第一次接触这个概念是在学习 Ruby 的时候，Ruby就将协程称为 Fiber。后来发现很多语言都有类似的机制，例如Lua 的<code>Coroutine</code>, 还有前端开发者比较熟悉的 <code>ES6</code> 新增的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator" target="_blank" rel="noopener"><code>Generator</code></a>。</p>
<blockquote>
<p>本文不纠结 <a href="https://stackoverflow.com/questions/3324643/processes-threads-green-threads-protothreads-fibers-coroutines-whats-the/16375591#16375591" target="_blank" rel="noopener">Processes, threads, green threads, protothreads, fibers, coroutines: what’s the difference?</a></p>
</blockquote>
<p><strong>🔴 其实协程和线程并不一样，协程本身是没有并发或者并行能力的（需要配合线程），它只是一种控制流程的让出机制</strong>。要理解协程，你得和普通函数一起来看, 以Generator为例:<br>普通函数执行的过程中无法<strong>被中断和恢复</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tasks = []</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> task</span><br><span class="line">  <span class="keyword">while</span> (task = tasks.shift()) &#123;</span><br><span class="line">    execute(task)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>而 <code>Generator</code> 可以:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tasks = []</span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> task</span><br><span class="line">  <span class="keyword">while</span> (task = tasks.shift()) &#123;</span><br><span class="line">    <span class="comment">// 🔴 判断是否有高优先级事件需要处理, 有的话让出控制权</span></span><br><span class="line">    <span class="keyword">if</span> (hasHighPriorityEvent()) &#123;</span><br><span class="line">      <span class="keyword">yield</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理完高优先级事件后，恢复函数调用栈，继续执行...</span></span><br><span class="line">    execute(task)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>React Fiber 的思想和协程的概念是契合的: <strong>🔴React 渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染</strong>。<br>那么现在你应该有以下疑问:</p>
<ul>
<li>1️⃣ 浏览器没有抢占的条件, 所以React只能用让出机制?</li>
<li>2️⃣ 怎么确定有高优先任务要处理，即什么时候让出？</li>
<li>3️⃣ React 那为什么不使用 Generator？</li>
</ul>
<p><strong>答1️⃣: 没错, 主动让出机制</strong><br>一是浏览器中没有类似进程的概念，’任务‘之间的界限很模糊，没有上下文，所以不具备中断/恢复的条件。二是没有抢占的机制，我们无法中断一个正在执行的程序。<br>所以我们只能采用类似协程这样控制权让出机制。这个和上文提到的进程调度策略都不同，它有更一个专业的名词：<a href="https://juejin.im/post/5d12c907f265da1b6d4033c5#heading-7" target="_blank" rel="noopener"><strong>合作式调度(Cooperative Scheduling)</strong></a>, 相对应的有<strong>抢占式调度(Preemptive Scheduling)</strong><br><strong>这是一种’契约‘调度，要求我们的程序和浏览器紧密结合，互相信任</strong>。比如可以由浏览器给我们分配执行时间片(通过<code>requestIdleCallback</code>实现, 下文会介绍)，我们要按照约定在这个时间内执行完毕，并将控制权还给浏览器。<br><img src="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396239-4588e86e-204a-4634-bfd2-1fa08ca19959.webp#align=left&display=inline&height=700&originHeight=700&originWidth=1268&size=0&status=done&width=1268" alt><br>这种调度方式很有趣，你会发现<strong>这是一种身份的对调</strong>，以前我们是老子，想怎么执行就怎么执行，执行多久就执行多久; 现在为了我们共同的用户体验统一了战线, 一切听由浏览器指挥调度，浏览器是老子，我们要跟浏览器申请执行权，而且这个执行权有期限，借了后要按照约定归还给浏览器。<br>当然你超时不还浏览器也拿你没办法 🤷‍… 合作式调度的缺点就在于此，全凭自律，用户要挖大坑，谁都拦不住。</p>
<hr>
<p><strong>答2️⃣: requestIdleCallback API</strong><br>上面代码示例中的 <code>hasHighPriorityEvent()</code> 在目前浏览器中是无法实现的，我们没办法判断当前是否有更高优先级的任务等待被执行。<br>只能换一种思路，通过<strong>超时检查的机制来让出控制权</strong>。解决办法是: _确定一个合理的运行时长，然后在合适的检查点检测是否超时(比如每执行一个小任务)，如果超时就停止执行，将控制权交换给浏览器_。<br>举个例子，为了让视图流畅地运行，可以按照人类能感知到最低限度每秒60帧的频率划分时间片，这样每个时间片就是 16ms。<br>其实浏览器提供了相关的接口 —— <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback" target="_blank" rel="noopener"><code>requestIdleCallback</code></a> API：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.requestIdleCallback(</span><br><span class="line">  callback: <span class="function">(<span class="params">dealine: IdleDeadline</span>) =&gt;</span> <span class="keyword">void</span>,</span><br><span class="line">  option?: &#123;<span class="attr">timeout</span>: number&#125;</span><br><span class="line">  )</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>IdleDeadline</code>的接口如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface IdleDealine &#123;</span><br><span class="line">  didTimeout: boolean <span class="comment">// 表示任务执行是否超过约定时间</span></span><br><span class="line">  timeRemaining(): DOMHighResTimeStamp <span class="comment">// 任务可供执行的剩余时间</span></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>单从名字上理解的话, <code>requestIdleCallback</code>的意思是<strong>让浏览器在’有空’的时候就执行我们的回调，这个回调会传入一个期限，表示浏览器有多少时间供我们执行, 为了不耽误事，我们最好在这个时间范围内执行完毕</strong>。<br><strong>那浏览器什么时候有空？</strong><br>我们先来看一下浏览器在一帧(Frame，可以认为事件循环的一次循环)内可能会做什么事情:<br><img src="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396233-20281cd9-9923-4b7d-8edf-9d39c81b3bff.webp#align=left&display=inline&height=850&originHeight=850&originWidth=1280&size=0&status=done&width=1280" alt><br><em>你可以打开 Chrome 开发者工具的Performance标签，这里可以详细看到Javascript的每一帧都执行了什么任务(Task), 花费了多少时间。</em><br><img src="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396191-166ad4ef-e6b9-4944-a1a0-90f3cc0e6268.webp#align=left&display=inline&height=260&originHeight=260&originWidth=800&size=0&status=done&width=800" alt><br><em>图片来源: <a href="https://juejin.im/post/5ad71f39f265da239f07e862" target="_blank" rel="noopener">你应该知道的requestIdleCallback</a></em><br>浏览器在一帧内可能会做执行下列任务，而且它们的执行顺序基本是固定的:</p>
<ul>
<li>处理用户输入事件</li>
<li>Javascript执行</li>
<li>requestAnimation 调用</li>
<li>布局 Layout</li>
<li>绘制 Paint</li>
</ul>
<p>上面说理想的一帧时间是 <code>16ms</code> (1000ms / 60)，如果浏览器处理完上述的任务(布局和绘制之后)，还有盈余时间，浏览器就会调用 <code>requestIdleCallback</code> 的回调。例如<br><img src="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396182-43d8dd11-d624-48d4-94d4-c7c9e7e58b9e.webp#align=left&display=inline&height=139&originHeight=139&originWidth=737&size=0&status=done&width=737" alt><br><strong>但是在浏览器繁忙的时候，可能不会有盈余时间，这时候<code>requestIdleCallback</code>回调可能就不会被执行。 为了避免饿死，可以通过requestIdleCallback的第二个参数指定一个超时时间</strong>。</p>
<blockquote>
<p>另外不建议在<code>requestIdleCallback</code>中进行<code>DOM</code>操作，因为这可能导致样式重新计算或重新布局(比如操作DOM后马上调用 <code>getBoundingClientRect</code>)，这些时间很难预估的，很有可能导致回调执行超时，从而掉帧。</p>
</blockquote>
<p>目前 <code>requestIdleCallback</code> 目前只有Chrome支持。所以目前 React <a href="https://github.com/facebook/react/blob/master/packages/scheduler/src/forks/SchedulerHostConfig.default.js" target="_blank" rel="noopener">自己实现了一个</a>。它利用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MessageChannel" target="_blank" rel="noopener"><code>MessageChannel</code></a> 模拟将回调延迟到’绘制操作’之后执行:<br><img src="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396196-08223c2d-94e6-451d-a188-55919efe2ca8.webp#align=left&display=inline&height=243&originHeight=243&originWidth=1185&size=0&status=done&width=1185" alt><br>简单看一下代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>)</span><br><span class="line"><span class="keyword">const</span> ch = <span class="keyword">new</span> MessageChannel()</span><br><span class="line"><span class="keyword">let</span> pendingCallback</span><br><span class="line"><span class="keyword">let</span> startTime</span><br><span class="line"><span class="keyword">let</span> timeout</span><br><span class="line">ch.port2.onmessage = <span class="function"><span class="keyword">function</span> <span class="title">work</span>(<span class="params"></span>)  </span>&#123;</span><br><span class="line">  <span class="comment">// 在绘制之后被执行</span></span><br><span class="line">  <span class="keyword">if</span> (pendingCallback) &#123;</span><br><span class="line">    <span class="keyword">const</span> now = performance.now()</span><br><span class="line">    <span class="comment">// 通过now - startTime可以计算出requestAnimationFrame到绘制结束的执行时间</span></span><br><span class="line">    <span class="comment">// 通过这些数据来计算剩余时间</span></span><br><span class="line">    <span class="comment">// 另外还要处理超时(timeout)，避免任务被饿死</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (hasRemain &amp;&amp; noTimeout) &#123;</span><br><span class="line">      pendingCallback(deadline)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleRequestIdleCallback</span>(<span class="params">callback, timeout</span>) </span>&#123;</span><br><span class="line">  requestAnimationFrame(<span class="function"><span class="keyword">function</span> <span class="title">animation</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在绘制之前被执行</span></span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    startTime = performance.now()</span><br><span class="line">    timeout = timeout</span><br><span class="line">    dosomething()</span><br><span class="line">    <span class="comment">// 调度回调到绘制结束后执行</span></span><br><span class="line">    pendingCallback = callback</span><br><span class="line">    ch.port1.postMessage(<span class="string">'hello'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><strong>任务优先级</strong><br>上面说了，为了避免任务被饿死，可以设置一个超时时间. <strong>这个超时时间不是死的，低优先级的可以慢慢等待, 高优先级的任务应该率先被执行</strong>. 目前 React 预定义了 5 个优先级, 这个我在[《谈谈React事件机制和未来(react-events)》]中也介绍过:</p>
<ul>
<li><code>Immediate</code>(-1) - 这个优先级的任务会同步执行, 或者说要马上执行且不能中断</li>
<li><code>UserBlocking</code>(250ms) 这些任务一般是用户交互的结果, 需要即时得到反馈</li>
<li><code>Normal</code> (5s) 应对哪些不需要立即感受到的任务，例如网络请求</li>
<li><code>Low</code> (10s) 这些任务可以放后，但是最终应该得到执行. 例如分析通知</li>
<li><code>Idle</code> (没有超时时间) 一些没有必要做的任务 (e.g. 比如隐藏的内容), 可能会被饿死</li>
</ul>
<hr>
<p><strong>答3️⃣: 太麻烦</strong><br>官方在<a href="https://github.com/facebook/react/issues/7942" target="_blank" rel="noopener">《Fiber Principles: Contributing To Fiber》</a> 也作出了解答。主要有两个原因：</p>
<ol>
<li>Generator 不能在栈中间让出。比如你想在嵌套的函数调用中间让出, 首先你需要将这些函数都包装成Generator，另外这种栈中间的让出处理起来也比较麻烦，难以理解。除了语法开销，现有的生成器实现开销比较大，所以不如不用。</li>
<li>Generator 是有状态的, 很难在中间恢复这些状态。<blockquote>
<p>上面理解可能有出入，建议看一下原文</p>
</blockquote>
</li>
</ol>
<p>可能都没看懂，简单就是 React 尝试过用 Generator 实现，后来发现很麻烦，就放弃了。<br><a name="nra3j"></a></p>
<h3 id="2-一个执行单元"><a href="#2-一个执行单元" class="headerlink" title="2. 一个执行单元"></a>2. 一个执行单元</h3><p>Fiber的另外一种解读是’纤维‘: <strong>这是一种数据结构或者说执行单元</strong>。我们暂且不管这个数据结构长什么样，<strong>🔴将它视作一个执行单元，每次执行完一个’执行单元’,  React 就会检查现在还剩多少时间，如果没有时间就将控制权让出去</strong>.<br>上文说了，React 没有使用 Generator 这些语言/语法层面的让出机制，而是实现了自己的调度让出机制。这个机制就是基于’Fiber‘这个执行单元的，它的过程如下：<br>假设用户调用 <code>setState</code> 更新组件, 这个待更新的任务会先放入队列中, 然后通过 <code>requestIdleCallback</code> 请求浏览器调度：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">updateQueue.push(updateTask);</span><br><span class="line">requestIdleCallback(performWork, &#123;timeout&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>现在浏览器有空闲或者超时了就会调用<code>performWork</code>来执行任务：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1️⃣ performWork 会拿到一个Deadline，表示剩余时间</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performWork</span>(<span class="params">deadline</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 2️⃣ 循环取出updateQueue中的任务</span></span><br><span class="line">  <span class="keyword">while</span> (updateQueue.length &gt; <span class="number">0</span> &amp;&amp; deadline.timeRemaining() &gt; ENOUGH_TIME) &#123;</span><br><span class="line">    workLoop(deadline);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 3️⃣ 如果在本次执行中，未能将所有任务执行完毕，那就再请求浏览器调度</span></span><br><span class="line">  <span class="keyword">if</span> (updateQueue.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    requestIdleCallback(performWork);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><strong><code>workLoop</code> 的工作大概猜到了，它会从更新队列(updateQueue)中弹出更新任务来执行，每执行完一个‘<code>执行单元</code>‘，就检查一下剩余时间是否充足，如果充足就进行执行下一个<code>执行单元</code>，反之则停止执行，保存现场，等下一次有执行权时恢复</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存当前的处理现场</span></span><br><span class="line"><span class="keyword">let</span> nextUnitOfWork: Fiber | <span class="literal">undefined</span> <span class="comment">// 保存下一个需要处理的工作单元</span></span><br><span class="line"><span class="keyword">let</span> topWork: Fiber | <span class="literal">undefined</span>        <span class="comment">// 保存第一个工作单元</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params">deadline: IdleDeadline</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// updateQueue中获取下一个或者恢复上一次中断的执行单元</span></span><br><span class="line">  <span class="keyword">if</span> (nextUnitOfWork == <span class="literal">null</span>) &#123;</span><br><span class="line">    nextUnitOfWork = topWork = getNextUnitOfWork();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 🔴 每执行完一个执行单元，检查一次剩余时间</span></span><br><span class="line">  <span class="comment">// 如果被中断，下一次执行还是从 nextUnitOfWork 开始处理</span></span><br><span class="line">  <span class="keyword">while</span> (nextUnitOfWork &amp;&amp; deadline.timeRemaining() &gt; ENOUGH_TIME) &#123;</span><br><span class="line">    <span class="comment">// 下文我们再看performUnitOfWork</span></span><br><span class="line">    nextUnitOfWork = performUnitOfWork(nextUnitOfWork, topWork);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 提交工作，下文会介绍</span></span><br><span class="line">  <span class="keyword">if</span> (pendingCommit) &#123;</span><br><span class="line">    commitAllWork(pendingCommit);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>画个流程图吧！<br><img src="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396185-4e1ab5e7-39a5-4fa2-83f9-ebf61a470860.webp#align=left&display=inline&height=990&originHeight=990&originWidth=960&size=0&status=done&width=960" alt><br><a name="iKmzw"></a></p>
<h2 id="React-的Fiber改造"><a href="#React-的Fiber改造" class="headerlink" title="React 的Fiber改造"></a>React 的Fiber改造</h2><p>Fiber 的核心内容已经介绍完了，现在来进一步看看React 为 Fiber 架构做了哪些改造, 如果你对这部分内容不感兴趣可以跳过。<br><a name="Im2uH"></a></p>
<h3 id="1-数据结构的调整"><a href="#1-数据结构的调整" class="headerlink" title="1. 数据结构的调整"></a>1. 数据结构的调整</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396179-c6b2f126-a957-4459-892d-374d1b3f4c29.webp#align=left&display=inline&height=330&originHeight=330&originWidth=1019&size=0&status=done&width=1019" alt><br><em>左侧是Virtual DOM，右侧可以看作diff的递归调用栈</em><br>上文中提到 React 16 之前，Reconcilation 是同步的、递归执行的。也就是说这是基于函数’调用栈‘的Reconcilation算法，因此通常也称它为<code>Stack Reconcilation</code>. 你可以通过这篇文章<a href="https://juejin.im/post/5cfa29e151882539c33e4f5e" target="_blank" rel="noopener">《从Preact中了解React组件和hooks基本原理》</a> 来回顾一下历史。<br>栈挺好的，代码量少，递归容易理解, 至少比现在的 React Fiber架构好理解😂, 递归非常适合树这种嵌套数据结构的处理。<br>只不过这种依赖于调用栈的方式不能随意中断、也很难被恢复, 不利于异步处理。 这种调用栈，不是程序所能控制的， 如果你要恢复递归现场，可能需要从头开始, 恢复到之前的调用栈。<br>因此<strong>首先我们需要对React现有的数据结构进行调整，<a href="https://zhuanlan.zhihu.com/p/36425839" target="_blank" rel="noopener"><code>模拟函数调用栈</code></a>, 将之前需要递归进行处理的事情分解成增量的执行单元，将递归转换成迭代</strong>.<br>React 目前的做法是使用<code>链表</code>, 每个 VirtualDOM 节点内部现在使用 <code>Fiber</code>表示, 它的结构大概如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> type Fiber = &#123;</span><br><span class="line">  <span class="comment">// Fiber 类型信息</span></span><br><span class="line">  type: any,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// ⚛️ 链表结构</span></span><br><span class="line">  <span class="comment">// 指向父节点，或者render该节点的组件</span></span><br><span class="line">  <span class="keyword">return</span>: Fiber | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 指向第一个子节点</span></span><br><span class="line">  child: Fiber | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 指向下一个兄弟节点</span></span><br><span class="line">  sibling: Fiber | <span class="literal">null</span>,</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>用图片来展示这种关系会更直观一些：<br><img src="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396241-14db8d9d-355a-4842-a759-11606136f7e7.webp#align=left&display=inline&height=439&originHeight=439&originWidth=982&size=0&status=done&width=982" alt><br><strong>使用链表结构只是一个结果，而不是目的，React 开发者一开始的目的是冲着模拟调用栈去的</strong>。这个很多关于Fiber 的文章都有提及, 关于调用栈的详细定义参见<a href="https://en.wikipedia.org/wiki/Call_stack" target="_blank" rel="noopener">Wiki</a>：<br><img src="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396195-aefd3b28-885e-4abc-9640-23a19b6b750f.webp#align=left&display=inline&height=461&originHeight=461&originWidth=566&size=0&status=done&width=566" alt></p>
<blockquote>
<p>调用栈最经常被用于存放子程序的<strong>返回地址</strong>。在调用任何子程序时，主程序都必须暂存子程序运行完毕后应该返回到的地址。因此，如果被调用的子程序还要调用其他的子程序，其自身的返回地址就必须存入调用栈，在其自身运行完毕后再行取回。除了返回地址，还会保存<code>本地变量</code>、<code>函数参数</code>、<code>环境传递</code>(Scope?)</p>
</blockquote>
<p>React Fiber 也被称为虚拟栈帧(Virtual Stack Frame), 你可以拿它和函数调用栈类比一下, 两者结构非常像:</p>
<table>
<thead>
<tr>
<th></th>
<th>函数调用栈</th>
<th>Fiber</th>
</tr>
</thead>
<tbody><tr>
<td>基本单位</td>
<td>函数</td>
<td>Virtual DOM 节点</td>
</tr>
<tr>
<td>输入</td>
<td>函数参数</td>
<td>Props</td>
</tr>
<tr>
<td>本地状态</td>
<td>本地变量</td>
<td>State</td>
</tr>
<tr>
<td>输出</td>
<td>函数返回值</td>
<td>React Element</td>
</tr>
<tr>
<td>下级</td>
<td>嵌套函数调用</td>
<td>子节点(child)</td>
</tr>
<tr>
<td>上级引用</td>
<td>返回地址</td>
<td>父节点(return)</td>
</tr>
</tbody></table>
<p>Fiber 和调用栈帧一样, 保存了节点处理的上下文信息，因为是手动实现的，所以更为可控，我们可以保存在内存中，随时中断和恢复。<br>有了这个数据结构调整，现在可以以迭代的方式来处理这些节点了。来看看 <code>performUnitOfWork</code> 的实现, 它其实就是一个深度优先的遍历：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @params fiber 当前需要处理的节点</span></span><br><span class="line"><span class="comment"> * @params topWork 本次更新的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">fiber: Fiber, topWork: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 对该节点进行处理</span></span><br><span class="line">  beginWork(fiber);</span><br><span class="line">  <span class="comment">// 如果存在子节点，那么下一个待处理的就是子节点</span></span><br><span class="line">  <span class="keyword">if</span> (fiber.child) &#123;</span><br><span class="line">    <span class="keyword">return</span> fiber.child;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 没有子节点了，上溯查找兄弟节点</span></span><br><span class="line">  <span class="keyword">let</span> temp = fiber;</span><br><span class="line">  <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">    completeWork(temp);</span><br><span class="line">    <span class="comment">// 到顶层节点了, 退出</span></span><br><span class="line">    <span class="keyword">if</span> (temp === topWork) &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到，下一个要处理的就是兄弟节点</span></span><br><span class="line">    <span class="keyword">if</span> (temp.sibling) &#123;</span><br><span class="line">      <span class="keyword">return</span> temp.sibling;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有, 继续上溯</span></span><br><span class="line">    temp = temp.return;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>你可以配合上文的 <code>workLoop</code> 一起看，<strong>Fiber 就是我们所说的工作单元，<code>performUnitOfWork</code> 负责对 <code>Fiber</code> 进行操作，并按照深度遍历的顺序返回下一个 Fiber</strong>。<br><strong>因为使用了链表结构，即使处理流程被中断了，我们随时可以从上次未处理完的<code>Fiber</code>继续遍历下去</strong>。<br>整个迭代顺序和之前递归的一样, 下图假设在 <code>div.app</code> 进行了更新：<br><img src="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396192-4402b685-7e05-48db-abcd-68e34d61af97.webp#align=left&display=inline&height=439&originHeight=439&originWidth=708&size=0&status=done&width=708" alt><br><em>比如你在<code>text(hello)</code>中断了，那么下一次就会从 <code>p</code> 节点开始处理</em><br>这个数据结构调整还有一个好处，就是某些节点异常时，我们可以打印出完整的’节点栈‘，只需要沿着节点的<code>return</code>回溯即可。<br><a name="WOo5Q"></a></p>
<h3 id="2-两个阶段的拆分"><a href="#2-两个阶段的拆分" class="headerlink" title="2. 两个阶段的拆分"></a>2. 两个阶段的拆分</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396228-9f5e5967-f1c6-45ea-911f-db79f4005f17.webp#align=left&display=inline&height=464&originHeight=464&originWidth=1232&size=0&status=done&width=1232" alt><br>如果你现在使用最新的 React 版本(v16), 使用 Chrome 的 Performance 工具，可以很清晰地看到每次渲染有两个阶段：<code>Reconciliation</code>(协调阶段) 和 <code>Commit</code>(提交阶段).</p>
<blockquote>
<p>我在之前的多篇文章中都有提及: <a href="https://juejin.im/post/5d8395646fb9a06ad16faa57" target="_blank" rel="noopener">《自己写个React渲染器: 以 Remax 为例(用React写小程序)》</a></p>
</blockquote>
<p>除了Fiber 工作单元的拆分，两阶段的拆分也是一个非常重要的改造，在此之前都是一边Diff一边提交的。先来看看这两者的区别:</p>
<ul>
<li><strong>⚛️ 协调阶段</strong>: 可以认为是 Diff 阶段, <strong>这个阶段可以被中断</strong>, 这个阶段会找出所有节点变更，例如节点新增、删除、属性变更等等, 这些变更React 称之为’<code>副作用</code>(Effect)’ . 以下生命周期钩子会在协调阶段被调用：<ul>
<li>constructor</li>
<li>componentWillMount 废弃</li>
<li>componentWillReceiveProps 废弃</li>
<li>static getDerivedStateFromProps</li>
<li>shouldComponentUpdate</li>
<li>componentWillUpdate 废弃</li>
<li>render</li>
<li>getSnapshotBeforeUpdate()</li>
</ul>
</li>
<li><strong>⚛️ 提交阶段</strong>: 将上一个阶段计算出来的需要处理的<strong>副作用(Effects)</strong>一次性执行了。<strong>这个阶段必须同步执行，不能被打断</strong>. 这些生命周期钩子在提交阶段被执行:<ul>
<li>componentDidMount</li>
<li>componentDidUpdate</li>
<li>componentWillUnmount</li>
</ul>
</li>
</ul>
<p>也就是说，在协调阶段如果时间片用完，React就会选择让出控制权。因为协调阶段执行的工作不会导致任何用户可见的变更，所以在这个阶段让出控制权不会有什么问题。<br>需要注意的是：因为协调阶段可能被中断、恢复，甚至重做，<strong>⚠️React 协调阶段的生命周期钩子可能会被调用多次!</strong>, 例如 <code>componentWillMount</code> 可能会被调用两次。<br>因此建议 <strong>协调阶段的生命周期钩子不要包含副作用</strong>. 索性 React 就废弃了这部分可能包含副作用的生命周期方法，例如<code>componentWillMount</code>、<code>componentWillUpdate</code>. v17后我们就不能再用它们了, 所以现有的应用应该尽快迁移.<br>现在你应该知道为什么’提交阶段’必须同步执行，不能中断的吧？ 因为我们要正确地处理各种副作用，包括DOM变更、还有你在<code>componentDidMount</code>中发起的异步请求、useEffect 中定义的副作用… 因为有副作用，所以必须保证按照次序只调用一次，况且会有用户可以察觉到的变更, 不容差池。<br>关于为什么要拆分两个阶段，<a href="https://github.com/facebook/react/issues/13186#issuecomment-403959161" target="_blank" rel="noopener">这里</a>有更详细的解释。<br><a name="SRaef"></a></p>
<h3 id="3-Reconcilation"><a href="#3-Reconcilation" class="headerlink" title="3. Reconcilation"></a>3. Reconcilation</h3><p>接下来就是就是我们熟知的<code>Reconcilation</code>(为了方便理解，本文不区分Diff和Reconcilation, 两者是同一个东西)阶段了. <strong>思路和 Fiber 重构之前差别不大, 只不过这里不会再递归去比对、而且不会马上提交变更</strong>。<br>首先再进一步看一下<code>Fiber</code>的结构:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">interface Fiber &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 节点的类型信息</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 标记 Fiber 类型, 例如函数组件、类组件、宿主组件</span></span><br><span class="line">  tag: WorkTag,</span><br><span class="line">  <span class="comment">// 节点元素类型, 是具体的类组件、函数组件、宿主组件(字符串)</span></span><br><span class="line">  type: any,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 结构信息</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">  <span class="keyword">return</span>: Fiber | <span class="literal">null</span>,</span><br><span class="line">  child: Fiber | <span class="literal">null</span>,</span><br><span class="line">  sibling: Fiber | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 子节点的唯一键, 即我们渲染列表传入的key属性</span></span><br><span class="line">  key: <span class="literal">null</span> | string,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 节点的状态</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 节点实例(状态)：</span></span><br><span class="line">  <span class="comment">//        对于宿主组件，这里保存宿主组件的实例, 例如DOM节点。</span></span><br><span class="line">  <span class="comment">//        对于类组件来说，这里保存类组件的实例</span></span><br><span class="line">  <span class="comment">//        对于函数组件说，这里为空，因为函数组件没有实例</span></span><br><span class="line">  stateNode: any,</span><br><span class="line">  <span class="comment">// 新的、待处理的props</span></span><br><span class="line">  pendingProps: any,</span><br><span class="line">  <span class="comment">// 上一次渲染的props</span></span><br><span class="line">  memoizedProps: any, <span class="comment">// The props used to create the output.</span></span><br><span class="line">  <span class="comment">// 上一次渲染的组件状态</span></span><br><span class="line">  memoizedState: any,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 副作用</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 当前节点的副作用类型，例如节点更新、删除、移动</span></span><br><span class="line">  effectTag: SideEffectTag,</span><br><span class="line">  <span class="comment">// 和节点关系一样，React 同样使用链表来将所有有副作用的Fiber连接起来</span></span><br><span class="line">  nextEffect: Fiber | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 替身</span></span><br><span class="line"><span class="comment">   * 指向旧树中的节点</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  alternate: Fiber | <span class="literal">null</span>,</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>Fiber 包含的属性可以划分为 5 个部分:</p>
<ul>
<li><strong>🆕 结构信息</strong> - 这个上文我们已经见过了，Fiber 使用链表的形式来表示节点在树中的定位<br></li>
<li><strong>节点类型信息</strong> - 这个也容易理解，tag表示节点的分类、type 保存具体的类型值，如div、MyComp<br></li>
<li><strong>节点的状态</strong> - 节点的组件实例、props、state等，它们将影响组件的输出<br></li>
<li><strong>🆕 副作用</strong> - 这个也是新东西. 在 Reconciliation 过程中发现的’副作用’(变更需求)就保存在节点的<code>effectTag</code> 中(想象为打上一个标记).<br>那么怎么将本次渲染的所有节点副作用都收集起来呢？ 这里也使用了链表结构，在遍历过程中React会将所有有‘副作用’的节点都通过<code>nextEffect</code>连接起来<br></li>
<li><strong>🆕 替身</strong> - React 在 Reconciliation 过程中会构建一颗新的树(官方称为workInProgress tree，<strong>WIP树</strong>)，可以认为是一颗表示当前工作进度的树。还有一颗表示已渲染界面的<strong>旧树</strong>，React就是一边和旧树比对，一边构建WIP树的。 alternate 指向旧树的同等节点。<br></li>
</ul>
<p>现在可以放大看看<code>beginWork</code>  是如何对 Fiber 进行比对的:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beginWork</span>(<span class="params">fiber: Fiber</span>): <span class="title">Fiber</span> | <span class="title">undefined</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fiber.tag === WorkTag.HostComponent) &#123;</span><br><span class="line">    <span class="comment">// 宿主节点diff</span></span><br><span class="line">    diffHostComponent(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.tag === WorkTag.ClassComponent) &#123;</span><br><span class="line">    <span class="comment">// 类组件节点diff</span></span><br><span class="line">    diffClassComponent(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.tag === WorkTag.FunctionComponent) &#123;</span><br><span class="line">    <span class="comment">// 函数组件节点diff</span></span><br><span class="line">    diffFunctionalComponent(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ... 其他类型节点，省略</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>宿主节点比对:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffHostComponent</span>(<span class="params">fiber: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 新增节点</span></span><br><span class="line">  <span class="keyword">if</span> (fiber.stateNode == <span class="literal">null</span>) &#123;</span><br><span class="line">    fiber.stateNode = createHostComponent(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    updateHostComponent(fiber)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> newChildren = fiber.pendingProps.children;</span><br><span class="line">  <span class="comment">// 比对子节点</span></span><br><span class="line">  diffChildren(fiber, newChildren);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>类组件节点比对也差不多:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffClassComponent</span>(<span class="params">fiber: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建组件实例</span></span><br><span class="line">  <span class="keyword">if</span> (fiber.stateNode == <span class="literal">null</span>) &#123;</span><br><span class="line">    fiber.stateNode = createInstance(fiber);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (fiber.hasMounted) &#123;</span><br><span class="line">    <span class="comment">// 调用更新前生命周期钩子</span></span><br><span class="line">    applybeforeUpdateHooks(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 调用挂载前生命周期钩子</span></span><br><span class="line">    applybeforeMountHooks(fiber)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 渲染新节点</span></span><br><span class="line">  <span class="keyword">const</span> newChildren = fiber.stateNode.render();</span><br><span class="line">  <span class="comment">// 比对子节点</span></span><br><span class="line">  diffChildren(fiber, newChildren);</span><br><span class="line">  fiber.memoizedState = fiber.stateNode.state</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>子节点比对:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffChildren</span>(<span class="params">fiber: Fiber, newChildren: React.ReactNode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> oldFiber = fiber.alternate ? fiber.alternate.child : <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 全新节点，直接挂载</span></span><br><span class="line">  <span class="keyword">if</span> (oldFiber == <span class="literal">null</span>) &#123;</span><br><span class="line">    mountChildFibers(fiber, newChildren)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> newFiber = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 新子节点</span></span><br><span class="line">  <span class="keyword">const</span> elements = extraElements(newChildren)</span><br><span class="line">  <span class="comment">// 比对子元素</span></span><br><span class="line">  <span class="keyword">while</span> (index &lt; elements.length || oldFiber != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> prevFiber = newFiber;</span><br><span class="line">    <span class="keyword">const</span> element = elements[index]</span><br><span class="line">    <span class="keyword">const</span> sameType = isSameType(element, oldFiber)</span><br><span class="line">    <span class="keyword">if</span> (sameType) &#123;</span><br><span class="line">      newFiber = cloneFiber(oldFiber, element)</span><br><span class="line">      <span class="comment">// 更新关系</span></span><br><span class="line">      newFiber.alternate = oldFiber</span><br><span class="line">      <span class="comment">// 打上Tag</span></span><br><span class="line">      newFiber.effectTag = UPDATE</span><br><span class="line">      newFiber.return = fiber</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新节点</span></span><br><span class="line">    <span class="keyword">if</span> (element &amp;&amp; !sameType) &#123;</span><br><span class="line">      newFiber = createFiber(element)</span><br><span class="line">      newFiber.effectTag = PLACEMENT</span><br><span class="line">      newFiber.return = fiber</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除旧节点</span></span><br><span class="line">    <span class="keyword">if</span> (oldFiber &amp;&amp; !sameType) &#123;</span><br><span class="line">      oldFiber.effectTag = DELETION;</span><br><span class="line">      oldFiber.nextEffect = fiber.nextEffect</span><br><span class="line">      fiber.nextEffect = oldFiber</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oldFiber) &#123;</span><br><span class="line">      oldFiber = oldFiber.sibling;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">      fiber.child = newFiber;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prevFiber &amp;&amp; element) &#123;</span><br><span class="line">      prevFiber.sibling = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line">    index++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>上面的代码很粗糙地还原了 Reconciliation 的过程, 但是对于我们理解React的基本原理已经足够了.<br>这里引用一下<a href="https://www.youtube.com/watch?v=ZCuYPiUIONs" target="_blank" rel="noopener">Youtube: Lin Clark presentation in ReactConf 2017</a> 的Slide，来还原 Reconciliation 的过程. Lin Clark 这个演讲太经典了，几乎所有介绍 React Fiber 的文章都会引用它的Slide. 偷个懒，我也用下:</p>
<blockquote>
<p>这篇文章<a href="https://juejin.im/post/5ab7b3a2f265da2378403e57" target="_blank" rel="noopener">《React Fiber》</a> 用文字版解释了Link Clark Slide.</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396223-6e5ea448-8298-499b-9e9c-855f46be71ef.webp#align=left&display=inline&height=690&originHeight=690&originWidth=915&size=0&status=done&width=915" alt><br>上图是 Reconciliation 完成后的状态，左边是旧树，右边是WIP树。对于需要变更的节点，都打上了’标签’。 在提交阶段，React 就会将这些打上标签的节点应用变更。<br><a name="5UAyJ"></a></p>
<h3 id="4-双缓冲"><a href="#4-双缓冲" class="headerlink" title="4. 双缓冲"></a>4. 双缓冲</h3><p><code>WIP 树</code>构建这种技术类似于图形化领域的’<strong>双缓存(Double Buffering)</strong>‘技术, 图形绘制引擎一般会使用双缓冲技术，先将图片绘制到一个缓冲区，再一次性传递给屏幕进行显示，这样可以防止屏幕抖动，优化渲染性能。<br>放到React 中，WIP树就是一个缓冲，它在Reconciliation 完毕后一次性提交给浏览器进行渲染。它可以减少内存分配和垃圾回收，WIP 的节点不完全是新的，比如某颗子树不需要变动，React会克隆复用旧树中的子树。<br>双缓存技术还有另外一个重要的场景就是异常的处理，比如当一个节点抛出异常，仍然可以继续沿用旧树的节点，避免整棵树挂掉。<br>Dan 在 <a href="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html" target="_blank" rel="noopener">Beyond React 16</a> 演讲中用了一个非常恰当的比喻，那就是Git 功能分支，<strong>你可以将 WIP 树想象成从旧树中 Fork 出来的功能分支，你在这新分支中添加或移除特性，即使是操作失误也不会影响旧的分支。当你这个分支经过了测试和完善，就可以合并到旧分支，将其替换掉. 这或许就是’提交(commit)阶段‘的提交一词的来源吧？</strong>:<br><img src="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396250-dd8d02ad-2b20-46b3-a163-4302cb36eaa1.webp#align=left&display=inline&height=342&originHeight=342&originWidth=560&size=0&status=done&width=560" alt><br><a name="yJzN3"></a></p>
<h3 id="5-副作用的收集和提交"><a href="#5-副作用的收集和提交" class="headerlink" title="5. 副作用的收集和提交"></a>5. 副作用的收集和提交</h3><p>接下来就是将所有打了 Effect 标记的节点串联起来，这个可以在<code>completeWork</code>中做, 例如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> parent = fiber.return</span><br><span class="line">  <span class="comment">// 到达顶端</span></span><br><span class="line">  <span class="keyword">if</span> (parent == <span class="literal">null</span> || fiber === topWork) &#123;</span><br><span class="line">    pendingCommit = fiber</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (fiber.effectTag != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent.nextEffect) &#123;</span><br><span class="line">      parent.nextEffect.nextEffect = fiber</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      parent.nextEffect = fiber</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.nextEffect) &#123;</span><br><span class="line">    parent.nextEffect = fiber.nextEffect</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>最后了，将所有副作用提交了:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitAllWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> next = fiber</span><br><span class="line">  <span class="keyword">while</span>(next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fiber.effectTag) &#123;</span><br><span class="line">      <span class="comment">// 提交，偷一下懒，这里就不展开了</span></span><br><span class="line">      commitWork(fiber)</span><br><span class="line">    &#125;</span><br><span class="line">    next = fiber.nextEffect</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 清理现场</span></span><br><span class="line">  pendingCommit = nextUnitOfWork = topWork = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><a name="UY8OW"></a></p>
<h2 id="⚠️-未展开部分-🚧-–-中断和恢复"><a href="#⚠️-未展开部分-🚧-–-中断和恢复" class="headerlink" title="⚠️ 未展开部分 🚧 – 中断和恢复"></a>⚠️ 未展开部分 🚧 – 中断和恢复</h2><p>上文只是介绍了简单的中断和恢复机制，我们从哪里跌倒就从哪里站起来，在哪个节点中断就从哪个节点继续处理下去。 也就是说，到目前为止：<strong>⚠️更新任务还是串行执行的，我们只是将整个过程碎片化了. 对于那些需要优先处理的更新任务还是会被阻塞</strong>。我个人觉得这才是 React Fiber 中最难处理的一部分。<br><strong>实际情况是，在 React 得到控制权后，应该优先处理高优先级的任务</strong>。也就是说中断时正在处理的任务，在恢复时会让位给高优先级任务，原本中断的任务可能会被放弃或者重做。<br><strong>但是如果不按顺序执行任务，可能会导致前后的状态不一致</strong>。 比如低优先级任务将 <code>a</code> 设置为0，而高优先级任务将 <code>a</code> 递增1, 两个任务的执行顺序会影响最终的渲染结果。因此<strong>要让高优先级任务插队, 首先要保证状态更新的时序</strong>。<br>解决办法是: <strong>所有更新任务按照顺序插入一个队列, 状态必须按照插入顺序进行计算，但任务可以按优先级顺序执行</strong>, 例如：<br><img src="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396188-f5fbcac4-564f-4ec1-b03d-f5c3d66b1e3a.webp#align=left&display=inline&height=155&originHeight=155&originWidth=709&size=0&status=done&width=709" alt><br>红色表示高优先级任务。要计算它的状态必须基于前序任务计算出来的状态, 从而保证<strong>状态的最终一致性</strong>：<br><img src="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396224-13b13078-f902-4e60-a4ad-ad2faa5f5a25.webp#align=left&display=inline&height=200&originHeight=200&originWidth=681&size=0&status=done&width=681" alt><br>最终红色的高优先级任务 <code>C</code> 执行时的状态值是<code>a=5,b=3</code>. 在恢复控制权时，会按照优先级先执行 <code>C</code>, 前面的<code>A</code>、 <code>B</code>暂时跳过<br><img src="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396304-8ecd6b99-ab21-401a-ac6d-560332af1c68.webp#align=left&display=inline&height=258&originHeight=258&originWidth=716&size=0&status=done&width=716" alt><br>上面被跳过任务不会被移除，在执行完高优先级任务后它们还是会被执行的。因为不同的更新任务影响的节点树范围可能是不一样的，举个例子 <code>a</code>、<code>b</code> 可能会影响 <code>Foo</code> 组件树，而 <code>c</code> 会影响 <code>Bar</code> 组件树。所以为了保证<strong>视图的最终一致性</strong>, 所有更新任务都要被执行。<br><img src="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396195-a8bb672b-2938-43b2-a75a-28f2249973fc.webp#align=left&display=inline&height=239&originHeight=239&originWidth=587&size=0&status=done&width=587" alt><br>首先 <code>C</code> 先被执行，它更新了 <code>Foo</code> 组件<br>接着执行 <code>A</code> 任务，它更新了<code>Foo</code> 和 <code>Bar</code> 组件，由于 <code>C</code> 已经以最终状态<code>a=5, b=3</code>更新了<code>Foo</code>组件，这里可以做一下性能优化，直接复用C的更新结果， 不必触发重新渲染。因此 <code>A</code> 仅需更新 <code>Bar</code> 组件即可。<br>接着执行 <code>B</code>，同理可以复用 Foo 更新结果。<br>道理讲起来都很简单，React Fiber 实际上非常复杂，不管执行的过程怎样拆分、以什么顺序执行，最重要的是保证<strong>状态的一致性</strong>和<strong>视图的一致性</strong>，这给了 React 团队很大的考验，以致于现在都没有正式release出来。<br><a name="azmA1"></a></p>
<h2 id="凌波微步"><a href="#凌波微步" class="headerlink" title="凌波微步"></a>凌波微步</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396248-8aabcc50-23da-4705-98ea-9c11160c32c7.webp#align=left&display=inline&height=1151&originHeight=1151&originWidth=960&size=0&status=done&width=960" alt><br><em>同样来自Link Clark 的 Slider</em><br>前面说了一大堆，从操作系统进程调度、到浏览器原理、再到合作式调度、最后谈了React的基本改造工作, 地老天荒… 就是为了上面的小人可以在练就凌波微步, 它脚下的坑是浏览器的调用栈。<br>React 开启 <code>Concurrent Mode</code> 之后就不会挖大坑了，而是一小坑一坑的挖，挖一下休息一下，有紧急任务就优先去做。<br><img src="https://cdn.nlark.com/yuque/0/2019/webp/263301/1573200396271-eefa3137-c2f2-4879-9a14-15f693743878.webp#align=left&display=inline&height=292&originHeight=292&originWidth=569&size=0&status=done&width=569" alt><br><em>来源：<a href="https://www.youtube.com/watch?v=V1Ly-8Z1wQA&t=207s" target="_blank" rel="noopener">Flarnie Marchan - Ready for Concurrent Mode?</a></em><br>开启 <code>Concurrent Mode</code> 后，我们可以得到以下好处(详见<a href="https://www.youtube.com/watch?v=ByBPyMBTzM0" target="_blank" rel="noopener">Concurrent Rendering in React</a>):</p>
<ul>
<li>快速响应用户操作和输入，提升用户交互体验</li>
<li>让动画更加流畅，通过调度，可以让应用保持高帧率</li>
<li>利用好I/O 操作空闲期或者CPU空闲期，进行一些预渲染。 比如离屏(offscreen)不可见的内容，优先级最低，可以让 React 等到CPU空闲时才去渲染这部分内容。这和浏览器的preload等预加载技术差不多。</li>
<li>用<code>Suspense</code> 降低加载状态(load state)的优先级，减少闪屏。 比如数据很快返回时，可以不必显示加载状态，而是直接显示出来，避免闪屏；如果超时没有返回才显式加载状态。</li>
</ul>
<p>但是它肯定不是完美的，因为浏览器无法实现抢占式调度，无法阻止开发者做傻事的，开发者可以随心所欲，想挖多大的坑，就挖多大的坑。<br>为了共同创造美好的世界，我们要严律于己，该做的优化还需要做: 纯组件、虚表、简化组件、缓存…<br>尤雨溪在今年的<a href="https://www.yuque.com/vueconf/2019" target="_blank" rel="noopener">Vue Conf</a>一个观点让我印象深刻：<strong>如果我们可以把更新做得足够快的话，理论上就不需要时间分片了</strong>。<br><strong>时间分片并没有降低整体的工作量，该做的还是要做</strong>, 因此React 也在考虑利用CPU空闲或者I/O空闲期间做一些预渲染。所以跟尤雨溪说的一样：React Fiber 本质上是为了解决 React 更新低效率的问题，<strong>不要期望 Fiber 能给你现有应用带来质的提升, 如果性能问题是自己造成的，自己的锅还是得自己背</strong>.
<a name="BBzBR"></a></p>
<h2 id="站在巨人的肩膀上"><a href="#站在巨人的肩膀上" class="headerlink" title="站在巨人的肩膀上"></a>站在巨人的肩膀上</h2><p>本文之所以能成文，离不开社区上优质的开源项目和资料。<br><strong>迷你 Fiber 实现</strong>:<br>React 现在的代码库太复杂了! 而且一直在变动和推翻自己，<a href="https://www.zhihu.com/people/he-shi-jun" target="_blank" rel="noopener">Hax</a> 在 <a href="https://www.zhihu.com/question/270428598/answer/354017709" target="_blank" rel="noopener">《为什么社区里那些类 React 库至今没有选择实现 Fiber 架构？》 </a> 就开玩笑说: Fiber 性价比略低… 到了这个阶段，竞品太多，facebook 就搞一个 fiber 来作为护城河……<br>这种工程量不是一般团队能Hold住的， 如果你只是想了解 Fiber，去读 React 的源码性价比也很低，不妨看看这些 Mini 版实现, 感受其精髓，不求甚解:</p>
<ul>
<li><a href="https://github.com/RubyLouvre/anu" target="_blank" rel="noopener">anu</a> <a href="https://github.com/RubyLouvre" target="_blank" rel="noopener">司徒正美</a> 开发的类React框架</li>
<li><a href="https://github.com/132yse/fre" target="_blank" rel="noopener">Fre</a> <a href="https://www.zhihu.com/people/132yse" target="_blank" rel="noopener">伊撒尔</a> 开发的类React框架，代码很精简⁉️</li>
<li><a href="https://github.com/Foveluy/Luy" target="_blank" rel="noopener">Luy</a></li>
<li><a href="https://github.com/pomber/didact" target="_blank" rel="noopener">didact</a></li>
</ul>
<p><strong>优秀的文章 &amp; 演讲</strong><br>本文只是对React Fiber进行了简单的科普，实际上React 的实现比本文复杂的多，如果你想深入理解React Fiber的，下面这些文章不容错过:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=ZCuYPiUIONs" target="_blank" rel="noopener">Lin Clark - A Cartoon Intro to Fiber - React Conf 2017 👍🎦</a> React Fiber 启蒙，YouTube</li>
<li><a href="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html" target="_blank" rel="noopener">Beyond React 16 - Dan Abramov 👍🎦</a></li>
<li><a href="https://www.youtube.com/watch?v=ByBPyMBTzM0&t=151s" target="_blank" rel="noopener">Concurrent Rendering in React - Andrew Clark and Brian Vaughn 👍🎦</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/37095662" target="_blank" rel="noopener">司徒正美: React Fiber架构 👍</a> 看不如写</li>
<li><a href="https://www.zhihu.com/people/NE_SmallTown/posts" target="_blank" rel="noopener">展望 React 17，回顾 React 往事 👍</a> 看完 <a href="https://www.zhihu.com/people/NE_SmallTown" target="_blank" rel="noopener">Heaven</a> 的相关文章，会觉得你了解的React 知识真的只是<a href="https://zhuanlan.zhihu.com/jheaven" target="_blank" rel="noopener">冰山一角</a>，我们都没资格说我们懂 React。</li>
<li><a href="https://zhuanlan.zhihu.com/p/36425839" target="_blank" rel="noopener">浅入 React16/fiber 系列 👍</a> 同样来自 Heaven</li>
<li><a href="https://www.zhihu.com/search?type=content&q=requestIdleCallback" target="_blank" rel="noopener">淡苍：深入剖析 React Concurrent 👍</a></li>
<li><a href="https://engineering.hexacta.com/didact-fiber-incremental-reconciliation-b2fe028dcaec" target="_blank" rel="noopener">Didact Fiber: Incremental reconciliation  👍</a> 实现了简单的 React Fiber</li>
<li><a href="https://zhuanlan.zhihu.com/p/26027085" target="_blank" rel="noopener">程墨: React Fiber是什么</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/57346388" target="_blank" rel="noopener">译 深入React fiber架构及源码</a></li>
<li><a href="http://www.ayqy.net/blog/dive-into-react-fiber/" target="_blank" rel="noopener">黯羽轻扬: 完全理解React Fiber</a></li>
<li><a href="https://github.com/facebook/react/issues/7942" target="_blank" rel="noopener">Fiber Principles: Contributing To Fiber</a></li>
<li><a href="https://philippspiess.com/scheduling-in-react/" target="_blank" rel="noopener">Scheduling in React</a></li>
<li><a href="https://juejin.im/post/5d12c907f265da1b6d4033c5" target="_blank" rel="noopener">桃翁: Deep In React 之浅谈 React Fiber 架构（一）</a></li>
<li><a href="https://juejin.im/post/5b028db26fb9a07ac162ba68#heading-12" target="_blank" rel="noopener">为 Luy 实现 React Fiber 架构</a></li>
<li><a href="https://juejin.im/post/5ab7b3a2f265da2378403e57" target="_blank" rel="noopener">妖僧风月: React Fiber</a></li>
<li><a href="https://www.youtube.com/watch?v=V1Ly-8Z1wQA&t=207s" target="_blank" rel="noopener">Flarnie Marchan - Ready for Concurrent Mode? 🎦</a></li>
<li><a href="https://developers.google.com/web/fundamentals/performance/rendering" target="_blank" rel="noopener">Web Fundamentals &gt; Performance</a></li>
<li><a href="https://juejin.im/post/5ad71f39f265da239f07e862" target="_blank" rel="noopener">你应该知道的requestIdleCallback</a></li>
<li><a href="https://www.404forest.com/2017/07/18/how-javascript-actually-works-eventloop-and-uirendering/" target="_blank" rel="noopener">深入探究 eventloop 与浏览器渲染的时序问题</a></li>
<li><a href="https://nolanlawson.com/2018/09/25/accurately-measuring-layout-on-the-web/" target="_blank" rel="noopener">Accurately measuring layout on the web</a></li>
</ul>
<p><strong>自荐React 相关文章</strong><br>回顾一下今年写的关于 React 的相关文章<br><strong>Concurrent模式预览（推荐）</strong>:</p>
<ul>
<li><a href="https://juejin.im/post/5db65d87518825648f2ef899#comment" target="_blank" rel="noopener">React Concurrent 模式抢先预览: Suspense 篇</a></li>
<li><a href="https://juejin.im/post/5dbee8e7e51d4558040f0830" target="_blank" rel="noopener">React Concurrent 模式抢先预览下篇: useTransition 的平行世界</a></li>
</ul>
<p><strong>往期文章</strong>:</p>
<ul>
<li><a href="https://juejin.im/post/5cd7f2c4e51d453a7d63b715" target="_blank" rel="noopener">React组件设计实践总结 系列 共5篇</a></li>
<li><a href="https://juejin.im/post/5d8395646fb9a06ad16faa57" target="_blank" rel="noopener">自己写个React渲染器: 以 Remax 为例(用React写小程序)</a></li>
<li><a href="https://juejin.im/post/5d44e3745188255d5861d654" target="_blank" rel="noopener">谈谈React事件机制和未来(react-events)</a></li>
<li><a href="https://juejin.im/post/5d594ea5518825041301bbcb" target="_blank" rel="noopener">2019年了，整理了N个实用案例帮你快速迁移到React Hooks</a></li>
<li><a href="https://juejin.im/post/5d045350f265da1b695d5bf2" target="_blank" rel="noopener">浅谈React性能优化的方向</a></li>
<li><a href="https://juejin.im/post/5cfa29e151882539c33e4f5e" target="_blank" rel="noopener">从Preact中了解React组件和hooks基本原理</a></li>
<li><a href="https://juejin.im/post/5d06bf0a51882528194a9736" target="_blank" rel="noopener">React性能测量和分析</a></li>
</ul>
<p>本文讲了 React 如何优化 CPU 问题，React 野心远不在于此, I/O 方向的优化也在实践，例如 Suspend…  还有很多没讲完，后面的文章见！</p>
<p><a name="knt2y"></a></p>
<h2 id="完全理解React-Fiber"><a href="#完全理解React-Fiber" class="headerlink" title="完全理解React Fiber"></a>完全理解React Fiber</h2><p><a href="https://blog.csdn.net/juzipidemimi/article/details/96753874" target="_blank" rel="noopener">https://blog.csdn.net/juzipidemimi/article/details/96753874</a><br><a name="articleHeader1"></a></p>
<h2 id="一-目标"><a href="#一-目标" class="headerlink" title="一.目标"></a>一.目标</h2><p>Fiber是对React核心算法的重构，2年重构的产物就是Fiber reconciler<br>核心目标：扩大其_适用性_，包括动画，布局和手势。分为5个具体目标（后2个算送的）：</p>
<ul>
<li>把可中断的工作拆分成小任务<br></li>
<li>对正在做的工作调整优先次序、重做、复用上次（做了一半的）成果<br></li>
<li>在父子任务之间从容切换（yield back and forth），以支持React执行过程中的布局刷新<br></li>
<li>支持<code>render()</code>返回多个元素<br></li>
<li>更好地支持error boundary<br></li>
</ul>
<p>既然初衷是不希望JS不受控制地长时间执行（想要手动调度），那么，为什么JS长时间执行会影响交互响应、动画？</p>
<blockquote>
<p>因为JavaScript在浏览器的主线程上运行，恰好与样式计算、布局以及许多情况下的绘制一起运行。如果JavaScript运行时间过长，就会阻塞这些其他工作，可能导致掉帧。</p>
</blockquote>
<p>（引自<a href="https://developers.google.com/web/fundamentals/performance/rendering/optimize-javascript-execution#reduce_complexity_or_use_web_workers" target="_blank" rel="noopener">Optimize JavaScript Execution</a>）<br>React希望通过Fiber重构来改变这种不可控的现状，进一步提升交互体验<br>P.S.关于Fiber目标的更多信息，请查看<a href="https://reactjs.org/docs/codebase-overview.html#fiber-reconciler" target="_blank" rel="noopener">Codebase Overview</a><br><a name="articleHeader2"></a></p>
<h2 id="二-关键特性"><a href="#二-关键特性" class="headerlink" title="二.关键特性"></a>二.关键特性</h2><p>Fiber的关键特性如下：</p>
<ul>
<li>增量渲染（把渲染任务拆分成块，匀到多帧）<br></li>
<li>更新时能够暂停，终止，复用渲染任务<br></li>
<li>给不同类型的更新赋予优先级<br></li>
<li>并发方面新的基础能力<br></li>
</ul>
<p>增量渲染用来解决掉帧的问题，渲染任务拆分之后，每次只做一小段，做完一段就把时间控制权交还给主线程，而不像之前长时间占用。这种策略叫做cooperative scheduling（合作式调度），操作系统的3种任务调度策略之一（Firefox还对真实DOM应用了这项技术）<br>另外，React自身的_killer feature_是virtual DOM，2个原因：</p>
<ul>
<li>coding UI变简单了（不用关心浏览器应该怎么做，而是把下一刻的UI描述给React听）<br></li>
<li>既然DOM能virtual，别的（硬件、VR、native App）也能<br></li>
</ul>
<p>React实现上分为2部分：</p>
<ul>
<li>reconciler 寻找某时刻前后两版UI的差异。包括之前的Stack reconciler与现在的Fiber reconciler<br></li>
<li>renderer 插件式的，平台相关的部分。包括React DOM、React Native、React ART、ReactHardware、ReactAframe、React-pdf、ReactThreeRenderer、ReactBlessed等等<br></li>
</ul>
<p>这一波是对reconciler的彻底改造，对killer feature的增强<br><a name="articleHeader3"></a></p>
<h2 id="三-fiber与fiber-tree"><a href="#三-fiber与fiber-tree" class="headerlink" title="三.fiber与fiber tree"></a>三.fiber与fiber tree</h2><p>React运行时存在3种实例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DOM 真实DOM节点</span><br><span class="line">Instances React维护的vDOM tree node</span><br><span class="line">Elements 描述UI长什么样子（type, props）</span><br></pre></td></tr></table></figure>

<p>Instances是根据Elements创建的，对组件及DOM节点的抽象表示，vDOM tree维护了组件状态以及组件与DOM树的关系<br>在首次渲染过程中构建出vDOM tree，后续需要更新时（<code>setState()</code>），diff vDOM tree得到DOM change，并把DOM change应用（patch）到DOM树<br>Fiber之前的reconciler（被称为Stack reconciler）自顶向下的递归<code>mount/update</code>，_无法中断_（持续占用主线程），这样主线程上的布局、动画等周期性任务以及交互响应就无法立即得到处理，影响体验<br>Fiber解决这个问题的_思路_是把渲染/更新过程（递归diff）拆分成一系列小任务，每次检查树上的一小部分，做完看是否还有时间继续下一个任务，有的话继续，没有的话把自己挂起，主线程不忙的时候再继续<br>增量更新需要更多的上下文信息，之前的vDOM tree显然难以满足，所以扩展出了_fiber tree_（即Fiber上下文的vDOM tree），更新过程就是根据输入数据以及现有的fiber tree构造出新的fiber tree（workInProgress tree）。因此，Instance层新增了这些实例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DOM</span><br><span class="line">    真实DOM节点</span><br><span class="line">- - - -</span><br><span class="line">effect</span><br><span class="line">    每个workInProgress tree节点上都有一个effect list</span><br><span class="line">    用来存放diff结果</span><br><span class="line">    当前节点更新完毕会向上merge effect list（queue收集diff结果）</span><br><span class="line">- - - -</span><br><span class="line">workInProgress</span><br><span class="line">    workInProgress tree是reconcile过程中从fiber tree建立的当前进度快照，用于断点恢复</span><br><span class="line">- - - - -</span><br><span class="line">fiber</span><br><span class="line">    fiber tree与vDOM tree类似，用来描述增量更新所需的上下文信息</span><br><span class="line">-------</span><br><span class="line">Elements</span><br><span class="line">    描述UI长什么样子（type, props）</span><br></pre></td></tr></table></figure>

<p>注意：放在虚线上的2层都是临时的结构，仅在更新时有用，日常不持续维护。_effect_指的就是side effect，包括将要做的DOM change<br>fiber tree上各节点的主要结构（每个节点称为_fiber_）如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fiber tree节点结构</span></span><br><span class="line">&#123;</span><br><span class="line">    stateNode,</span><br><span class="line">    child,</span><br><span class="line">    <span class="keyword">return</span>,</span><br><span class="line">    sibling,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>return</code>表示当前节点处理完毕后，应该向谁提交自己的成果（effect list）<br>P.S.fiber tree实际上是个单链表（Singly Linked List）树结构，见<a href="https://github.com/facebook/react/blob/v16.2.0/packages/react-reconciler/src/ReactFiber.js#L91" target="_blank" rel="noopener">react/packages/react-reconciler/src/ReactFiber.js</a><br>P.S.注意小fiber与大Fiber，前者表示fiber tree上的节点，后者表示React Fiber<br><a name="articleHeader4"></a></p>
<h2 id="四-Fiber-reconciler"><a href="#四-Fiber-reconciler" class="headerlink" title="四.Fiber reconciler"></a>四.Fiber reconciler</h2><p>reconcile过程分为2个阶段（phase）：</p>
<ol>
<li><p>（可中断）render/reconciliation 通过构造workInProgress tree得出change<br></p>
</li>
<li><p>（不可中断）commit 应用这些DOM change<br><br><a name="articleHeader5"></a></p>
<h3 id="render-reconciliation"><a href="#render-reconciliation" class="headerlink" title="render/reconciliation"></a>render/reconciliation</h3><p>以fiber tree为蓝本，把每个fiber作为一个工作单元，自顶向下逐节点构造_workInProgress tree_（构建中的新fiber tree）<br>具体过程如下（以组件节点为例）：</p>
</li>
<li><p>如果当前节点不需要更新，直接把子节点clone过来，跳到5；要更新的话打个tag<br></p>
</li>
<li><p>更新当前节点状态（<code>props, state, context</code>等）<br></p>
</li>
<li><p>调用<code>shouldComponentUpdate()</code>，<code>false</code>的话，跳到5<br></p>
</li>
<li><p>调用<code>render()</code>获得新的子节点，并为子节点创建fiber（创建过程会尽量复用现有fiber，子节点增删也发生在这里）<br></p>
</li>
<li><p>如果没有产生child fiber，该工作单元结束，把effect list归并到return，并把当前节点的sibling作为下一个工作单元；否则把child作为下一个工作单元<br></p>
</li>
<li><p>如果没有剩余可用时间了，等到下一次主线程空闲时才开始下一个工作单元；否则，立即开始做<br></p>
</li>
<li><p>如果没有下一个工作单元了（回到了workInProgress tree的根节点），第1阶段结束，进入pendingCommit状态<br></p>
</li>
</ol>
<p>实际上是1-6的_工作循环_，7是出口，工作循环每次只做一件事，做完看要不要喘口气。工作循环结束时，workInProgress tree的根节点身上的effect list就是收集到的所有side effect（因为每做完一个都向上归并）<br>所以，构建workInProgress tree的过程就是diff的过程，通过<code>requestIdleCallback</code>来调度执行一组任务，每完成一个任务后回来看看有没有插队的（更紧急的），每完成一组任务，把时间控制权交还给主线程，直到下一次<code>requestIdleCallback</code>回调再继续构建workInProgress tree<br>P.S.Fiber之前的reconciler被称为Stack reconciler，就是因为这些调度上下文信息是由系统栈来保存的。虽然之前一次性做完，强调栈没什么意义，起个名字只是为了便于区分Fiber reconciler<br><a name="s8gEi"></a></p>
<h4 id="requestIdleCallback"><a href="#requestIdleCallback" class="headerlink" title="requestIdleCallback"></a>requestIdleCallback</h4><blockquote>
<p>通知主线程，要求在不忙的时候告诉我，我有几个不太着急的事情要做</p>
</blockquote>
<p>具体用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.requestIdleCallback(callback[, options])</span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">let</span> handle = <span class="built_in">window</span>.requestIdleCallback(<span class="function">(<span class="params">idleDeadline</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;didTimeout, timeRemaining&#125; = idleDeadline;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`超时了吗？<span class="subst">$&#123;didTimeout&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`可用时间剩余<span class="subst">$&#123;timeRemaining.call(idleDeadline)&#125;</span>ms`</span>);</span><br><span class="line">    <span class="comment">// do some stuff</span></span><br><span class="line">    <span class="keyword">const</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>, timespent = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (+<span class="keyword">new</span> <span class="built_in">Date</span> &lt; now + timespent);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`花了<span class="subst">$&#123;timespent&#125;</span>ms搞事情`</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`可用时间剩余<span class="subst">$&#123;timeRemaining.call(idleDeadline)&#125;</span>ms`</span>);</span><br><span class="line">&#125;, &#123;<span class="attr">timeout</span>: <span class="number">1000</span>&#125;);</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// 超时了吗？false</span></span><br><span class="line"><span class="comment">// 可用时间剩余49.535000000000004ms</span></span><br><span class="line"><span class="comment">// 花了10ms搞事情</span></span><br><span class="line"><span class="comment">// 可用时间剩余38.64ms</span></span><br></pre></td></tr></table></figure>

<p>_注意_，<code>requestIdleCallback</code>调度只是希望做到流畅体验，并不能绝对保证什么，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// do some stuff</span></span><br><span class="line"><span class="keyword">const</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>, timespent = <span class="number">300</span>;</span><br><span class="line"><span class="keyword">while</span> (+<span class="keyword">new</span> <span class="built_in">Date</span> &lt; now + timespent);</span><br></pre></td></tr></table></figure>

<p>如果搞事情（对应React中的生命周期函数等时间上不受React控制的东西）就花了300ms，什么机制也保证不了流畅<br>P.S.一般剩余可用时间也就10-50ms，可调度空间不很宽裕<br><a name="articleHeader6"></a></p>
<h3 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h3><p>第2阶段直接一口气做完：</p>
<ol>
<li>处理effect list（包括3种处理：更新DOM树、调用组件生命周期函数以及更新ref等内部状态）<br></li>
<li>出对结束，第2阶段结束，所有更新都commit到DOM树上了<br></li>
</ol>
<p>注意，真的是_一口气做完_（同步执行，不能喊停）的，这个阶段的实际工作量是比较大的，所以尽量不要在后3个生命周期函数里干重活儿<br><a name="articleHeader7"></a></p>
<h3 id="生命周期hook"><a href="#生命周期hook" class="headerlink" title="生命周期hook"></a>生命周期hook</h3><p>生命周期函数也被分为2个阶段了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第1阶段 render/reconciliation</span></span><br><span class="line">componentWillMount</span><br><span class="line">componentWillReceiveProps</span><br><span class="line">shouldComponentUpdate</span><br><span class="line">componentWillUpdate</span><br><span class="line"><span class="comment">// 第2阶段 commit</span></span><br><span class="line">componentDidMount</span><br><span class="line">componentDidUpdate</span><br><span class="line">componentWillUnmount</span><br></pre></td></tr></table></figure>

<p>第1阶段的生命周期函数可能会被_多次调用_，默认以low优先级（后面介绍的6种优先级之一）执行，被高优先级任务打断的话，稍后重新执行<br><a name="articleHeader8"></a></p>
<h2 id="五-fiber-tree与workInProgress-tree"><a href="#五-fiber-tree与workInProgress-tree" class="headerlink" title="五.fiber tree与workInProgress tree"></a>五.fiber tree与workInProgress tree</h2><p>双缓冲技术（double buffering），就像<a href="http://www.ayqy.net/blog/redux%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/#articleHeader7" target="_blank" rel="noopener">redux里的<code>nextListeners</code></a>，以fiber tree为主，workInProgress tree为辅<br>双缓冲具体指的是workInProgress tree构造完毕，得到的就是新的fiber tree，然后喜新厌旧（把current指针指向workInProgress tree，丢掉旧的fiber tree）就好了<br>这样做的好处：</p>
<ul>
<li>能够复用内部对象（fiber）<br></li>
<li>节省内存分配、GC的时间开销<br></li>
</ul>
<p>每个fiber上都有个<code>alternate</code>属性，也指向一个fiber，创建workInProgress节点时优先取<code>alternate</code>，没有的话就创建一个：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> workInProgress = current.alternate;</span><br><span class="line"><span class="keyword">if</span> (workInProgress === <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="comment">//...这里很有意思</span></span><br><span class="line">  workInProgress.alternate = current;</span><br><span class="line">  current.alternate = workInProgress;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// We already have an alternate.</span></span><br><span class="line">  <span class="comment">// Reset the effect tag.</span></span><br><span class="line">  workInProgress.effectTag = NoEffect;</span><br><span class="line">  <span class="comment">// The effect list is no longer valid.</span></span><br><span class="line">  workInProgress.nextEffect = <span class="literal">null</span>;</span><br><span class="line">  workInProgress.firstEffect = <span class="literal">null</span>;</span><br><span class="line">  workInProgress.lastEffect = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如注释指出的，fiber与workInProgress互相持有引用，“喜新厌旧”之后，旧fiber就作为新fiber更新的_预留空间_，达到复用fiber实例的目的<br>P.S.源码里还有一些有意思的技巧，比如<a href="http://makersden.io/blog/look-inside-fiber/#side-effect-tags-types-of-side-effects" target="_blank" rel="noopener">tag的位运算</a><br><a name="articleHeader9"></a></p>
<h2 id="六-优先级策略"><a href="#六-优先级策略" class="headerlink" title="六.优先级策略"></a>六.优先级策略</h2><p>每个工作单元运行时有6种优先级：</p>
<ul>
<li>synchronous 与之前的Stack reconciler操作一样，同步执行<br></li>
<li>task 在next tick之前执行<br></li>
<li>animation 下一帧之前执行<br></li>
<li>high 在不久的将来立即执行<br></li>
<li>low 稍微延迟（100-200ms）执行也没关系<br></li>
<li>offscreen 下一次render时或scroll时才执行<br></li>
</ul>
<p>synchronous首屏（首次渲染）用，要求尽量快，不管会不会阻塞UI线程。animation通过<code>requestAnimationFrame</code>来调度，这样在下一帧就能立即开始动画过程；后3个都是由<code>requestIdleCallback</code>回调执行的；offscreen指的是当前隐藏的、屏幕外的（看不见的）元素<br>高优先级的比如键盘输入（希望立即得到反馈），低优先级的比如网络请求，让评论显示出来等等。另外，<em>紧急的事件允许插队</em><br>这样的优先级机制存在_2个问题_：</p>
<ul>
<li>生命周期函数怎么执行（可能被频频中断）：触发顺序、次数没有保证了<br></li>
<li>starvation（低优先级饿死）：如果高优先级任务很多，那么低优先级任务根本没机会执行（就饿死了）<br></li>
</ul>
<p>生命周期函数的问题有一个官方例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">low A</span><br><span class="line">componentWillUpdate()</span><br><span class="line">high B</span><br><span class="line">componentWillUpdate()</span><br><span class="line">componentDidUpdate()</span><br><span class="line">restart low A</span><br><span class="line">componentWillUpdate()</span><br><span class="line">componentDidUpdate()</span><br></pre></td></tr></table></figure>

<p>第1个问题正在解决（还没解决），生命周期的问题会破坏一些现有App，给平滑升级带来困难，Fiber团队正在努力寻找优雅的升级途径<br>第2个问题通过尽量复用已完成的操作（reusing work where it can）来缓解，听起来也是正在想办法解决<br>这两个问题本身不太好解决，只是解决到什么程度的问题。比如第一个问题，如果组件生命周期函数掺杂副作用太多，就没有办法无伤解决。这些问题虽然会给升级Fiber带来一定阻力，但绝不是不可解的（退一步讲，如果新特性有足够的吸引力，第一个问题大家自己想办法就解决了）<br><a name="articleHeader10"></a></p>
<h2 id="七-总结"><a href="#七-总结" class="headerlink" title="七.总结"></a>七.总结</h2><p><a name="articleHeader11"></a></p>
<h3 id="已知"><a href="#已知" class="headerlink" title="已知"></a>已知</h3><p>React在一些响应体验要求较高的场景不适用，比如动画，布局和手势<br>根本原因是渲染/更新过程一旦开始无法中断，持续占用主线程，主线程忙于执行JS，无暇他顾（布局、动画），造成掉帧、延迟响应（甚至无响应）等不佳体验<br><a name="articleHeader12"></a></p>
<h3 id="求"><a href="#求" class="headerlink" title="求"></a>求</h3><p>一种能够彻底解决主线程长时间占用问题的机制，不仅能够应对眼前的问题，还要有长远意义</p>
<blockquote>
<p>The “fiber” reconciler is a new effort aiming to resolve the problems inherent in the stack reconciler and fix a few long-standing issues.</p>
</blockquote>
<p><a name="articleHeader13"></a></p>
<h3 id="解"><a href="#解" class="headerlink" title="解"></a>解</h3><p>把渲染/更新过程拆分为小块任务，通过合理的调度机制来控制时间（更细粒度、更强的控制力）<br>那么，面临5个子问题：<br><a name="jSyY6"></a></p>
<h4 id="1-拆什么？什么不能拆？"><a href="#1-拆什么？什么不能拆？" class="headerlink" title="1.拆什么？什么不能拆？"></a>1.拆什么？什么不能拆？</h4><p>把渲染/更新过程分为2个阶段（diff + patch）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>diff ~ render/reconciliation</span><br><span class="line"><span class="number">2.</span>patch ~ commit</span><br></pre></td></tr></table></figure>

<p>diff的实际工作是对比<code>prevInstance</code>和<code>nextInstance</code>的状态，找出差异及其对应的DOM change。diff本质上是一些计算（遍历、比较），是可拆分的（算一半待会儿接着算）<br>patch阶段把本次更新中的所有DOM change应用到DOM树，是一连串的DOM操作。这些DOM操作虽然看起来也可以拆分（按照change list一段一段做），但这样做一方面可能造成DOM实际状态与维护的内部状态不一致，另外还会影响体验。而且，一般场景下，DOM更新的耗时比起diff及生命周期函数耗时不算什么，拆分的意义不很大<br>所以，render/reconciliation阶段的工作（diff）可以拆分，commit阶段的工作（patch）不可拆分<br>P.S.diff与reconciliation只是对应关系，并不等价，如果非要区分的话，reconciliation包括diff：</p>
<blockquote>
<p>This is a part of the process that React calls reconciliation which starts when you call ReactDOM.render() or setState(). By the end of the reconciliation, React knows the result DOM tree, and a renderer like react-dom or react-native applies the minimal set of changes necessary to update the DOM nodes (or the platform-specific views in case of React Native).</p>
</blockquote>
<p>（引自<a href="https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html#top-down-reconciliation" target="_blank" rel="noopener">Top-Down Reconciliation</a>）
<a name="ZgXm0"></a></p>
<h4 id="2-怎么拆？"><a href="#2-怎么拆？" class="headerlink" title="2.怎么拆？"></a>2.怎么拆？</h4><p>先凭空乱来几种diff工作拆分方案：</p>
<ul>
<li>按组件结构拆。不好分，无法预估各组件更新的工作量<br></li>
<li>按实际工序拆。比如分为<code>getNextState(), shouldUpdate(), updateState(), checkChildren()</code>再穿插一些生命周期函数<br></li>
</ul>
<p>按组件拆太粗，显然对大组件不太公平。按工序拆太细，任务太多，频繁调度不划算。那么有没有合适的拆分单位？<br>有。Fiber的拆分单位是fiber（fiber tree上的一个节点），实际上就是_按虚拟DOM节点拆_，因为fiber tree是根据vDOM tree构造出来的，树结构一模一样，只是节点携带的信息有差异<br>所以，实际上是vDOM node粒度的拆分（以fiber为工作单元），每个组件实例和每个DOM节点抽象表示的实例都是一个工作单元。工作循环中，每次处理一个fiber，处理完可以中断/挂起整个工作循环<br><a name="Yd403"></a></p>
<h4 id="3-如何调度任务？"><a href="#3-如何调度任务？" class="headerlink" title="3.如何调度任务？"></a>3.如何调度任务？</h4><p>分2部分：</p>
<ul>
<li>工作循环<br></li>
<li>优先级机制<br></li>
</ul>
<p>工作循环是_基本的任务调度机制_，工作循环中每次处理一个任务（工作单元），处理完毕有一次喘息的机会：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Flush asynchronous work until the deadline runs out of time.</span></span><br><span class="line"><span class="keyword">while</span> (nextUnitOfWork !== <span class="literal">null</span> &amp;&amp; !shouldYield()) &#123;</span><br><span class="line">  nextUnitOfWork = performUnitOfWork(nextUnitOfWork);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>shouldYield</code>就是看时间用完了没（<code>idleDeadline.timeRemaining()</code>），没用完的话继续处理下一个任务，用完了就结束，把时间控制权还给主线程，等下一次<code>requestIdleCallback</code>回调再接着做：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If there's work left over, schedule a new callback.</span></span><br><span class="line"><span class="keyword">if</span> (nextFlushedExpirationTime !== NoWork) &#123;</span><br><span class="line">  scheduleCallbackWithExpiration(nextFlushedExpirationTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，（不考虑突发事件的）正常调度是由工作循环来完成的，基本_规则_是：每个工作单元结束检查是否还有时间做下一个，没时间了就先“挂起”<br>优先级机制用来处理突发事件与优化次序，例如：</p>
<ul>
<li>到commit阶段了，提高优先级<br></li>
<li>高优任务做一半出错了，给降一下优先级<br></li>
<li>抽空关注一下低优任务，别给饿死了<br></li>
<li>如果对应DOM节点此刻不可见，给降到最低优先级<br></li>
</ul>
<p>这些策略用来动态调整任务调度，是工作循环的_辅助机制_，最先做最重要的事情<br><a name="CdrxP"></a></p>
<h4 id="4-如何中断-断点恢复？"><a href="#4-如何中断-断点恢复？" class="headerlink" title="4.如何中断/断点恢复？"></a>4.如何中断/断点恢复？</h4><p>中断：检查当前正在处理的工作单元，保存当前成果（<code>firstEffect, lastEffect</code>），修改tag标记一下，迅速收尾并再开一个<code>requestIdleCallback</code>，下次有机会再做<br>断点恢复：下次再处理到该工作单元时，看tag是被打断的任务，接着做未完成的部分或者重做<br>P.S.无论是时间用尽“自然”中断，还是被高优任务粗暴打断，对中断机制来说都一样<br><a name="rendd"></a></p>
<h4 id="5-如何收集任务结果？"><a href="#5-如何收集任务结果？" class="headerlink" title="5.如何收集任务结果？"></a>5.如何收集任务结果？</h4><p>Fiber reconciliation的工作循环具体如下：</p>
<ol>
<li>找到根节点优先级最高的workInProgress tree，取其待处理的节点（代表组件或DOM节点）<br></li>
<li>检查当前节点是否需要更新，不需要的话，直接到4<br></li>
<li>标记一下（打个tag），更新自己（组件更新<code>props</code>，<code>context</code>等，DOM节点记下DOM change），并为孩子生成workInProgress node<br></li>
<li>如果没有产生子节点，归并effect list（包含DOM change）到父级<br></li>
<li>把孩子或兄弟作为待处理节点，准备进入下一个工作循环。如果没有待处理节点（回到了workInProgress tree的根节点），工作循环结束<br></li>
</ol>
<p>通过每个节点更新结束时_向上归并effect list_来收集任务结果，reconciliation结束后，根节点的effect list里记录了包括DOM change在内的所有side effect<br><a name="articleHeader14"></a></p>
<h3 id="举一反三"><a href="#举一反三" class="headerlink" title="举一反三"></a>举一反三</h3><p>既然任务可拆分（只要最终得到完整effect list就行），那就允许_并行执行_（多个Fiber reconciler + 多个worker），首屏也更容易分块加载/渲染（vDOM森林）<br>并行渲染的话，据说Firefox测试结果显示，130ms的页面，只需要30ms就能搞定，所以在这方面是值得期待的，而React已经做好准备了，这也就是在React Fiber上下文经常听到的待_unlock_的更多特性之一<br><a name="articleHeader15"></a></p>
<h2 id="八-源码简析"><a href="#八-源码简析" class="headerlink" title="八.源码简析"></a>八.源码简析</h2><p>从15到16，源码结构发生了很大变化：</p>
<ul>
<li>再也看不到<code>mountComponent/updateComponent()</code>了，被拆分重组成了（<code>beginWork/completeWork/commitWork()</code>）<br></li>
<li><a href="https://github.com/facebook/react/blob/v16.0.0/src/renderers/dom/stack/client/ReactDOMComponent.js#L384" target="_blank" rel="noopener">ReactDOMComponent</a>也被去掉了，在Fiber体系下DOM节点抽象用<a href="https://github.com/facebook/react/blob/v16.2.0/packages/react-dom/src/client/ReactDOMFiberComponent.js#L353" target="_blank" rel="noopener">ReactDOMFiberComponent</a>表示，组件用<a href="https://github.com/facebook/react/blob/v16.2.0/packages/react-reconciler/src/ReactFiberClassComponent.js#L78" target="_blank" rel="noopener">ReactFiberClassComponent</a>表示，之前是<a href="https://github.com/facebook/react/blob/v15.6.2/src/renderers/shared/stack/reconciler/ReactCompositeComponent.js#L126" target="_blank" rel="noopener">ReactCompositeComponent</a><br></li>
<li>Fiber体系的核心机制是负责任务调度的<a href="https://github.com/facebook/react/blob/v16.2.0/packages/react-reconciler/src/ReactFiberScheduler.js" target="_blank" rel="noopener">ReactFiberScheduler</a>，相当于之前的<a href="https://github.com/facebook/react/blob/v15.6.2/src/renderers/shared/stack/reconciler/ReactReconciler.js" target="_blank" rel="noopener">ReactReconciler</a><br></li>
<li>vDOM tree变成fiber tree了，以前是自上而下的简单树结构，现在是基于单链表的树结构，维护的节点关系更多一些<br></li>
</ul>
<p>fiber tree来张图感受一下：<br><a href="http://www.ayqy.net/cms/wordpress/wp-content/uploads/2018/01/fiber-tree.png" target="_blank" rel="noopener"><img src="https://cdn.nlark.com/yuque/0/2019/png/263301/1573208702714-ef95663e-db0b-4faa-a4f1-3e16a3f6921c.png#align=left&display=inline&height=732&originHeight=732&originWidth=970&size=0&status=done&width=970" alt></a><br>fiber-tree<br>其实稍一细想，从Stack reconciler到Fiber reconciler，源码层面就是干了一件_递归改循环_的事情（当然，实际做的事情远不止递归改循环，但这是第一步）<br>总之，源码变化很大，如果对Fiber思路没有预先了解的话，看源码会比较_艰难_（看过React[15-]的源码的话，就更容易迷惑了）<br>P.S.这张<a href="https://bogdan-lyashenko.github.io/Under-the-hood-ReactJS/stack/images/intro/all-page-stack-reconciler.svg" target="_blank" rel="noopener">清明流程图</a>要正式退役了<br><a name="articleHeader16"></a></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://www.youtube.com/watch?v=ZCuYPiUIONs" target="_blank" rel="noopener">Lin Clark – A Cartoon Intro to Fiber – React Conf 2017</a>：_5星推荐_，声音很好听，比Jing Chen好100倍<br></li>
<li><a href="https://github.com/acdlite/react-fiber-architecture" target="_blank" rel="noopener">acdlite/react-fiber-architecture</a><br></li>
<li><a href="https://reactjs.org/docs/codebase-overview.html" target="_blank" rel="noopener">Codebase Overview</a><br></li>
<li><a href="http://makersden.io/blog/look-inside-fiber/" target="_blank" rel="noopener">A look inside React Fiber – how work will get done.</a>：Fiber源码解读，小说体看着有点费劲<br></li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/11/07/yuque/高效开发，必知必会的Chrome开发工具/" rel="next" title="高效开发，必知必会的Chrome开发工具">
                <i class="fa fa-chevron-left"></i> 高效开发，必知必会的Chrome开发工具
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/11/08/yuque/2019年了，整理了N个实用案例帮你快速迁移到React Hooks/" rel="prev" title="2019年了，整理了N个实用案例帮你快速迁移到React Hooks">
                2019年了，整理了N个实用案例帮你快速迁移到React Hooks <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC80NDgxOC8yMTMzOQ=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/1916867.png" alt="FangCao">
            
              <p class="site-author-name" itemprop="name">FangCao</p>
              <p class="site-description motion-element" itemprop="description">天空不留下鸟的痕迹，但我已飞过；流星是美丽的不为永恒，只为瞬间</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">185</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/fang-cao-2-96" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-zhihu"></i>知乎</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:wangfangcao7618@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://plus.google.com/wangfangcao7618" target="_blank" title="Google">
                      
                        <i class="fa fa-fw fa-google"></i>Google</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://macshuo.com/" title="MacTalk" target="_blank">MacTalk</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://example.com/" title="Title" target="_blank">Title</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#单处理进程调度-Fiber-不是一个新的东西"><span class="nav-number">1.</span> <span class="nav-text">单处理进程调度: Fiber 不是一个新的东西</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类比浏览器JavaScript执行环境"><span class="nav-number">2.</span> <span class="nav-text">类比浏览器JavaScript执行环境</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#何为-Fiber"><span class="nav-number">3.</span> <span class="nav-text">何为 Fiber</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-一种流程控制原语"><span class="nav-number">3.1.</span> <span class="nav-text">1. 一种流程控制原语</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-一个执行单元"><span class="nav-number">3.2.</span> <span class="nav-text">2. 一个执行单元</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#React-的Fiber改造"><span class="nav-number">4.</span> <span class="nav-text">React 的Fiber改造</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-数据结构的调整"><span class="nav-number">4.1.</span> <span class="nav-text">1. 数据结构的调整</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-两个阶段的拆分"><span class="nav-number">4.2.</span> <span class="nav-text">2. 两个阶段的拆分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Reconcilation"><span class="nav-number">4.3.</span> <span class="nav-text">3. Reconcilation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-双缓冲"><span class="nav-number">4.4.</span> <span class="nav-text">4. 双缓冲</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-副作用的收集和提交"><span class="nav-number">4.5.</span> <span class="nav-text">5. 副作用的收集和提交</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#⚠️-未展开部分-🚧-–-中断和恢复"><span class="nav-number">5.</span> <span class="nav-text">⚠️ 未展开部分 🚧 – 中断和恢复</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#凌波微步"><span class="nav-number">6.</span> <span class="nav-text">凌波微步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#站在巨人的肩膀上"><span class="nav-number">7.</span> <span class="nav-text">站在巨人的肩膀上</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#完全理解React-Fiber"><span class="nav-number">8.</span> <span class="nav-text">完全理解React Fiber</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一-目标"><span class="nav-number">9.</span> <span class="nav-text">一.目标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二-关键特性"><span class="nav-number">10.</span> <span class="nav-text">二.关键特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三-fiber与fiber-tree"><span class="nav-number">11.</span> <span class="nav-text">三.fiber与fiber tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四-Fiber-reconciler"><span class="nav-number">12.</span> <span class="nav-text">四.Fiber reconciler</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#render-reconciliation"><span class="nav-number">12.1.</span> <span class="nav-text">render/reconciliation</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#requestIdleCallback"><span class="nav-number">12.1.1.</span> <span class="nav-text">requestIdleCallback</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#commit"><span class="nav-number">12.2.</span> <span class="nav-text">commit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生命周期hook"><span class="nav-number">12.3.</span> <span class="nav-text">生命周期hook</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五-fiber-tree与workInProgress-tree"><span class="nav-number">13.</span> <span class="nav-text">五.fiber tree与workInProgress tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六-优先级策略"><span class="nav-number">14.</span> <span class="nav-text">六.优先级策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#七-总结"><span class="nav-number">15.</span> <span class="nav-text">七.总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#已知"><span class="nav-number">15.1.</span> <span class="nav-text">已知</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#求"><span class="nav-number">15.2.</span> <span class="nav-text">求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解"><span class="nav-number">15.3.</span> <span class="nav-text">解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-拆什么？什么不能拆？"><span class="nav-number">15.3.1.</span> <span class="nav-text">1.拆什么？什么不能拆？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-怎么拆？"><span class="nav-number">15.3.2.</span> <span class="nav-text">2.怎么拆？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-如何调度任务？"><span class="nav-number">15.3.3.</span> <span class="nav-text">3.如何调度任务？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-如何中断-断点恢复？"><span class="nav-number">15.3.4.</span> <span class="nav-text">4.如何中断/断点恢复？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-如何收集任务结果？"><span class="nav-number">15.3.5.</span> <span class="nav-text">5.如何收集任务结果？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#举一反三"><span class="nav-number">15.4.</span> <span class="nav-text">举一反三</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#八-源码简析"><span class="nav-number">16.</span> <span class="nav-text">八.源码简析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#参考资料"><span class="nav-number">16.1.</span> <span class="nav-text">参考资料</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2012 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">FangCao</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">321.9k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

  <!--添加复制-->
  <script type="text/javascript" src="/lib/zclip/clipboard.min.js"></script>
<script type="text/javascript" src="/js/src/custom.js"></script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"width":150,"height":300,"position":"right"},"mobile":{"show":true,"scale":0.5},"react":{"opacity":0.9},"dialog":{"enable":true,"hitokoto":true},"log":false});</script></body>
<!-- 页面点击小红心 <script type="text/javascript" src="/js/src/click.js"></script> -->
</html>
